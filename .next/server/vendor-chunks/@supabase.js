/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@supabase";
exports.ids = ["vendor-chunks/@supabase"];
exports.modules = {

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueAdminApi */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\");\n\nconst AuthAdminApi = _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AuthAdminApi); //# sourceMappingURL=AuthAdminApi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvQXV0aEFkbWluQXBpLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQThDO0FBQzlDLE1BQU1DLGVBQWVELHVEQUFjQTtBQUNuQyxpRUFBZUMsWUFBWUEsRUFBQyxDQUM1Qix3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmNob3Itd29ya2Zsb3dzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL0F1dGhBZG1pbkFwaS5qcz8yMDYxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBHb1RydWVBZG1pbkFwaSBmcm9tICcuL0dvVHJ1ZUFkbWluQXBpJztcbmNvbnN0IEF1dGhBZG1pbkFwaSA9IEdvVHJ1ZUFkbWluQXBpO1xuZXhwb3J0IGRlZmF1bHQgQXV0aEFkbWluQXBpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXV0aEFkbWluQXBpLmpzLm1hcCJdLCJuYW1lcyI6WyJHb1RydWVBZG1pbkFwaSIsIkF1dGhBZG1pbkFwaSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/AuthClient.js":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/AuthClient.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _GoTrueClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueClient */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js\");\n\nconst AuthClient = _GoTrueClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AuthClient); //# sourceMappingURL=AuthClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvQXV0aENsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwQztBQUMxQyxNQUFNQyxhQUFhRCxxREFBWUE7QUFDL0IsaUVBQWVDLFVBQVVBLEVBQUMsQ0FDMUIsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5jaG9yLXdvcmtmbG93cy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9BdXRoQ2xpZW50LmpzPzRmOGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEdvVHJ1ZUNsaWVudCBmcm9tICcuL0dvVHJ1ZUNsaWVudCc7XG5jb25zdCBBdXRoQ2xpZW50ID0gR29UcnVlQ2xpZW50O1xuZXhwb3J0IGRlZmF1bHQgQXV0aENsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF1dGhDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIkdvVHJ1ZUNsaWVudCIsIkF1dGhDbGllbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/AuthClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GoTrueAdminApi)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/fetch */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/helpers */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _lib_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/types */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/types.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/errors */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n\n\n\n\n\nclass GoTrueAdminApi {\n    /**\n     * Creates an admin API client that can be used to manage users and OAuth clients.\n     *\n     * @example\n     * ```ts\n     * import { GoTrueAdminApi } from '@supabase/auth-js'\n     *\n     * const admin = new GoTrueAdminApi({\n     *   url: 'https://xyzcompany.supabase.co/auth/v1',\n     *   headers: { Authorization: `Bearer ${process.env.SUPABASE_SERVICE_ROLE_KEY}` },\n     * })\n     * ```\n     */ constructor({ url = \"\", headers = {}, fetch }){\n        this.url = url;\n        this.headers = headers;\n        this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.resolveFetch)(fetch);\n        this.mfa = {\n            listFactors: this._listFactors.bind(this),\n            deleteFactor: this._deleteFactor.bind(this)\n        };\n        this.oauth = {\n            listClients: this._listOAuthClients.bind(this),\n            createClient: this._createOAuthClient.bind(this),\n            getClient: this._getOAuthClient.bind(this),\n            updateClient: this._updateOAuthClient.bind(this),\n            deleteClient: this._deleteOAuthClient.bind(this),\n            regenerateClientSecret: this._regenerateOAuthClientSecret.bind(this)\n        };\n    }\n    /**\n     * Removes a logged-in session.\n     * @param jwt A valid, logged-in JWT.\n     * @param scope The logout sope.\n     */ async signOut(jwt, scope = _lib_types__WEBPACK_IMPORTED_MODULE_2__.SIGN_OUT_SCOPES[0]) {\n        if (_lib_types__WEBPACK_IMPORTED_MODULE_2__.SIGN_OUT_SCOPES.indexOf(scope) < 0) {\n            throw new Error(`@supabase/auth-js: Parameter scope must be one of ${_lib_types__WEBPACK_IMPORTED_MODULE_2__.SIGN_OUT_SCOPES.join(\", \")}`);\n        }\n        try {\n            await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", `${this.url}/logout?scope=${scope}`, {\n                headers: this.headers,\n                jwt,\n                noResolveJson: true\n            });\n            return {\n                data: null,\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sends an invite link to an email address.\n     * @param email The email address of the user.\n     * @param options Additional options to be included when inviting.\n     */ async inviteUserByEmail(email, options = {}) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", `${this.url}/invite`, {\n                body: {\n                    email,\n                    data: options.data\n                },\n                headers: this.headers,\n                redirectTo: options.redirectTo,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Generates email links and OTPs to be sent via a custom email provider.\n     * @param email The user's email.\n     * @param options.password User password. For signup only.\n     * @param options.data Optional user metadata. For signup only.\n     * @param options.redirectTo The redirect url which should be appended to the generated link\n     */ async generateLink(params) {\n        try {\n            const { options } = params, rest = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(params, [\n                \"options\"\n            ]);\n            const body = Object.assign(Object.assign({}, rest), options);\n            if (\"newEmail\" in rest) {\n                // replace newEmail with new_email in request body\n                body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;\n                delete body[\"newEmail\"];\n            }\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", `${this.url}/admin/generate_link`, {\n                body: body,\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._generateLinkResponse,\n                redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        properties: null,\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    // User Admin API\n    /**\n     * Creates a new user.\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async createUser(attributes) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", `${this.url}/admin/users`, {\n                body: attributes,\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Get a list of users.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.\n     */ async listUsers(params) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        try {\n            const pagination = {\n                nextPage: null,\n                lastPage: 0,\n                total: 0\n            };\n            const response = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"GET\", `${this.url}/admin/users`, {\n                headers: this.headers,\n                noResolveJson: true,\n                query: {\n                    page: (_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : \"\",\n                    per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : \"\"\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._noResolveJsonResponse\n            });\n            if (response.error) throw response.error;\n            const users = await response.json();\n            const total = (_e = response.headers.get(\"x-total-count\")) !== null && _e !== void 0 ? _e : 0;\n            const links = (_g = (_f = response.headers.get(\"link\")) === null || _f === void 0 ? void 0 : _f.split(\",\")) !== null && _g !== void 0 ? _g : [];\n            if (links.length > 0) {\n                links.forEach((link)=>{\n                    const page = parseInt(link.split(\";\")[0].split(\"=\")[1].substring(0, 1));\n                    const rel = JSON.parse(link.split(\";\")[1].split(\"=\")[1]);\n                    pagination[`${rel}Page`] = page;\n                });\n                pagination.total = parseInt(total);\n            }\n            return {\n                data: Object.assign(Object.assign({}, users), pagination),\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        users: []\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Get user by id.\n     *\n     * @param uid The user's unique identifier\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async getUserById(uid) {\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(uid);\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"GET\", `${this.url}/admin/users/${uid}`, {\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Updates the user data. Changes are applied directly without confirmation flows.\n     *\n     * @param uid The user's unique identifier\n     * @param attributes The data you want to update.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     *\n     * @remarks\n     * **Important:** This is a server-side operation and does **not** trigger client-side\n     * `onAuthStateChange` listeners. The admin API has no connection to client state.\n     *\n     * To sync changes to the client after calling this method:\n     * 1. On the client, call `supabase.auth.refreshSession()` to fetch the updated user data\n     * 2. This will trigger the `TOKEN_REFRESHED` event and notify all listeners\n     *\n     * @example\n     * ```typescript\n     * // Server-side (Edge Function)\n     * const { data, error } = await supabase.auth.admin.updateUserById(\n     *   userId,\n     *   { user_metadata: { preferences: { theme: 'dark' } } }\n     * )\n     *\n     * // Client-side (to sync the changes)\n     * const { data, error } = await supabase.auth.refreshSession()\n     * // onAuthStateChange listeners will now be notified with updated user\n     * ```\n     *\n     * @see {@link GoTrueClient.refreshSession} for syncing admin changes to the client\n     * @see {@link GoTrueClient.updateUser} for client-side user updates (triggers listeners automatically)\n     */ async updateUserById(uid, attributes) {\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(uid);\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"PUT\", `${this.url}/admin/users/${uid}`, {\n                body: attributes,\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Delete a user. Requires a `service_role` key.\n     *\n     * @param id The user id you want to remove.\n     * @param shouldSoftDelete If true, then the user will be soft-deleted from the auth schema. Soft deletion allows user identification from the hashed user ID but is not reversible.\n     * Defaults to false for backward compatibility.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async deleteUser(id, shouldSoftDelete = false) {\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(id);\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"DELETE\", `${this.url}/admin/users/${id}`, {\n                headers: this.headers,\n                body: {\n                    should_soft_delete: shouldSoftDelete\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    async _listFactors(params) {\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(params.userId);\n        try {\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"GET\", `${this.url}/admin/users/${params.userId}/factors`, {\n                headers: this.headers,\n                xform: (factors)=>{\n                    return {\n                        data: {\n                            factors\n                        },\n                        error: null\n                    };\n                }\n            });\n            return {\n                data,\n                error\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    async _deleteFactor(params) {\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(params.userId);\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(params.id);\n        try {\n            const data = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"DELETE\", `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {\n                headers: this.headers\n            });\n            return {\n                data,\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Lists all OAuth clients with optional pagination.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _listOAuthClients(params) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        try {\n            const pagination = {\n                nextPage: null,\n                lastPage: 0,\n                total: 0\n            };\n            const response = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"GET\", `${this.url}/admin/oauth/clients`, {\n                headers: this.headers,\n                noResolveJson: true,\n                query: {\n                    page: (_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : \"\",\n                    per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : \"\"\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._noResolveJsonResponse\n            });\n            if (response.error) throw response.error;\n            const clients = await response.json();\n            const total = (_e = response.headers.get(\"x-total-count\")) !== null && _e !== void 0 ? _e : 0;\n            const links = (_g = (_f = response.headers.get(\"link\")) === null || _f === void 0 ? void 0 : _f.split(\",\")) !== null && _g !== void 0 ? _g : [];\n            if (links.length > 0) {\n                links.forEach((link)=>{\n                    const page = parseInt(link.split(\";\")[0].split(\"=\")[1].substring(0, 1));\n                    const rel = JSON.parse(link.split(\";\")[1].split(\"=\")[1]);\n                    pagination[`${rel}Page`] = page;\n                });\n                pagination.total = parseInt(total);\n            }\n            return {\n                data: Object.assign(Object.assign({}, clients), pagination),\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        clients: []\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Creates a new OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _createOAuthClient(params) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", `${this.url}/admin/oauth/clients`, {\n                body: params,\n                headers: this.headers,\n                xform: (client)=>{\n                    return {\n                        data: client,\n                        error: null\n                    };\n                }\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Gets details of a specific OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _getOAuthClient(clientId) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"GET\", `${this.url}/admin/oauth/clients/${clientId}`, {\n                headers: this.headers,\n                xform: (client)=>{\n                    return {\n                        data: client,\n                        error: null\n                    };\n                }\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Updates an existing OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _updateOAuthClient(clientId, params) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"PUT\", `${this.url}/admin/oauth/clients/${clientId}`, {\n                body: params,\n                headers: this.headers,\n                xform: (client)=>{\n                    return {\n                        data: client,\n                        error: null\n                    };\n                }\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Deletes an OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _deleteOAuthClient(clientId) {\n        try {\n            await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"DELETE\", `${this.url}/admin/oauth/clients/${clientId}`, {\n                headers: this.headers,\n                noResolveJson: true\n            });\n            return {\n                data: null,\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Regenerates the secret for an OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _regenerateOAuthClientSecret(clientId) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", `${this.url}/admin/oauth/clients/${clientId}/regenerate_secret`, {\n                headers: this.headers,\n                xform: (client)=>{\n                    return {\n                        data: client,\n                        error: null\n                    };\n                }\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n} //# sourceMappingURL=GoTrueAdminApi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvR29UcnVlQWRtaW5BcGkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQStCO0FBQ3VFO0FBQzNDO0FBQ1o7QUFDSjtBQUM1QixNQUFNUztJQUNqQjs7Ozs7Ozs7Ozs7O0tBWUMsR0FDREMsWUFBWSxFQUFFQyxNQUFNLEVBQUUsRUFBRUMsVUFBVSxDQUFDLENBQUMsRUFBRUMsS0FBSyxFQUFHLENBQUU7UUFDNUMsSUFBSSxDQUFDRixHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxLQUFLLEdBQUdSLDBEQUFZQSxDQUFDUTtRQUMxQixJQUFJLENBQUNDLEdBQUcsR0FBRztZQUNQQyxhQUFhLElBQUksQ0FBQ0MsWUFBWSxDQUFDQyxJQUFJLENBQUMsSUFBSTtZQUN4Q0MsY0FBYyxJQUFJLENBQUNDLGFBQWEsQ0FBQ0YsSUFBSSxDQUFDLElBQUk7UUFDOUM7UUFDQSxJQUFJLENBQUNHLEtBQUssR0FBRztZQUNUQyxhQUFhLElBQUksQ0FBQ0MsaUJBQWlCLENBQUNMLElBQUksQ0FBQyxJQUFJO1lBQzdDTSxjQUFjLElBQUksQ0FBQ0Msa0JBQWtCLENBQUNQLElBQUksQ0FBQyxJQUFJO1lBQy9DUSxXQUFXLElBQUksQ0FBQ0MsZUFBZSxDQUFDVCxJQUFJLENBQUMsSUFBSTtZQUN6Q1UsY0FBYyxJQUFJLENBQUNDLGtCQUFrQixDQUFDWCxJQUFJLENBQUMsSUFBSTtZQUMvQ1ksY0FBYyxJQUFJLENBQUNDLGtCQUFrQixDQUFDYixJQUFJLENBQUMsSUFBSTtZQUMvQ2Msd0JBQXdCLElBQUksQ0FBQ0MsNEJBQTRCLENBQUNmLElBQUksQ0FBQyxJQUFJO1FBQ3ZFO0lBQ0o7SUFDQTs7OztLQUlDLEdBQ0QsTUFBTWdCLFFBQVFDLEdBQUcsRUFBRUMsUUFBUTVCLHVEQUFlLENBQUMsRUFBRSxFQUFFO1FBQzNDLElBQUlBLHVEQUFlQSxD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d0RBQVdBLENBQUNpQyxRQUFRO2dCQUNwQixPQUFPO29CQUFFRCxNQUFNO29CQUFNQztnQkFBTTtZQUMvQjtZQUNBLE1BQU1BO1FBQ1Y7SUFDSjtJQUNBOzs7OztLQUtDLEdBQ0QsTUFBTVQsNkJBQTZCcUUsUUFBUSxFQUFFO1FBQ3pDLElBQUk7WUFDQSxPQUFPLE1BQU1sRyxvREFBUUEsQ0FBQyxJQUFJLENBQUNVLEtBQUssRUFBRSxRQUFRLENBQUMsRUFBRSxJQUFJLENBQUNGLEdBQUcsQ0FBQyxxQkFBcUIsRUFBRTBGLFNBQVMsa0JBQWtCLENBQUMsRUFBRTtnQkFDdkd6RixTQUFTLElBQUksQ0FBQ0EsT0FBTztnQkFDckJtQyxPQUFPLENBQUNxRDtvQkFDSixPQUFPO3dCQUFFNUQsTUFBTTREO3dCQUFRM0QsT0FBTztvQkFBSztnQkFDdkM7WUFDSjtRQUNKLEVBQ0EsT0FBT0EsT0FBTztZQUNWLElBQUlqQyx3REFBV0EsQ0FBQ2lDLFFBQVE7Z0JBQ3BCLE9BQU87b0JBQUVELE1BQU07b0JBQU1DO2dCQUFNO1lBQy9CO1lBQ0EsTUFBTUE7UUFDVjtJQUNKO0FBQ0osRUFDQSwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmNob3Itd29ya2Zsb3dzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL0dvVHJ1ZUFkbWluQXBpLmpzPzRhMDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19yZXN0IH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBfZ2VuZXJhdGVMaW5rUmVzcG9uc2UsIF9ub1Jlc29sdmVKc29uUmVzcG9uc2UsIF9yZXF1ZXN0LCBfdXNlclJlc3BvbnNlLCB9IGZyb20gJy4vbGliL2ZldGNoJztcbmltcG9ydCB7IHJlc29sdmVGZXRjaCwgdmFsaWRhdGVVVUlEIH0gZnJvbSAnLi9saWIvaGVscGVycyc7XG5pbXBvcnQgeyBTSUdOX09VVF9TQ09QRVMsIH0gZnJvbSAnLi9saWIvdHlwZXMnO1xuaW1wb3J0IHsgaXNBdXRoRXJyb3IgfSBmcm9tICcuL2xpYi9lcnJvcnMnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR29UcnVlQWRtaW5BcGkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYWRtaW4gQVBJIGNsaWVudCB0aGF0IGNhbiBiZSB1c2VkIHRvIG1hbmFnZSB1c2VycyBhbmQgT0F1dGggY2xpZW50cy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBpbXBvcnQgeyBHb1RydWVBZG1pbkFwaSB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICAgICAqXG4gICAgICogY29uc3QgYWRtaW4gPSBuZXcgR29UcnVlQWRtaW5BcGkoe1xuICAgICAqICAgdXJsOiAnaHR0cHM6Ly94eXpjb21wYW55LnN1cGFiYXNlLmNvL2F1dGgvdjEnLFxuICAgICAqICAgaGVhZGVyczogeyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7cHJvY2Vzcy5lbnYuU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWX1gIH0sXG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IHVybCA9ICcnLCBoZWFkZXJzID0ge30sIGZldGNoLCB9KSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICB0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKGZldGNoKTtcbiAgICAgICAgdGhpcy5tZmEgPSB7XG4gICAgICAgICAgICBsaXN0RmFjdG9yczogdGhpcy5fbGlzdEZhY3RvcnMuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGRlbGV0ZUZhY3RvcjogdGhpcy5fZGVsZXRlRmFjdG9yLmJpbmQodGhpcyksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub2F1dGggPSB7XG4gICAgICAgICAgICBsaXN0Q2xpZW50czogdGhpcy5fbGlzdE9BdXRoQ2xpZW50cy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgY3JlYXRlQ2xpZW50OiB0aGlzLl9jcmVhdGVPQXV0aENsaWVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2V0Q2xpZW50OiB0aGlzLl9nZXRPQXV0aENsaWVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgdXBkYXRlQ2xpZW50OiB0aGlzLl91cGRhdGVPQXV0aENsaWVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZGVsZXRlQ2xpZW50OiB0aGlzLl9kZWxldGVPQXV0aENsaWVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgcmVnZW5lcmF0ZUNsaWVudFNlY3JldDogdGhpcy5fcmVnZW5lcmF0ZU9BdXRoQ2xpZW50U2VjcmV0LmJpbmQodGhpcyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBsb2dnZWQtaW4gc2Vzc2lvbi5cbiAgICAgKiBAcGFyYW0gand0IEEgdmFsaWQsIGxvZ2dlZC1pbiBKV1QuXG4gICAgICogQHBhcmFtIHNjb3BlIFRoZSBsb2dvdXQgc29wZS5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduT3V0KGp3dCwgc2NvcGUgPSBTSUdOX09VVF9TQ09QRVNbMF0pIHtcbiAgICAgICAgaWYgKFNJR05fT1VUX1NDT1BFUy5pbmRleE9mKHNjb3BlKSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IFBhcmFtZXRlciBzY29wZSBtdXN0IGJlIG9uZSBvZiAke1NJR05fT1VUX1NDT1BFUy5qb2luKCcsICcpfWApO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9sb2dvdXQ/c2NvcGU9JHtzY29wZX1gLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGp3dCxcbiAgICAgICAgICAgICAgICBub1Jlc29sdmVKc29uOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhbiBpbnZpdGUgbGluayB0byBhbiBlbWFpbCBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSBlbWFpbCBUaGUgZW1haWwgYWRkcmVzcyBvZiB0aGUgdXNlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgdG8gYmUgaW5jbHVkZWQgd2hlbiBpbnZpdGluZy5cbiAgICAgKi9cbiAgICBhc3luYyBpbnZpdGVVc2VyQnlFbWFpbChlbWFpbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vaW52aXRlYCwge1xuICAgICAgICAgICAgICAgIGJvZHk6IHsgZW1haWwsIGRhdGE6IG9wdGlvbnMuZGF0YSB9LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zLnJlZGlyZWN0VG8sXG4gICAgICAgICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBlbWFpbCBsaW5rcyBhbmQgT1RQcyB0byBiZSBzZW50IHZpYSBhIGN1c3RvbSBlbWFpbCBwcm92aWRlci5cbiAgICAgKiBAcGFyYW0gZW1haWwgVGhlIHVzZXIncyBlbWFpbC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wYXNzd29yZCBVc2VyIHBhc3N3b3JkLiBGb3Igc2lnbnVwIG9ubHkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGF0YSBPcHRpb25hbCB1c2VyIG1ldGFkYXRhLiBGb3Igc2lnbnVwIG9ubHkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVkaXJlY3RUbyBUaGUgcmVkaXJlY3QgdXJsIHdoaWNoIHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgZ2VuZXJhdGVkIGxpbmtcbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZUxpbmsocGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHBhcmFtcywgcmVzdCA9IF9fcmVzdChwYXJhbXMsIFtcIm9wdGlvbnNcIl0pO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdCksIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKCduZXdFbWFpbCcgaW4gcmVzdCkge1xuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgbmV3RW1haWwgd2l0aCBuZXdfZW1haWwgaW4gcmVxdWVzdCBib2R5XG4gICAgICAgICAgICAgICAgYm9keS5uZXdfZW1haWwgPSByZXN0ID09PSBudWxsIHx8IHJlc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3QubmV3RW1haWw7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ25ld0VtYWlsJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vYWRtaW4vZ2VuZXJhdGVfbGlua2AsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX2dlbmVyYXRlTGlua1Jlc3BvbnNlLFxuICAgICAgICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZWRpcmVjdFRvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBVc2VyIEFkbWluIEFQSVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdXNlci5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVVzZXIoYXR0cmlidXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzYCwge1xuICAgICAgICAgICAgICAgIGJvZHk6IGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBsaXN0IG9mIHVzZXJzLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIEFuIG9iamVjdCB3aGljaCBzdXBwb3J0cyBgcGFnZWAgYW5kIGBwZXJQYWdlYCBhcyBudW1iZXJzLCB0byBhbHRlciB0aGUgcGFnaW5hdGVkIHJlc3VsdHMuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdFVzZXJzKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYWdpbmF0aW9uID0geyBuZXh0UGFnZTogbnVsbCwgbGFzdFBhZ2U6IDAsIHRvdGFsOiAwIH07XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnNgLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIG5vUmVzb2x2ZUpzb246IHRydWUsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZTogKF9iID0gKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnBhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgcGVyX3BhZ2U6IChfZCA9IChfYyA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5wZXJQYWdlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9TdHJpbmcoKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogJycsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX25vUmVzb2x2ZUpzb25SZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKVxuICAgICAgICAgICAgICAgIHRocm93IHJlc3BvbnNlLmVycm9yO1xuICAgICAgICAgICAgY29uc3QgdXNlcnMgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBjb25zdCB0b3RhbCA9IChfZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LXRvdGFsLWNvdW50JykpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsaW5rcyA9IChfZyA9IChfZiA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdsaW5rJykpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5zcGxpdCgnLCcpKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBbXTtcbiAgICAgICAgICAgIGlmIChsaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGlua3MuZm9yRWFjaCgobGluaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWdlID0gcGFyc2VJbnQobGluay5zcGxpdCgnOycpWzBdLnNwbGl0KCc9JylbMV0uc3Vic3RyaW5nKDAsIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVsID0gSlNPTi5wYXJzZShsaW5rLnNwbGl0KCc7JylbMV0uc3BsaXQoJz0nKVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2luYXRpb25bYCR7cmVsfVBhZ2VgXSA9IHBhZ2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcGFnaW5hdGlvbi50b3RhbCA9IHBhcnNlSW50KHRvdGFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdXNlcnMpLCBwYWdpbmF0aW9uKSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXJzOiBbXSB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHVzZXIgYnkgaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdWlkIFRoZSB1c2VyJ3MgdW5pcXVlIGlkZW50aWZpZXJcbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VXNlckJ5SWQodWlkKSB7XG4gICAgICAgIHZhbGlkYXRlVVVJRCh1aWQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnMvJHt1aWR9YCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdXNlciBkYXRhLiBDaGFuZ2VzIGFyZSBhcHBsaWVkIGRpcmVjdGx5IHdpdGhvdXQgY29uZmlybWF0aW9uIGZsb3dzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVpZCBUaGUgdXNlcidzIHVuaXF1ZSBpZGVudGlmaWVyXG4gICAgICogQHBhcmFtIGF0dHJpYnV0ZXMgVGhlIGRhdGEgeW91IHdhbnQgdG8gdXBkYXRlLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogKipJbXBvcnRhbnQ6KiogVGhpcyBpcyBhIHNlcnZlci1zaWRlIG9wZXJhdGlvbiBhbmQgZG9lcyAqKm5vdCoqIHRyaWdnZXIgY2xpZW50LXNpZGVcbiAgICAgKiBgb25BdXRoU3RhdGVDaGFuZ2VgIGxpc3RlbmVycy4gVGhlIGFkbWluIEFQSSBoYXMgbm8gY29ubmVjdGlvbiB0byBjbGllbnQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBUbyBzeW5jIGNoYW5nZXMgdG8gdGhlIGNsaWVudCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kOlxuICAgICAqIDEuIE9uIHRoZSBjbGllbnQsIGNhbGwgYHN1cGFiYXNlLmF1dGgucmVmcmVzaFNlc3Npb24oKWAgdG8gZmV0Y2ggdGhlIHVwZGF0ZWQgdXNlciBkYXRhXG4gICAgICogMi4gVGhpcyB3aWxsIHRyaWdnZXIgdGhlIGBUT0tFTl9SRUZSRVNIRURgIGV2ZW50IGFuZCBub3RpZnkgYWxsIGxpc3RlbmVyc1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gU2VydmVyLXNpZGUgKEVkZ2UgRnVuY3Rpb24pXG4gICAgICogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5hZG1pbi51cGRhdGVVc2VyQnlJZChcbiAgICAgKiAgIHVzZXJJZCxcbiAgICAgKiAgIHsgdXNlcl9tZXRhZGF0YTogeyBwcmVmZXJlbmNlczogeyB0aGVtZTogJ2RhcmsnIH0gfSB9XG4gICAgICogKVxuICAgICAqXG4gICAgICogLy8gQ2xpZW50LXNpZGUgKHRvIHN5bmMgdGhlIGNoYW5nZXMpXG4gICAgICogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5yZWZyZXNoU2Vzc2lvbigpXG4gICAgICogLy8gb25BdXRoU3RhdGVDaGFuZ2UgbGlzdGVuZXJzIHdpbGwgbm93IGJlIG5vdGlmaWVkIHdpdGggdXBkYXRlZCB1c2VyXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBHb1RydWVDbGllbnQucmVmcmVzaFNlc3Npb259IGZvciBzeW5jaW5nIGFkbWluIGNoYW5nZXMgdG8gdGhlIGNsaWVudFxuICAgICAqIEBzZWUge0BsaW5rIEdvVHJ1ZUNsaWVudC51cGRhdGVVc2VyfSBmb3IgY2xpZW50LXNpZGUgdXNlciB1cGRhdGVzICh0cmlnZ2VycyBsaXN0ZW5lcnMgYXV0b21hdGljYWxseSlcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVVc2VyQnlJZCh1aWQsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdmFsaWRhdGVVVUlEKHVpZCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BVVCcsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke3VpZH1gLCB7XG4gICAgICAgICAgICAgICAgYm9keTogYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHVzZXIuIFJlcXVpcmVzIGEgYHNlcnZpY2Vfcm9sZWAga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIFRoZSB1c2VyIGlkIHlvdSB3YW50IHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0gc2hvdWxkU29mdERlbGV0ZSBJZiB0cnVlLCB0aGVuIHRoZSB1c2VyIHdpbGwgYmUgc29mdC1kZWxldGVkIGZyb20gdGhlIGF1dGggc2NoZW1hLiBTb2Z0IGRlbGV0aW9uIGFsbG93cyB1c2VyIGlkZW50aWZpY2F0aW9uIGZyb20gdGhlIGhhc2hlZCB1c2VyIElEIGJ1dCBpcyBub3QgcmV2ZXJzaWJsZS5cbiAgICAgKiBEZWZhdWx0cyB0byBmYWxzZSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlVXNlcihpZCwgc2hvdWxkU29mdERlbGV0ZSA9IGZhbHNlKSB7XG4gICAgICAgIHZhbGlkYXRlVVVJRChpZCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0RFTEVURScsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke2lkfWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRfc29mdF9kZWxldGU6IHNob3VsZFNvZnREZWxldGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2xpc3RGYWN0b3JzKHBhcmFtcykge1xuICAgICAgICB2YWxpZGF0ZVVVSUQocGFyYW1zLnVzZXJJZCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzLyR7cGFyYW1zLnVzZXJJZH0vZmFjdG9yc2AsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IChmYWN0b3JzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgZmFjdG9ycyB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9kZWxldGVGYWN0b3IocGFyYW1zKSB7XG4gICAgICAgIHZhbGlkYXRlVVVJRChwYXJhbXMudXNlcklkKTtcbiAgICAgICAgdmFsaWRhdGVVVUlEKHBhcmFtcy5pZCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0RFTEVURScsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke3BhcmFtcy51c2VySWR9L2ZhY3RvcnMvJHtwYXJhbXMuaWR9YCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgYWxsIE9BdXRoIGNsaWVudHMgd2l0aCBvcHRpb25hbCBwYWdpbmF0aW9uLlxuICAgICAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIF9saXN0T0F1dGhDbGllbnRzKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYWdpbmF0aW9uID0geyBuZXh0UGFnZTogbnVsbCwgbGFzdFBhZ2U6IDAsIHRvdGFsOiAwIH07XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vYWRtaW4vb2F1dGgvY2xpZW50c2AsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgbm9SZXNvbHZlSnNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICBwYWdlOiAoX2IgPSAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGFnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvU3RyaW5nKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnLFxuICAgICAgICAgICAgICAgICAgICBwZXJfcGFnZTogKF9kID0gKF9jID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnBlclBhZ2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAnJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfbm9SZXNvbHZlSnNvblJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpXG4gICAgICAgICAgICAgICAgdGhyb3cgcmVzcG9uc2UuZXJyb3I7XG4gICAgICAgICAgICBjb25zdCBjbGllbnRzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgY29uc3QgdG90YWwgPSAoX2UgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC10b3RhbC1jb3VudCcpKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAwO1xuICAgICAgICAgICAgY29uc3QgbGlua3MgPSAoX2cgPSAoX2YgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnbGluaycpKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yuc3BsaXQoJywnKSkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogW107XG4gICAgICAgICAgICBpZiAobGlua3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxpbmtzLmZvckVhY2goKGxpbmspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFnZSA9IHBhcnNlSW50KGxpbmsuc3BsaXQoJzsnKVswXS5zcGxpdCgnPScpWzFdLnN1YnN0cmluZygwLCAxKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbCA9IEpTT04ucGFyc2UobGluay5zcGxpdCgnOycpWzFdLnNwbGl0KCc9JylbMV0pO1xuICAgICAgICAgICAgICAgICAgICBwYWdpbmF0aW9uW2Ake3JlbH1QYWdlYF0gPSBwYWdlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHBhZ2luYXRpb24udG90YWwgPSBwYXJzZUludCh0b3RhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNsaWVudHMpLCBwYWdpbmF0aW9uKSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IGNsaWVudHM6IFtdIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE9BdXRoIGNsaWVudC5cbiAgICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBhc3luYyBfY3JlYXRlT0F1dGhDbGllbnQocGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vYWRtaW4vb2F1dGgvY2xpZW50c2AsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiAoY2xpZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IGNsaWVudCwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgZGV0YWlscyBvZiBhIHNwZWNpZmljIE9BdXRoIGNsaWVudC5cbiAgICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBhc3luYyBfZ2V0T0F1dGhDbGllbnQoY2xpZW50SWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L2FkbWluL29hdXRoL2NsaWVudHMvJHtjbGllbnRJZH1gLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiAoY2xpZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IGNsaWVudCwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYW4gZXhpc3RpbmcgT0F1dGggY2xpZW50LlxuICAgICAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIF91cGRhdGVPQXV0aENsaWVudChjbGllbnRJZCwgcGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BVVCcsIGAke3RoaXMudXJsfS9hZG1pbi9vYXV0aC9jbGllbnRzLyR7Y2xpZW50SWR9YCwge1xuICAgICAgICAgICAgICAgIGJvZHk6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IChjbGllbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogY2xpZW50LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhbiBPQXV0aCBjbGllbnQuXG4gICAgICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgYXN5bmMgX2RlbGV0ZU9BdXRoQ2xpZW50KGNsaWVudElkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnREVMRVRFJywgYCR7dGhpcy51cmx9L2FkbWluL29hdXRoL2NsaWVudHMvJHtjbGllbnRJZH1gLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIG5vUmVzb2x2ZUpzb246IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2VuZXJhdGVzIHRoZSBzZWNyZXQgZm9yIGFuIE9BdXRoIGNsaWVudC5cbiAgICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBhc3luYyBfcmVnZW5lcmF0ZU9BdXRoQ2xpZW50U2VjcmV0KGNsaWVudElkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vYWRtaW4vb2F1dGgvY2xpZW50cy8ke2NsaWVudElkfS9yZWdlbmVyYXRlX3NlY3JldGAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IChjbGllbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogY2xpZW50LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Hb1RydWVBZG1pbkFwaS5qcy5tYXAiXSwibmFtZXMiOlsiX19yZXN0IiwiX2dlbmVyYXRlTGlua1Jlc3BvbnNlIiwiX25vUmVzb2x2ZUpzb25SZXNwb25zZSIsIl9yZXF1ZXN0IiwiX3VzZXJSZXNwb25zZSIsInJlc29sdmVGZXRjaCIsInZhbGlkYXRlVVVJRCIsIlNJR05fT1VUX1NDT1BFUyIsImlzQXV0aEVycm9yIiwiR29UcnVlQWRtaW5BcGkiLCJjb25zdHJ1Y3RvciIsInVybCIsImhlYWRlcnMiLCJmZXRjaCIsIm1mYSIsImxpc3RGYWN0b3JzIiwiX2xpc3RGYWN0b3JzIiwiYmluZCIsImRlbGV0ZUZhY3RvciIsIl9kZWxldGVGYWN0b3IiLCJvYXV0aCIsImxpc3RDbGllbnRzIiwiX2xpc3RPQXV0aENsaWVudHMiLCJjcmVhdGVDbGllbnQiLCJfY3JlYXRlT0F1dGhDbGllbnQiLCJnZXRDbGllbnQiLCJfZ2V0T0F1dGhDbGllbnQiLCJ1cGRhdGVDbGllbnQiLCJfdXBkYXRlT0F1dGhDbGllbnQiLCJkZWxldGVDbGllbnQiLCJfZGVsZXRlT0F1dGhDbGllbnQiLCJyZWdlbmVyYXRlQ2xpZW50U2VjcmV0IiwiX3JlZ2VuZXJhdGVPQXV0aENsaWVudFNlY3JldCIsInNpZ25PdXQiLCJqd3QiLCJzY29wZSIsImluZGV4T2YiLCJFcnJvciIsImpvaW4iLCJub1Jlc29sdmVKc29uIiwiZGF0YSIsImVycm9yIiwiaW52aXRlVXNlckJ5RW1haWwiLCJlbWFpbCIsIm9wdGlvbnMiLCJib2R5IiwicmVkaXJlY3RUbyIsInhmb3JtIiwidXNlciIsImdlbmVyYXRlTGluayIsInBhcmFtcyIsInJlc3QiLCJPYmplY3QiLCJhc3NpZ24iLCJuZXdfZW1haWwiLCJuZXdFbWFpbCIsInByb3BlcnRpZXMiLCJjcmVhdGVVc2VyIiwiYXR0cmlidXRlcyIsImxpc3RVc2VycyIsIl9hIiwiX2IiLCJfYyIsIl9kIiwiX2UiLCJfZiIsIl9nIiwicGFnaW5hdGlvbiIsIm5leHRQYWdlIiwibGFzdFBhZ2UiLCJ0b3RhbCIsInJlc3BvbnNlIiwicXVlcnkiLCJwYWdlIiwidG9TdHJpbmciLCJwZXJfcGFnZSIsInBlclBhZ2UiLCJ1c2VycyIsImpzb24iLCJnZXQiLCJsaW5rcyIsInNwbGl0IiwibGVuZ3RoIiwiZm9yRWFjaCIsImxpbmsiLCJwYXJzZUludCIsInN1YnN0cmluZyIsInJlbCIsIkpTT04iLCJwYXJzZSIsImdldFVzZXJCeUlkIiwidWlkIiwidXBkYXRlVXNlckJ5SWQiLCJkZWxldGVVc2VyIiwiaWQiLCJzaG91bGRTb2Z0RGVsZXRlIiwic2hvdWxkX3NvZnRfZGVsZXRlIiwidXNlcklkIiwiZmFjdG9ycyIsImNsaWVudHMiLCJjbGllbnQiLCJjbGllbnRJZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueAdminApi */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\");\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/constants */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/errors */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/fetch */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/helpers */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _lib_local_storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/local-storage */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js\");\n/* harmony import */ var _lib_locks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/locks */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js\");\n/* harmony import */ var _lib_polyfills__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/polyfills */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js\");\n/* harmony import */ var _lib_version__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/version */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/version.js\");\n/* harmony import */ var _lib_base64url__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/base64url */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/base64url.js\");\n/* harmony import */ var _lib_web3_ethereum__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/web3/ethereum */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/web3/ethereum.js\");\n/* harmony import */ var _lib_webauthn__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/webauthn */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n(0,_lib_polyfills__WEBPACK_IMPORTED_MODULE_7__.polyfillGlobalThis)(); // Make \"globalThis\" available\nconst DEFAULT_OPTIONS = {\n    url: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.GOTRUE_URL,\n    storageKey: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.STORAGE_KEY,\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    headers: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_HEADERS,\n    flowType: \"implicit\",\n    debug: false,\n    hasCustomAuthorizationHeader: false,\n    throwOnError: false,\n    lockAcquireTimeout: 10000,\n    skipAutoInitialize: false\n};\nasync function lockNoOp(name, acquireTimeout, fn) {\n    return await fn();\n}\n/**\n * Caches JWKS values for all clients created in the same environment. This is\n * especially useful for shared-memory execution environments such as Vercel's\n * Fluid Compute, AWS Lambda or Supabase's Edge Functions. Regardless of how\n * many clients are created, if they share the same storage key they will use\n * the same JWKS cache, significantly speeding up getClaims() with asymmetric\n * JWTs.\n */ const GLOBAL_JWKS = {};\nclass GoTrueClient {\n    /**\n     * The JWKS used for verifying asymmetric JWTs\n     */ get jwks() {\n        var _a, _b;\n        return (_b = (_a = GLOBAL_JWKS[this.storageKey]) === null || _a === void 0 ? void 0 : _a.jwks) !== null && _b !== void 0 ? _b : {\n            keys: []\n        };\n    }\n    set jwks(value) {\n        GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), {\n            jwks: value\n        });\n    }\n    get jwks_cached_at() {\n        var _a, _b;\n        return (_b = (_a = GLOBAL_JWKS[this.storageKey]) === null || _a === void 0 ? void 0 : _a.cachedAt) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER;\n    }\n    set jwks_cached_at(value) {\n        GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), {\n            cachedAt: value\n        });\n    }\n    /**\n     * Create a new client for use in the browser.\n     *\n     * @example\n     * ```ts\n     * import { GoTrueClient } from '@supabase/auth-js'\n     *\n     * const auth = new GoTrueClient({\n     *   url: 'https://xyzcompany.supabase.co/auth/v1',\n     *   headers: { apikey: 'public-anon-key' },\n     *   storageKey: 'supabase-auth',\n     * })\n     * ```\n     */ constructor(options){\n        var _a, _b, _c;\n        /**\n         * @experimental\n         */ this.userStorage = null;\n        this.memoryStorage = null;\n        this.stateChangeEmitters = new Map();\n        this.autoRefreshTicker = null;\n        this.autoRefreshTickTimeout = null;\n        this.visibilityChangedCallback = null;\n        this.refreshingDeferred = null;\n        /**\n         * Keeps track of the async client initialization.\n         * When null or not yet resolved the auth state is `unknown`\n         * Once resolved the auth state is known and it's safe to call any further client methods.\n         * Keep extra care to never reject or throw uncaught errors\n         */ this.initializePromise = null;\n        this.detectSessionInUrl = true;\n        this.hasCustomAuthorizationHeader = false;\n        this.suppressGetSessionWarning = false;\n        this.lockAcquired = false;\n        this.pendingInLock = [];\n        /**\n         * Used to broadcast state change events to other tabs listening.\n         */ this.broadcastChannel = null;\n        this.logger = console.log;\n        const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n        this.storageKey = settings.storageKey;\n        this.instanceID = (_a = GoTrueClient.nextInstanceID[this.storageKey]) !== null && _a !== void 0 ? _a : 0;\n        GoTrueClient.nextInstanceID[this.storageKey] = this.instanceID + 1;\n        this.logDebugMessages = !!settings.debug;\n        if (typeof settings.debug === \"function\") {\n            this.logger = settings.debug;\n        }\n        if (this.instanceID > 0 && (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) {\n            const message = `${this._logPrefix()} Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.`;\n            console.warn(message);\n            if (this.logDebugMessages) {\n                console.trace(message);\n            }\n        }\n        this.persistSession = settings.persistSession;\n        this.autoRefreshToken = settings.autoRefreshToken;\n        this.admin = new _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n            url: settings.url,\n            headers: settings.headers,\n            fetch: settings.fetch\n        });\n        this.url = settings.url;\n        this.headers = settings.headers;\n        this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.resolveFetch)(settings.fetch);\n        this.lock = settings.lock || lockNoOp;\n        this.detectSessionInUrl = settings.detectSessionInUrl;\n        this.flowType = settings.flowType;\n        this.hasCustomAuthorizationHeader = settings.hasCustomAuthorizationHeader;\n        this.throwOnError = settings.throwOnError;\n        this.lockAcquireTimeout = settings.lockAcquireTimeout;\n        if (settings.lock) {\n            this.lock = settings.lock;\n        } else if (this.persistSession && (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && ((_b = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _b === void 0 ? void 0 : _b.locks)) {\n            this.lock = _lib_locks__WEBPACK_IMPORTED_MODULE_6__.navigatorLock;\n        } else {\n            this.lock = lockNoOp;\n        }\n        if (!this.jwks) {\n            this.jwks = {\n                keys: []\n            };\n            this.jwks_cached_at = Number.MIN_SAFE_INTEGER;\n        }\n        this.mfa = {\n            verify: this._verify.bind(this),\n            enroll: this._enroll.bind(this),\n            unenroll: this._unenroll.bind(this),\n            challenge: this._challenge.bind(this),\n            listFactors: this._listFactors.bind(this),\n            challengeAndVerify: this._challengeAndVerify.bind(this),\n            getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),\n            webauthn: new _lib_webauthn__WEBPACK_IMPORTED_MODULE_11__.WebAuthnApi(this)\n        };\n        this.oauth = {\n            getAuthorizationDetails: this._getAuthorizationDetails.bind(this),\n            approveAuthorization: this._approveAuthorization.bind(this),\n            denyAuthorization: this._denyAuthorization.bind(this),\n            listGrants: this._listOAuthGrants.bind(this),\n            revokeGrant: this._revokeOAuthGrant.bind(this)\n        };\n        if (this.persistSession) {\n            if (settings.storage) {\n                this.storage = settings.storage;\n            } else {\n                if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.supportsLocalStorage)()) {\n                    this.storage = globalThis.localStorage;\n                } else {\n                    this.memoryStorage = {};\n                    this.storage = (0,_lib_local_storage__WEBPACK_IMPORTED_MODULE_5__.memoryLocalStorageAdapter)(this.memoryStorage);\n                }\n            }\n            if (settings.userStorage) {\n                this.userStorage = settings.userStorage;\n            }\n        } else {\n            this.memoryStorage = {};\n            this.storage = (0,_lib_local_storage__WEBPACK_IMPORTED_MODULE_5__.memoryLocalStorageAdapter)(this.memoryStorage);\n        }\n        if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {\n            try {\n                this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);\n            } catch (e) {\n                console.error(\"Failed to create a new BroadcastChannel, multi-tab state changes will not be available\", e);\n            }\n            (_c = this.broadcastChannel) === null || _c === void 0 ? void 0 : _c.addEventListener(\"message\", async (event)=>{\n                this._debug(\"received broadcast notification from other tab or client\", event);\n                try {\n                    await this._notifyAllSubscribers(event.data.event, event.data.session, false); // broadcast = false so we don't get an endless loop of messages\n                } catch (error) {\n                    this._debug(\"#broadcastChannel\", \"error\", error);\n                }\n            });\n        }\n        // Only auto-initialize if not explicitly disabled. Skipped in SSR contexts\n        // where initialization timing must be controlled. All public methods have\n        // lazy initialization, so the client remains fully functional.\n        if (!settings.skipAutoInitialize) {\n            this.initialize().catch((error)=>{\n                this._debug(\"#initialize()\", \"error\", error);\n            });\n        }\n    }\n    /**\n     * Returns whether error throwing mode is enabled for this client.\n     */ isThrowOnErrorEnabled() {\n        return this.throwOnError;\n    }\n    /**\n     * Centralizes return handling with optional error throwing. When `throwOnError` is enabled\n     * and the provided result contains a non-nullish error, the error is thrown instead of\n     * being returned. This ensures consistent behavior across all public API methods.\n     */ _returnResult(result) {\n        if (this.throwOnError && result && result.error) {\n            throw result.error;\n        }\n        return result;\n    }\n    _logPrefix() {\n        return \"GoTrueClient@\" + `${this.storageKey}:${this.instanceID} (${_lib_version__WEBPACK_IMPORTED_MODULE_8__.version}) ${new Date().toISOString()}`;\n    }\n    _debug(...args) {\n        if (this.logDebugMessages) {\n            this.logger(this._logPrefix(), ...args);\n        }\n        return this;\n    }\n    /**\n     * Initializes the client session either from the url or from storage.\n     * This method is automatically called when instantiating the client, but should also be called\n     * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n     */ async initialize() {\n        if (this.initializePromise) {\n            return await this.initializePromise;\n        }\n        this.initializePromise = (async ()=>{\n            return await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n                return await this._initialize();\n            });\n        })();\n        return await this.initializePromise;\n    }\n    /**\n     * IMPORTANT:\n     * 1. Never throw in this method, as it is called from the constructor\n     * 2. Never return a session from this method as it would be cached over\n     *    the whole lifetime of the client\n     */ async _initialize() {\n        var _a;\n        try {\n            let params = {};\n            let callbackUrlType = \"none\";\n            if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) {\n                params = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.parseParametersFromURL)(window.location.href);\n                if (this._isImplicitGrantCallback(params)) {\n                    callbackUrlType = \"implicit\";\n                } else if (await this._isPKCECallback(params)) {\n                    callbackUrlType = \"pkce\";\n                }\n            }\n            /**\n             * Attempt to get the session from the URL only if these conditions are fulfilled\n             *\n             * Note: If the URL isn't one of the callback url types (implicit or pkce),\n             * then there could be an existing session so we don't want to prematurely remove it\n             */ if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && this.detectSessionInUrl && callbackUrlType !== \"none\") {\n                const { data, error } = await this._getSessionFromURL(params, callbackUrlType);\n                if (error) {\n                    this._debug(\"#_initialize()\", \"error detecting session from URL\", error);\n                    if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthImplicitGrantRedirectError)(error)) {\n                        const errorCode = (_a = error.details) === null || _a === void 0 ? void 0 : _a.code;\n                        if (errorCode === \"identity_already_exists\" || errorCode === \"identity_not_found\" || errorCode === \"single_identity_not_deletable\") {\n                            return {\n                                error\n                            };\n                        }\n                    }\n                    // Don't remove existing session on URL login failure.\n                    // A failed attempt (e.g. reused magic link) shouldn't invalidate a valid session.\n                    return {\n                        error\n                    };\n                }\n                const { session, redirectType } = data;\n                this._debug(\"#_initialize()\", \"detected session in URL\", session, \"redirect type\", redirectType);\n                await this._saveSession(session);\n                setTimeout(async ()=>{\n                    if (redirectType === \"recovery\") {\n                        await this._notifyAllSubscribers(\"PASSWORD_RECOVERY\", session);\n                    } else {\n                        await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n                    }\n                }, 0);\n                return {\n                    error: null\n                };\n            }\n            // no login attempt via callback url try to recover session from storage\n            await this._recoverAndRefresh();\n            return {\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    error\n                });\n            }\n            return this._returnResult({\n                error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthUnknownError(\"Unexpected error during initialization\", error)\n            });\n        } finally{\n            await this._handleVisibilityChange();\n            this._debug(\"#_initialize()\", \"end\");\n        }\n    }\n    /**\n     * Creates a new anonymous user.\n     *\n     * @returns A session where the is_anonymous claim in the access token JWT set to true\n     */ async signInAnonymously(credentials) {\n        var _a, _b, _c;\n        try {\n            const res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/signup`, {\n                headers: this.headers,\n                body: {\n                    data: (_b = (_a = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _a === void 0 ? void 0 : _a.data) !== null && _b !== void 0 ? _b : {},\n                    gotrue_meta_security: {\n                        captcha_token: (_c = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _c === void 0 ? void 0 : _c.captchaToken\n                    }\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            const { data, error } = res;\n            if (error || !data) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: error\n                });\n            }\n            const session = data.session;\n            const user = data.user;\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n            }\n            return this._returnResult({\n                data: {\n                    user,\n                    session\n                },\n                error: null\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Creates a new user.\n     *\n     * Be aware that if a user account exists in the system you may get back an\n     * error message that attempts to hide this information from the user.\n     * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.\n     *\n     * @returns A logged-in session if the server has \"autoconfirm\" ON\n     * @returns A user if the server has \"autoconfirm\" OFF\n     */ async signUp(credentials) {\n        var _a, _b, _c;\n        try {\n            let res;\n            if (\"email\" in credentials) {\n                const { email, password, options } = credentials;\n                let codeChallenge = null;\n                let codeChallengeMethod = null;\n                if (this.flowType === \"pkce\") {\n                    ;\n                    [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n                }\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/signup`, {\n                    headers: this.headers,\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                    body: {\n                        email,\n                        password,\n                        data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        },\n                        code_challenge: codeChallenge,\n                        code_challenge_method: codeChallengeMethod\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n                });\n            } else if (\"phone\" in credentials) {\n                const { phone, password, options } = credentials;\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/signup`, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        password,\n                        data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},\n                        channel: (_c = options === null || options === void 0 ? void 0 : options.channel) !== null && _c !== void 0 ? _c : \"sms\",\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n                });\n            } else {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError(\"You must provide either an email or phone number and a password\");\n            }\n            const { data, error } = res;\n            if (error || !data) {\n                await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: error\n                });\n            }\n            const session = data.session;\n            const user = data.user;\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n            }\n            return this._returnResult({\n                data: {\n                    user,\n                    session\n                },\n                error: null\n            });\n        } catch (error) {\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in an existing user with an email and password or phone and password.\n     *\n     * Be aware that you may get back an error message that will not distinguish\n     * between the cases where the account does not exist or that the\n     * email/phone and password combination is wrong or that the account can only\n     * be accessed via social login.\n     */ async signInWithPassword(credentials) {\n        try {\n            let res;\n            if (\"email\" in credentials) {\n                const { email, password, options } = credentials;\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=password`, {\n                    headers: this.headers,\n                    body: {\n                        email,\n                        password,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponsePassword\n                });\n            } else if (\"phone\" in credentials) {\n                const { phone, password, options } = credentials;\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=password`, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        password,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponsePassword\n                });\n            } else {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError(\"You must provide either an email or phone number and a password\");\n            }\n            const { data, error } = res;\n            if (error) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            } else if (!data || !data.session || !data.user) {\n                const invalidTokenError = new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError();\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: invalidTokenError\n                });\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return this._returnResult({\n                data: Object.assign({\n                    user: data.user,\n                    session: data.session\n                }, data.weak_password ? {\n                    weakPassword: data.weak_password\n                } : null),\n                error\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in an existing user via a third-party provider.\n     * This method supports the PKCE flow.\n     */ async signInWithOAuth(credentials) {\n        var _a, _b, _c, _d;\n        return await this._handleProviderSignIn(credentials.provider, {\n            redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n            scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n            queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n            skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect\n        });\n    }\n    /**\n     * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.\n     */ async exchangeCodeForSession(authCode) {\n        await this.initializePromise;\n        return this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return this._exchangeCodeForSession(authCode);\n        });\n    }\n    /**\n     * Signs in a user by verifying a message signed by the user's private key.\n     * Supports Ethereum (via Sign-In-With-Ethereum) & Solana (Sign-In-With-Solana) standards,\n     * both of which derive from the EIP-4361 standard\n     * With slight variation on Solana's side.\n     * @reference https://eips.ethereum.org/EIPS/eip-4361\n     */ async signInWithWeb3(credentials) {\n        const { chain } = credentials;\n        switch(chain){\n            case \"ethereum\":\n                return await this.signInWithEthereum(credentials);\n            case \"solana\":\n                return await this.signInWithSolana(credentials);\n            default:\n                throw new Error(`@supabase/auth-js: Unsupported chain \"${chain}\"`);\n        }\n    }\n    async signInWithEthereum(credentials) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n        // TODO: flatten type\n        let message;\n        let signature;\n        if (\"message\" in credentials) {\n            message = credentials.message;\n            signature = credentials.signature;\n        } else {\n            const { chain, wallet, statement, options } = credentials;\n            let resolvedWallet;\n            if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) {\n                if (typeof wallet !== \"object\" || !(options === null || options === void 0 ? void 0 : options.url)) {\n                    throw new Error(\"@supabase/auth-js: Both wallet and url must be specified in non-browser environments.\");\n                }\n                resolvedWallet = wallet;\n            } else if (typeof wallet === \"object\") {\n                resolvedWallet = wallet;\n            } else {\n                const windowAny = window;\n                if (\"ethereum\" in windowAny && typeof windowAny.ethereum === \"object\" && \"request\" in windowAny.ethereum && typeof windowAny.ethereum.request === \"function\") {\n                    resolvedWallet = windowAny.ethereum;\n                } else {\n                    throw new Error(`@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.`);\n                }\n            }\n            const url = new URL((_a = options === null || options === void 0 ? void 0 : options.url) !== null && _a !== void 0 ? _a : window.location.href);\n            const accounts = await resolvedWallet.request({\n                method: \"eth_requestAccounts\"\n            }).then((accs)=>accs).catch(()=>{\n                throw new Error(`@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid`);\n            });\n            if (!accounts || accounts.length === 0) {\n                throw new Error(`@supabase/auth-js: No accounts available. Please ensure the wallet is connected.`);\n            }\n            const address = (0,_lib_web3_ethereum__WEBPACK_IMPORTED_MODULE_10__.getAddress)(accounts[0]);\n            let chainId = (_b = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _b === void 0 ? void 0 : _b.chainId;\n            if (!chainId) {\n                const chainIdHex = await resolvedWallet.request({\n                    method: \"eth_chainId\"\n                });\n                chainId = (0,_lib_web3_ethereum__WEBPACK_IMPORTED_MODULE_10__.fromHex)(chainIdHex);\n            }\n            const siweMessage = {\n                domain: url.host,\n                address: address,\n                statement: statement,\n                uri: url.href,\n                version: \"1\",\n                chainId: chainId,\n                nonce: (_c = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _c === void 0 ? void 0 : _c.nonce,\n                issuedAt: (_e = (_d = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _d === void 0 ? void 0 : _d.issuedAt) !== null && _e !== void 0 ? _e : new Date(),\n                expirationTime: (_f = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _f === void 0 ? void 0 : _f.expirationTime,\n                notBefore: (_g = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _g === void 0 ? void 0 : _g.notBefore,\n                requestId: (_h = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _h === void 0 ? void 0 : _h.requestId,\n                resources: (_j = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _j === void 0 ? void 0 : _j.resources\n            };\n            message = (0,_lib_web3_ethereum__WEBPACK_IMPORTED_MODULE_10__.createSiweMessage)(siweMessage);\n            // Sign message\n            signature = await resolvedWallet.request({\n                method: \"personal_sign\",\n                params: [\n                    (0,_lib_web3_ethereum__WEBPACK_IMPORTED_MODULE_10__.toHex)(message),\n                    address\n                ]\n            });\n        }\n        try {\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=web3`, {\n                headers: this.headers,\n                body: Object.assign({\n                    chain: \"ethereum\",\n                    message,\n                    signature\n                }, ((_k = credentials.options) === null || _k === void 0 ? void 0 : _k.captchaToken) ? {\n                    gotrue_meta_security: {\n                        captcha_token: (_l = credentials.options) === null || _l === void 0 ? void 0 : _l.captchaToken\n                    }\n                } : null),\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            if (error) {\n                throw error;\n            }\n            if (!data || !data.session || !data.user) {\n                const invalidTokenError = new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError();\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: invalidTokenError\n                });\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return this._returnResult({\n                data: Object.assign({}, data),\n                error\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async signInWithSolana(credentials) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n        let message;\n        let signature;\n        if (\"message\" in credentials) {\n            message = credentials.message;\n            signature = credentials.signature;\n        } else {\n            const { chain, wallet, statement, options } = credentials;\n            let resolvedWallet;\n            if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) {\n                if (typeof wallet !== \"object\" || !(options === null || options === void 0 ? void 0 : options.url)) {\n                    throw new Error(\"@supabase/auth-js: Both wallet and url must be specified in non-browser environments.\");\n                }\n                resolvedWallet = wallet;\n            } else if (typeof wallet === \"object\") {\n                resolvedWallet = wallet;\n            } else {\n                const windowAny = window;\n                if (\"solana\" in windowAny && typeof windowAny.solana === \"object\" && (\"signIn\" in windowAny.solana && typeof windowAny.solana.signIn === \"function\" || \"signMessage\" in windowAny.solana && typeof windowAny.solana.signMessage === \"function\")) {\n                    resolvedWallet = windowAny.solana;\n                } else {\n                    throw new Error(`@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.`);\n                }\n            }\n            const url = new URL((_a = options === null || options === void 0 ? void 0 : options.url) !== null && _a !== void 0 ? _a : window.location.href);\n            if (\"signIn\" in resolvedWallet && resolvedWallet.signIn) {\n                const output = await resolvedWallet.signIn(Object.assign(Object.assign(Object.assign({\n                    issuedAt: new Date().toISOString()\n                }, options === null || options === void 0 ? void 0 : options.signInWithSolana), {\n                    // non-overridable properties\n                    version: \"1\",\n                    domain: url.host,\n                    uri: url.href\n                }), statement ? {\n                    statement\n                } : null));\n                let outputToProcess;\n                if (Array.isArray(output) && output[0] && typeof output[0] === \"object\") {\n                    outputToProcess = output[0];\n                } else if (output && typeof output === \"object\" && \"signedMessage\" in output && \"signature\" in output) {\n                    outputToProcess = output;\n                } else {\n                    throw new Error(\"@supabase/auth-js: Wallet method signIn() returned unrecognized value\");\n                }\n                if (\"signedMessage\" in outputToProcess && \"signature\" in outputToProcess && (typeof outputToProcess.signedMessage === \"string\" || outputToProcess.signedMessage instanceof Uint8Array) && outputToProcess.signature instanceof Uint8Array) {\n                    message = typeof outputToProcess.signedMessage === \"string\" ? outputToProcess.signedMessage : new TextDecoder().decode(outputToProcess.signedMessage);\n                    signature = outputToProcess.signature;\n                } else {\n                    throw new Error(\"@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields\");\n                }\n            } else {\n                if (!(\"signMessage\" in resolvedWallet) || typeof resolvedWallet.signMessage !== \"function\" || !(\"publicKey\" in resolvedWallet) || typeof resolvedWallet !== \"object\" || !resolvedWallet.publicKey || !(\"toBase58\" in resolvedWallet.publicKey) || typeof resolvedWallet.publicKey.toBase58 !== \"function\") {\n                    throw new Error(\"@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API\");\n                }\n                message = [\n                    `${url.host} wants you to sign in with your Solana account:`,\n                    resolvedWallet.publicKey.toBase58(),\n                    ...statement ? [\n                        \"\",\n                        statement,\n                        \"\"\n                    ] : [\n                        \"\"\n                    ],\n                    \"Version: 1\",\n                    `URI: ${url.href}`,\n                    `Issued At: ${(_c = (_b = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _b === void 0 ? void 0 : _b.issuedAt) !== null && _c !== void 0 ? _c : new Date().toISOString()}`,\n                    ...((_d = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _d === void 0 ? void 0 : _d.notBefore) ? [\n                        `Not Before: ${options.signInWithSolana.notBefore}`\n                    ] : [],\n                    ...((_e = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _e === void 0 ? void 0 : _e.expirationTime) ? [\n                        `Expiration Time: ${options.signInWithSolana.expirationTime}`\n                    ] : [],\n                    ...((_f = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _f === void 0 ? void 0 : _f.chainId) ? [\n                        `Chain ID: ${options.signInWithSolana.chainId}`\n                    ] : [],\n                    ...((_g = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _g === void 0 ? void 0 : _g.nonce) ? [\n                        `Nonce: ${options.signInWithSolana.nonce}`\n                    ] : [],\n                    ...((_h = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _h === void 0 ? void 0 : _h.requestId) ? [\n                        `Request ID: ${options.signInWithSolana.requestId}`\n                    ] : [],\n                    ...((_k = (_j = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _j === void 0 ? void 0 : _j.resources) === null || _k === void 0 ? void 0 : _k.length) ? [\n                        \"Resources\",\n                        ...options.signInWithSolana.resources.map((resource)=>`- ${resource}`)\n                    ] : []\n                ].join(\"\\n\");\n                const maybeSignature = await resolvedWallet.signMessage(new TextEncoder().encode(message), \"utf8\");\n                if (!maybeSignature || !(maybeSignature instanceof Uint8Array)) {\n                    throw new Error(\"@supabase/auth-js: Wallet signMessage() API returned an recognized value\");\n                }\n                signature = maybeSignature;\n            }\n        }\n        try {\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=web3`, {\n                headers: this.headers,\n                body: Object.assign({\n                    chain: \"solana\",\n                    message,\n                    signature: (0,_lib_base64url__WEBPACK_IMPORTED_MODULE_9__.bytesToBase64URL)(signature)\n                }, ((_l = credentials.options) === null || _l === void 0 ? void 0 : _l.captchaToken) ? {\n                    gotrue_meta_security: {\n                        captcha_token: (_m = credentials.options) === null || _m === void 0 ? void 0 : _m.captchaToken\n                    }\n                } : null),\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            if (error) {\n                throw error;\n            }\n            if (!data || !data.session || !data.user) {\n                const invalidTokenError = new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError();\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: invalidTokenError\n                });\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return this._returnResult({\n                data: Object.assign({}, data),\n                error\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async _exchangeCodeForSession(authCode) {\n        const storageItem = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n        const [codeVerifier, redirectType] = (storageItem !== null && storageItem !== void 0 ? storageItem : \"\").split(\"/\");\n        try {\n            if (!codeVerifier && this.flowType === \"pkce\") {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthPKCECodeVerifierMissingError();\n            }\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=pkce`, {\n                headers: this.headers,\n                body: {\n                    auth_code: authCode,\n                    code_verifier: codeVerifier\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            if (error) {\n                throw error;\n            }\n            if (!data || !data.session || !data.user) {\n                const invalidTokenError = new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError();\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null,\n                        redirectType: null\n                    },\n                    error: invalidTokenError\n                });\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return this._returnResult({\n                data: Object.assign(Object.assign({}, data), {\n                    redirectType: redirectType !== null && redirectType !== void 0 ? redirectType : null\n                }),\n                error\n            });\n        } catch (error) {\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null,\n                        redirectType: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Allows signing in with an OIDC ID token. The authentication provider used\n     * should be enabled and configured.\n     */ async signInWithIdToken(credentials) {\n        try {\n            const { options, provider, token, access_token, nonce } = credentials;\n            const res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=id_token`, {\n                headers: this.headers,\n                body: {\n                    provider,\n                    id_token: token,\n                    access_token,\n                    nonce,\n                    gotrue_meta_security: {\n                        captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                    }\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            const { data, error } = res;\n            if (error) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            } else if (!data || !data.session || !data.user) {\n                const invalidTokenError = new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError();\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: invalidTokenError\n                });\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return this._returnResult({\n                data,\n                error\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in a user using magiclink or a one-time password (OTP).\n     *\n     * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n     * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n     * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n     *\n     * Be aware that you may get back an error message that will not distinguish\n     * between the cases where the account does not exist or, that the account\n     * can only be accessed via social login.\n     *\n     * Do note that you will need to configure a Whatsapp sender on Twilio\n     * if you are using phone sign in with the 'whatsapp' channel. The whatsapp\n     * channel is not supported on other providers\n     * at this time.\n     * This method supports PKCE when an email is passed.\n     */ async signInWithOtp(credentials) {\n        var _a, _b, _c, _d, _e;\n        try {\n            if (\"email\" in credentials) {\n                const { email, options } = credentials;\n                let codeChallenge = null;\n                let codeChallengeMethod = null;\n                if (this.flowType === \"pkce\") {\n                    ;\n                    [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n                }\n                const { error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/otp`, {\n                    headers: this.headers,\n                    body: {\n                        email,\n                        data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                        create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        },\n                        code_challenge: codeChallenge,\n                        code_challenge_method: codeChallengeMethod\n                    },\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n                });\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            if (\"phone\" in credentials) {\n                const { phone, options } = credentials;\n                const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/otp`, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},\n                        create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        },\n                        channel: (_e = options === null || options === void 0 ? void 0 : options.channel) !== null && _e !== void 0 ? _e : \"sms\"\n                    }\n                });\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null,\n                        messageId: data === null || data === void 0 ? void 0 : data.message_id\n                    },\n                    error\n                });\n            }\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError(\"You must provide either an email or phone number.\");\n        } catch (error) {\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in a user given a User supplied OTP or TokenHash received through mobile or email.\n     */ async verifyOtp(params) {\n        var _a, _b;\n        try {\n            let redirectTo = undefined;\n            let captchaToken = undefined;\n            if (\"options\" in params) {\n                redirectTo = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo;\n                captchaToken = (_b = params.options) === null || _b === void 0 ? void 0 : _b.captchaToken;\n            }\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/verify`, {\n                headers: this.headers,\n                body: Object.assign(Object.assign({}, params), {\n                    gotrue_meta_security: {\n                        captcha_token: captchaToken\n                    }\n                }),\n                redirectTo,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            if (error) {\n                throw error;\n            }\n            if (!data) {\n                const tokenVerificationError = new Error(\"An error occurred on token verification.\");\n                throw tokenVerificationError;\n            }\n            const session = data.session;\n            const user = data.user;\n            if (session === null || session === void 0 ? void 0 : session.access_token) {\n                await this._saveSession(session);\n                await this._notifyAllSubscribers(params.type == \"recovery\" ? \"PASSWORD_RECOVERY\" : \"SIGNED_IN\", session);\n            }\n            return this._returnResult({\n                data: {\n                    user,\n                    session\n                },\n                error: null\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Attempts a single-sign on using an enterprise Identity Provider. A\n     * successful SSO attempt will redirect the current page to the identity\n     * provider authorization page. The redirect URL is implementation and SSO\n     * protocol specific.\n     *\n     * You can use it by providing a SSO domain. Typically you can extract this\n     * domain by asking users for their email address. If this domain is\n     * registered on the Auth instance the redirect will use that organization's\n     * currently active SSO Identity Provider for the login.\n     *\n     * If you have built an organization-specific login page, you can use the\n     * organization's SSO Identity Provider UUID directly instead.\n     */ async signInWithSSO(params) {\n        var _a, _b, _c, _d, _e;\n        try {\n            let codeChallenge = null;\n            let codeChallengeMethod = null;\n            if (this.flowType === \"pkce\") {\n                ;\n                [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n            }\n            const result = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/sso`, {\n                body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, \"providerId\" in params ? {\n                    provider_id: params.providerId\n                } : null), \"domain\" in params ? {\n                    domain: params.domain\n                } : null), {\n                    redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined\n                }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? {\n                    gotrue_meta_security: {\n                        captcha_token: params.options.captchaToken\n                    }\n                } : null), {\n                    skip_http_redirect: true,\n                    code_challenge: codeChallenge,\n                    code_challenge_method: codeChallengeMethod\n                }),\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._ssoResponse\n            });\n            // Automatically redirect in browser unless skipBrowserRedirect is true\n            if (((_d = result.data) === null || _d === void 0 ? void 0 : _d.url) && (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !((_e = params.options) === null || _e === void 0 ? void 0 : _e.skipBrowserRedirect)) {\n                window.location.assign(result.data.url);\n            }\n            return this._returnResult(result);\n        } catch (error) {\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sends a reauthentication OTP to the user's email or phone number.\n     * Requires the user to be signed-in.\n     */ async reauthenticate() {\n        await this.initializePromise;\n        return await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return await this._reauthenticate();\n        });\n    }\n    async _reauthenticate() {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) throw sessionError;\n                if (!session) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n                const { error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", `${this.url}/reauthenticate`, {\n                    headers: this.headers,\n                    jwt: session.access_token\n                });\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.\n     */ async resend(credentials) {\n        try {\n            const endpoint = `${this.url}/resend`;\n            if (\"email\" in credentials) {\n                const { email, type, options } = credentials;\n                const { error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", endpoint, {\n                    headers: this.headers,\n                    body: {\n                        email,\n                        type,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n                });\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            } else if (\"phone\" in credentials) {\n                const { phone, type, options } = credentials;\n                const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", endpoint, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        type,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    }\n                });\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null,\n                        messageId: data === null || data === void 0 ? void 0 : data.message_id\n                    },\n                    error\n                });\n            }\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError(\"You must provide either an email or phone number and a type\");\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Returns the session, refreshing it if necessary.\n     *\n     * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n     *\n     * **IMPORTANT:** This method loads values directly from the storage attached\n     * to the client. If that storage is based on request cookies for example,\n     * the values in it may not be authentic and therefore it's strongly advised\n     * against using this method and its results in such circumstances. A warning\n     * will be emitted if this is detected. Use {@link #getUser()} instead.\n     */ async getSession() {\n        await this.initializePromise;\n        const result = await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return this._useSession(async (result)=>{\n                return result;\n            });\n        });\n        return result;\n    }\n    /**\n     * Acquires a global lock based on the storage key.\n     */ async _acquireLock(acquireTimeout, fn) {\n        this._debug(\"#_acquireLock\", \"begin\", acquireTimeout);\n        try {\n            if (this.lockAcquired) {\n                const last = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve();\n                const result = (async ()=>{\n                    await last;\n                    return await fn();\n                })();\n                this.pendingInLock.push((async ()=>{\n                    try {\n                        await result;\n                    } catch (e) {\n                    // we just care if it finished\n                    }\n                })());\n                return result;\n            }\n            return await this.lock(`lock:${this.storageKey}`, acquireTimeout, async ()=>{\n                this._debug(\"#_acquireLock\", \"lock acquired for storage key\", this.storageKey);\n                try {\n                    this.lockAcquired = true;\n                    const result = fn();\n                    this.pendingInLock.push((async ()=>{\n                        try {\n                            await result;\n                        } catch (e) {\n                        // we just care if it finished\n                        }\n                    })());\n                    await result;\n                    // keep draining the queue until there's nothing to wait on\n                    while(this.pendingInLock.length){\n                        const waitOn = [\n                            ...this.pendingInLock\n                        ];\n                        await Promise.all(waitOn);\n                        this.pendingInLock.splice(0, waitOn.length);\n                    }\n                    return await result;\n                } finally{\n                    this._debug(\"#_acquireLock\", \"lock released for storage key\", this.storageKey);\n                    this.lockAcquired = false;\n                }\n            });\n        } finally{\n            this._debug(\"#_acquireLock\", \"end\");\n        }\n    }\n    /**\n     * Use instead of {@link #getSession} inside the library. It is\n     * semantically usually what you want, as getting a session involves some\n     * processing afterwards that requires only one client operating on the\n     * session at once across multiple tabs or processes.\n     */ async _useSession(fn) {\n        this._debug(\"#_useSession\", \"begin\");\n        try {\n            // the use of __loadSession here is the only correct use of the function!\n            const result = await this.__loadSession();\n            return await fn(result);\n        } finally{\n            this._debug(\"#_useSession\", \"end\");\n        }\n    }\n    /**\n     * NEVER USE DIRECTLY!\n     *\n     * Always use {@link #_useSession}.\n     */ async __loadSession() {\n        this._debug(\"#__loadSession()\", \"begin\");\n        if (!this.lockAcquired) {\n            this._debug(\"#__loadSession()\", \"used outside of an acquired lock!\", new Error().stack);\n        }\n        try {\n            let currentSession = null;\n            const maybeSession = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, this.storageKey);\n            this._debug(\"#getSession()\", \"session from storage\", maybeSession);\n            if (maybeSession !== null) {\n                if (this._isValidSession(maybeSession)) {\n                    currentSession = maybeSession;\n                } else {\n                    this._debug(\"#getSession()\", \"session from storage is not valid\");\n                    await this._removeSession();\n                }\n            }\n            if (!currentSession) {\n                return {\n                    data: {\n                        session: null\n                    },\n                    error: null\n                };\n            }\n            // A session is considered expired before the access token _actually_\n            // expires. When the autoRefreshToken option is off (or when the tab is\n            // in the background), very eager users of getSession() -- like\n            // realtime-js -- might send a valid JWT which will expire by the time it\n            // reaches the server.\n            const hasExpired = currentSession.expires_at ? currentSession.expires_at * 1000 - Date.now() < _lib_constants__WEBPACK_IMPORTED_MODULE_1__.EXPIRY_MARGIN_MS : false;\n            this._debug(\"#__loadSession()\", `session has${hasExpired ? \"\" : \" not\"} expired`, \"expires_at\", currentSession.expires_at);\n            if (!hasExpired) {\n                if (this.userStorage) {\n                    const maybeUser = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.userStorage, this.storageKey + \"-user\");\n                    if (maybeUser === null || maybeUser === void 0 ? void 0 : maybeUser.user) {\n                        currentSession.user = maybeUser.user;\n                    } else {\n                        currentSession.user = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.userNotAvailableProxy)();\n                    }\n                }\n                // Wrap the user object with a warning proxy on the server\n                // This warns when properties of the user are accessed, not when session.user itself is accessed\n                if (this.storage.isServer && currentSession.user && !currentSession.user.__isUserNotAvailableProxy) {\n                    const suppressWarningRef = {\n                        value: this.suppressGetSessionWarning\n                    };\n                    currentSession.user = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.insecureUserWarningProxy)(currentSession.user, suppressWarningRef);\n                    // Update the client-level suppression flag when the proxy suppresses the warning\n                    if (suppressWarningRef.value) {\n                        this.suppressGetSessionWarning = true;\n                    }\n                }\n                return {\n                    data: {\n                        session: currentSession\n                    },\n                    error: null\n                };\n            }\n            const { data: session, error } = await this._callRefreshToken(currentSession.refresh_token);\n            if (error) {\n                return this._returnResult({\n                    data: {\n                        session: null\n                    },\n                    error\n                });\n            }\n            return this._returnResult({\n                data: {\n                    session\n                },\n                error: null\n            });\n        } finally{\n            this._debug(\"#__loadSession()\", \"end\");\n        }\n    }\n    /**\n     * Gets the current user details if there is an existing session. This method\n     * performs a network request to the Supabase Auth server, so the returned\n     * value is authentic and can be used to base authorization rules on.\n     *\n     * @param jwt Takes in an optional access token JWT. If no JWT is provided, the JWT from the current session is used.\n     */ async getUser(jwt) {\n        if (jwt) {\n            return await this._getUser(jwt);\n        }\n        await this.initializePromise;\n        const result = await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return await this._getUser();\n        });\n        if (result.data.user) {\n            this.suppressGetSessionWarning = true;\n        }\n        return result;\n    }\n    async _getUser(jwt) {\n        try {\n            if (jwt) {\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", `${this.url}/user`, {\n                    headers: this.headers,\n                    jwt: jwt,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._userResponse\n                });\n            }\n            return await this._useSession(async (result)=>{\n                var _a, _b, _c;\n                const { data, error } = result;\n                if (error) {\n                    throw error;\n                }\n                // returns an error if there is no access_token or custom authorization header\n                if (!((_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) && !this.hasCustomAuthorizationHeader) {\n                    return {\n                        data: {\n                            user: null\n                        },\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError()\n                    };\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", `${this.url}/user`, {\n                    headers: this.headers,\n                    jwt: (_c = (_b = data.session) === null || _b === void 0 ? void 0 : _b.access_token) !== null && _c !== void 0 ? _c : undefined,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._userResponse\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthSessionMissingError)(error)) {\n                    // JWT contains a `session_id` which does not correspond to an active\n                    // session in the database, indicating the user is signed out.\n                    await this._removeSession();\n                    await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n                }\n                return this._returnResult({\n                    data: {\n                        user: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Updates user data for a logged in user.\n     */ async updateUser(attributes, options = {}) {\n        await this.initializePromise;\n        return await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return await this._updateUser(attributes, options);\n        });\n    }\n    async _updateUser(attributes, options = {}) {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: sessionData, error: sessionError } = result;\n                if (sessionError) {\n                    throw sessionError;\n                }\n                if (!sessionData.session) {\n                    throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n                }\n                const session = sessionData.session;\n                let codeChallenge = null;\n                let codeChallengeMethod = null;\n                if (this.flowType === \"pkce\" && attributes.email != null) {\n                    ;\n                    [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n                }\n                const { data, error: userError } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"PUT\", `${this.url}/user`, {\n                    headers: this.headers,\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                    body: Object.assign(Object.assign({}, attributes), {\n                        code_challenge: codeChallenge,\n                        code_challenge_method: codeChallengeMethod\n                    }),\n                    jwt: session.access_token,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._userResponse\n                });\n                if (userError) {\n                    throw userError;\n                }\n                session.user = data.user;\n                await this._saveSession(session);\n                await this._notifyAllSubscribers(\"USER_UPDATED\", session);\n                return this._returnResult({\n                    data: {\n                        user: session.user\n                    },\n                    error: null\n                });\n            });\n        } catch (error) {\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n     * If the refresh token or access token in the current session is invalid, an error will be thrown.\n     * @param currentSession The current session that minimally contains an access token and refresh token.\n     */ async setSession(currentSession) {\n        await this.initializePromise;\n        return await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return await this._setSession(currentSession);\n        });\n    }\n    async _setSession(currentSession) {\n        try {\n            if (!currentSession.access_token || !currentSession.refresh_token) {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n            }\n            const timeNow = Date.now() / 1000;\n            let expiresAt = timeNow;\n            let hasExpired = true;\n            let session = null;\n            const { payload } = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.decodeJWT)(currentSession.access_token);\n            if (payload.exp) {\n                expiresAt = payload.exp;\n                hasExpired = expiresAt <= timeNow;\n            }\n            if (hasExpired) {\n                const { data: refreshedSession, error } = await this._callRefreshToken(currentSession.refresh_token);\n                if (error) {\n                    return this._returnResult({\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: error\n                    });\n                }\n                if (!refreshedSession) {\n                    return {\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: null\n                    };\n                }\n                session = refreshedSession;\n            } else {\n                const { data, error } = await this._getUser(currentSession.access_token);\n                if (error) {\n                    return this._returnResult({\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error\n                    });\n                }\n                session = {\n                    access_token: currentSession.access_token,\n                    refresh_token: currentSession.refresh_token,\n                    user: data.user,\n                    token_type: \"bearer\",\n                    expires_in: expiresAt - timeNow,\n                    expires_at: expiresAt\n                };\n                await this._saveSession(session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n            }\n            return this._returnResult({\n                data: {\n                    user: session.user,\n                    session\n                },\n                error: null\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        session: null,\n                        user: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Returns a new session, regardless of expiry status.\n     * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n     * If the current session's refresh token is invalid, an error will be thrown.\n     * @param currentSession The current session. If passed in, it must contain a refresh token.\n     */ async refreshSession(currentSession) {\n        await this.initializePromise;\n        return await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return await this._refreshSession(currentSession);\n        });\n    }\n    async _refreshSession(currentSession) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a;\n                if (!currentSession) {\n                    const { data, error } = result;\n                    if (error) {\n                        throw error;\n                    }\n                    currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;\n                }\n                if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {\n                    throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n                }\n                const { data: session, error } = await this._callRefreshToken(currentSession.refresh_token);\n                if (error) {\n                    return this._returnResult({\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: error\n                    });\n                }\n                if (!session) {\n                    return this._returnResult({\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: null\n                    });\n                }\n                return this._returnResult({\n                    data: {\n                        user: session.user,\n                        session\n                    },\n                    error: null\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Gets the session data from a URL string\n     */ async _getSessionFromURL(params, callbackUrlType) {\n        try {\n            if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError(\"No browser detected.\");\n            // If there's an error in the URL, it doesn't matter what flow it is, we just return the error.\n            if (params.error || params.error_description || params.error_code) {\n                // The error class returned implies that the redirect is from an implicit grant flow\n                // but it could also be from a redirect error from a PKCE flow.\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError(params.error_description || \"Error in URL with unspecified error_description\", {\n                    error: params.error || \"unspecified_error\",\n                    code: params.error_code || \"unspecified_code\"\n                });\n            }\n            // Checks for mismatches between the flowType initialised in the client and the URL parameters\n            switch(callbackUrlType){\n                case \"implicit\":\n                    if (this.flowType === \"pkce\") {\n                        throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthPKCEGrantCodeExchangeError(\"Not a valid PKCE flow url.\");\n                    }\n                    break;\n                case \"pkce\":\n                    if (this.flowType === \"implicit\") {\n                        throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError(\"Not a valid implicit grant flow url.\");\n                    }\n                    break;\n                default:\n            }\n            // Since this is a redirect for PKCE, we attempt to retrieve the code from the URL for the code exchange\n            if (callbackUrlType === \"pkce\") {\n                this._debug(\"#_initialize()\", \"begin\", \"is PKCE flow\", true);\n                if (!params.code) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthPKCEGrantCodeExchangeError(\"No code detected.\");\n                const { data, error } = await this._exchangeCodeForSession(params.code);\n                if (error) throw error;\n                const url = new URL(window.location.href);\n                url.searchParams.delete(\"code\");\n                window.history.replaceState(window.history.state, \"\", url.toString());\n                return {\n                    data: {\n                        session: data.session,\n                        redirectType: null\n                    },\n                    error: null\n                };\n            }\n            const { provider_token, provider_refresh_token, access_token, refresh_token, expires_in, expires_at, token_type } = params;\n            if (!access_token || !expires_in || !refresh_token || !token_type) {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError(\"No session defined in URL\");\n            }\n            const timeNow = Math.round(Date.now() / 1000);\n            const expiresIn = parseInt(expires_in);\n            let expiresAt = timeNow + expiresIn;\n            if (expires_at) {\n                expiresAt = parseInt(expires_at);\n            }\n            const actuallyExpiresIn = expiresAt - timeNow;\n            if (actuallyExpiresIn * 1000 <= _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS) {\n                console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${actuallyExpiresIn}s, should have been closer to ${expiresIn}s`);\n            }\n            const issuedAt = expiresAt - expiresIn;\n            if (timeNow - issuedAt >= 120) {\n                console.warn(\"@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale\", issuedAt, expiresAt, timeNow);\n            } else if (timeNow - issuedAt < 0) {\n                console.warn(\"@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew\", issuedAt, expiresAt, timeNow);\n            }\n            const { data, error } = await this._getUser(access_token);\n            if (error) throw error;\n            const session = {\n                provider_token,\n                provider_refresh_token,\n                access_token,\n                expires_in: expiresIn,\n                expires_at: expiresAt,\n                refresh_token,\n                token_type: token_type,\n                user: data.user\n            };\n            // Remove tokens from URL\n            window.location.hash = \"\";\n            this._debug(\"#_getSessionFromURL()\", \"clearing window.location.hash\");\n            return this._returnResult({\n                data: {\n                    session,\n                    redirectType: params.type\n                },\n                error: null\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        session: null,\n                        redirectType: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n     *\n     * If `detectSessionInUrl` is a function, it will be called with the URL and params to determine\n     * if the URL should be processed as a Supabase auth callback. This allows users to exclude\n     * URLs from other OAuth providers (e.g., Facebook Login) that also return access_token in the fragment.\n     */ _isImplicitGrantCallback(params) {\n        if (typeof this.detectSessionInUrl === \"function\") {\n            return this.detectSessionInUrl(new URL(window.location.href), params);\n        }\n        return Boolean(params.access_token || params.error_description);\n    }\n    /**\n     * Checks if the current URL and backing storage contain parameters given by a PKCE flow\n     */ async _isPKCECallback(params) {\n        const currentStorageContent = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n        return !!(params.code && currentStorageContent);\n    }\n    /**\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n     *\n     * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n     * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n     *\n     * If using `others` scope, no `SIGNED_OUT` event is fired!\n     */ async signOut(options = {\n        scope: \"global\"\n    }) {\n        await this.initializePromise;\n        return await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return await this._signOut(options);\n        });\n    }\n    async _signOut({ scope } = {\n        scope: \"global\"\n    }) {\n        return await this._useSession(async (result)=>{\n            var _a;\n            const { data, error: sessionError } = result;\n            if (sessionError && !(0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthSessionMissingError)(sessionError)) {\n                return this._returnResult({\n                    error: sessionError\n                });\n            }\n            const accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;\n            if (accessToken) {\n                const { error } = await this.admin.signOut(accessToken, scope);\n                if (error) {\n                    // ignore 404s since user might not exist anymore\n                    // ignore 401s since an invalid or expired JWT should sign out the current session\n                    if (!((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthApiError)(error) && (error.status === 404 || error.status === 401 || error.status === 403) || (0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthSessionMissingError)(error))) {\n                        return this._returnResult({\n                            error\n                        });\n                    }\n                }\n            }\n            if (scope !== \"others\") {\n                await this._removeSession();\n                await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            }\n            return this._returnResult({\n                error: null\n            });\n        });\n    }\n    onAuthStateChange(callback) {\n        const id = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.generateCallbackId)();\n        const subscription = {\n            id,\n            callback,\n            unsubscribe: ()=>{\n                this._debug(\"#unsubscribe()\", \"state change callback with id removed\", id);\n                this.stateChangeEmitters.delete(id);\n            }\n        };\n        this._debug(\"#onAuthStateChange()\", \"registered callback with id\", id);\n        this.stateChangeEmitters.set(id, subscription);\n        (async ()=>{\n            await this.initializePromise;\n            await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n                this._emitInitialSession(id);\n            });\n        })();\n        return {\n            data: {\n                subscription\n            }\n        };\n    }\n    async _emitInitialSession(id) {\n        return await this._useSession(async (result)=>{\n            var _a, _b;\n            try {\n                const { data: { session }, error } = result;\n                if (error) throw error;\n                await ((_a = this.stateChangeEmitters.get(id)) === null || _a === void 0 ? void 0 : _a.callback(\"INITIAL_SESSION\", session));\n                this._debug(\"INITIAL_SESSION\", \"callback id\", id, \"session\", session);\n            } catch (err) {\n                await ((_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback(\"INITIAL_SESSION\", null));\n                this._debug(\"INITIAL_SESSION\", \"callback id\", id, \"error\", err);\n                console.error(err);\n            }\n        });\n    }\n    /**\n     * Sends a password reset request to an email address. This method supports the PKCE flow.\n     *\n     * @param email The email address of the user.\n     * @param options.redirectTo The URL to send the user to after they click the password reset link.\n     * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n     */ async resetPasswordForEmail(email, options = {}) {\n        let codeChallenge = null;\n        let codeChallengeMethod = null;\n        if (this.flowType === \"pkce\") {\n            ;\n            [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey, true // isPasswordRecovery\n            );\n        }\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/recover`, {\n                body: {\n                    email,\n                    code_challenge: codeChallenge,\n                    code_challenge_method: codeChallengeMethod,\n                    gotrue_meta_security: {\n                        captcha_token: options.captchaToken\n                    }\n                },\n                headers: this.headers,\n                redirectTo: options.redirectTo\n            });\n        } catch (error) {\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Gets all the identities linked to a user.\n     */ async getUserIdentities() {\n        var _a;\n        try {\n            const { data, error } = await this.getUser();\n            if (error) throw error;\n            return this._returnResult({\n                data: {\n                    identities: (_a = data.user.identities) !== null && _a !== void 0 ? _a : []\n                },\n                error: null\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async linkIdentity(credentials) {\n        if (\"token\" in credentials) {\n            return this.linkIdentityIdToken(credentials);\n        }\n        return this.linkIdentityOAuth(credentials);\n    }\n    async linkIdentityOAuth(credentials) {\n        var _a;\n        try {\n            const { data, error } = await this._useSession(async (result)=>{\n                var _a, _b, _c, _d, _e;\n                const { data, error } = result;\n                if (error) throw error;\n                const url = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, credentials.provider, {\n                    redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n                    scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n                    queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n                    skipBrowserRedirect: true\n                });\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", url, {\n                    headers: this.headers,\n                    jwt: (_e = (_d = data.session) === null || _d === void 0 ? void 0 : _d.access_token) !== null && _e !== void 0 ? _e : undefined\n                });\n            });\n            if (error) throw error;\n            if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !((_a = credentials.options) === null || _a === void 0 ? void 0 : _a.skipBrowserRedirect)) {\n                window.location.assign(data === null || data === void 0 ? void 0 : data.url);\n            }\n            return this._returnResult({\n                data: {\n                    provider: credentials.provider,\n                    url: data === null || data === void 0 ? void 0 : data.url\n                },\n                error: null\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        provider: credentials.provider,\n                        url: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async linkIdentityIdToken(credentials) {\n        return await this._useSession(async (result)=>{\n            var _a;\n            try {\n                const { error: sessionError, data: { session } } = result;\n                if (sessionError) throw sessionError;\n                const { options, provider, token, access_token, nonce } = credentials;\n                const res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=id_token`, {\n                    headers: this.headers,\n                    jwt: (_a = session === null || session === void 0 ? void 0 : session.access_token) !== null && _a !== void 0 ? _a : undefined,\n                    body: {\n                        provider,\n                        id_token: token,\n                        access_token,\n                        nonce,\n                        link_identity: true,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n                });\n                const { data, error } = res;\n                if (error) {\n                    return this._returnResult({\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error\n                    });\n                } else if (!data || !data.session || !data.user) {\n                    return this._returnResult({\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError()\n                    });\n                }\n                if (data.session) {\n                    await this._saveSession(data.session);\n                    await this._notifyAllSubscribers(\"USER_UPDATED\", data.session);\n                }\n                return this._returnResult({\n                    data,\n                    error\n                });\n            } catch (error) {\n                await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                    return this._returnResult({\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Unlinks an identity from a user by deleting it. The user will no longer be able to sign in with that identity once it's unlinked.\n     */ async unlinkIdentity(identity) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a, _b;\n                const { data, error } = result;\n                if (error) {\n                    throw error;\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"DELETE\", `${this.url}/user/identities/${identity.identity_id}`, {\n                    headers: this.headers,\n                    jwt: (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Generates a new JWT.\n     * @param refreshToken A valid refresh token that was returned on login.\n     */ async _refreshAccessToken(refreshToken) {\n        const debugName = `#_refreshAccessToken(${refreshToken.substring(0, 5)}...)`;\n        this._debug(debugName, \"begin\");\n        try {\n            const startedAt = Date.now();\n            // will attempt to refresh the token with exponential backoff\n            return await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.retryable)(async (attempt)=>{\n                if (attempt > 0) {\n                    await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.sleep)(200 * Math.pow(2, attempt - 1)); // 200, 400, 800, ...\n                }\n                this._debug(debugName, \"refreshing attempt\", attempt);\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=refresh_token`, {\n                    body: {\n                        refresh_token: refreshToken\n                    },\n                    headers: this.headers,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n                });\n            }, (attempt, error)=>{\n                const nextBackOffInterval = 200 * Math.pow(2, attempt);\n                return error && (0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError)(error) && // retryable only if the request can be sent before the backoff overflows the tick duration\n                Date.now() + nextBackOffInterval - startedAt < _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS;\n            });\n        } catch (error) {\n            this._debug(debugName, \"error\", error);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        session: null,\n                        user: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        } finally{\n            this._debug(debugName, \"end\");\n        }\n    }\n    _isValidSession(maybeSession) {\n        const isValidSession = typeof maybeSession === \"object\" && maybeSession !== null && \"access_token\" in maybeSession && \"refresh_token\" in maybeSession && \"expires_at\" in maybeSession;\n        return isValidSession;\n    }\n    async _handleProviderSignIn(provider, options) {\n        const url = await this._getUrlForProvider(`${this.url}/authorize`, provider, {\n            redirectTo: options.redirectTo,\n            scopes: options.scopes,\n            queryParams: options.queryParams\n        });\n        this._debug(\"#_handleProviderSignIn()\", \"provider\", provider, \"options\", options, \"url\", url);\n        // try to open on the browser\n        if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !options.skipBrowserRedirect) {\n            window.location.assign(url);\n        }\n        return {\n            data: {\n                provider,\n                url\n            },\n            error: null\n        };\n    }\n    /**\n     * Recovers the session from LocalStorage and refreshes the token\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n     */ async _recoverAndRefresh() {\n        var _a, _b;\n        const debugName = \"#_recoverAndRefresh()\";\n        this._debug(debugName, \"begin\");\n        try {\n            const currentSession = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, this.storageKey);\n            if (currentSession && this.userStorage) {\n                let maybeUser = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.userStorage, this.storageKey + \"-user\");\n                if (!this.storage.isServer && Object.is(this.storage, this.userStorage) && !maybeUser) {\n                    // storage and userStorage are the same storage medium, for example\n                    // window.localStorage if userStorage does not have the user from\n                    // storage stored, store it first thereby migrating the user object\n                    // from storage -> userStorage\n                    maybeUser = {\n                        user: currentSession.user\n                    };\n                    await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.userStorage, this.storageKey + \"-user\", maybeUser);\n                }\n                currentSession.user = (_a = maybeUser === null || maybeUser === void 0 ? void 0 : maybeUser.user) !== null && _a !== void 0 ? _a : (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.userNotAvailableProxy)();\n            } else if (currentSession && !currentSession.user) {\n                // user storage is not set, let's check if it was previously enabled so\n                // we bring back the storage as it should be\n                if (!currentSession.user) {\n                    // test if userStorage was previously enabled and the storage medium was the same, to move the user back under the same key\n                    const separateUser = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, this.storageKey + \"-user\");\n                    if (separateUser && (separateUser === null || separateUser === void 0 ? void 0 : separateUser.user)) {\n                        currentSession.user = separateUser.user;\n                        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, this.storageKey + \"-user\");\n                        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.storage, this.storageKey, currentSession);\n                    } else {\n                        currentSession.user = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.userNotAvailableProxy)();\n                    }\n                }\n            }\n            this._debug(debugName, \"session from storage\", currentSession);\n            if (!this._isValidSession(currentSession)) {\n                this._debug(debugName, \"session is not valid\");\n                if (currentSession !== null) {\n                    await this._removeSession();\n                }\n                return;\n            }\n            const expiresWithMargin = ((_b = currentSession.expires_at) !== null && _b !== void 0 ? _b : Infinity) * 1000 - Date.now() < _lib_constants__WEBPACK_IMPORTED_MODULE_1__.EXPIRY_MARGIN_MS;\n            this._debug(debugName, `session has${expiresWithMargin ? \"\" : \" not\"} expired with margin of ${_lib_constants__WEBPACK_IMPORTED_MODULE_1__.EXPIRY_MARGIN_MS}s`);\n            if (expiresWithMargin) {\n                if (this.autoRefreshToken && currentSession.refresh_token) {\n                    const { error } = await this._callRefreshToken(currentSession.refresh_token);\n                    if (error) {\n                        console.error(error);\n                        if (!(0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError)(error)) {\n                            this._debug(debugName, \"refresh failed with a non-retryable error, removing the session\", error);\n                            await this._removeSession();\n                        }\n                    }\n                }\n            } else if (currentSession.user && currentSession.user.__isUserNotAvailableProxy === true) {\n                // If we have a proxy user, try to get the real user data\n                try {\n                    const { data, error: userError } = await this._getUser(currentSession.access_token);\n                    if (!userError && (data === null || data === void 0 ? void 0 : data.user)) {\n                        currentSession.user = data.user;\n                        await this._saveSession(currentSession);\n                        await this._notifyAllSubscribers(\"SIGNED_IN\", currentSession);\n                    } else {\n                        this._debug(debugName, \"could not get user data, skipping SIGNED_IN notification\");\n                    }\n                } catch (getUserError) {\n                    console.error(\"Error getting user data:\", getUserError);\n                    this._debug(debugName, \"error getting user data, skipping SIGNED_IN notification\", getUserError);\n                }\n            } else {\n                // no need to persist currentSession again, as we just loaded it from\n                // local storage; persisting it again may overwrite a value saved by\n                // another client with access to the same local storage\n                await this._notifyAllSubscribers(\"SIGNED_IN\", currentSession);\n            }\n        } catch (err) {\n            this._debug(debugName, \"error\", err);\n            console.error(err);\n            return;\n        } finally{\n            this._debug(debugName, \"end\");\n        }\n    }\n    async _callRefreshToken(refreshToken) {\n        var _a, _b;\n        if (!refreshToken) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n        }\n        // refreshing is already in progress\n        if (this.refreshingDeferred) {\n            return this.refreshingDeferred.promise;\n        }\n        const debugName = `#_callRefreshToken(${refreshToken.substring(0, 5)}...)`;\n        this._debug(debugName, \"begin\");\n        try {\n            this.refreshingDeferred = new _lib_helpers__WEBPACK_IMPORTED_MODULE_4__.Deferred();\n            const { data, error } = await this._refreshAccessToken(refreshToken);\n            if (error) throw error;\n            if (!data.session) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n            await this._saveSession(data.session);\n            await this._notifyAllSubscribers(\"TOKEN_REFRESHED\", data.session);\n            const result = {\n                data: data.session,\n                error: null\n            };\n            this.refreshingDeferred.resolve(result);\n            return result;\n        } catch (error) {\n            this._debug(debugName, \"error\", error);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                const result = {\n                    data: null,\n                    error\n                };\n                if (!(0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError)(error)) {\n                    await this._removeSession();\n                }\n                (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(result);\n                return result;\n            }\n            (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);\n            throw error;\n        } finally{\n            this.refreshingDeferred = null;\n            this._debug(debugName, \"end\");\n        }\n    }\n    async _notifyAllSubscribers(event, session, broadcast = true) {\n        const debugName = `#_notifyAllSubscribers(${event})`;\n        this._debug(debugName, \"begin\", session, `broadcast = ${broadcast}`);\n        try {\n            if (this.broadcastChannel && broadcast) {\n                this.broadcastChannel.postMessage({\n                    event,\n                    session\n                });\n            }\n            const errors = [];\n            const promises = Array.from(this.stateChangeEmitters.values()).map(async (x)=>{\n                try {\n                    await x.callback(event, session);\n                } catch (e) {\n                    errors.push(e);\n                }\n            });\n            await Promise.all(promises);\n            if (errors.length > 0) {\n                for(let i = 0; i < errors.length; i += 1){\n                    console.error(errors[i]);\n                }\n                throw errors[0];\n            }\n        } finally{\n            this._debug(debugName, \"end\");\n        }\n    }\n    /**\n     * set currentSession and currentUser\n     * process to _startAutoRefreshToken if possible\n     */ async _saveSession(session) {\n        this._debug(\"#_saveSession()\", session);\n        // _saveSession is always called whenever a new session has been acquired\n        // so we can safely suppress the warning returned by future getSession calls\n        this.suppressGetSessionWarning = true;\n        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n        // Create a shallow copy to work with, to avoid mutating the original session object if it's used elsewhere\n        const sessionToProcess = Object.assign({}, session);\n        const userIsProxy = sessionToProcess.user && sessionToProcess.user.__isUserNotAvailableProxy === true;\n        if (this.userStorage) {\n            if (!userIsProxy && sessionToProcess.user) {\n                // If it's a real user object, save it to userStorage.\n                await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.userStorage, this.storageKey + \"-user\", {\n                    user: sessionToProcess.user\n                });\n            } else if (userIsProxy) {\n            // If it's the proxy, it means user was not found in userStorage.\n            // We should ensure no stale user data for this key exists in userStorage if we were to save null,\n            // or simply not save the proxy. For now, we don't save the proxy here.\n            // If there's a need to clear userStorage if user becomes proxy, that logic would go here.\n            }\n            // Prepare the main session data for primary storage: remove the user property before cloning\n            // This is important because the original session.user might be the proxy\n            const mainSessionData = Object.assign({}, sessionToProcess);\n            delete mainSessionData.user; // Remove user (real or proxy) before cloning for main storage\n            const clonedMainSessionData = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.deepClone)(mainSessionData);\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.storage, this.storageKey, clonedMainSessionData);\n        } else {\n            // No userStorage is configured.\n            // In this case, session.user should ideally not be a proxy.\n            // If it were, structuredClone would fail. This implies an issue elsewhere if user is a proxy here\n            const clonedSession = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.deepClone)(sessionToProcess); // sessionToProcess still has its original user property\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.storage, this.storageKey, clonedSession);\n        }\n    }\n    async _removeSession() {\n        this._debug(\"#_removeSession()\");\n        this.suppressGetSessionWarning = false;\n        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, this.storageKey);\n        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, this.storageKey + \"-code-verifier\");\n        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, this.storageKey + \"-user\");\n        if (this.userStorage) {\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.userStorage, this.storageKey + \"-user\");\n        }\n        await this._notifyAllSubscribers(\"SIGNED_OUT\", null);\n    }\n    /**\n     * Removes any registered visibilitychange callback.\n     *\n     * {@see #startAutoRefresh}\n     * {@see #stopAutoRefresh}\n     */ _removeVisibilityChangedCallback() {\n        this._debug(\"#_removeVisibilityChangedCallback()\");\n        const callback = this.visibilityChangedCallback;\n        this.visibilityChangedCallback = null;\n        try {\n            if (callback && (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {\n                window.removeEventListener(\"visibilitychange\", callback);\n            }\n        } catch (e) {\n            console.error(\"removing visibilitychange callback failed\", e);\n        }\n    }\n    /**\n     * This is the private implementation of {@link #startAutoRefresh}. Use this\n     * within the library.\n     */ async _startAutoRefresh() {\n        await this._stopAutoRefresh();\n        this._debug(\"#_startAutoRefresh()\");\n        const ticker = setInterval(()=>this._autoRefreshTokenTick(), _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS);\n        this.autoRefreshTicker = ticker;\n        if (ticker && typeof ticker === \"object\" && typeof ticker.unref === \"function\") {\n            // ticker is a NodeJS Timeout object that has an `unref` method\n            // https://nodejs.org/api/timers.html#timeoutunref\n            // When auto refresh is used in NodeJS (like for testing) the\n            // `setInterval` is preventing the process from being marked as\n            // finished and tests run endlessly. This can be prevented by calling\n            // `unref()` on the returned object.\n            ticker.unref();\n        // @ts-expect-error TS has no context of Deno\n        } else if (typeof Deno !== \"undefined\" && typeof Deno.unrefTimer === \"function\") {\n            // similar like for NodeJS, but with the Deno API\n            // https://deno.land/api@latest?unstable&s=Deno.unrefTimer\n            // @ts-expect-error TS has no context of Deno\n            Deno.unrefTimer(ticker);\n        }\n        // run the tick immediately, but in the next pass of the event loop so that\n        // #_initialize can be allowed to complete without recursively waiting on\n        // itself\n        const timeout = setTimeout(async ()=>{\n            await this.initializePromise;\n            await this._autoRefreshTokenTick();\n        }, 0);\n        this.autoRefreshTickTimeout = timeout;\n        if (timeout && typeof timeout === \"object\" && typeof timeout.unref === \"function\") {\n            timeout.unref();\n        // @ts-expect-error TS has no context of Deno\n        } else if (typeof Deno !== \"undefined\" && typeof Deno.unrefTimer === \"function\") {\n            // @ts-expect-error TS has no context of Deno\n            Deno.unrefTimer(timeout);\n        }\n    }\n    /**\n     * This is the private implementation of {@link #stopAutoRefresh}. Use this\n     * within the library.\n     */ async _stopAutoRefresh() {\n        this._debug(\"#_stopAutoRefresh()\");\n        const ticker = this.autoRefreshTicker;\n        this.autoRefreshTicker = null;\n        if (ticker) {\n            clearInterval(ticker);\n        }\n        const timeout = this.autoRefreshTickTimeout;\n        this.autoRefreshTickTimeout = null;\n        if (timeout) {\n            clearTimeout(timeout);\n        }\n    }\n    /**\n     * Starts an auto-refresh process in the background. The session is checked\n     * every few seconds. Close to the time of expiration a process is started to\n     * refresh the session. If refreshing fails it will be retried for as long as\n     * necessary.\n     *\n     * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need\n     * to call this function, it will be called for you.\n     *\n     * On browsers the refresh process works only when the tab/window is in the\n     * foreground to conserve resources as well as prevent race conditions and\n     * flooding auth with requests. If you call this method any managed\n     * visibility change callback will be removed and you must manage visibility\n     * changes on your own.\n     *\n     * On non-browser platforms the refresh process works *continuously* in the\n     * background, which may not be desirable. You should hook into your\n     * platform's foreground indication mechanism and call these methods\n     * appropriately to conserve resources.\n     *\n     * {@see #stopAutoRefresh}\n     */ async startAutoRefresh() {\n        this._removeVisibilityChangedCallback();\n        await this._startAutoRefresh();\n    }\n    /**\n     * Stops an active auto refresh process running in the background (if any).\n     *\n     * If you call this method any managed visibility change callback will be\n     * removed and you must manage visibility changes on your own.\n     *\n     * See {@link #startAutoRefresh} for more details.\n     */ async stopAutoRefresh() {\n        this._removeVisibilityChangedCallback();\n        await this._stopAutoRefresh();\n    }\n    /**\n     * Runs the auto refresh token tick.\n     */ async _autoRefreshTokenTick() {\n        this._debug(\"#_autoRefreshTokenTick()\", \"begin\");\n        try {\n            await this._acquireLock(0, async ()=>{\n                try {\n                    const now = Date.now();\n                    try {\n                        return await this._useSession(async (result)=>{\n                            const { data: { session } } = result;\n                            if (!session || !session.refresh_token || !session.expires_at) {\n                                this._debug(\"#_autoRefreshTokenTick()\", \"no session\");\n                                return;\n                            }\n                            // session will expire in this many ticks (or has already expired if <= 0)\n                            const expiresInTicks = Math.floor((session.expires_at * 1000 - now) / _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS);\n                            this._debug(\"#_autoRefreshTokenTick()\", `access token expires in ${expiresInTicks} ticks, a tick lasts ${_lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS}ms, refresh threshold is ${_lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_THRESHOLD} ticks`);\n                            if (expiresInTicks <= _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_THRESHOLD) {\n                                await this._callRefreshToken(session.refresh_token);\n                            }\n                        });\n                    } catch (e) {\n                        console.error(\"Auto refresh tick failed with error. This is likely a transient error.\", e);\n                    }\n                } finally{\n                    this._debug(\"#_autoRefreshTokenTick()\", \"end\");\n                }\n            });\n        } catch (e) {\n            if (e.isAcquireTimeout || e instanceof _lib_locks__WEBPACK_IMPORTED_MODULE_6__.LockAcquireTimeoutError) {\n                this._debug(\"auto refresh token tick lock not available\");\n            } else {\n                throw e;\n            }\n        }\n    }\n    /**\n     * Registers callbacks on the browser / platform, which in-turn run\n     * algorithms when the browser window/tab are in foreground. On non-browser\n     * platforms it assumes always foreground.\n     */ async _handleVisibilityChange() {\n        this._debug(\"#_handleVisibilityChange()\");\n        if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n            if (this.autoRefreshToken) {\n                // in non-browser environments the refresh token ticker runs always\n                this.startAutoRefresh();\n            }\n            return false;\n        }\n        try {\n            this.visibilityChangedCallback = async ()=>{\n                try {\n                    await this._onVisibilityChanged(false);\n                } catch (error) {\n                    this._debug(\"#visibilityChangedCallback\", \"error\", error);\n                }\n            };\n            window === null || window === void 0 ? void 0 : window.addEventListener(\"visibilitychange\", this.visibilityChangedCallback);\n            // now immediately call the visbility changed callback to setup with the\n            // current visbility state\n            await this._onVisibilityChanged(true); // initial call\n        } catch (error) {\n            console.error(\"_handleVisibilityChange\", error);\n        }\n    }\n    /**\n     * Callback registered with `window.addEventListener('visibilitychange')`.\n     */ async _onVisibilityChanged(calledFromInitialize) {\n        const methodName = `#_onVisibilityChanged(${calledFromInitialize})`;\n        this._debug(methodName, \"visibilityState\", document.visibilityState);\n        if (document.visibilityState === \"visible\") {\n            if (this.autoRefreshToken) {\n                // in browser environments the refresh token ticker runs only on focused tabs\n                // which prevents race conditions\n                this._startAutoRefresh();\n            }\n            if (!calledFromInitialize) {\n                // called when the visibility has changed, i.e. the browser\n                // transitioned from hidden -> visible so we need to see if the session\n                // should be recovered immediately... but to do that we need to acquire\n                // the lock first asynchronously\n                await this.initializePromise;\n                await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n                    if (document.visibilityState !== \"visible\") {\n                        this._debug(methodName, \"acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting\");\n                        // visibility has changed while waiting for the lock, abort\n                        return;\n                    }\n                    // recover the session\n                    await this._recoverAndRefresh();\n                });\n            }\n        } else if (document.visibilityState === \"hidden\") {\n            if (this.autoRefreshToken) {\n                this._stopAutoRefresh();\n            }\n        }\n    }\n    /**\n     * Generates the relevant login URL for a third-party provider.\n     * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n     * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n     */ async _getUrlForProvider(url, provider, options) {\n        const urlParams = [\n            `provider=${encodeURIComponent(provider)}`\n        ];\n        if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n            urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n        }\n        if (options === null || options === void 0 ? void 0 : options.scopes) {\n            urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n        }\n        if (this.flowType === \"pkce\") {\n            const [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n            const flowParams = new URLSearchParams({\n                code_challenge: `${encodeURIComponent(codeChallenge)}`,\n                code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`\n            });\n            urlParams.push(flowParams.toString());\n        }\n        if (options === null || options === void 0 ? void 0 : options.queryParams) {\n            const query = new URLSearchParams(options.queryParams);\n            urlParams.push(query.toString());\n        }\n        if (options === null || options === void 0 ? void 0 : options.skipBrowserRedirect) {\n            urlParams.push(`skip_http_redirect=${options.skipBrowserRedirect}`);\n        }\n        return `${url}?${urlParams.join(\"&\")}`;\n    }\n    async _unenroll(params) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a;\n                const { data: sessionData, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"DELETE\", `${this.url}/factors/${params.factorId}`, {\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async _enroll(params) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a, _b;\n                const { data: sessionData, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                const body = Object.assign({\n                    friendly_name: params.friendlyName,\n                    factor_type: params.factorType\n                }, params.factorType === \"phone\" ? {\n                    phone: params.phone\n                } : params.factorType === \"totp\" ? {\n                    issuer: params.issuer\n                } : {});\n                const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/factors`, {\n                    body,\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n                if (error) {\n                    return this._returnResult({\n                        data: null,\n                        error\n                    });\n                }\n                if (params.factorType === \"totp\" && data.type === \"totp\" && ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code)) {\n                    data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;\n                }\n                return this._returnResult({\n                    data,\n                    error: null\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async _verify(params) {\n        return this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            try {\n                return await this._useSession(async (result)=>{\n                    var _a;\n                    const { data: sessionData, error: sessionError } = result;\n                    if (sessionError) {\n                        return this._returnResult({\n                            data: null,\n                            error: sessionError\n                        });\n                    }\n                    const body = Object.assign({\n                        challenge_id: params.challengeId\n                    }, \"webauthn\" in params ? {\n                        webauthn: Object.assign(Object.assign({}, params.webauthn), {\n                            credential_response: params.webauthn.type === \"create\" ? (0,_lib_webauthn__WEBPACK_IMPORTED_MODULE_11__.serializeCredentialCreationResponse)(params.webauthn.credential_response) : (0,_lib_webauthn__WEBPACK_IMPORTED_MODULE_11__.serializeCredentialRequestResponse)(params.webauthn.credential_response)\n                        })\n                    } : {\n                        code: params.code\n                    });\n                    const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/factors/${params.factorId}/verify`, {\n                        body,\n                        headers: this.headers,\n                        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                    });\n                    if (error) {\n                        return this._returnResult({\n                            data: null,\n                            error\n                        });\n                    }\n                    await this._saveSession(Object.assign({\n                        expires_at: Math.round(Date.now() / 1000) + data.expires_in\n                    }, data));\n                    await this._notifyAllSubscribers(\"MFA_CHALLENGE_VERIFIED\", data);\n                    return this._returnResult({\n                        data,\n                        error\n                    });\n                });\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                    return this._returnResult({\n                        data: null,\n                        error\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    async _challenge(params) {\n        return this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            try {\n                return await this._useSession(async (result)=>{\n                    var _a;\n                    const { data: sessionData, error: sessionError } = result;\n                    if (sessionError) {\n                        return this._returnResult({\n                            data: null,\n                            error: sessionError\n                        });\n                    }\n                    const response = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/factors/${params.factorId}/challenge`, {\n                        body: params,\n                        headers: this.headers,\n                        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                    });\n                    if (response.error) {\n                        return response;\n                    }\n                    const { data } = response;\n                    if (data.type !== \"webauthn\") {\n                        return {\n                            data,\n                            error: null\n                        };\n                    }\n                    switch(data.webauthn.type){\n                        case \"create\":\n                            return {\n                                data: Object.assign(Object.assign({}, data), {\n                                    webauthn: Object.assign(Object.assign({}, data.webauthn), {\n                                        credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), {\n                                            publicKey: (0,_lib_webauthn__WEBPACK_IMPORTED_MODULE_11__.deserializeCredentialCreationOptions)(data.webauthn.credential_options.publicKey)\n                                        })\n                                    })\n                                }),\n                                error: null\n                            };\n                        case \"request\":\n                            return {\n                                data: Object.assign(Object.assign({}, data), {\n                                    webauthn: Object.assign(Object.assign({}, data.webauthn), {\n                                        credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), {\n                                            publicKey: (0,_lib_webauthn__WEBPACK_IMPORTED_MODULE_11__.deserializeCredentialRequestOptions)(data.webauthn.credential_options.publicKey)\n                                        })\n                                    })\n                                }),\n                                error: null\n                            };\n                    }\n                });\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                    return this._returnResult({\n                        data: null,\n                        error\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#challengeAndVerify}\n     */ async _challengeAndVerify(params) {\n        // both _challenge and _verify independently acquire the lock, so no need\n        // to acquire it here\n        const { data: challengeData, error: challengeError } = await this._challenge({\n            factorId: params.factorId\n        });\n        if (challengeError) {\n            return this._returnResult({\n                data: null,\n                error: challengeError\n            });\n        }\n        return await this._verify({\n            factorId: params.factorId,\n            challengeId: challengeData.id,\n            code: params.code\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#listFactors}\n     */ async _listFactors() {\n        var _a;\n        // use #getUser instead of #_getUser as the former acquires a lock\n        const { data: { user }, error: userError } = await this.getUser();\n        if (userError) {\n            return {\n                data: null,\n                error: userError\n            };\n        }\n        const data = {\n            all: [],\n            phone: [],\n            totp: [],\n            webauthn: []\n        };\n        // loop over the factors ONCE\n        for (const factor of (_a = user === null || user === void 0 ? void 0 : user.factors) !== null && _a !== void 0 ? _a : []){\n            data.all.push(factor);\n            if (factor.status === \"verified\") {\n                ;\n                data[factor.factor_type].push(factor);\n            }\n        }\n        return {\n            data,\n            error: null\n        };\n    }\n    /**\n     * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}\n     */ async _getAuthenticatorAssuranceLevel(jwt) {\n        var _a, _b, _c, _d;\n        if (jwt) {\n            try {\n                const { payload } = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.decodeJWT)(jwt);\n                let currentLevel = null;\n                if (payload.aal) {\n                    currentLevel = payload.aal;\n                }\n                let nextLevel = currentLevel;\n                const { data: { user }, error: userError } = await this.getUser(jwt);\n                if (userError) {\n                    return this._returnResult({\n                        data: null,\n                        error: userError\n                    });\n                }\n                const verifiedFactors = (_b = (_a = user === null || user === void 0 ? void 0 : user.factors) === null || _a === void 0 ? void 0 : _a.filter((factor)=>factor.status === \"verified\")) !== null && _b !== void 0 ? _b : [];\n                if (verifiedFactors.length > 0) {\n                    nextLevel = \"aal2\";\n                }\n                const currentAuthenticationMethods = payload.amr || [];\n                return {\n                    data: {\n                        currentLevel,\n                        nextLevel,\n                        currentAuthenticationMethods\n                    },\n                    error: null\n                };\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                    return this._returnResult({\n                        data: null,\n                        error\n                    });\n                }\n                throw error;\n            }\n        }\n        const { data: { session }, error: sessionError } = await this.getSession();\n        if (sessionError) {\n            return this._returnResult({\n                data: null,\n                error: sessionError\n            });\n        }\n        if (!session) {\n            return {\n                data: {\n                    currentLevel: null,\n                    nextLevel: null,\n                    currentAuthenticationMethods: []\n                },\n                error: null\n            };\n        }\n        const { payload } = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.decodeJWT)(session.access_token);\n        let currentLevel = null;\n        if (payload.aal) {\n            currentLevel = payload.aal;\n        }\n        let nextLevel = currentLevel;\n        const verifiedFactors = (_d = (_c = session.user.factors) === null || _c === void 0 ? void 0 : _c.filter((factor)=>factor.status === \"verified\")) !== null && _d !== void 0 ? _d : [];\n        if (verifiedFactors.length > 0) {\n            nextLevel = \"aal2\";\n        }\n        const currentAuthenticationMethods = payload.amr || [];\n        return {\n            data: {\n                currentLevel,\n                nextLevel,\n                currentAuthenticationMethods\n            },\n            error: null\n        };\n    }\n    /**\n     * Retrieves details about an OAuth authorization request.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * Returns authorization details including client info, scopes, and user information.\n     * If the response includes only a redirect_url field, it means consent was already given - the caller\n     * should handle the redirect manually if needed.\n     */ async _getAuthorizationDetails(authorizationId) {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                if (!session) {\n                    return this._returnResult({\n                        data: null,\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError()\n                    });\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", `${this.url}/oauth/authorizations/${authorizationId}`, {\n                    headers: this.headers,\n                    jwt: session.access_token,\n                    xform: (data)=>({\n                            data,\n                            error: null\n                        })\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Approves an OAuth authorization request.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     */ async _approveAuthorization(authorizationId, options) {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                if (!session) {\n                    return this._returnResult({\n                        data: null,\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError()\n                    });\n                }\n                const response = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/oauth/authorizations/${authorizationId}/consent`, {\n                    headers: this.headers,\n                    jwt: session.access_token,\n                    body: {\n                        action: \"approve\"\n                    },\n                    xform: (data)=>({\n                            data,\n                            error: null\n                        })\n                });\n                if (response.data && response.data.redirect_url) {\n                    // Automatically redirect in browser unless skipBrowserRedirect is true\n                    if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !(options === null || options === void 0 ? void 0 : options.skipBrowserRedirect)) {\n                        window.location.assign(response.data.redirect_url);\n                    }\n                }\n                return response;\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Denies an OAuth authorization request.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     */ async _denyAuthorization(authorizationId, options) {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                if (!session) {\n                    return this._returnResult({\n                        data: null,\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError()\n                    });\n                }\n                const response = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/oauth/authorizations/${authorizationId}/consent`, {\n                    headers: this.headers,\n                    jwt: session.access_token,\n                    body: {\n                        action: \"deny\"\n                    },\n                    xform: (data)=>({\n                            data,\n                            error: null\n                        })\n                });\n                if (response.data && response.data.redirect_url) {\n                    // Automatically redirect in browser unless skipBrowserRedirect is true\n                    if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !(options === null || options === void 0 ? void 0 : options.skipBrowserRedirect)) {\n                        window.location.assign(response.data.redirect_url);\n                    }\n                }\n                return response;\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Lists all OAuth grants that the authenticated user has authorized.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     */ async _listOAuthGrants() {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                if (!session) {\n                    return this._returnResult({\n                        data: null,\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError()\n                    });\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", `${this.url}/user/oauth/grants`, {\n                    headers: this.headers,\n                    jwt: session.access_token,\n                    xform: (data)=>({\n                            data,\n                            error: null\n                        })\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Revokes a user's OAuth grant for a specific client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     */ async _revokeOAuthGrant(options) {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                if (!session) {\n                    return this._returnResult({\n                        data: null,\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError()\n                    });\n                }\n                await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"DELETE\", `${this.url}/user/oauth/grants`, {\n                    headers: this.headers,\n                    jwt: session.access_token,\n                    query: {\n                        client_id: options.clientId\n                    },\n                    noResolveJson: true\n                });\n                return {\n                    data: {},\n                    error: null\n                };\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async fetchJwk(kid, jwks = {\n        keys: []\n    }) {\n        // try fetching from the supplied jwks\n        let jwk = jwks.keys.find((key)=>key.kid === kid);\n        if (jwk) {\n            return jwk;\n        }\n        const now = Date.now();\n        // try fetching from cache\n        jwk = this.jwks.keys.find((key)=>key.kid === kid);\n        // jwk exists and jwks isn't stale\n        if (jwk && this.jwks_cached_at + _lib_constants__WEBPACK_IMPORTED_MODULE_1__.JWKS_TTL > now) {\n            return jwk;\n        }\n        // jwk isn't cached in memory so we need to fetch it from the well-known endpoint\n        const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", `${this.url}/.well-known/jwks.json`, {\n            headers: this.headers\n        });\n        if (error) {\n            throw error;\n        }\n        if (!data.keys || data.keys.length === 0) {\n            return null;\n        }\n        this.jwks = data;\n        this.jwks_cached_at = now;\n        // Find the signing key\n        jwk = data.keys.find((key)=>key.kid === kid);\n        if (!jwk) {\n            return null;\n        }\n        return jwk;\n    }\n    /**\n     * Extracts the JWT claims present in the access token by first verifying the\n     * JWT against the server's JSON Web Key Set endpoint\n     * `/.well-known/jwks.json` which is often cached, resulting in significantly\n     * faster responses. Prefer this method over {@link #getUser} which always\n     * sends a request to the Auth server for each JWT.\n     *\n     * If the project is not using an asymmetric JWT signing key (like ECC or\n     * RSA) it always sends a request to the Auth server (similar to {@link\n     * #getUser}) to verify the JWT.\n     *\n     * @param jwt An optional specific JWT you wish to verify, not the one you\n     *            can obtain from {@link #getSession}.\n     * @param options Various additional options that allow you to customize the\n     *                behavior of this method.\n     */ async getClaims(jwt, options = {}) {\n        try {\n            let token = jwt;\n            if (!token) {\n                const { data, error } = await this.getSession();\n                if (error || !data.session) {\n                    return this._returnResult({\n                        data: null,\n                        error\n                    });\n                }\n                token = data.session.access_token;\n            }\n            const { header, payload, signature, raw: { header: rawHeader, payload: rawPayload } } = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.decodeJWT)(token);\n            if (!(options === null || options === void 0 ? void 0 : options.allowExpired)) {\n                // Reject expired JWTs should only happen if jwt argument was passed\n                (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.validateExp)(payload.exp);\n            }\n            const signingKey = !header.alg || header.alg.startsWith(\"HS\") || !header.kid || !(\"crypto\" in globalThis && \"subtle\" in globalThis.crypto) ? null : await this.fetchJwk(header.kid, (options === null || options === void 0 ? void 0 : options.keys) ? {\n                keys: options.keys\n            } : options === null || options === void 0 ? void 0 : options.jwks);\n            // If symmetric algorithm or WebCrypto API is unavailable, fallback to getUser()\n            if (!signingKey) {\n                const { error } = await this.getUser(token);\n                if (error) {\n                    throw error;\n                }\n                // getUser succeeds so the claims in the JWT can be trusted\n                return {\n                    data: {\n                        claims: payload,\n                        header,\n                        signature\n                    },\n                    error: null\n                };\n            }\n            const algorithm = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getAlgorithm)(header.alg);\n            // Convert JWK to CryptoKey\n            const publicKey = await crypto.subtle.importKey(\"jwk\", signingKey, algorithm, true, [\n                \"verify\"\n            ]);\n            // Verify the signature\n            const isValid = await crypto.subtle.verify(algorithm, publicKey, signature, (0,_lib_base64url__WEBPACK_IMPORTED_MODULE_9__.stringToUint8Array)(`${rawHeader}.${rawPayload}`));\n            if (!isValid) {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidJwtError(\"Invalid JWT signature\");\n            }\n            // If verification succeeds, decode and return claims\n            return {\n                data: {\n                    claims: payload,\n                    header,\n                    signature\n                },\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n}\nGoTrueClient.nextInstanceID = {};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GoTrueClient); //# sourceMappingURL=GoTrueClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvR29UcnVlQ2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFDc0g7QUFDOE07QUFDalE7QUFDZ047QUFDalE7QUFDSztBQUNoQjtBQUNiO0FBQytCO0FBQ2M7QUFDNkc7QUFDbE0rQyxrRUFBa0JBLElBQUksOEJBQThCO0FBQ3BELE1BQU1hLGtCQUFrQjtJQUNwQkMsS0FBS3hELHNEQUFVQTtJQUNmeUQsWUFBWXZELHVEQUFXQTtJQUN2QndELGtCQUFrQjtJQUNsQkMsZ0JBQWdCO0lBQ2hCQyxvQkFBb0I7SUFDcEJDLFNBQVMvRCwyREFBZUE7SUFDeEJnRSxVQUFVO0lBQ1ZDLE9BQU87SUFDUEMsOEJBQThCO0lBQzlCQyxjQUFjO0lBQ2RDLG9CQUFvQjtJQUNwQkMsb0JBQW9CO0FBQ3hCO0FBQ0EsZUFBZUMsU0FBU0MsSUFBSSxFQUFFQyxjQUFjLEVBQUVDLEVBQUU7SUFDNUMsT0FBTyxNQUFNQTtBQUNqQjtBQUNBOzs7Ozs7O0NBT0MsR0FDRCxNQUFNQyxjQUFjLENBQUM7QUFDckIsTUFBTUM7SUFDRjs7S0FFQyxHQUNELElBQUlDLE9BQU87UUFDUCxJQUFJQyxJQUFJQztRQUNSLE9BQU8sQ0FBQ0EsS0FBSyxDQUFDRCxLQUFLSCxXQUFXLENBQUMsSUFBSSxDQUFDZixVQUFVLENBQUMsTUFBTSxRQUFRa0IsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHRCxJQUFJLE1BQU0sUUFBUUUsT0FBTyxLQUFLLElBQUlBLEtBQUs7WUFBRUMsTUFBTSxFQUFFO1FBQUM7SUFDL0k7SUFDQSxJQUFJSCxLQUFLSSxLQUFLLEVBQUU7UUFDWk4sV0FBVyxDQUFDLElBQUksQ0FBQ2YsVUFBVSxDQUFDLEdBQUdzQixPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdSLFdBQVcsQ0FBQyxJQUFJLENBQUNmLFVBQVUsQ0FBQyxH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QUFHLENBQUM7QUFDL0IsaUVBQWVqQyxZQUFZQSxFQUFDLENBQzVCLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2FuY2hvci13b3JrZmxvd3MvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvR29UcnVlQ2xpZW50LmpzP2Y2NzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEdvVHJ1ZUFkbWluQXBpIGZyb20gJy4vR29UcnVlQWRtaW5BcGknO1xuaW1wb3J0IHsgQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVMsIEFVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRCwgREVGQVVMVF9IRUFERVJTLCBFWFBJUllfTUFSR0lOX01TLCBHT1RSVUVfVVJMLCBKV0tTX1RUTCwgU1RPUkFHRV9LRVksIH0gZnJvbSAnLi9saWIvY29uc3RhbnRzJztcbmltcG9ydCB7IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciwgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yLCBBdXRoSW52YWxpZEp3dEVycm9yLCBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvciwgQXV0aFBLQ0VDb2RlVmVyaWZpZXJNaXNzaW5nRXJyb3IsIEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvciwgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IsIEF1dGhVbmtub3duRXJyb3IsIGlzQXV0aEFwaUVycm9yLCBpc0F1dGhFcnJvciwgaXNBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IsIGlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IsIGlzQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IsIH0gZnJvbSAnLi9saWIvZXJyb3JzJztcbmltcG9ydCB7IF9yZXF1ZXN0LCBfc2Vzc2lvblJlc3BvbnNlLCBfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQsIF9zc29SZXNwb25zZSwgX3VzZXJSZXNwb25zZSwgfSBmcm9tICcuL2xpYi9mZXRjaCc7XG5pbXBvcnQgeyBkZWNvZGVKV1QsIGRlZXBDbG9uZSwgRGVmZXJyZWQsIGdlbmVyYXRlQ2FsbGJhY2tJZCwgZ2V0QWxnb3JpdGhtLCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kLCBnZXRJdGVtQXN5bmMsIGluc2VjdXJlVXNlcldhcm5pbmdQcm94eSwgaXNCcm93c2VyLCBwYXJzZVBhcmFtZXRlcnNGcm9tVVJMLCByZW1vdmVJdGVtQXN5bmMsIHJlc29sdmVGZXRjaCwgcmV0cnlhYmxlLCBzZXRJdGVtQXN5bmMsIHNsZWVwLCBzdXBwb3J0c0xvY2FsU3RvcmFnZSwgdXNlck5vdEF2YWlsYWJsZVByb3h5LCB2YWxpZGF0ZUV4cCwgfSBmcm9tICcuL2xpYi9oZWxwZXJzJztcbmltcG9ydCB7IG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIgfSBmcm9tICcuL2xpYi9sb2NhbC1zdG9yYWdlJztcbmltcG9ydCB7IExvY2tBY3F1aXJlVGltZW91dEVycm9yLCBuYXZpZ2F0b3JMb2NrIH0gZnJvbSAnLi9saWIvbG9ja3MnO1xuaW1wb3J0IHsgcG9seWZpbGxHbG9iYWxUaGlzIH0gZnJvbSAnLi9saWIvcG9seWZpbGxzJztcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL2xpYi92ZXJzaW9uJztcbmltcG9ydCB7IGJ5dGVzVG9CYXNlNjRVUkwsIHN0cmluZ1RvVWludDhBcnJheSB9IGZyb20gJy4vbGliL2Jhc2U2NHVybCc7XG5pbXBvcnQgeyBjcmVhdGVTaXdlTWVzc2FnZSwgZnJvbUhleCwgZ2V0QWRkcmVzcywgdG9IZXgsIH0gZnJvbSAnLi9saWIvd2ViMy9ldGhlcmV1bSc7XG5pbXBvcnQgeyBkZXNlcmlhbGl6ZUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMsIGRlc2VyaWFsaXplQ3JlZGVudGlhbFJlcXVlc3RPcHRpb25zLCBzZXJpYWxpemVDcmVkZW50aWFsQ3JlYXRpb25SZXNwb25zZSwgc2VyaWFsaXplQ3JlZGVudGlhbFJlcXVlc3RSZXNwb25zZSwgV2ViQXV0aG5BcGksIH0gZnJvbSAnLi9saWIvd2ViYXV0aG4nO1xucG9seWZpbGxHbG9iYWxUaGlzKCk7IC8vIE1ha2UgXCJnbG9iYWxUaGlzXCIgYXZhaWxhYmxlXG5jb25zdCBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgdXJsOiBHT1RSVUVfVVJMLFxuICAgIHN0b3JhZ2VLZXk6IFNUT1JBR0VfS0VZLFxuICAgIGF1dG9SZWZyZXNoVG9rZW46IHRydWUsXG4gICAgcGVyc2lzdFNlc3Npb246IHRydWUsXG4gICAgZGV0ZWN0U2Vzc2lvbkluVXJsOiB0cnVlLFxuICAgIGhlYWRlcnM6IERFRkFVTFRfSEVBREVSUyxcbiAgICBmbG93VHlwZTogJ2ltcGxpY2l0JyxcbiAgICBkZWJ1ZzogZmFsc2UsXG4gICAgaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlcjogZmFsc2UsXG4gICAgdGhyb3dPbkVycm9yOiBmYWxzZSxcbiAgICBsb2NrQWNxdWlyZVRpbWVvdXQ6IDEwMDAwLCAvLyAxMCBzZWNvbmRzXG4gICAgc2tpcEF1dG9Jbml0aWFsaXplOiBmYWxzZSxcbn07XG5hc3luYyBmdW5jdGlvbiBsb2NrTm9PcChuYW1lLCBhY3F1aXJlVGltZW91dCwgZm4pIHtcbiAgICByZXR1cm4gYXdhaXQgZm4oKTtcbn1cbi8qKlxuICogQ2FjaGVzIEpXS1MgdmFsdWVzIGZvciBhbGwgY2xpZW50cyBjcmVhdGVkIGluIHRoZSBzYW1lIGVudmlyb25tZW50LiBUaGlzIGlzXG4gKiBlc3BlY2lhbGx5IHVzZWZ1bCBmb3Igc2hhcmVkLW1lbW9yeSBleGVjdXRpb24gZW52aXJvbm1lbnRzIHN1Y2ggYXMgVmVyY2VsJ3NcbiAqIEZsdWlkIENvbXB1dGUsIEFXUyBMYW1iZGEgb3IgU3VwYWJhc2UncyBFZGdlIEZ1bmN0aW9ucy4gUmVnYXJkbGVzcyBvZiBob3dcbiAqIG1hbnkgY2xpZW50cyBhcmUgY3JlYXRlZCwgaWYgdGhleSBzaGFyZSB0aGUgc2FtZSBzdG9yYWdlIGtleSB0aGV5IHdpbGwgdXNlXG4gKiB0aGUgc2FtZSBKV0tTIGNhY2hlLCBzaWduaWZpY2FudGx5IHNwZWVkaW5nIHVwIGdldENsYWltcygpIHdpdGggYXN5bW1ldHJpY1xuICogSldUcy5cbiAqL1xuY29uc3QgR0xPQkFMX0pXS1MgPSB7fTtcbmNsYXNzIEdvVHJ1ZUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogVGhlIEpXS1MgdXNlZCBmb3IgdmVyaWZ5aW5nIGFzeW1tZXRyaWMgSldUc1xuICAgICAqL1xuICAgIGdldCBqd2tzKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gR0xPQkFMX0pXS1NbdGhpcy5zdG9yYWdlS2V5XSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmp3a3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHsga2V5czogW10gfTtcbiAgICB9XG4gICAgc2V0IGp3a3ModmFsdWUpIHtcbiAgICAgICAgR0xPQkFMX0pXS1NbdGhpcy5zdG9yYWdlS2V5XSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgR0xPQkFMX0pXS1NbdGhpcy5zdG9yYWdlS2V5XSksIHsgandrczogdmFsdWUgfSk7XG4gICAgfVxuICAgIGdldCBqd2tzX2NhY2hlZF9hdCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IEdMT0JBTF9KV0tTW3RoaXMuc3RvcmFnZUtleV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWNoZWRBdCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgfVxuICAgIHNldCBqd2tzX2NhY2hlZF9hdCh2YWx1ZSkge1xuICAgICAgICBHTE9CQUxfSldLU1t0aGlzLnN0b3JhZ2VLZXldID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBHTE9CQUxfSldLU1t0aGlzLnN0b3JhZ2VLZXldKSwgeyBjYWNoZWRBdDogdmFsdWUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBjbGllbnQgZm9yIHVzZSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBpbXBvcnQgeyBHb1RydWVDbGllbnQgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAgICAgKlxuICAgICAqIGNvbnN0IGF1dGggPSBuZXcgR29UcnVlQ2xpZW50KHtcbiAgICAgKiAgIHVybDogJ2h0dHBzOi8veHl6Y29tcGFueS5zdXBhYmFzZS5jby9hdXRoL3YxJyxcbiAgICAgKiAgIGhlYWRlcnM6IHsgYXBpa2V5OiAncHVibGljLWFub24ta2V5JyB9LFxuICAgICAqICAgc3RvcmFnZUtleTogJ3N1cGFiYXNlLWF1dGgnLFxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXNlclN0b3JhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLm1lbW9yeVN0b3JhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuYXV0b1JlZnJlc2hUaWNrZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmF1dG9SZWZyZXNoVGlja1RpbWVvdXQgPSBudWxsO1xuICAgICAgICB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgYXN5bmMgY2xpZW50IGluaXRpYWxpemF0aW9uLlxuICAgICAgICAgKiBXaGVuIG51bGwgb3Igbm90IHlldCByZXNvbHZlZCB0aGUgYXV0aCBzdGF0ZSBpcyBgdW5rbm93bmBcbiAgICAgICAgICogT25jZSByZXNvbHZlZCB0aGUgYXV0aCBzdGF0ZSBpcyBrbm93biBhbmQgaXQncyBzYWZlIHRvIGNhbGwgYW55IGZ1cnRoZXIgY2xpZW50IG1ldGhvZHMuXG4gICAgICAgICAqIEtlZXAgZXh0cmEgY2FyZSB0byBuZXZlciByZWplY3Qgb3IgdGhyb3cgdW5jYXVnaHQgZXJyb3JzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluaXRpYWxpemVQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZXRlY3RTZXNzaW9uSW5VcmwgPSB0cnVlO1xuICAgICAgICB0aGlzLmhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdXBwcmVzc0dldFNlc3Npb25XYXJuaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9ja0FjcXVpcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGVuZGluZ0luTG9jayA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCB0byBicm9hZGNhc3Qgc3RhdGUgY2hhbmdlIGV2ZW50cyB0byBvdGhlciB0YWJzIGxpc3RlbmluZy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbCA9IG51bGw7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gY29uc29sZS5sb2c7XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMpLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5zdG9yYWdlS2V5ID0gc2V0dGluZ3Muc3RvcmFnZUtleTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZUlEID0gKF9hID0gR29UcnVlQ2xpZW50Lm5leHRJbnN0YW5jZUlEW3RoaXMuc3RvcmFnZUtleV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgIEdvVHJ1ZUNsaWVudC5uZXh0SW5zdGFuY2VJRFt0aGlzLnN0b3JhZ2VLZXldID0gdGhpcy5pbnN0YW5jZUlEICsgMTtcbiAgICAgICAgdGhpcy5sb2dEZWJ1Z01lc3NhZ2VzID0gISFzZXR0aW5ncy5kZWJ1ZztcbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5kZWJ1ZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIgPSBzZXR0aW5ncy5kZWJ1ZztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZUlEID4gMCAmJiBpc0Jyb3dzZXIoKSkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGAke3RoaXMuX2xvZ1ByZWZpeCgpfSBNdWx0aXBsZSBHb1RydWVDbGllbnQgaW5zdGFuY2VzIGRldGVjdGVkIGluIHRoZSBzYW1lIGJyb3dzZXIgY29udGV4dC4gSXQgaXMgbm90IGFuIGVycm9yLCBidXQgdGhpcyBzaG91bGQgYmUgYXZvaWRlZCBhcyBpdCBtYXkgcHJvZHVjZSB1bmRlZmluZWQgYmVoYXZpb3Igd2hlbiB1c2VkIGNvbmN1cnJlbnRseSB1bmRlciB0aGUgc2FtZSBzdG9yYWdlIGtleS5gO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKHRoaXMubG9nRGVidWdNZXNzYWdlcykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUudHJhY2UobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZXJzaXN0U2Vzc2lvbiA9IHNldHRpbmdzLnBlcnNpc3RTZXNzaW9uO1xuICAgICAgICB0aGlzLmF1dG9SZWZyZXNoVG9rZW4gPSBzZXR0aW5ncy5hdXRvUmVmcmVzaFRva2VuO1xuICAgICAgICB0aGlzLmFkbWluID0gbmV3IEdvVHJ1ZUFkbWluQXBpKHtcbiAgICAgICAgICAgIHVybDogc2V0dGluZ3MudXJsLFxuICAgICAgICAgICAgaGVhZGVyczogc2V0dGluZ3MuaGVhZGVycyxcbiAgICAgICAgICAgIGZldGNoOiBzZXR0aW5ncy5mZXRjaCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXJsID0gc2V0dGluZ3MudXJsO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBzZXR0aW5ncy5oZWFkZXJzO1xuICAgICAgICB0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKHNldHRpbmdzLmZldGNoKTtcbiAgICAgICAgdGhpcy5sb2NrID0gc2V0dGluZ3MubG9jayB8fCBsb2NrTm9PcDtcbiAgICAgICAgdGhpcy5kZXRlY3RTZXNzaW9uSW5VcmwgPSBzZXR0aW5ncy5kZXRlY3RTZXNzaW9uSW5Vcmw7XG4gICAgICAgIHRoaXMuZmxvd1R5cGUgPSBzZXR0aW5ncy5mbG93VHlwZTtcbiAgICAgICAgdGhpcy5oYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyID0gc2V0dGluZ3MuaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlcjtcbiAgICAgICAgdGhpcy50aHJvd09uRXJyb3IgPSBzZXR0aW5ncy50aHJvd09uRXJyb3I7XG4gICAgICAgIHRoaXMubG9ja0FjcXVpcmVUaW1lb3V0ID0gc2V0dGluZ3MubG9ja0FjcXVpcmVUaW1lb3V0O1xuICAgICAgICBpZiAoc2V0dGluZ3MubG9jaykge1xuICAgICAgICAgICAgdGhpcy5sb2NrID0gc2V0dGluZ3MubG9jaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnBlcnNpc3RTZXNzaW9uICYmIGlzQnJvd3NlcigpICYmICgoX2IgPSBnbG9iYWxUaGlzID09PSBudWxsIHx8IGdsb2JhbFRoaXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdsb2JhbFRoaXMubmF2aWdhdG9yKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubG9ja3MpKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2sgPSBuYXZpZ2F0b3JMb2NrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2NrID0gbG9ja05vT3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmp3a3MpIHtcbiAgICAgICAgICAgIHRoaXMuandrcyA9IHsga2V5czogW10gfTtcbiAgICAgICAgICAgIHRoaXMuandrc19jYWNoZWRfYXQgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1mYSA9IHtcbiAgICAgICAgICAgIHZlcmlmeTogdGhpcy5fdmVyaWZ5LmJpbmQodGhpcyksXG4gICAgICAgICAgICBlbnJvbGw6IHRoaXMuX2Vucm9sbC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgdW5lbnJvbGw6IHRoaXMuX3VuZW5yb2xsLmJpbmQodGhpcyksXG4gICAgICAgICAgICBjaGFsbGVuZ2U6IHRoaXMuX2NoYWxsZW5nZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgbGlzdEZhY3RvcnM6IHRoaXMuX2xpc3RGYWN0b3JzLmJpbmQodGhpcyksXG4gICAgICAgICAgICBjaGFsbGVuZ2VBbmRWZXJpZnk6IHRoaXMuX2NoYWxsZW5nZUFuZFZlcmlmeS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsOiB0aGlzLl9nZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWwuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHdlYmF1dGhuOiBuZXcgV2ViQXV0aG5BcGkodGhpcyksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub2F1dGggPSB7XG4gICAgICAgICAgICBnZXRBdXRob3JpemF0aW9uRGV0YWlsczogdGhpcy5fZ2V0QXV0aG9yaXphdGlvbkRldGFpbHMuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGFwcHJvdmVBdXRob3JpemF0aW9uOiB0aGlzLl9hcHByb3ZlQXV0aG9yaXphdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZGVueUF1dGhvcml6YXRpb246IHRoaXMuX2RlbnlBdXRob3JpemF0aW9uLmJpbmQodGhpcyksXG4gICAgICAgICAgICBsaXN0R3JhbnRzOiB0aGlzLl9saXN0T0F1dGhHcmFudHMuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHJldm9rZUdyYW50OiB0aGlzLl9yZXZva2VPQXV0aEdyYW50LmJpbmQodGhpcyksXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnBlcnNpc3RTZXNzaW9uKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Muc3RvcmFnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9IHNldHRpbmdzLnN0b3JhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPSBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVtb3J5U3RvcmFnZSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPSBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyKHRoaXMubWVtb3J5U3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLnVzZXJTdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51c2VyU3RvcmFnZSA9IHNldHRpbmdzLnVzZXJTdG9yYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tZW1vcnlTdG9yYWdlID0ge307XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPSBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyKHRoaXMubWVtb3J5U3RvcmFnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQnJvd3NlcigpICYmIGdsb2JhbFRoaXMuQnJvYWRjYXN0Q2hhbm5lbCAmJiB0aGlzLnBlcnNpc3RTZXNzaW9uICYmIHRoaXMuc3RvcmFnZUtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWwgPSBuZXcgZ2xvYmFsVGhpcy5Ccm9hZGNhc3RDaGFubmVsKHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgYSBuZXcgQnJvYWRjYXN0Q2hhbm5lbCwgbXVsdGktdGFiIHN0YXRlIGNoYW5nZXMgd2lsbCBub3QgYmUgYXZhaWxhYmxlJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2MgPSB0aGlzLmJyb2FkY2FzdENoYW5uZWwpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJ3JlY2VpdmVkIGJyb2FkY2FzdCBub3RpZmljYXRpb24gZnJvbSBvdGhlciB0YWIgb3IgY2xpZW50JywgZXZlbnQpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKGV2ZW50LmRhdGEuZXZlbnQsIGV2ZW50LmRhdGEuc2Vzc2lvbiwgZmFsc2UpOyAvLyBicm9hZGNhc3QgPSBmYWxzZSBzbyB3ZSBkb24ndCBnZXQgYW4gZW5kbGVzcyBsb29wIG9mIG1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI2Jyb2FkY2FzdENoYW5uZWwnLCAnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBhdXRvLWluaXRpYWxpemUgaWYgbm90IGV4cGxpY2l0bHkgZGlzYWJsZWQuIFNraXBwZWQgaW4gU1NSIGNvbnRleHRzXG4gICAgICAgIC8vIHdoZXJlIGluaXRpYWxpemF0aW9uIHRpbWluZyBtdXN0IGJlIGNvbnRyb2xsZWQuIEFsbCBwdWJsaWMgbWV0aG9kcyBoYXZlXG4gICAgICAgIC8vIGxhenkgaW5pdGlhbGl6YXRpb24sIHNvIHRoZSBjbGllbnQgcmVtYWlucyBmdWxseSBmdW5jdGlvbmFsLlxuICAgICAgICBpZiAoIXNldHRpbmdzLnNraXBBdXRvSW5pdGlhbGl6ZSkge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplKCkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNpbml0aWFsaXplKCknLCAnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgZXJyb3IgdGhyb3dpbmcgbW9kZSBpcyBlbmFibGVkIGZvciB0aGlzIGNsaWVudC5cbiAgICAgKi9cbiAgICBpc1Rocm93T25FcnJvckVuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRocm93T25FcnJvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2VudHJhbGl6ZXMgcmV0dXJuIGhhbmRsaW5nIHdpdGggb3B0aW9uYWwgZXJyb3IgdGhyb3dpbmcuIFdoZW4gYHRocm93T25FcnJvcmAgaXMgZW5hYmxlZFxuICAgICAqIGFuZCB0aGUgcHJvdmlkZWQgcmVzdWx0IGNvbnRhaW5zIGEgbm9uLW51bGxpc2ggZXJyb3IsIHRoZSBlcnJvciBpcyB0aHJvd24gaW5zdGVhZCBvZlxuICAgICAqIGJlaW5nIHJldHVybmVkLiBUaGlzIGVuc3VyZXMgY29uc2lzdGVudCBiZWhhdmlvciBhY3Jvc3MgYWxsIHB1YmxpYyBBUEkgbWV0aG9kcy5cbiAgICAgKi9cbiAgICBfcmV0dXJuUmVzdWx0KHJlc3VsdCkge1xuICAgICAgICBpZiAodGhpcy50aHJvd09uRXJyb3IgJiYgcmVzdWx0ICYmIHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIF9sb2dQcmVmaXgoKSB7XG4gICAgICAgIHJldHVybiAoJ0dvVHJ1ZUNsaWVudEAnICtcbiAgICAgICAgICAgIGAke3RoaXMuc3RvcmFnZUtleX06JHt0aGlzLmluc3RhbmNlSUR9ICgke3ZlcnNpb259KSAke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1gKTtcbiAgICB9XG4gICAgX2RlYnVnKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMubG9nRGVidWdNZXNzYWdlcykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIodGhpcy5fbG9nUHJlZml4KCksIC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgY2xpZW50IHNlc3Npb24gZWl0aGVyIGZyb20gdGhlIHVybCBvciBmcm9tIHN0b3JhZ2UuXG4gICAgICogVGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgd2hlbiBpbnN0YW50aWF0aW5nIHRoZSBjbGllbnQsIGJ1dCBzaG91bGQgYWxzbyBiZSBjYWxsZWRcbiAgICAgKiBtYW51YWxseSB3aGVuIGNoZWNraW5nIGZvciBhbiBlcnJvciBmcm9tIGFuIGF1dGggcmVkaXJlY3QgKG9hdXRoLCBtYWdpY2xpbmssIHBhc3N3b3JkIHJlY292ZXJ5LCBldGMpLlxuICAgICAqL1xuICAgIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemVQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRpYWxpemVQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9pbml0aWFsaXplKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElNUE9SVEFOVDpcbiAgICAgKiAxLiBOZXZlciB0aHJvdyBpbiB0aGlzIG1ldGhvZCwgYXMgaXQgaXMgY2FsbGVkIGZyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAgICogMi4gTmV2ZXIgcmV0dXJuIGEgc2Vzc2lvbiBmcm9tIHRoaXMgbWV0aG9kIGFzIGl0IHdvdWxkIGJlIGNhY2hlZCBvdmVyXG4gICAgICogICAgdGhlIHdob2xlIGxpZmV0aW1lIG9mIHRoZSBjbGllbnRcbiAgICAgKi9cbiAgICBhc3luYyBfaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgbGV0IGNhbGxiYWNrVXJsVHlwZSA9ICdub25lJztcbiAgICAgICAgICAgIGlmIChpc0Jyb3dzZXIoKSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IHBhcnNlUGFyYW1ldGVyc0Zyb21VUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0ltcGxpY2l0R3JhbnRDYWxsYmFjayhwYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrVXJsVHlwZSA9ICdpbXBsaWNpdCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGF3YWl0IHRoaXMuX2lzUEtDRUNhbGxiYWNrKHBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tVcmxUeXBlID0gJ3BrY2UnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXR0ZW1wdCB0byBnZXQgdGhlIHNlc3Npb24gZnJvbSB0aGUgVVJMIG9ubHkgaWYgdGhlc2UgY29uZGl0aW9ucyBhcmUgZnVsZmlsbGVkXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogTm90ZTogSWYgdGhlIFVSTCBpc24ndCBvbmUgb2YgdGhlIGNhbGxiYWNrIHVybCB0eXBlcyAoaW1wbGljaXQgb3IgcGtjZSksXG4gICAgICAgICAgICAgKiB0aGVuIHRoZXJlIGNvdWxkIGJlIGFuIGV4aXN0aW5nIHNlc3Npb24gc28gd2UgZG9uJ3Qgd2FudCB0byBwcmVtYXR1cmVseSByZW1vdmUgaXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGlzQnJvd3NlcigpICYmIHRoaXMuZGV0ZWN0U2Vzc2lvbkluVXJsICYmIGNhbGxiYWNrVXJsVHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fZ2V0U2Vzc2lvbkZyb21VUkwocGFyYW1zLCBjYWxsYmFja1VybFR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnZXJyb3IgZGV0ZWN0aW5nIHNlc3Npb24gZnJvbSBVUkwnLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IChfYSA9IGVycm9yLmRldGFpbHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yQ29kZSA9PT0gJ2lkZW50aXR5X2FscmVhZHlfZXhpc3RzJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9PT0gJ2lkZW50aXR5X25vdF9mb3VuZCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNvZGUgPT09ICdzaW5nbGVfaWRlbnRpdHlfbm90X2RlbGV0YWJsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvciB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHJlbW92ZSBleGlzdGluZyBzZXNzaW9uIG9uIFVSTCBsb2dpbiBmYWlsdXJlLlxuICAgICAgICAgICAgICAgICAgICAvLyBBIGZhaWxlZCBhdHRlbXB0IChlLmcuIHJldXNlZCBtYWdpYyBsaW5rKSBzaG91bGRuJ3QgaW52YWxpZGF0ZSBhIHZhbGlkIHNlc3Npb24uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2Vzc2lvbiwgcmVkaXJlY3RUeXBlIH0gPSBkYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2luaXRpYWxpemUoKScsICdkZXRlY3RlZCBzZXNzaW9uIGluIFVSTCcsIHNlc3Npb24sICdyZWRpcmVjdCB0eXBlJywgcmVkaXJlY3RUeXBlKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZGlyZWN0VHlwZSA9PT0gJ3JlY292ZXJ5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1BBU1NXT1JEX1JFQ09WRVJZJywgc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm8gbG9naW4gYXR0ZW1wdCB2aWEgY2FsbGJhY2sgdXJsIHRyeSB0byByZWNvdmVyIHNlc3Npb24gZnJvbSBzdG9yYWdlXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9yZWNvdmVyQW5kUmVmcmVzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHtcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEF1dGhVbmtub3duRXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3IgZHVyaW5nIGluaXRpYWxpemF0aW9uJywgZXJyb3IpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKCk7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBhbm9ueW1vdXMgdXNlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgc2Vzc2lvbiB3aGVyZSB0aGUgaXNfYW5vbnltb3VzIGNsYWltIGluIHRoZSBhY2Nlc3MgdG9rZW4gSldUIHNldCB0byB0cnVlXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkluQW5vbnltb3VzbHkoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9zaWdudXBgLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogKF9iID0gKF9hID0gY3JlZGVudGlhbHMgPT09IG51bGwgfHwgY3JlZGVudGlhbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogKF9jID0gY3JlZGVudGlhbHMgPT09IG51bGwgfHwgY3JlZGVudGlhbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXM7XG4gICAgICAgICAgICBpZiAoZXJyb3IgfHwgIWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBkYXRhLnNlc3Npb247XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gZGF0YS51c2VyO1xuICAgICAgICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIHNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlciwgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB1c2VyLlxuICAgICAqXG4gICAgICogQmUgYXdhcmUgdGhhdCBpZiBhIHVzZXIgYWNjb3VudCBleGlzdHMgaW4gdGhlIHN5c3RlbSB5b3UgbWF5IGdldCBiYWNrIGFuXG4gICAgICogZXJyb3IgbWVzc2FnZSB0aGF0IGF0dGVtcHRzIHRvIGhpZGUgdGhpcyBpbmZvcm1hdGlvbiBmcm9tIHRoZSB1c2VyLlxuICAgICAqIFRoaXMgbWV0aG9kIGhhcyBzdXBwb3J0IGZvciBQS0NFIHZpYSBlbWFpbCBzaWdudXBzLiBUaGUgUEtDRSBmbG93IGNhbm5vdCBiZSB1c2VkIHdoZW4gYXV0b2NvbmZpcm0gaXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbG9nZ2VkLWluIHNlc3Npb24gaWYgdGhlIHNlcnZlciBoYXMgXCJhdXRvY29uZmlybVwiIE9OXG4gICAgICogQHJldHVybnMgQSB1c2VyIGlmIHRoZSBzZXJ2ZXIgaGFzIFwiYXV0b2NvbmZpcm1cIiBPRkZcbiAgICAgKi9cbiAgICBhc3luYyBzaWduVXAoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcmVzO1xuICAgICAgICAgICAgaWYgKCdlbWFpbCcgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVtYWlsLCBwYXNzd29yZCwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3NpZ251cGAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZW1haWxSZWRpcmVjdFRvLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRhdGEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoJ3Bob25lJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGhvbmUsIHBhc3N3b3JkLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9zaWdudXBgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kYXRhKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWw6IChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jaGFubmVsKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnc21zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKCdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIgYW5kIGEgcGFzc3dvcmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlcztcbiAgICAgICAgICAgIGlmIChlcnJvciB8fCAhZGF0YSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGRhdGEuc2Vzc2lvbjtcbiAgICAgICAgICAgIGNvbnN0IHVzZXIgPSBkYXRhLnVzZXI7XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCk7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhbiBleGlzdGluZyB1c2VyIHdpdGggYW4gZW1haWwgYW5kIHBhc3N3b3JkIG9yIHBob25lIGFuZCBwYXNzd29yZC5cbiAgICAgKlxuICAgICAqIEJlIGF3YXJlIHRoYXQgeW91IG1heSBnZXQgYmFjayBhbiBlcnJvciBtZXNzYWdlIHRoYXQgd2lsbCBub3QgZGlzdGluZ3Vpc2hcbiAgICAgKiBiZXR3ZWVuIHRoZSBjYXNlcyB3aGVyZSB0aGUgYWNjb3VudCBkb2VzIG5vdCBleGlzdCBvciB0aGF0IHRoZVxuICAgICAqIGVtYWlsL3Bob25lIGFuZCBwYXNzd29yZCBjb21iaW5hdGlvbiBpcyB3cm9uZyBvciB0aGF0IHRoZSBhY2NvdW50IGNhbiBvbmx5XG4gICAgICogYmUgYWNjZXNzZWQgdmlhIHNvY2lhbCBsb2dpbi5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduSW5XaXRoUGFzc3dvcmQoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZXM7XG4gICAgICAgICAgICBpZiAoJ2VtYWlsJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1haWwsIHBhc3N3b3JkLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS90b2tlbj9ncmFudF90eXBlPXBhc3N3b3JkYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgncGhvbmUnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwaG9uZSwgcGFzc3dvcmQsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cGFzc3dvcmRgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2VQYXNzd29yZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGVtYWlsIG9yIHBob25lIG51bWJlciBhbmQgYSBwYXNzd29yZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFkYXRhIHx8ICFkYXRhLnNlc3Npb24gfHwgIWRhdGEudXNlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludmFsaWRUb2tlbkVycm9yID0gbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogaW52YWxpZFRva2VuRXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoe1xuICAgICAgICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oeyB1c2VyOiBkYXRhLnVzZXIsIHNlc3Npb246IGRhdGEuc2Vzc2lvbiB9LCAoZGF0YS53ZWFrX3Bhc3N3b3JkID8geyB3ZWFrUGFzc3dvcmQ6IGRhdGEud2Vha19wYXNzd29yZCB9IDogbnVsbCkpLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhbiBleGlzdGluZyB1c2VyIHZpYSBhIHRoaXJkLXBhcnR5IHByb3ZpZGVyLlxuICAgICAqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIHRoZSBQS0NFIGZsb3cuXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkluV2l0aE9BdXRoKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2hhbmRsZVByb3ZpZGVyU2lnbkluKGNyZWRlbnRpYWxzLnByb3ZpZGVyLCB7XG4gICAgICAgICAgICByZWRpcmVjdFRvOiAoX2EgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVkaXJlY3RUbyxcbiAgICAgICAgICAgIHNjb3BlczogKF9iID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNjb3BlcyxcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiAoX2MgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucXVlcnlQYXJhbXMsXG4gICAgICAgICAgICBza2lwQnJvd3NlclJlZGlyZWN0OiAoX2QgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc2tpcEJyb3dzZXJSZWRpcmVjdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhbiBleGlzdGluZyB1c2VyIGJ5IGV4Y2hhbmdpbmcgYW4gQXV0aCBDb2RlIGlzc3VlZCBkdXJpbmcgdGhlIFBLQ0UgZmxvdy5cbiAgICAgKi9cbiAgICBhc3luYyBleGNoYW5nZUNvZGVGb3JTZXNzaW9uKGF1dGhDb2RlKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4Y2hhbmdlQ29kZUZvclNlc3Npb24oYXV0aENvZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgaW4gYSB1c2VyIGJ5IHZlcmlmeWluZyBhIG1lc3NhZ2Ugc2lnbmVkIGJ5IHRoZSB1c2VyJ3MgcHJpdmF0ZSBrZXkuXG4gICAgICogU3VwcG9ydHMgRXRoZXJldW0gKHZpYSBTaWduLUluLVdpdGgtRXRoZXJldW0pICYgU29sYW5hIChTaWduLUluLVdpdGgtU29sYW5hKSBzdGFuZGFyZHMsXG4gICAgICogYm90aCBvZiB3aGljaCBkZXJpdmUgZnJvbSB0aGUgRUlQLTQzNjEgc3RhbmRhcmRcbiAgICAgKiBXaXRoIHNsaWdodCB2YXJpYXRpb24gb24gU29sYW5hJ3Mgc2lkZS5cbiAgICAgKiBAcmVmZXJlbmNlIGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNDM2MVxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25JbldpdGhXZWIzKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IHsgY2hhaW4gfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICBzd2l0Y2ggKGNoYWluKSB7XG4gICAgICAgICAgICBjYXNlICdldGhlcmV1bSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2lnbkluV2l0aEV0aGVyZXVtKGNyZWRlbnRpYWxzKTtcbiAgICAgICAgICAgIGNhc2UgJ3NvbGFuYSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2lnbkluV2l0aFNvbGFuYShjcmVkZW50aWFscyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IFVuc3VwcG9ydGVkIGNoYWluIFwiJHtjaGFpbn1cImApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNpZ25JbldpdGhFdGhlcmV1bShjcmVkZW50aWFscykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sO1xuICAgICAgICAvLyBUT0RPOiBmbGF0dGVuIHR5cGVcbiAgICAgICAgbGV0IG1lc3NhZ2U7XG4gICAgICAgIGxldCBzaWduYXR1cmU7XG4gICAgICAgIGlmICgnbWVzc2FnZScgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBjcmVkZW50aWFscy5tZXNzYWdlO1xuICAgICAgICAgICAgc2lnbmF0dXJlID0gY3JlZGVudGlhbHMuc2lnbmF0dXJlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBjaGFpbiwgd2FsbGV0LCBzdGF0ZW1lbnQsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgbGV0IHJlc29sdmVkV2FsbGV0O1xuICAgICAgICAgICAgaWYgKCFpc0Jyb3dzZXIoKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2FsbGV0ICE9PSAnb2JqZWN0JyB8fCAhKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy51cmwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQHN1cGFiYXNlL2F1dGgtanM6IEJvdGggd2FsbGV0IGFuZCB1cmwgbXVzdCBiZSBzcGVjaWZpZWQgaW4gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlZFdhbGxldCA9IHdhbGxldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB3YWxsZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRXYWxsZXQgPSB3YWxsZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3aW5kb3dBbnkgPSB3aW5kb3c7XG4gICAgICAgICAgICAgICAgaWYgKCdldGhlcmV1bScgaW4gd2luZG93QW55ICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB3aW5kb3dBbnkuZXRoZXJldW0gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgICdyZXF1ZXN0JyBpbiB3aW5kb3dBbnkuZXRoZXJldW0gJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHdpbmRvd0FueS5ldGhlcmV1bS5yZXF1ZXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkV2FsbGV0ID0gd2luZG93QW55LmV0aGVyZXVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogTm8gY29tcGF0aWJsZSBFdGhlcmV1bSB3YWxsZXQgaW50ZXJmYWNlIG9uIHRoZSB3aW5kb3cgb2JqZWN0ICh3aW5kb3cuZXRoZXJldW0pIGRldGVjdGVkLiBNYWtlIHN1cmUgdGhlIHVzZXIgYWxyZWFkeSBoYXMgYSB3YWxsZXQgaW5zdGFsbGVkIGFuZCBjb25uZWN0ZWQgZm9yIHRoaXMgYXBwLiBQcmVmZXIgcGFzc2luZyB0aGUgd2FsbGV0IGludGVyZmFjZSBvYmplY3QgZGlyZWN0bHkgdG8gc2lnbkluV2l0aFdlYjMoeyBjaGFpbjogJ2V0aGVyZXVtJywgd2FsbGV0OiByZXNvbHZlZFVzZXJXYWxsZXQgfSkgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy51cmwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgcmVzb2x2ZWRXYWxsZXRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX3JlcXVlc3RBY2NvdW50cycsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChhY2NzKSA9PiBhY2NzKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogV2FsbGV0IG1ldGhvZCBldGhfcmVxdWVzdEFjY291bnRzIGlzIG1pc3Npbmcgb3IgaW52YWxpZGApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWFjY291bnRzIHx8IGFjY291bnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IE5vIGFjY291bnRzIGF2YWlsYWJsZS4gUGxlYXNlIGVuc3VyZSB0aGUgd2FsbGV0IGlzIGNvbm5lY3RlZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBnZXRBZGRyZXNzKGFjY291bnRzWzBdKTtcbiAgICAgICAgICAgIGxldCBjaGFpbklkID0gKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhFdGhlcmV1bSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNoYWluSWQ7XG4gICAgICAgICAgICBpZiAoIWNoYWluSWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFpbklkSGV4ID0gYXdhaXQgcmVzb2x2ZWRXYWxsZXQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9jaGFpbklkJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjaGFpbklkID0gZnJvbUhleChjaGFpbklkSGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNpd2VNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGRvbWFpbjogdXJsLmhvc3QsXG4gICAgICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnQ6IHN0YXRlbWVudCxcbiAgICAgICAgICAgICAgICB1cmk6IHVybC5ocmVmLFxuICAgICAgICAgICAgICAgIHZlcnNpb246ICcxJyxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiBjaGFpbklkLFxuICAgICAgICAgICAgICAgIG5vbmNlOiAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aEV0aGVyZXVtKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Mubm9uY2UsXG4gICAgICAgICAgICAgICAgaXNzdWVkQXQ6IChfZSA9IChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoRXRoZXJldW0pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5pc3N1ZWRBdCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICBleHBpcmF0aW9uVGltZTogKF9mID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhFdGhlcmV1bSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmV4cGlyYXRpb25UaW1lLFxuICAgICAgICAgICAgICAgIG5vdEJlZm9yZTogKF9nID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhFdGhlcmV1bSkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLm5vdEJlZm9yZSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IChfaCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoRXRoZXJldW0pID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5yZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VzOiAoX2ogPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aEV0aGVyZXVtKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2oucmVzb3VyY2VzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBjcmVhdGVTaXdlTWVzc2FnZShzaXdlTWVzc2FnZSk7XG4gICAgICAgICAgICAvLyBTaWduIG1lc3NhZ2VcbiAgICAgICAgICAgIHNpZ25hdHVyZSA9IChhd2FpdCByZXNvbHZlZFdhbGxldC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdwZXJzb25hbF9zaWduJyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFt0b0hleChtZXNzYWdlKSwgYWRkcmVzc10sXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9d2ViM2AsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogT2JqZWN0LmFzc2lnbih7IGNoYWluOiAnZXRoZXJldW0nLCBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUgfSwgKCgoX2sgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2suY2FwdGNoYVRva2VuKVxuICAgICAgICAgICAgICAgICAgICA/IHsgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogKF9sID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sLmNhcHRjaGFUb2tlbiB9IH1cbiAgICAgICAgICAgICAgICAgICAgOiBudWxsKSksXG4gICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLnNlc3Npb24gfHwgIWRhdGEudXNlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludmFsaWRUb2tlbkVycm9yID0gbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogaW52YWxpZFRva2VuRXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBkYXRhKSwgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNpZ25JbldpdGhTb2xhbmEoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX207XG4gICAgICAgIGxldCBtZXNzYWdlO1xuICAgICAgICBsZXQgc2lnbmF0dXJlO1xuICAgICAgICBpZiAoJ21lc3NhZ2UnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gY3JlZGVudGlhbHMubWVzc2FnZTtcbiAgICAgICAgICAgIHNpZ25hdHVyZSA9IGNyZWRlbnRpYWxzLnNpZ25hdHVyZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhaW4sIHdhbGxldCwgc3RhdGVtZW50LCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgIGxldCByZXNvbHZlZFdhbGxldDtcbiAgICAgICAgICAgIGlmICghaXNCcm93c2VyKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdhbGxldCAhPT0gJ29iamVjdCcgfHwgIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudXJsKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0BzdXBhYmFzZS9hdXRoLWpzOiBCb3RoIHdhbGxldCBhbmQgdXJsIG11c3QgYmUgc3BlY2lmaWVkIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50cy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRXYWxsZXQgPSB3YWxsZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygd2FsbGV0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkV2FsbGV0ID0gd2FsbGV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2luZG93QW55ID0gd2luZG93O1xuICAgICAgICAgICAgICAgIGlmICgnc29sYW5hJyBpbiB3aW5kb3dBbnkgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHdpbmRvd0FueS5zb2xhbmEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgICgoJ3NpZ25JbicgaW4gd2luZG93QW55LnNvbGFuYSAmJiB0eXBlb2Ygd2luZG93QW55LnNvbGFuYS5zaWduSW4gPT09ICdmdW5jdGlvbicpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoJ3NpZ25NZXNzYWdlJyBpbiB3aW5kb3dBbnkuc29sYW5hICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHdpbmRvd0FueS5zb2xhbmEuc2lnbk1lc3NhZ2UgPT09ICdmdW5jdGlvbicpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFdhbGxldCA9IHdpbmRvd0FueS5zb2xhbmE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBObyBjb21wYXRpYmxlIFNvbGFuYSB3YWxsZXQgaW50ZXJmYWNlIG9uIHRoZSB3aW5kb3cgb2JqZWN0ICh3aW5kb3cuc29sYW5hKSBkZXRlY3RlZC4gTWFrZSBzdXJlIHRoZSB1c2VyIGFscmVhZHkgaGFzIGEgd2FsbGV0IGluc3RhbGxlZCBhbmQgY29ubmVjdGVkIGZvciB0aGlzIGFwcC4gUHJlZmVyIHBhc3NpbmcgdGhlIHdhbGxldCBpbnRlcmZhY2Ugb2JqZWN0IGRpcmVjdGx5IHRvIHNpZ25JbldpdGhXZWIzKHsgY2hhaW46ICdzb2xhbmEnLCB3YWxsZXQ6IHJlc29sdmVkVXNlcldhbGxldCB9KSBpbnN0ZWFkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnVybCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgaWYgKCdzaWduSW4nIGluIHJlc29sdmVkV2FsbGV0ICYmIHJlc29sdmVkV2FsbGV0LnNpZ25Jbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHJlc29sdmVkV2FsbGV0LnNpZ25JbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGlzc3VlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhTb2xhbmEpLCB7IFxuICAgICAgICAgICAgICAgICAgICAvLyBub24tb3ZlcnJpZGFibGUgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiAnMScsIGRvbWFpbjogdXJsLmhvc3QsIHVyaTogdXJsLmhyZWYgfSksIChzdGF0ZW1lbnQgPyB7IHN0YXRlbWVudCB9IDogbnVsbCkpKTtcbiAgICAgICAgICAgICAgICBsZXQgb3V0cHV0VG9Qcm9jZXNzO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG91dHB1dCkgJiYgb3V0cHV0WzBdICYmIHR5cGVvZiBvdXRwdXRbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFRvUHJvY2VzcyA9IG91dHB1dFswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3V0cHV0ICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBvdXRwdXQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgICdzaWduZWRNZXNzYWdlJyBpbiBvdXRwdXQgJiZcbiAgICAgICAgICAgICAgICAgICAgJ3NpZ25hdHVyZScgaW4gb3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFRvUHJvY2VzcyA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQHN1cGFiYXNlL2F1dGgtanM6IFdhbGxldCBtZXRob2Qgc2lnbkluKCkgcmV0dXJuZWQgdW5yZWNvZ25pemVkIHZhbHVlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgnc2lnbmVkTWVzc2FnZScgaW4gb3V0cHV0VG9Qcm9jZXNzICYmXG4gICAgICAgICAgICAgICAgICAgICdzaWduYXR1cmUnIGluIG91dHB1dFRvUHJvY2VzcyAmJlxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIG91dHB1dFRvUHJvY2Vzcy5zaWduZWRNZXNzYWdlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0VG9Qcm9jZXNzLnNpZ25lZE1lc3NhZ2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSAmJlxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRUb1Byb2Nlc3Muc2lnbmF0dXJlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBvdXRwdXRUb1Byb2Nlc3Muc2lnbmVkTWVzc2FnZSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG91dHB1dFRvUHJvY2Vzcy5zaWduZWRNZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUob3V0cHV0VG9Qcm9jZXNzLnNpZ25lZE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUgPSBvdXRwdXRUb1Byb2Nlc3Muc2lnbmF0dXJlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdAc3VwYWJhc2UvYXV0aC1qczogV2FsbGV0IG1ldGhvZCBzaWduSW4oKSBBUEkgcmV0dXJuZWQgb2JqZWN0IHdpdGhvdXQgc2lnbmVkTWVzc2FnZSBhbmQgc2lnbmF0dXJlIGZpZWxkcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghKCdzaWduTWVzc2FnZScgaW4gcmVzb2x2ZWRXYWxsZXQpIHx8XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiByZXNvbHZlZFdhbGxldC5zaWduTWVzc2FnZSAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgICAgICAgICAhKCdwdWJsaWNLZXknIGluIHJlc29sdmVkV2FsbGV0KSB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcmVzb2x2ZWRXYWxsZXQgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgICAgICFyZXNvbHZlZFdhbGxldC5wdWJsaWNLZXkgfHxcbiAgICAgICAgICAgICAgICAgICAgISgndG9CYXNlNTgnIGluIHJlc29sdmVkV2FsbGV0LnB1YmxpY0tleSkgfHxcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlc29sdmVkV2FsbGV0LnB1YmxpY0tleS50b0Jhc2U1OCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0BzdXBhYmFzZS9hdXRoLWpzOiBXYWxsZXQgZG9lcyBub3QgaGF2ZSBhIGNvbXBhdGlibGUgc2lnbk1lc3NhZ2UoKSBhbmQgcHVibGljS2V5LnRvQmFzZTU4KCkgQVBJJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBbXG4gICAgICAgICAgICAgICAgICAgIGAke3VybC5ob3N0fSB3YW50cyB5b3UgdG8gc2lnbiBpbiB3aXRoIHlvdXIgU29sYW5hIGFjY291bnQ6YCxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRXYWxsZXQucHVibGljS2V5LnRvQmFzZTU4KCksXG4gICAgICAgICAgICAgICAgICAgIC4uLihzdGF0ZW1lbnQgPyBbJycsIHN0YXRlbWVudCwgJyddIDogWycnXSksXG4gICAgICAgICAgICAgICAgICAgICdWZXJzaW9uOiAxJyxcbiAgICAgICAgICAgICAgICAgICAgYFVSSTogJHt1cmwuaHJlZn1gLFxuICAgICAgICAgICAgICAgICAgICBgSXNzdWVkIEF0OiAkeyhfYyA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoU29sYW5hKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaXNzdWVkQXQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1gLFxuICAgICAgICAgICAgICAgICAgICAuLi4oKChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoU29sYW5hKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Qubm90QmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBbYE5vdCBCZWZvcmU6ICR7b3B0aW9ucy5zaWduSW5XaXRoU29sYW5hLm5vdEJlZm9yZX1gXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbXSksXG4gICAgICAgICAgICAgICAgICAgIC4uLigoKF9lID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhTb2xhbmEpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5leHBpcmF0aW9uVGltZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gW2BFeHBpcmF0aW9uIFRpbWU6ICR7b3B0aW9ucy5zaWduSW5XaXRoU29sYW5hLmV4cGlyYXRpb25UaW1lfWBdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uKCgoX2YgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aFNvbGFuYSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNoYWluSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtgQ2hhaW4gSUQ6ICR7b3B0aW9ucy5zaWduSW5XaXRoU29sYW5hLmNoYWluSWR9YF1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogW10pLFxuICAgICAgICAgICAgICAgICAgICAuLi4oKChfZyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoU29sYW5hKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cubm9uY2UpID8gW2BOb25jZTogJHtvcHRpb25zLnNpZ25JbldpdGhTb2xhbmEubm9uY2V9YF0gOiBbXSksXG4gICAgICAgICAgICAgICAgICAgIC4uLigoKF9oID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhTb2xhbmEpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5yZXF1ZXN0SWQpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtgUmVxdWVzdCBJRDogJHtvcHRpb25zLnNpZ25JbldpdGhTb2xhbmEucmVxdWVzdElkfWBdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uKCgoX2sgPSAoX2ogPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aFNvbGFuYSkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLnJlc291cmNlcykgPT09IG51bGwgfHwgX2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdSZXNvdXJjZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMuc2lnbkluV2l0aFNvbGFuYS5yZXNvdXJjZXMubWFwKChyZXNvdXJjZSkgPT4gYC0gJHtyZXNvdXJjZX1gKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogW10pLFxuICAgICAgICAgICAgICAgIF0uam9pbignXFxuJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF5YmVTaWduYXR1cmUgPSBhd2FpdCByZXNvbHZlZFdhbGxldC5zaWduTWVzc2FnZShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUobWVzc2FnZSksICd1dGY4Jyk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXliZVNpZ25hdHVyZSB8fCAhKG1heWJlU2lnbmF0dXJlIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdAc3VwYWJhc2UvYXV0aC1qczogV2FsbGV0IHNpZ25NZXNzYWdlKCkgQVBJIHJldHVybmVkIGFuIHJlY29nbml6ZWQgdmFsdWUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlID0gbWF5YmVTaWduYXR1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9d2ViM2AsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogT2JqZWN0LmFzc2lnbih7IGNoYWluOiAnc29sYW5hJywgbWVzc2FnZSwgc2lnbmF0dXJlOiBieXRlc1RvQmFzZTY0VVJMKHNpZ25hdHVyZSkgfSwgKCgoX2wgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2wuY2FwdGNoYVRva2VuKVxuICAgICAgICAgICAgICAgICAgICA/IHsgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogKF9tID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX20gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tLmNhcHRjaGFUb2tlbiB9IH1cbiAgICAgICAgICAgICAgICAgICAgOiBudWxsKSksXG4gICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLnNlc3Npb24gfHwgIWRhdGEudXNlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludmFsaWRUb2tlbkVycm9yID0gbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogaW52YWxpZFRva2VuRXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBkYXRhKSwgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9leGNoYW5nZUNvZGVGb3JTZXNzaW9uKGF1dGhDb2RlKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VJdGVtID0gYXdhaXQgZ2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCk7XG4gICAgICAgIGNvbnN0IFtjb2RlVmVyaWZpZXIsIHJlZGlyZWN0VHlwZV0gPSAoc3RvcmFnZUl0ZW0gIT09IG51bGwgJiYgc3RvcmFnZUl0ZW0gIT09IHZvaWQgMCA/IHN0b3JhZ2VJdGVtIDogJycpLnNwbGl0KCcvJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWNvZGVWZXJpZmllciAmJiB0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aFBLQ0VDb2RlVmVyaWZpZXJNaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cGtjZWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBhdXRoX2NvZGU6IGF1dGhDb2RlLFxuICAgICAgICAgICAgICAgICAgICBjb2RlX3ZlcmlmaWVyOiBjb2RlVmVyaWZpZXIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5zZXNzaW9uIHx8ICFkYXRhLnVzZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnZhbGlkVG9rZW5FcnJvciA9IG5ldyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIHJlZGlyZWN0VHlwZTogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogaW52YWxpZFRva2VuRXJyb3IsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEpLCB7IHJlZGlyZWN0VHlwZTogcmVkaXJlY3RUeXBlICE9PSBudWxsICYmIHJlZGlyZWN0VHlwZSAhPT0gdm9pZCAwID8gcmVkaXJlY3RUeXBlIDogbnVsbCB9KSwgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKTtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsLCByZWRpcmVjdFR5cGU6IG51bGwgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3Mgc2lnbmluZyBpbiB3aXRoIGFuIE9JREMgSUQgdG9rZW4uIFRoZSBhdXRoZW50aWNhdGlvbiBwcm92aWRlciB1c2VkXG4gICAgICogc2hvdWxkIGJlIGVuYWJsZWQgYW5kIGNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkluV2l0aElkVG9rZW4oY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb3B0aW9ucywgcHJvdmlkZXIsIHRva2VuLCBhY2Nlc3NfdG9rZW4sIG5vbmNlIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9aWRfdG9rZW5gLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICAgIGlkX3Rva2VuOiB0b2tlbixcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlcztcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZGF0YSB8fCAhZGF0YS5zZXNzaW9uIHx8ICFkYXRhLnVzZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnZhbGlkVG9rZW5FcnJvciA9IG5ldyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IGludmFsaWRUb2tlbkVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YSwgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgbWFnaWNsaW5rIG9yIGEgb25lLXRpbWUgcGFzc3dvcmQgKE9UUCkuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgYHt7IC5Db25maXJtYXRpb25VUkwgfX1gIHZhcmlhYmxlIGlzIHNwZWNpZmllZCBpbiB0aGUgZW1haWwgdGVtcGxhdGUsIGEgbWFnaWNsaW5rIHdpbGwgYmUgc2VudC5cbiAgICAgKiBJZiB0aGUgYHt7IC5Ub2tlbiB9fWAgdmFyaWFibGUgaXMgc3BlY2lmaWVkIGluIHRoZSBlbWFpbCB0ZW1wbGF0ZSwgYW4gT1RQIHdpbGwgYmUgc2VudC5cbiAgICAgKiBJZiB5b3UncmUgdXNpbmcgcGhvbmUgc2lnbi1pbnMsIG9ubHkgYW4gT1RQIHdpbGwgYmUgc2VudC4gWW91IHdvbid0IGJlIGFibGUgdG8gc2VuZCBhIG1hZ2ljbGluayBmb3IgcGhvbmUgc2lnbi1pbnMuXG4gICAgICpcbiAgICAgKiBCZSBhd2FyZSB0aGF0IHlvdSBtYXkgZ2V0IGJhY2sgYW4gZXJyb3IgbWVzc2FnZSB0aGF0IHdpbGwgbm90IGRpc3Rpbmd1aXNoXG4gICAgICogYmV0d2VlbiB0aGUgY2FzZXMgd2hlcmUgdGhlIGFjY291bnQgZG9lcyBub3QgZXhpc3Qgb3IsIHRoYXQgdGhlIGFjY291bnRcbiAgICAgKiBjYW4gb25seSBiZSBhY2Nlc3NlZCB2aWEgc29jaWFsIGxvZ2luLlxuICAgICAqXG4gICAgICogRG8gbm90ZSB0aGF0IHlvdSB3aWxsIG5lZWQgdG8gY29uZmlndXJlIGEgV2hhdHNhcHAgc2VuZGVyIG9uIFR3aWxpb1xuICAgICAqIGlmIHlvdSBhcmUgdXNpbmcgcGhvbmUgc2lnbiBpbiB3aXRoIHRoZSAnd2hhdHNhcHAnIGNoYW5uZWwuIFRoZSB3aGF0c2FwcFxuICAgICAqIGNoYW5uZWwgaXMgbm90IHN1cHBvcnRlZCBvbiBvdGhlciBwcm92aWRlcnNcbiAgICAgKiBhdCB0aGlzIHRpbWUuXG4gICAgICogVGhpcyBtZXRob2Qgc3VwcG9ydHMgUEtDRSB3aGVuIGFuIGVtYWlsIGlzIHBhc3NlZC5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduSW5XaXRoT3RwKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoJ2VtYWlsJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1haWwsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgY29kZUNoYWxsZW5nZU1ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIFtjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0IGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QodGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9vdHBgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1haWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGF0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVfdXNlcjogKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNob3VsZENyZWF0ZVVzZXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlX2NoYWxsZW5nZTogY29kZUNoYWxsZW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogY29kZUNoYWxsZW5nZU1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVtYWlsUmVkaXJlY3RUbyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdwaG9uZScgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBob25lLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9vdHBgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGF0YSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVfdXNlcjogKF9kID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNob3VsZENyZWF0ZVVzZXIpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsOiAoX2UgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2hhbm5lbCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogJ3NtcycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCwgbWVzc2FnZUlkOiBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEubWVzc2FnZV9pZCB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGVtYWlsIG9yIHBob25lIG51bWJlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2cgaW4gYSB1c2VyIGdpdmVuIGEgVXNlciBzdXBwbGllZCBPVFAgb3IgVG9rZW5IYXNoIHJlY2VpdmVkIHRocm91Z2ggbW9iaWxlIG9yIGVtYWlsLlxuICAgICAqL1xuICAgIGFzeW5jIHZlcmlmeU90cChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZWRpcmVjdFRvID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IGNhcHRjaGFUb2tlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICgnb3B0aW9ucycgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgcmVkaXJlY3RUbyA9IChfYSA9IHBhcmFtcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVkaXJlY3RUbztcbiAgICAgICAgICAgICAgICBjYXB0Y2hhVG9rZW4gPSAoX2IgPSBwYXJhbXMub3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhcHRjaGFUb2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3ZlcmlmeWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCB7IGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IGNhcHRjaGFUb2tlbiB9IH0pLFxuICAgICAgICAgICAgICAgIHJlZGlyZWN0VG8sXG4gICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5WZXJpZmljYXRpb25FcnJvciA9IG5ldyBFcnJvcignQW4gZXJyb3Igb2NjdXJyZWQgb24gdG9rZW4gdmVyaWZpY2F0aW9uLicpO1xuICAgICAgICAgICAgICAgIHRocm93IHRva2VuVmVyaWZpY2F0aW9uRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gZGF0YS5zZXNzaW9uO1xuICAgICAgICAgICAgY29uc3QgdXNlciA9IGRhdGEudXNlcjtcbiAgICAgICAgICAgIGlmIChzZXNzaW9uID09PSBudWxsIHx8IHNlc3Npb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb24uYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMocGFyYW1zLnR5cGUgPT0gJ3JlY292ZXJ5JyA/ICdQQVNTV09SRF9SRUNPVkVSWScgOiAnU0lHTkVEX0lOJywgc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyBhIHNpbmdsZS1zaWduIG9uIHVzaW5nIGFuIGVudGVycHJpc2UgSWRlbnRpdHkgUHJvdmlkZXIuIEFcbiAgICAgKiBzdWNjZXNzZnVsIFNTTyBhdHRlbXB0IHdpbGwgcmVkaXJlY3QgdGhlIGN1cnJlbnQgcGFnZSB0byB0aGUgaWRlbnRpdHlcbiAgICAgKiBwcm92aWRlciBhdXRob3JpemF0aW9uIHBhZ2UuIFRoZSByZWRpcmVjdCBVUkwgaXMgaW1wbGVtZW50YXRpb24gYW5kIFNTT1xuICAgICAqIHByb3RvY29sIHNwZWNpZmljLlxuICAgICAqXG4gICAgICogWW91IGNhbiB1c2UgaXQgYnkgcHJvdmlkaW5nIGEgU1NPIGRvbWFpbi4gVHlwaWNhbGx5IHlvdSBjYW4gZXh0cmFjdCB0aGlzXG4gICAgICogZG9tYWluIGJ5IGFza2luZyB1c2VycyBmb3IgdGhlaXIgZW1haWwgYWRkcmVzcy4gSWYgdGhpcyBkb21haW4gaXNcbiAgICAgKiByZWdpc3RlcmVkIG9uIHRoZSBBdXRoIGluc3RhbmNlIHRoZSByZWRpcmVjdCB3aWxsIHVzZSB0aGF0IG9yZ2FuaXphdGlvbidzXG4gICAgICogY3VycmVudGx5IGFjdGl2ZSBTU08gSWRlbnRpdHkgUHJvdmlkZXIgZm9yIHRoZSBsb2dpbi5cbiAgICAgKlxuICAgICAqIElmIHlvdSBoYXZlIGJ1aWx0IGFuIG9yZ2FuaXphdGlvbi1zcGVjaWZpYyBsb2dpbiBwYWdlLCB5b3UgY2FuIHVzZSB0aGVcbiAgICAgKiBvcmdhbml6YXRpb24ncyBTU08gSWRlbnRpdHkgUHJvdmlkZXIgVVVJRCBkaXJlY3RseSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25JbldpdGhTU08ocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgY29kZUNoYWxsZW5nZSA9IG51bGw7XG4gICAgICAgICAgICBsZXQgY29kZUNoYWxsZW5nZU1ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIFtjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0IGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QodGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vc3NvYCwge1xuICAgICAgICAgICAgICAgIGJvZHk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKCdwcm92aWRlcklkJyBpbiBwYXJhbXMgPyB7IHByb3ZpZGVyX2lkOiBwYXJhbXMucHJvdmlkZXJJZCB9IDogbnVsbCkpLCAoJ2RvbWFpbicgaW4gcGFyYW1zID8geyBkb21haW46IHBhcmFtcy5kb21haW4gfSA6IG51bGwpKSwgeyByZWRpcmVjdF90bzogKF9iID0gKF9hID0gcGFyYW1zLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWRpcmVjdFRvKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB1bmRlZmluZWQgfSksICgoKF9jID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLm9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYXB0Y2hhVG9rZW4pXG4gICAgICAgICAgICAgICAgICAgID8geyBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBwYXJhbXMub3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSB9XG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCkpLCB7IHNraXBfaHR0cF9yZWRpcmVjdDogdHJ1ZSwgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogY29kZUNoYWxsZW5nZU1ldGhvZCB9KSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IF9zc29SZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQXV0b21hdGljYWxseSByZWRpcmVjdCBpbiBicm93c2VyIHVubGVzcyBza2lwQnJvd3NlclJlZGlyZWN0IGlzIHRydWVcbiAgICAgICAgICAgIGlmICgoKF9kID0gcmVzdWx0LmRhdGEpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC51cmwpICYmIGlzQnJvd3NlcigpICYmICEoKF9lID0gcGFyYW1zLm9wdGlvbnMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5za2lwQnJvd3NlclJlZGlyZWN0KSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24ocmVzdWx0LmRhdGEudXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgcmVhdXRoZW50aWNhdGlvbiBPVFAgdG8gdGhlIHVzZXIncyBlbWFpbCBvciBwaG9uZSBudW1iZXIuXG4gICAgICogUmVxdWlyZXMgdGhlIHVzZXIgdG8gYmUgc2lnbmVkLWluLlxuICAgICAqL1xuICAgIGFzeW5jIHJlYXV0aGVudGljYXRlKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2sodGhpcy5sb2NrQWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9yZWF1dGhlbnRpY2F0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3JlYXV0aGVudGljYXRlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yOiBzZXNzaW9uRXJyb3IsIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgc2Vzc2lvbkVycm9yO1xuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS9yZWF1dGhlbnRpY2F0ZWAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IHNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZW5kcyBhbiBleGlzdGluZyBzaWdudXAgY29uZmlybWF0aW9uIGVtYWlsLCBlbWFpbCBjaGFuZ2UgZW1haWwsIFNNUyBPVFAgb3IgcGhvbmUgY2hhbmdlIE9UUC5cbiAgICAgKi9cbiAgICBhc3luYyByZXNlbmQoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dGhpcy51cmx9L3Jlc2VuZGA7XG4gICAgICAgICAgICBpZiAoJ2VtYWlsJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1haWwsIHR5cGUsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgZW5kcG9pbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5lbWFpbFJlZGlyZWN0VG8sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCdwaG9uZScgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBob25lLCB0eXBlLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGVuZHBvaW50LCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIG1lc3NhZ2VJZDogZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLm1lc3NhZ2VfaWQgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKCdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIgYW5kIGEgdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzZXNzaW9uLCByZWZyZXNoaW5nIGl0IGlmIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIFRoZSBzZXNzaW9uIHJldHVybmVkIGNhbiBiZSBudWxsIGlmIHRoZSBzZXNzaW9uIGlzIG5vdCBkZXRlY3RlZCB3aGljaCBjYW4gaGFwcGVuIGluIHRoZSBldmVudCBhIHVzZXIgaXMgbm90IHNpZ25lZC1pbiBvciBoYXMgbG9nZ2VkIG91dC5cbiAgICAgKlxuICAgICAqICoqSU1QT1JUQU5UOioqIFRoaXMgbWV0aG9kIGxvYWRzIHZhbHVlcyBkaXJlY3RseSBmcm9tIHRoZSBzdG9yYWdlIGF0dGFjaGVkXG4gICAgICogdG8gdGhlIGNsaWVudC4gSWYgdGhhdCBzdG9yYWdlIGlzIGJhc2VkIG9uIHJlcXVlc3QgY29va2llcyBmb3IgZXhhbXBsZSxcbiAgICAgKiB0aGUgdmFsdWVzIGluIGl0IG1heSBub3QgYmUgYXV0aGVudGljIGFuZCB0aGVyZWZvcmUgaXQncyBzdHJvbmdseSBhZHZpc2VkXG4gICAgICogYWdhaW5zdCB1c2luZyB0aGlzIG1ldGhvZCBhbmQgaXRzIHJlc3VsdHMgaW4gc3VjaCBjaXJjdW1zdGFuY2VzLiBBIHdhcm5pbmdcbiAgICAgKiB3aWxsIGJlIGVtaXR0ZWQgaWYgdGhpcyBpcyBkZXRlY3RlZC4gVXNlIHtAbGluayAjZ2V0VXNlcigpfSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFNlc3Npb24oKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKHRoaXMubG9ja0FjcXVpcmVUaW1lb3V0LCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWNxdWlyZXMgYSBnbG9iYWwgbG9jayBiYXNlZCBvbiB0aGUgc3RvcmFnZSBrZXkuXG4gICAgICovXG4gICAgYXN5bmMgX2FjcXVpcmVMb2NrKGFjcXVpcmVUaW1lb3V0LCBmbikge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdiZWdpbicsIGFjcXVpcmVUaW1lb3V0KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvY2tBY3F1aXJlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzLnBlbmRpbmdJbkxvY2subGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5wZW5kaW5nSW5Mb2NrW3RoaXMucGVuZGluZ0luTG9jay5sZW5ndGggLSAxXVxuICAgICAgICAgICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGxhc3Q7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBmbigpO1xuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nSW5Mb2NrLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UganVzdCBjYXJlIGlmIGl0IGZpbmlzaGVkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9jayhgbG9jazoke3RoaXMuc3RvcmFnZUtleX1gLCBhY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2FjcXVpcmVMb2NrJywgJ2xvY2sgYWNxdWlyZWQgZm9yIHN0b3JhZ2Uga2V5JywgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvY2tBY3F1aXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0luTG9jay5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UganVzdCBjYXJlIGlmIGl0IGZpbmlzaGVkXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgZHJhaW5pbmcgdGhlIHF1ZXVlIHVudGlsIHRoZXJlJ3Mgbm90aGluZyB0byB3YWl0IG9uXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLnBlbmRpbmdJbkxvY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3YWl0T24gPSBbLi4udGhpcy5wZW5kaW5nSW5Mb2NrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHdhaXRPbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdJbkxvY2suc3BsaWNlKDAsIHdhaXRPbi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdsb2NrIHJlbGVhc2VkIGZvciBzdG9yYWdlIGtleScsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9ja0FjcXVpcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdlbmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2UgaW5zdGVhZCBvZiB7QGxpbmsgI2dldFNlc3Npb259IGluc2lkZSB0aGUgbGlicmFyeS4gSXQgaXNcbiAgICAgKiBzZW1hbnRpY2FsbHkgdXN1YWxseSB3aGF0IHlvdSB3YW50LCBhcyBnZXR0aW5nIGEgc2Vzc2lvbiBpbnZvbHZlcyBzb21lXG4gICAgICogcHJvY2Vzc2luZyBhZnRlcndhcmRzIHRoYXQgcmVxdWlyZXMgb25seSBvbmUgY2xpZW50IG9wZXJhdGluZyBvbiB0aGVcbiAgICAgKiBzZXNzaW9uIGF0IG9uY2UgYWNyb3NzIG11bHRpcGxlIHRhYnMgb3IgcHJvY2Vzc2VzLlxuICAgICAqL1xuICAgIGFzeW5jIF91c2VTZXNzaW9uKGZuKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX3VzZVNlc3Npb24nLCAnYmVnaW4nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIHRoZSB1c2Ugb2YgX19sb2FkU2Vzc2lvbiBoZXJlIGlzIHRoZSBvbmx5IGNvcnJlY3QgdXNlIG9mIHRoZSBmdW5jdGlvbiFcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX19sb2FkU2Vzc2lvbigpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI191c2VTZXNzaW9uJywgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5FVkVSIFVTRSBESVJFQ1RMWSFcbiAgICAgKlxuICAgICAqIEFsd2F5cyB1c2Uge0BsaW5rICNfdXNlU2Vzc2lvbn0uXG4gICAgICovXG4gICAgYXN5bmMgX19sb2FkU2Vzc2lvbigpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfX2xvYWRTZXNzaW9uKCknLCAnYmVnaW4nKTtcbiAgICAgICAgaWYgKCF0aGlzLmxvY2tBY3F1aXJlZCkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfX2xvYWRTZXNzaW9uKCknLCAndXNlZCBvdXRzaWRlIG9mIGFuIGFjcXVpcmVkIGxvY2shJywgbmV3IEVycm9yKCkuc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFNlc3Npb24gPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgbWF5YmVTZXNzaW9uID0gYXdhaXQgZ2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjZ2V0U2Vzc2lvbigpJywgJ3Nlc3Npb24gZnJvbSBzdG9yYWdlJywgbWF5YmVTZXNzaW9uKTtcbiAgICAgICAgICAgIGlmIChtYXliZVNlc3Npb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNWYWxpZFNlc3Npb24obWF5YmVTZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvbiA9IG1heWJlU2Vzc2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjZ2V0U2Vzc2lvbigpJywgJ3Nlc3Npb24gZnJvbSBzdG9yYWdlIGlzIG5vdCB2YWxpZCcpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjdXJyZW50U2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQSBzZXNzaW9uIGlzIGNvbnNpZGVyZWQgZXhwaXJlZCBiZWZvcmUgdGhlIGFjY2VzcyB0b2tlbiBfYWN0dWFsbHlfXG4gICAgICAgICAgICAvLyBleHBpcmVzLiBXaGVuIHRoZSBhdXRvUmVmcmVzaFRva2VuIG9wdGlvbiBpcyBvZmYgKG9yIHdoZW4gdGhlIHRhYiBpc1xuICAgICAgICAgICAgLy8gaW4gdGhlIGJhY2tncm91bmQpLCB2ZXJ5IGVhZ2VyIHVzZXJzIG9mIGdldFNlc3Npb24oKSAtLSBsaWtlXG4gICAgICAgICAgICAvLyByZWFsdGltZS1qcyAtLSBtaWdodCBzZW5kIGEgdmFsaWQgSldUIHdoaWNoIHdpbGwgZXhwaXJlIGJ5IHRoZSB0aW1lIGl0XG4gICAgICAgICAgICAvLyByZWFjaGVzIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAgICBjb25zdCBoYXNFeHBpcmVkID0gY3VycmVudFNlc3Npb24uZXhwaXJlc19hdFxuICAgICAgICAgICAgICAgID8gY3VycmVudFNlc3Npb24uZXhwaXJlc19hdCAqIDEwMDAgLSBEYXRlLm5vdygpIDwgRVhQSVJZX01BUkdJTl9NU1xuICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19fbG9hZFNlc3Npb24oKScsIGBzZXNzaW9uIGhhcyR7aGFzRXhwaXJlZCA/ICcnIDogJyBub3QnfSBleHBpcmVkYCwgJ2V4cGlyZXNfYXQnLCBjdXJyZW50U2Vzc2lvbi5leHBpcmVzX2F0KTtcbiAgICAgICAgICAgIGlmICghaGFzRXhwaXJlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVzZXJTdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heWJlVXNlciA9IChhd2FpdCBnZXRJdGVtQXN5bmModGhpcy51c2VyU3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5ICsgJy11c2VyJykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF5YmVVc2VyID09PSBudWxsIHx8IG1heWJlVXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF5YmVVc2VyLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnVzZXIgPSBtYXliZVVzZXIudXNlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnVzZXIgPSB1c2VyTm90QXZhaWxhYmxlUHJveHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXcmFwIHRoZSB1c2VyIG9iamVjdCB3aXRoIGEgd2FybmluZyBwcm94eSBvbiB0aGUgc2VydmVyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3YXJucyB3aGVuIHByb3BlcnRpZXMgb2YgdGhlIHVzZXIgYXJlIGFjY2Vzc2VkLCBub3Qgd2hlbiBzZXNzaW9uLnVzZXIgaXRzZWxmIGlzIGFjY2Vzc2VkXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RvcmFnZS5pc1NlcnZlciAmJlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvbi51c2VyICYmXG4gICAgICAgICAgICAgICAgICAgICFjdXJyZW50U2Vzc2lvbi51c2VyLl9faXNVc2VyTm90QXZhaWxhYmxlUHJveHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VwcHJlc3NXYXJuaW5nUmVmID0geyB2YWx1ZTogdGhpcy5zdXBwcmVzc0dldFNlc3Npb25XYXJuaW5nIH07XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnVzZXIgPSBpbnNlY3VyZVVzZXJXYXJuaW5nUHJveHkoY3VycmVudFNlc3Npb24udXNlciwgc3VwcHJlc3NXYXJuaW5nUmVmKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBjbGllbnQtbGV2ZWwgc3VwcHJlc3Npb24gZmxhZyB3aGVuIHRoZSBwcm94eSBzdXBwcmVzc2VzIHRoZSB3YXJuaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdXBwcmVzc1dhcm5pbmdSZWYudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBjdXJyZW50U2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfX2xvYWRTZXNzaW9uKCknLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB1c2VyIGRldGFpbHMgaWYgdGhlcmUgaXMgYW4gZXhpc3Rpbmcgc2Vzc2lvbi4gVGhpcyBtZXRob2RcbiAgICAgKiBwZXJmb3JtcyBhIG5ldHdvcmsgcmVxdWVzdCB0byB0aGUgU3VwYWJhc2UgQXV0aCBzZXJ2ZXIsIHNvIHRoZSByZXR1cm5lZFxuICAgICAqIHZhbHVlIGlzIGF1dGhlbnRpYyBhbmQgY2FuIGJlIHVzZWQgdG8gYmFzZSBhdXRob3JpemF0aW9uIHJ1bGVzIG9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGp3dCBUYWtlcyBpbiBhbiBvcHRpb25hbCBhY2Nlc3MgdG9rZW4gSldULiBJZiBubyBKV1QgaXMgcHJvdmlkZWQsIHRoZSBKV1QgZnJvbSB0aGUgY3VycmVudCBzZXNzaW9uIGlzIHVzZWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VXNlcihqd3QpIHtcbiAgICAgICAgaWYgKGp3dCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2dldFVzZXIoand0KTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2dldFVzZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXN1bHQuZGF0YS51c2VyKSB7XG4gICAgICAgICAgICB0aGlzLnN1cHByZXNzR2V0U2Vzc2lvbldhcm5pbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRVc2VyKGp3dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGp3dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L3VzZXJgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiBqd3QsXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJldHVybnMgYW4gZXJyb3IgaWYgdGhlcmUgaXMgbm8gYWNjZXNzX3Rva2VuIG9yIGN1c3RvbSBhdXRob3JpemF0aW9uIGhlYWRlclxuICAgICAgICAgICAgICAgIGlmICghKChfYSA9IGRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2Vzc190b2tlbikgJiYgIXRoaXMuaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3I6IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L3VzZXJgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiAoX2MgPSAoX2IgPSBkYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hY2Nlc3NfdG9rZW4pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSldUIGNvbnRhaW5zIGEgYHNlc3Npb25faWRgIHdoaWNoIGRvZXMgbm90IGNvcnJlc3BvbmQgdG8gYW4gYWN0aXZlXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlc3Npb24gaW4gdGhlIGRhdGFiYXNlLCBpbmRpY2F0aW5nIHRoZSB1c2VyIGlzIHNpZ25lZCBvdXQuXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHVzZXIgZGF0YSBmb3IgYSBsb2dnZWQgaW4gdXNlci5cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVVc2VyKGF0dHJpYnV0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2sodGhpcy5sb2NrQWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91cGRhdGVVc2VyKGF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3VwZGF0ZVVzZXIoYXR0cmlidXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgc2Vzc2lvbkVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb25EYXRhLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBzZXNzaW9uRGF0YS5zZXNzaW9uO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgY29kZUNoYWxsZW5nZU1ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJyAmJiBhdHRyaWJ1dGVzLmVtYWlsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvcjogdXNlckVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUFVUJywgYCR7dGhpcy51cmx9L3VzZXJgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVtYWlsUmVkaXJlY3RUbyxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKSwgeyBjb2RlX2NoYWxsZW5nZTogY29kZUNoYWxsZW5nZSwgY29kZV9jaGFsbGVuZ2VfbWV0aG9kOiBjb2RlQ2hhbGxlbmdlTWV0aG9kIH0pLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IHNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodXNlckVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHVzZXJFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi51c2VyID0gZGF0YS51c2VyO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdVU0VSX1VQREFURUQnLCBzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBzZXNzaW9uLnVzZXIgfSwgZXJyb3I6IG51bGwgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzZXNzaW9uIGRhdGEgZnJvbSB0aGUgY3VycmVudCBzZXNzaW9uLiBJZiB0aGUgY3VycmVudCBzZXNzaW9uIGlzIGV4cGlyZWQsIHNldFNlc3Npb24gd2lsbCB0YWtlIGNhcmUgb2YgcmVmcmVzaGluZyBpdCB0byBvYnRhaW4gYSBuZXcgc2Vzc2lvbi5cbiAgICAgKiBJZiB0aGUgcmVmcmVzaCB0b2tlbiBvciBhY2Nlc3MgdG9rZW4gaW4gdGhlIGN1cnJlbnQgc2Vzc2lvbiBpcyBpbnZhbGlkLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICAgKiBAcGFyYW0gY3VycmVudFNlc3Npb24gVGhlIGN1cnJlbnQgc2Vzc2lvbiB0aGF0IG1pbmltYWxseSBjb250YWlucyBhbiBhY2Nlc3MgdG9rZW4gYW5kIHJlZnJlc2ggdG9rZW4uXG4gICAgICovXG4gICAgYXN5bmMgc2V0U2Vzc2lvbihjdXJyZW50U2Vzc2lvbikge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2sodGhpcy5sb2NrQWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9zZXRTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9zZXRTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRTZXNzaW9uLmFjY2Vzc190b2tlbiB8fCAhY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGltZU5vdyA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgICAgICAgICAgbGV0IGV4cGlyZXNBdCA9IHRpbWVOb3c7XG4gICAgICAgICAgICBsZXQgaGFzRXhwaXJlZCA9IHRydWU7XG4gICAgICAgICAgICBsZXQgc2Vzc2lvbiA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCB7IHBheWxvYWQgfSA9IGRlY29kZUpXVChjdXJyZW50U2Vzc2lvbi5hY2Nlc3NfdG9rZW4pO1xuICAgICAgICAgICAgaWYgKHBheWxvYWQuZXhwKSB7XG4gICAgICAgICAgICAgICAgZXhwaXJlc0F0ID0gcGF5bG9hZC5leHA7XG4gICAgICAgICAgICAgICAgaGFzRXhwaXJlZCA9IGV4cGlyZXNBdCA8PSB0aW1lTm93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc0V4cGlyZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHJlZnJlc2hlZFNlc3Npb24sIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9jYWxsUmVmcmVzaFRva2VuKGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFyZWZyZXNoZWRTZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXNzaW9uID0gcmVmcmVzaGVkU2Vzc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2dldFVzZXIoY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2Vzc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiBjdXJyZW50U2Vzc2lvbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hfdG9rZW46IGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHVzZXI6IGRhdGEudXNlcixcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5fdHlwZTogJ2JlYXJlcicsXG4gICAgICAgICAgICAgICAgICAgIGV4cGlyZXNfaW46IGV4cGlyZXNBdCAtIHRpbWVOb3csXG4gICAgICAgICAgICAgICAgICAgIGV4cGlyZXNfYXQ6IGV4cGlyZXNBdCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBzZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IHNlc3Npb24udXNlciwgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyBzZXNzaW9uOiBudWxsLCB1c2VyOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBzZXNzaW9uLCByZWdhcmRsZXNzIG9mIGV4cGlyeSBzdGF0dXMuXG4gICAgICogVGFrZXMgaW4gYW4gb3B0aW9uYWwgY3VycmVudCBzZXNzaW9uLiBJZiBub3QgcGFzc2VkIGluLCB0aGVuIHJlZnJlc2hTZXNzaW9uKCkgd2lsbCBhdHRlbXB0IHRvIHJldHJpZXZlIGl0IGZyb20gZ2V0U2Vzc2lvbigpLlxuICAgICAqIElmIHRoZSBjdXJyZW50IHNlc3Npb24ncyByZWZyZXNoIHRva2VuIGlzIGludmFsaWQsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgICAqIEBwYXJhbSBjdXJyZW50U2Vzc2lvbiBUaGUgY3VycmVudCBzZXNzaW9uLiBJZiBwYXNzZWQgaW4sIGl0IG11c3QgY29udGFpbiBhIHJlZnJlc2ggdG9rZW4uXG4gICAgICovXG4gICAgYXN5bmMgcmVmcmVzaFNlc3Npb24oY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKHRoaXMubG9ja0FjcXVpcmVUaW1lb3V0LCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcmVmcmVzaFNlc3Npb24oY3VycmVudFNlc3Npb24pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3JlZnJlc2hTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmICghY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uID0gKF9hID0gZGF0YS5zZXNzaW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKGN1cnJlbnRTZXNzaW9uID09PSBudWxsIHx8IGN1cnJlbnRTZXNzaW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBudWxsIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBzZXNzaW9uLnVzZXIsIHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2Vzc2lvbiBkYXRhIGZyb20gYSBVUkwgc3RyaW5nXG4gICAgICovXG4gICAgYXN5bmMgX2dldFNlc3Npb25Gcm9tVVJMKHBhcmFtcywgY2FsbGJhY2tVcmxUeXBlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWlzQnJvd3NlcigpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoJ05vIGJyb3dzZXIgZGV0ZWN0ZWQuJyk7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGFuIGVycm9yIGluIHRoZSBVUkwsIGl0IGRvZXNuJ3QgbWF0dGVyIHdoYXQgZmxvdyBpdCBpcywgd2UganVzdCByZXR1cm4gdGhlIGVycm9yLlxuICAgICAgICAgICAgaWYgKHBhcmFtcy5lcnJvciB8fCBwYXJhbXMuZXJyb3JfZGVzY3JpcHRpb24gfHwgcGFyYW1zLmVycm9yX2NvZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZXJyb3IgY2xhc3MgcmV0dXJuZWQgaW1wbGllcyB0aGF0IHRoZSByZWRpcmVjdCBpcyBmcm9tIGFuIGltcGxpY2l0IGdyYW50IGZsb3dcbiAgICAgICAgICAgICAgICAvLyBidXQgaXQgY291bGQgYWxzbyBiZSBmcm9tIGEgcmVkaXJlY3QgZXJyb3IgZnJvbSBhIFBLQ0UgZmxvdy5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKHBhcmFtcy5lcnJvcl9kZXNjcmlwdGlvbiB8fCAnRXJyb3IgaW4gVVJMIHdpdGggdW5zcGVjaWZpZWQgZXJyb3JfZGVzY3JpcHRpb24nLCB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBwYXJhbXMuZXJyb3IgfHwgJ3Vuc3BlY2lmaWVkX2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogcGFyYW1zLmVycm9yX2NvZGUgfHwgJ3Vuc3BlY2lmaWVkX2NvZGUnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2tzIGZvciBtaXNtYXRjaGVzIGJldHdlZW4gdGhlIGZsb3dUeXBlIGluaXRpYWxpc2VkIGluIHRoZSBjbGllbnQgYW5kIHRoZSBVUkwgcGFyYW1ldGVyc1xuICAgICAgICAgICAgc3dpdGNoIChjYWxsYmFja1VybFR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdpbXBsaWNpdCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoUEtDRUdyYW50Q29kZUV4Y2hhbmdlRXJyb3IoJ05vdCBhIHZhbGlkIFBLQ0UgZmxvdyB1cmwuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncGtjZSc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAnaW1wbGljaXQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKCdOb3QgYSB2YWxpZCBpbXBsaWNpdCBncmFudCBmbG93IHVybC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIHRoZXJlJ3Mgbm8gbWlzbWF0Y2ggc28gd2UgY29udGludWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgYSByZWRpcmVjdCBmb3IgUEtDRSwgd2UgYXR0ZW1wdCB0byByZXRyaWV2ZSB0aGUgY29kZSBmcm9tIHRoZSBVUkwgZm9yIHRoZSBjb2RlIGV4Y2hhbmdlXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2tVcmxUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnYmVnaW4nLCAnaXMgUEtDRSBmbG93JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbXMuY29kZSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvcignTm8gY29kZSBkZXRlY3RlZC4nKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9leGNoYW5nZUNvZGVGb3JTZXNzaW9uKHBhcmFtcy5jb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKCdjb2RlJyk7XG4gICAgICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHdpbmRvdy5oaXN0b3J5LnN0YXRlLCAnJywgdXJsLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogZGF0YS5zZXNzaW9uLCByZWRpcmVjdFR5cGU6IG51bGwgfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgcHJvdmlkZXJfdG9rZW4sIHByb3ZpZGVyX3JlZnJlc2hfdG9rZW4sIGFjY2Vzc190b2tlbiwgcmVmcmVzaF90b2tlbiwgZXhwaXJlc19pbiwgZXhwaXJlc19hdCwgdG9rZW5fdHlwZSwgfSA9IHBhcmFtcztcbiAgICAgICAgICAgIGlmICghYWNjZXNzX3Rva2VuIHx8ICFleHBpcmVzX2luIHx8ICFyZWZyZXNoX3Rva2VuIHx8ICF0b2tlbl90eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcignTm8gc2Vzc2lvbiBkZWZpbmVkIGluIFVSTCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGltZU5vdyA9IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgICAgICAgY29uc3QgZXhwaXJlc0luID0gcGFyc2VJbnQoZXhwaXJlc19pbik7XG4gICAgICAgICAgICBsZXQgZXhwaXJlc0F0ID0gdGltZU5vdyArIGV4cGlyZXNJbjtcbiAgICAgICAgICAgIGlmIChleHBpcmVzX2F0KSB7XG4gICAgICAgICAgICAgICAgZXhwaXJlc0F0ID0gcGFyc2VJbnQoZXhwaXJlc19hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhY3R1YWxseUV4cGlyZXNJbiA9IGV4cGlyZXNBdCAtIHRpbWVOb3c7XG4gICAgICAgICAgICBpZiAoYWN0dWFsbHlFeHBpcmVzSW4gKiAxMDAwIDw9IEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBAc3VwYWJhc2UvZ290cnVlLWpzOiBTZXNzaW9uIGFzIHJldHJpZXZlZCBmcm9tIFVSTCBleHBpcmVzIGluICR7YWN0dWFsbHlFeHBpcmVzSW59cywgc2hvdWxkIGhhdmUgYmVlbiBjbG9zZXIgdG8gJHtleHBpcmVzSW59c2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNzdWVkQXQgPSBleHBpcmVzQXQgLSBleHBpcmVzSW47XG4gICAgICAgICAgICBpZiAodGltZU5vdyAtIGlzc3VlZEF0ID49IDEyMCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQHN1cGFiYXNlL2dvdHJ1ZS1qczogU2Vzc2lvbiBhcyByZXRyaWV2ZWQgZnJvbSBVUkwgd2FzIGlzc3VlZCBvdmVyIDEyMHMgYWdvLCBVUkwgY291bGQgYmUgc3RhbGUnLCBpc3N1ZWRBdCwgZXhwaXJlc0F0LCB0aW1lTm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRpbWVOb3cgLSBpc3N1ZWRBdCA8IDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0BzdXBhYmFzZS9nb3RydWUtanM6IFNlc3Npb24gYXMgcmV0cmlldmVkIGZyb20gVVJMIHdhcyBpc3N1ZWQgaW4gdGhlIGZ1dHVyZT8gQ2hlY2sgdGhlIGRldmljZSBjbG9jayBmb3Igc2tldycsIGlzc3VlZEF0LCBleHBpcmVzQXQsIHRpbWVOb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fZ2V0VXNlcihhY2Nlc3NfdG9rZW4pO1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHtcbiAgICAgICAgICAgICAgICBwcm92aWRlcl90b2tlbixcbiAgICAgICAgICAgICAgICBwcm92aWRlcl9yZWZyZXNoX3Rva2VuLFxuICAgICAgICAgICAgICAgIGFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICBleHBpcmVzX2luOiBleHBpcmVzSW4sXG4gICAgICAgICAgICAgICAgZXhwaXJlc19hdDogZXhwaXJlc0F0LFxuICAgICAgICAgICAgICAgIHJlZnJlc2hfdG9rZW4sXG4gICAgICAgICAgICAgICAgdG9rZW5fdHlwZTogdG9rZW5fdHlwZSxcbiAgICAgICAgICAgICAgICB1c2VyOiBkYXRhLnVzZXIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRva2VucyBmcm9tIFVSTFxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSAnJztcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2dldFNlc3Npb25Gcm9tVVJMKCknLCAnY2xlYXJpbmcgd2luZG93LmxvY2F0aW9uLmhhc2gnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHNlc3Npb24sIHJlZGlyZWN0VHlwZTogcGFyYW1zLnR5cGUgfSwgZXJyb3I6IG51bGwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCwgcmVkaXJlY3RUeXBlOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IFVSTCBjb250YWlucyBwYXJhbWV0ZXJzIGdpdmVuIGJ5IGFuIGltcGxpY2l0IG9hdXRoIGdyYW50IGZsb3cgKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM2NzQ5Lmh0bWwjc2VjdGlvbi00LjIpXG4gICAgICpcbiAgICAgKiBJZiBgZGV0ZWN0U2Vzc2lvbkluVXJsYCBpcyBhIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBVUkwgYW5kIHBhcmFtcyB0byBkZXRlcm1pbmVcbiAgICAgKiBpZiB0aGUgVVJMIHNob3VsZCBiZSBwcm9jZXNzZWQgYXMgYSBTdXBhYmFzZSBhdXRoIGNhbGxiYWNrLiBUaGlzIGFsbG93cyB1c2VycyB0byBleGNsdWRlXG4gICAgICogVVJMcyBmcm9tIG90aGVyIE9BdXRoIHByb3ZpZGVycyAoZS5nLiwgRmFjZWJvb2sgTG9naW4pIHRoYXQgYWxzbyByZXR1cm4gYWNjZXNzX3Rva2VuIGluIHRoZSBmcmFnbWVudC5cbiAgICAgKi9cbiAgICBfaXNJbXBsaWNpdEdyYW50Q2FsbGJhY2socGFyYW1zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5kZXRlY3RTZXNzaW9uSW5VcmwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRldGVjdFNlc3Npb25JblVybChuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKSwgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQm9vbGVhbihwYXJhbXMuYWNjZXNzX3Rva2VuIHx8IHBhcmFtcy5lcnJvcl9kZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBVUkwgYW5kIGJhY2tpbmcgc3RvcmFnZSBjb250YWluIHBhcmFtZXRlcnMgZ2l2ZW4gYnkgYSBQS0NFIGZsb3dcbiAgICAgKi9cbiAgICBhc3luYyBfaXNQS0NFQ2FsbGJhY2socGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdG9yYWdlQ29udGVudCA9IGF3YWl0IGdldEl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICByZXR1cm4gISEocGFyYW1zLmNvZGUgJiYgY3VycmVudFN0b3JhZ2VDb250ZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zaWRlIGEgYnJvd3NlciBjb250ZXh0LCBgc2lnbk91dCgpYCB3aWxsIHJlbW92ZSB0aGUgbG9nZ2VkIGluIHVzZXIgZnJvbSB0aGUgYnJvd3NlciBzZXNzaW9uIGFuZCBsb2cgdGhlbSBvdXQgLSByZW1vdmluZyBhbGwgaXRlbXMgZnJvbSBsb2NhbHN0b3JhZ2UgYW5kIHRoZW4gdHJpZ2dlciBhIGBcIlNJR05FRF9PVVRcImAgZXZlbnQuXG4gICAgICpcbiAgICAgKiBGb3Igc2VydmVyLXNpZGUgbWFuYWdlbWVudCwgeW91IGNhbiByZXZva2UgYWxsIHJlZnJlc2ggdG9rZW5zIGZvciBhIHVzZXIgYnkgcGFzc2luZyBhIHVzZXIncyBKV1QgdGhyb3VnaCB0byBgYXV0aC5hcGkuc2lnbk91dChKV1Q6IHN0cmluZylgLlxuICAgICAqIFRoZXJlIGlzIG5vIHdheSB0byByZXZva2UgYSB1c2VyJ3MgYWNjZXNzIHRva2VuIGp3dCB1bnRpbCBpdCBleHBpcmVzLiBJdCBpcyByZWNvbW1lbmRlZCB0byBzZXQgYSBzaG9ydGVyIGV4cGlyeSBvbiB0aGUgand0IGZvciB0aGlzIHJlYXNvbi5cbiAgICAgKlxuICAgICAqIElmIHVzaW5nIGBvdGhlcnNgIHNjb3BlLCBubyBgU0lHTkVEX09VVGAgZXZlbnQgaXMgZmlyZWQhXG4gICAgICovXG4gICAgYXN5bmMgc2lnbk91dChvcHRpb25zID0geyBzY29wZTogJ2dsb2JhbCcgfSkge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2sodGhpcy5sb2NrQWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9zaWduT3V0KG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3NpZ25PdXQoeyBzY29wZSB9ID0geyBzY29wZTogJ2dsb2JhbCcgfSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IgJiYgIWlzQXV0aFNlc3Npb25NaXNzaW5nRXJyb3Ioc2Vzc2lvbkVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBlcnJvcjogc2Vzc2lvbkVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWNjZXNzVG9rZW4gPSAoX2EgPSBkYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW47XG4gICAgICAgICAgICBpZiAoYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCB0aGlzLmFkbWluLnNpZ25PdXQoYWNjZXNzVG9rZW4sIHNjb3BlKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIDQwNHMgc2luY2UgdXNlciBtaWdodCBub3QgZXhpc3QgYW55bW9yZVxuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgNDAxcyBzaW5jZSBhbiBpbnZhbGlkIG9yIGV4cGlyZWQgSldUIHNob3VsZCBzaWduIG91dCB0aGUgY3VycmVudCBzZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICghKChpc0F1dGhBcGlFcnJvcihlcnJvcikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChlcnJvci5zdGF0dXMgPT09IDQwNCB8fCBlcnJvci5zdGF0dXMgPT09IDQwMSB8fCBlcnJvci5zdGF0dXMgPT09IDQwMykpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKGVycm9yKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY29wZSAhPT0gJ290aGVycycpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZXJyb3I6IG51bGwgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbkF1dGhTdGF0ZUNoYW5nZShjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBpZCA9IGdlbmVyYXRlQ2FsbGJhY2tJZCgpO1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI3Vuc3Vic2NyaWJlKCknLCAnc3RhdGUgY2hhbmdlIGNhbGxiYWNrIHdpdGggaWQgcmVtb3ZlZCcsIGlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjb25BdXRoU3RhdGVDaGFuZ2UoKScsICdyZWdpc3RlcmVkIGNhbGxiYWNrIHdpdGggaWQnLCBpZCk7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy5zZXQoaWQsIHN1YnNjcmlwdGlvbik7XG4gICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2sodGhpcy5sb2NrQWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0SW5pdGlhbFNlc3Npb24oaWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHsgc3Vic2NyaXB0aW9uIH0gfTtcbiAgICB9XG4gICAgYXN5bmMgX2VtaXRJbml0aWFsU2Vzc2lvbihpZCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9LCBlcnJvciwgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIGF3YWl0ICgoX2EgPSB0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMuZ2V0KGlkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGxiYWNrKCdJTklUSUFMX1NFU1NJT04nLCBzZXNzaW9uKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJ0lOSVRJQUxfU0VTU0lPTicsICdjYWxsYmFjayBpZCcsIGlkLCAnc2Vzc2lvbicsIHNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGF3YWl0ICgoX2IgPSB0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMuZ2V0KGlkKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGxiYWNrKCdJTklUSUFMX1NFU1NJT04nLCBudWxsKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJ0lOSVRJQUxfU0VTU0lPTicsICdjYWxsYmFjayBpZCcsIGlkLCAnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgcGFzc3dvcmQgcmVzZXQgcmVxdWVzdCB0byBhbiBlbWFpbCBhZGRyZXNzLiBUaGlzIG1ldGhvZCBzdXBwb3J0cyB0aGUgUEtDRSBmbG93LlxuICAgICAqXG4gICAgICogQHBhcmFtIGVtYWlsIFRoZSBlbWFpbCBhZGRyZXNzIG9mIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlZGlyZWN0VG8gVGhlIFVSTCB0byBzZW5kIHRoZSB1c2VyIHRvIGFmdGVyIHRoZXkgY2xpY2sgdGhlIHBhc3N3b3JkIHJlc2V0IGxpbmsuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY2FwdGNoYVRva2VuIFZlcmlmaWNhdGlvbiB0b2tlbiByZWNlaXZlZCB3aGVuIHRoZSB1c2VyIGNvbXBsZXRlcyB0aGUgY2FwdGNoYSBvbiB0aGUgc2l0ZS5cbiAgICAgKi9cbiAgICBhc3luYyByZXNldFBhc3N3b3JkRm9yRW1haWwoZW1haWwsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgY29kZUNoYWxsZW5nZSA9IG51bGw7XG4gICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSwgdHJ1ZSAvLyBpc1Bhc3N3b3JkUmVjb3ZlcnlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9yZWNvdmVyYCwge1xuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgZW1haWwsXG4gICAgICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlOiBjb2RlQ2hhbGxlbmdlLFxuICAgICAgICAgICAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucy5yZWRpcmVjdFRvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKTtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCB0aGUgaWRlbnRpdGllcyBsaW5rZWQgdG8gYSB1c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFVzZXJJZGVudGl0aWVzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLmdldFVzZXIoKTtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IGlkZW50aXRpZXM6IChfYSA9IGRhdGEudXNlci5pZGVudGl0aWVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSB9LCBlcnJvcjogbnVsbCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsaW5rSWRlbnRpdHkoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgaWYgKCd0b2tlbicgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbmtJZGVudGl0eUlkVG9rZW4oY3JlZGVudGlhbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmtJZGVudGl0eU9BdXRoKGNyZWRlbnRpYWxzKTtcbiAgICB9XG4gICAgYXN5bmMgbGlua0lkZW50aXR5T0F1dGgoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLl9nZXRVcmxGb3JQcm92aWRlcihgJHt0aGlzLnVybH0vdXNlci9pZGVudGl0aWVzL2F1dGhvcml6ZWAsIGNyZWRlbnRpYWxzLnByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0VG86IChfYSA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWRpcmVjdFRvLFxuICAgICAgICAgICAgICAgICAgICBzY29wZXM6IChfYiA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zY29wZXMsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiAoX2MgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgIHNraXBCcm93c2VyUmVkaXJlY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCB1cmwsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IChfZSA9IChfZCA9IGRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFjY2Vzc190b2tlbikgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICBpZiAoaXNCcm93c2VyKCkgJiYgISgoX2EgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2tpcEJyb3dzZXJSZWRpcmVjdCkpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS51cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7XG4gICAgICAgICAgICAgICAgZGF0YTogeyBwcm92aWRlcjogY3JlZGVudGlhbHMucHJvdmlkZXIsIHVybDogZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLnVybCB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgcHJvdmlkZXI6IGNyZWRlbnRpYWxzLnByb3ZpZGVyLCB1cmw6IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsaW5rSWRlbnRpdHlJZFRva2VuKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvcjogc2Vzc2lvbkVycm9yLCBkYXRhOiB7IHNlc3Npb24gfSwgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBzZXNzaW9uRXJyb3I7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBvcHRpb25zLCBwcm92aWRlciwgdG9rZW4sIGFjY2Vzc190b2tlbiwgbm9uY2UgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9aWRfdG9rZW5gLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiAoX2EgPSBzZXNzaW9uID09PSBudWxsIHx8IHNlc3Npb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb24uYWNjZXNzX3Rva2VuKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWRfdG9rZW46IHRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rX2lkZW50aXR5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXM7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFkYXRhIHx8ICFkYXRhLnNlc3Npb24gfHwgIWRhdGEudXNlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcigpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnVVNFUl9VUERBVEVEJywgZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGEsIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVubGlua3MgYW4gaWRlbnRpdHkgZnJvbSBhIHVzZXIgYnkgZGVsZXRpbmcgaXQuIFRoZSB1c2VyIHdpbGwgbm8gbG9uZ2VyIGJlIGFibGUgdG8gc2lnbiBpbiB3aXRoIHRoYXQgaWRlbnRpdHkgb25jZSBpdCdzIHVubGlua2VkLlxuICAgICAqL1xuICAgIGFzeW5jIHVubGlua0lkZW50aXR5KGlkZW50aXR5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0RFTEVURScsIGAke3RoaXMudXJsfS91c2VyL2lkZW50aXRpZXMvJHtpZGVudGl0eS5pZGVudGl0eV9pZH1gLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiAoX2IgPSAoX2EgPSBkYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW4pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIG5ldyBKV1QuXG4gICAgICogQHBhcmFtIHJlZnJlc2hUb2tlbiBBIHZhbGlkIHJlZnJlc2ggdG9rZW4gdGhhdCB3YXMgcmV0dXJuZWQgb24gbG9naW4uXG4gICAgICovXG4gICAgYXN5bmMgX3JlZnJlc2hBY2Nlc3NUb2tlbihyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgY29uc3QgZGVidWdOYW1lID0gYCNfcmVmcmVzaEFjY2Vzc1Rva2VuKCR7cmVmcmVzaFRva2VuLnN1YnN0cmluZygwLCA1KX0uLi4pYDtcbiAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnYmVnaW4nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ZWRBdCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAvLyB3aWxsIGF0dGVtcHQgdG8gcmVmcmVzaCB0aGUgdG9rZW4gd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcmV0cnlhYmxlKGFzeW5jIChhdHRlbXB0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dGVtcHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHNsZWVwKDIwMCAqIE1hdGgucG93KDIsIGF0dGVtcHQgLSAxKSk7IC8vIDIwMCwgNDAwLCA4MDAsIC4uLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdyZWZyZXNoaW5nIGF0dGVtcHQnLCBhdHRlbXB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1yZWZyZXNoX3Rva2VuYCwge1xuICAgICAgICAgICAgICAgICAgICBib2R5OiB7IHJlZnJlc2hfdG9rZW46IHJlZnJlc2hUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgKGF0dGVtcHQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dEJhY2tPZmZJbnRlcnZhbCA9IDIwMCAqIE1hdGgucG93KDIsIGF0dGVtcHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoZXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihlcnJvcikgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0cnlhYmxlIG9ubHkgaWYgdGhlIHJlcXVlc3QgY2FuIGJlIHNlbnQgYmVmb3JlIHRoZSBiYWNrb2ZmIG92ZXJmbG93cyB0aGUgdGljayBkdXJhdGlvblxuICAgICAgICAgICAgICAgICAgICBEYXRlLm5vdygpICsgbmV4dEJhY2tPZmZJbnRlcnZhbCAtIHN0YXJ0ZWRBdCA8IEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCwgdXNlcjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2lzVmFsaWRTZXNzaW9uKG1heWJlU2Vzc2lvbikge1xuICAgICAgICBjb25zdCBpc1ZhbGlkU2Vzc2lvbiA9IHR5cGVvZiBtYXliZVNlc3Npb24gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBtYXliZVNlc3Npb24gIT09IG51bGwgJiZcbiAgICAgICAgICAgICdhY2Nlc3NfdG9rZW4nIGluIG1heWJlU2Vzc2lvbiAmJlxuICAgICAgICAgICAgJ3JlZnJlc2hfdG9rZW4nIGluIG1heWJlU2Vzc2lvbiAmJlxuICAgICAgICAgICAgJ2V4cGlyZXNfYXQnIGluIG1heWJlU2Vzc2lvbjtcbiAgICAgICAgcmV0dXJuIGlzVmFsaWRTZXNzaW9uO1xuICAgIH1cbiAgICBhc3luYyBfaGFuZGxlUHJvdmlkZXJTaWduSW4ocHJvdmlkZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5fZ2V0VXJsRm9yUHJvdmlkZXIoYCR7dGhpcy51cmx9L2F1dGhvcml6ZWAsIHByb3ZpZGVyLCB7XG4gICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zLnJlZGlyZWN0VG8sXG4gICAgICAgICAgICBzY29wZXM6IG9wdGlvbnMuc2NvcGVzLFxuICAgICAgICAgICAgcXVlcnlQYXJhbXM6IG9wdGlvbnMucXVlcnlQYXJhbXMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19oYW5kbGVQcm92aWRlclNpZ25JbigpJywgJ3Byb3ZpZGVyJywgcHJvdmlkZXIsICdvcHRpb25zJywgb3B0aW9ucywgJ3VybCcsIHVybCk7XG4gICAgICAgIC8vIHRyeSB0byBvcGVuIG9uIHRoZSBicm93c2VyXG4gICAgICAgIGlmIChpc0Jyb3dzZXIoKSAmJiAhb3B0aW9ucy5za2lwQnJvd3NlclJlZGlyZWN0KSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBwcm92aWRlciwgdXJsIH0sIGVycm9yOiBudWxsIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY292ZXJzIHRoZSBzZXNzaW9uIGZyb20gTG9jYWxTdG9yYWdlIGFuZCByZWZyZXNoZXMgdGhlIHRva2VuXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgaXMgYXN5bmMgdG8gYWNjb21tb2RhdGUgZm9yIEFzeW5jU3RvcmFnZSBlLmcuIGluIFJlYWN0IG5hdGl2ZS5cbiAgICAgKi9cbiAgICBhc3luYyBfcmVjb3ZlckFuZFJlZnJlc2goKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGRlYnVnTmFtZSA9ICcjX3JlY292ZXJBbmRSZWZyZXNoKCknO1xuICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdiZWdpbicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFNlc3Npb24gPSAoYXdhaXQgZ2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KSk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFNlc3Npb24gJiYgdGhpcy51c2VyU3RvcmFnZSkge1xuICAgICAgICAgICAgICAgIGxldCBtYXliZVVzZXIgPSAoYXdhaXQgZ2V0SXRlbUFzeW5jKHRoaXMudXNlclN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSArICctdXNlcicpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RvcmFnZS5pc1NlcnZlciAmJiBPYmplY3QuaXModGhpcy5zdG9yYWdlLCB0aGlzLnVzZXJTdG9yYWdlKSAmJiAhbWF5YmVVc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JhZ2UgYW5kIHVzZXJTdG9yYWdlIGFyZSB0aGUgc2FtZSBzdG9yYWdlIG1lZGl1bSwgZm9yIGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgICAgLy8gd2luZG93LmxvY2FsU3RvcmFnZSBpZiB1c2VyU3RvcmFnZSBkb2VzIG5vdCBoYXZlIHRoZSB1c2VyIGZyb21cbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmFnZSBzdG9yZWQsIHN0b3JlIGl0IGZpcnN0IHRoZXJlYnkgbWlncmF0aW5nIHRoZSB1c2VyIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIHN0b3JhZ2UgLT4gdXNlclN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgICAgbWF5YmVVc2VyID0geyB1c2VyOiBjdXJyZW50U2Vzc2lvbi51c2VyIH07XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHNldEl0ZW1Bc3luYyh0aGlzLnVzZXJTdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkgKyAnLXVzZXInLCBtYXliZVVzZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvbi51c2VyID0gKF9hID0gbWF5YmVVc2VyID09PSBudWxsIHx8IG1heWJlVXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF5YmVVc2VyLnVzZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVzZXJOb3RBdmFpbGFibGVQcm94eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudFNlc3Npb24gJiYgIWN1cnJlbnRTZXNzaW9uLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2VyIHN0b3JhZ2UgaXMgbm90IHNldCwgbGV0J3MgY2hlY2sgaWYgaXQgd2FzIHByZXZpb3VzbHkgZW5hYmxlZCBzb1xuICAgICAgICAgICAgICAgIC8vIHdlIGJyaW5nIGJhY2sgdGhlIHN0b3JhZ2UgYXMgaXQgc2hvdWxkIGJlXG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50U2Vzc2lvbi51c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRlc3QgaWYgdXNlclN0b3JhZ2Ugd2FzIHByZXZpb3VzbHkgZW5hYmxlZCBhbmQgdGhlIHN0b3JhZ2UgbWVkaXVtIHdhcyB0aGUgc2FtZSwgdG8gbW92ZSB0aGUgdXNlciBiYWNrIHVuZGVyIHRoZSBzYW1lIGtleVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXBhcmF0ZVVzZXIgPSAoYXdhaXQgZ2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5ICsgJy11c2VyJykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdGVVc2VyICYmIChzZXBhcmF0ZVVzZXIgPT09IG51bGwgfHwgc2VwYXJhdGVVc2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXBhcmF0ZVVzZXIudXNlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnVzZXIgPSBzZXBhcmF0ZVVzZXIudXNlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSArICctdXNlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5LCBjdXJyZW50U2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvbi51c2VyID0gdXNlck5vdEF2YWlsYWJsZVByb3h5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdzZXNzaW9uIGZyb20gc3RvcmFnZScsIGN1cnJlbnRTZXNzaW9uKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNWYWxpZFNlc3Npb24oY3VycmVudFNlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnc2Vzc2lvbiBpcyBub3QgdmFsaWQnKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNlc3Npb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBleHBpcmVzV2l0aE1hcmdpbiA9ICgoX2IgPSBjdXJyZW50U2Vzc2lvbi5leHBpcmVzX2F0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBJbmZpbml0eSkgKiAxMDAwIC0gRGF0ZS5ub3coKSA8IEVYUElSWV9NQVJHSU5fTVM7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsIGBzZXNzaW9uIGhhcyR7ZXhwaXJlc1dpdGhNYXJnaW4gPyAnJyA6ICcgbm90J30gZXhwaXJlZCB3aXRoIG1hcmdpbiBvZiAke0VYUElSWV9NQVJHSU5fTVN9c2ApO1xuICAgICAgICAgICAgaWYgKGV4cGlyZXNXaXRoTWFyZ2luKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXV0b1JlZnJlc2hUb2tlbiAmJiBjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAncmVmcmVzaCBmYWlsZWQgd2l0aCBhIG5vbi1yZXRyeWFibGUgZXJyb3IsIHJlbW92aW5nIHRoZSBzZXNzaW9uJywgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRTZXNzaW9uLnVzZXIgJiZcbiAgICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvbi51c2VyLl9faXNVc2VyTm90QXZhaWxhYmxlUHJveHkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcHJveHkgdXNlciwgdHJ5IHRvIGdldCB0aGUgcmVhbCB1c2VyIGRhdGFcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiB1c2VyRXJyb3IgfSA9IGF3YWl0IHRoaXMuX2dldFVzZXIoY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VyRXJyb3IgJiYgKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS51c2VyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNlc3Npb24udXNlciA9IGRhdGEudXNlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBjdXJyZW50U2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdjb3VsZCBub3QgZ2V0IHVzZXIgZGF0YSwgc2tpcHBpbmcgU0lHTkVEX0lOIG5vdGlmaWNhdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChnZXRVc2VyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB1c2VyIGRhdGE6JywgZ2V0VXNlckVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZXJyb3IgZ2V0dGluZyB1c2VyIGRhdGEsIHNraXBwaW5nIFNJR05FRF9JTiBub3RpZmljYXRpb24nLCBnZXRVc2VyRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gcGVyc2lzdCBjdXJyZW50U2Vzc2lvbiBhZ2FpbiwgYXMgd2UganVzdCBsb2FkZWQgaXQgZnJvbVxuICAgICAgICAgICAgICAgIC8vIGxvY2FsIHN0b3JhZ2U7IHBlcnNpc3RpbmcgaXQgYWdhaW4gbWF5IG92ZXJ3cml0ZSBhIHZhbHVlIHNhdmVkIGJ5XG4gICAgICAgICAgICAgICAgLy8gYW5vdGhlciBjbGllbnQgd2l0aCBhY2Nlc3MgdG8gdGhlIHNhbWUgbG9jYWwgc3RvcmFnZVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBjdXJyZW50U2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2NhbGxSZWZyZXNoVG9rZW4ocmVmcmVzaFRva2VuKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghcmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWZyZXNoaW5nIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3NcbiAgICAgICAgaWYgKHRoaXMucmVmcmVzaGluZ0RlZmVycmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWJ1Z05hbWUgPSBgI19jYWxsUmVmcmVzaFRva2VuKCR7cmVmcmVzaFRva2VuLnN1YnN0cmluZygwLCA1KX0uLi4pYDtcbiAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnYmVnaW4nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9yZWZyZXNoQWNjZXNzVG9rZW4ocmVmcmVzaFRva2VuKTtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIGlmICghZGF0YS5zZXNzaW9uKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdUT0tFTl9SRUZSRVNIRUQnLCBkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyBkYXRhOiBkYXRhLnNlc3Npb24sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIGlmICghaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9iID0gdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlbmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfbm90aWZ5QWxsU3Vic2NyaWJlcnMoZXZlbnQsIHNlc3Npb24sIGJyb2FkY2FzdCA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgZGVidWdOYW1lID0gYCNfbm90aWZ5QWxsU3Vic2NyaWJlcnMoJHtldmVudH0pYDtcbiAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnYmVnaW4nLCBzZXNzaW9uLCBgYnJvYWRjYXN0ID0gJHticm9hZGNhc3R9YCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5icm9hZGNhc3RDaGFubmVsICYmIGJyb2FkY2FzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSh7IGV2ZW50LCBzZXNzaW9uIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IEFycmF5LmZyb20odGhpcy5zdGF0ZUNoYW5nZUVtaXR0ZXJzLnZhbHVlcygpKS5tYXAoYXN5bmMgKHgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB4LmNhbGxiYWNrKGV2ZW50LCBzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVycm9ycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNldCBjdXJyZW50U2Vzc2lvbiBhbmQgY3VycmVudFVzZXJcbiAgICAgKiBwcm9jZXNzIHRvIF9zdGFydEF1dG9SZWZyZXNoVG9rZW4gaWYgcG9zc2libGVcbiAgICAgKi9cbiAgICBhc3luYyBfc2F2ZVNlc3Npb24oc2Vzc2lvbikge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19zYXZlU2Vzc2lvbigpJywgc2Vzc2lvbik7XG4gICAgICAgIC8vIF9zYXZlU2Vzc2lvbiBpcyBhbHdheXMgY2FsbGVkIHdoZW5ldmVyIGEgbmV3IHNlc3Npb24gaGFzIGJlZW4gYWNxdWlyZWRcbiAgICAgICAgLy8gc28gd2UgY2FuIHNhZmVseSBzdXBwcmVzcyB0aGUgd2FybmluZyByZXR1cm5lZCBieSBmdXR1cmUgZ2V0U2Vzc2lvbiBjYWxsc1xuICAgICAgICB0aGlzLnN1cHByZXNzR2V0U2Vzc2lvbldhcm5pbmcgPSB0cnVlO1xuICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgc2hhbGxvdyBjb3B5IHRvIHdvcmsgd2l0aCwgdG8gYXZvaWQgbXV0YXRpbmcgdGhlIG9yaWdpbmFsIHNlc3Npb24gb2JqZWN0IGlmIGl0J3MgdXNlZCBlbHNld2hlcmVcbiAgICAgICAgY29uc3Qgc2Vzc2lvblRvUHJvY2VzcyA9IE9iamVjdC5hc3NpZ24oe30sIHNlc3Npb24pO1xuICAgICAgICBjb25zdCB1c2VySXNQcm94eSA9IHNlc3Npb25Ub1Byb2Nlc3MudXNlciAmJiBzZXNzaW9uVG9Qcm9jZXNzLnVzZXIuX19pc1VzZXJOb3RBdmFpbGFibGVQcm94eSA9PT0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMudXNlclN0b3JhZ2UpIHtcbiAgICAgICAgICAgIGlmICghdXNlcklzUHJveHkgJiYgc2Vzc2lvblRvUHJvY2Vzcy51c2VyKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQncyBhIHJlYWwgdXNlciBvYmplY3QsIHNhdmUgaXQgdG8gdXNlclN0b3JhZ2UuXG4gICAgICAgICAgICAgICAgYXdhaXQgc2V0SXRlbUFzeW5jKHRoaXMudXNlclN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSArICctdXNlcicsIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlcjogc2Vzc2lvblRvUHJvY2Vzcy51c2VyLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodXNlcklzUHJveHkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIHRoZSBwcm94eSwgaXQgbWVhbnMgdXNlciB3YXMgbm90IGZvdW5kIGluIHVzZXJTdG9yYWdlLlxuICAgICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBlbnN1cmUgbm8gc3RhbGUgdXNlciBkYXRhIGZvciB0aGlzIGtleSBleGlzdHMgaW4gdXNlclN0b3JhZ2UgaWYgd2Ugd2VyZSB0byBzYXZlIG51bGwsXG4gICAgICAgICAgICAgICAgLy8gb3Igc2ltcGx5IG5vdCBzYXZlIHRoZSBwcm94eS4gRm9yIG5vdywgd2UgZG9uJ3Qgc2F2ZSB0aGUgcHJveHkgaGVyZS5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgbmVlZCB0byBjbGVhciB1c2VyU3RvcmFnZSBpZiB1c2VyIGJlY29tZXMgcHJveHksIHRoYXQgbG9naWMgd291bGQgZ28gaGVyZS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByZXBhcmUgdGhlIG1haW4gc2Vzc2lvbiBkYXRhIGZvciBwcmltYXJ5IHN0b3JhZ2U6IHJlbW92ZSB0aGUgdXNlciBwcm9wZXJ0eSBiZWZvcmUgY2xvbmluZ1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgYmVjYXVzZSB0aGUgb3JpZ2luYWwgc2Vzc2lvbi51c2VyIG1pZ2h0IGJlIHRoZSBwcm94eVxuICAgICAgICAgICAgY29uc3QgbWFpblNlc3Npb25EYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgc2Vzc2lvblRvUHJvY2Vzcyk7XG4gICAgICAgICAgICBkZWxldGUgbWFpblNlc3Npb25EYXRhLnVzZXI7IC8vIFJlbW92ZSB1c2VyIChyZWFsIG9yIHByb3h5KSBiZWZvcmUgY2xvbmluZyBmb3IgbWFpbiBzdG9yYWdlXG4gICAgICAgICAgICBjb25zdCBjbG9uZWRNYWluU2Vzc2lvbkRhdGEgPSBkZWVwQ2xvbmUobWFpblNlc3Npb25EYXRhKTtcbiAgICAgICAgICAgIGF3YWl0IHNldEl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSwgY2xvbmVkTWFpblNlc3Npb25EYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIHVzZXJTdG9yYWdlIGlzIGNvbmZpZ3VyZWQuXG4gICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHNlc3Npb24udXNlciBzaG91bGQgaWRlYWxseSBub3QgYmUgYSBwcm94eS5cbiAgICAgICAgICAgIC8vIElmIGl0IHdlcmUsIHN0cnVjdHVyZWRDbG9uZSB3b3VsZCBmYWlsLiBUaGlzIGltcGxpZXMgYW4gaXNzdWUgZWxzZXdoZXJlIGlmIHVzZXIgaXMgYSBwcm94eSBoZXJlXG4gICAgICAgICAgICBjb25zdCBjbG9uZWRTZXNzaW9uID0gZGVlcENsb25lKHNlc3Npb25Ub1Byb2Nlc3MpOyAvLyBzZXNzaW9uVG9Qcm9jZXNzIHN0aWxsIGhhcyBpdHMgb3JpZ2luYWwgdXNlciBwcm9wZXJ0eVxuICAgICAgICAgICAgYXdhaXQgc2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5LCBjbG9uZWRTZXNzaW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfcmVtb3ZlU2Vzc2lvbigpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfcmVtb3ZlU2Vzc2lvbigpJyk7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyA9IGZhbHNlO1xuICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkgKyAnLWNvZGUtdmVyaWZpZXInKTtcbiAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5ICsgJy11c2VyJyk7XG4gICAgICAgIGlmICh0aGlzLnVzZXJTdG9yYWdlKSB7XG4gICAgICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy51c2VyU3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5ICsgJy11c2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9PVVQnLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbnkgcmVnaXN0ZXJlZCB2aXNpYmlsaXR5Y2hhbmdlIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICoge0BzZWUgI3N0YXJ0QXV0b1JlZnJlc2h9XG4gICAgICoge0BzZWUgI3N0b3BBdXRvUmVmcmVzaH1cbiAgICAgKi9cbiAgICBfcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpJyk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy52aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrO1xuICAgICAgICB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIGlzQnJvd3NlcigpICYmICh3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcikpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcigncmVtb3ZpbmcgdmlzaWJpbGl0eWNoYW5nZSBjYWxsYmFjayBmYWlsZWQnLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBwcml2YXRlIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayAjc3RhcnRBdXRvUmVmcmVzaH0uIFVzZSB0aGlzXG4gICAgICogd2l0aGluIHRoZSBsaWJyYXJ5LlxuICAgICAqL1xuICAgIGFzeW5jIF9zdGFydEF1dG9SZWZyZXNoKCkge1xuICAgICAgICBhd2FpdCB0aGlzLl9zdG9wQXV0b1JlZnJlc2goKTtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfc3RhcnRBdXRvUmVmcmVzaCgpJyk7XG4gICAgICAgIGNvbnN0IHRpY2tlciA9IHNldEludGVydmFsKCgpID0+IHRoaXMuX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCksIEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TKTtcbiAgICAgICAgdGhpcy5hdXRvUmVmcmVzaFRpY2tlciA9IHRpY2tlcjtcbiAgICAgICAgaWYgKHRpY2tlciAmJiB0eXBlb2YgdGlja2VyID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGlja2VyLnVucmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyB0aWNrZXIgaXMgYSBOb2RlSlMgVGltZW91dCBvYmplY3QgdGhhdCBoYXMgYW4gYHVucmVmYCBtZXRob2RcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvdGltZXJzLmh0bWwjdGltZW91dHVucmVmXG4gICAgICAgICAgICAvLyBXaGVuIGF1dG8gcmVmcmVzaCBpcyB1c2VkIGluIE5vZGVKUyAobGlrZSBmb3IgdGVzdGluZykgdGhlXG4gICAgICAgICAgICAvLyBgc2V0SW50ZXJ2YWxgIGlzIHByZXZlbnRpbmcgdGhlIHByb2Nlc3MgZnJvbSBiZWluZyBtYXJrZWQgYXNcbiAgICAgICAgICAgIC8vIGZpbmlzaGVkIGFuZCB0ZXN0cyBydW4gZW5kbGVzc2x5LiBUaGlzIGNhbiBiZSBwcmV2ZW50ZWQgYnkgY2FsbGluZ1xuICAgICAgICAgICAgLy8gYHVucmVmKClgIG9uIHRoZSByZXR1cm5lZCBvYmplY3QuXG4gICAgICAgICAgICB0aWNrZXIudW5yZWYoKTtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMgaGFzIG5vIGNvbnRleHQgb2YgRGVub1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBEZW5vICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgRGVuby51bnJlZlRpbWVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBzaW1pbGFyIGxpa2UgZm9yIE5vZGVKUywgYnV0IHdpdGggdGhlIERlbm8gQVBJXG4gICAgICAgICAgICAvLyBodHRwczovL2Rlbm8ubGFuZC9hcGlAbGF0ZXN0P3Vuc3RhYmxlJnM9RGVuby51bnJlZlRpbWVyXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTIGhhcyBubyBjb250ZXh0IG9mIERlbm9cbiAgICAgICAgICAgIERlbm8udW5yZWZUaW1lcih0aWNrZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJ1biB0aGUgdGljayBpbW1lZGlhdGVseSwgYnV0IGluIHRoZSBuZXh0IHBhc3Mgb2YgdGhlIGV2ZW50IGxvb3Agc28gdGhhdFxuICAgICAgICAvLyAjX2luaXRpYWxpemUgY2FuIGJlIGFsbG93ZWQgdG8gY29tcGxldGUgd2l0aG91dCByZWN1cnNpdmVseSB3YWl0aW5nIG9uXG4gICAgICAgIC8vIGl0c2VsZlxuICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fYXV0b1JlZnJlc2hUb2tlblRpY2soKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIHRoaXMuYXV0b1JlZnJlc2hUaWNrVGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIGlmICh0aW1lb3V0ICYmIHR5cGVvZiB0aW1lb3V0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGltZW91dC51bnJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGltZW91dC51bnJlZigpO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUUyBoYXMgbm8gY29udGV4dCBvZiBEZW5vXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIERlbm8gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBEZW5vLnVucmVmVGltZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMgaGFzIG5vIGNvbnRleHQgb2YgRGVub1xuICAgICAgICAgICAgRGVuby51bnJlZlRpbWVyKHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIHByaXZhdGUgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rICNzdG9wQXV0b1JlZnJlc2h9LiBVc2UgdGhpc1xuICAgICAqIHdpdGhpbiB0aGUgbGlicmFyeS5cbiAgICAgKi9cbiAgICBhc3luYyBfc3RvcEF1dG9SZWZyZXNoKCkge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19zdG9wQXV0b1JlZnJlc2goKScpO1xuICAgICAgICBjb25zdCB0aWNrZXIgPSB0aGlzLmF1dG9SZWZyZXNoVGlja2VyO1xuICAgICAgICB0aGlzLmF1dG9SZWZyZXNoVGlja2VyID0gbnVsbDtcbiAgICAgICAgaWYgKHRpY2tlcikge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aWNrZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSB0aGlzLmF1dG9SZWZyZXNoVGlja1RpbWVvdXQ7XG4gICAgICAgIHRoaXMuYXV0b1JlZnJlc2hUaWNrVGltZW91dCA9IG51bGw7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGFuIGF1dG8tcmVmcmVzaCBwcm9jZXNzIGluIHRoZSBiYWNrZ3JvdW5kLiBUaGUgc2Vzc2lvbiBpcyBjaGVja2VkXG4gICAgICogZXZlcnkgZmV3IHNlY29uZHMuIENsb3NlIHRvIHRoZSB0aW1lIG9mIGV4cGlyYXRpb24gYSBwcm9jZXNzIGlzIHN0YXJ0ZWQgdG9cbiAgICAgKiByZWZyZXNoIHRoZSBzZXNzaW9uLiBJZiByZWZyZXNoaW5nIGZhaWxzIGl0IHdpbGwgYmUgcmV0cmllZCBmb3IgYXMgbG9uZyBhc1xuICAgICAqIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIElmIHlvdSBzZXQgdGhlIHtAbGluayBHb1RydWVDbGllbnRPcHRpb25zI2F1dG9SZWZyZXNoVG9rZW59IHlvdSBkb24ndCBuZWVkXG4gICAgICogdG8gY2FsbCB0aGlzIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGNhbGxlZCBmb3IgeW91LlxuICAgICAqXG4gICAgICogT24gYnJvd3NlcnMgdGhlIHJlZnJlc2ggcHJvY2VzcyB3b3JrcyBvbmx5IHdoZW4gdGhlIHRhYi93aW5kb3cgaXMgaW4gdGhlXG4gICAgICogZm9yZWdyb3VuZCB0byBjb25zZXJ2ZSByZXNvdXJjZXMgYXMgd2VsbCBhcyBwcmV2ZW50IHJhY2UgY29uZGl0aW9ucyBhbmRcbiAgICAgKiBmbG9vZGluZyBhdXRoIHdpdGggcmVxdWVzdHMuIElmIHlvdSBjYWxsIHRoaXMgbWV0aG9kIGFueSBtYW5hZ2VkXG4gICAgICogdmlzaWJpbGl0eSBjaGFuZ2UgY2FsbGJhY2sgd2lsbCBiZSByZW1vdmVkIGFuZCB5b3UgbXVzdCBtYW5hZ2UgdmlzaWJpbGl0eVxuICAgICAqIGNoYW5nZXMgb24geW91ciBvd24uXG4gICAgICpcbiAgICAgKiBPbiBub24tYnJvd3NlciBwbGF0Zm9ybXMgdGhlIHJlZnJlc2ggcHJvY2VzcyB3b3JrcyAqY29udGludW91c2x5KiBpbiB0aGVcbiAgICAgKiBiYWNrZ3JvdW5kLCB3aGljaCBtYXkgbm90IGJlIGRlc2lyYWJsZS4gWW91IHNob3VsZCBob29rIGludG8geW91clxuICAgICAqIHBsYXRmb3JtJ3MgZm9yZWdyb3VuZCBpbmRpY2F0aW9uIG1lY2hhbmlzbSBhbmQgY2FsbCB0aGVzZSBtZXRob2RzXG4gICAgICogYXBwcm9wcmlhdGVseSB0byBjb25zZXJ2ZSByZXNvdXJjZXMuXG4gICAgICpcbiAgICAgKiB7QHNlZSAjc3RvcEF1dG9SZWZyZXNofVxuICAgICAqL1xuICAgIGFzeW5jIHN0YXJ0QXV0b1JlZnJlc2goKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2soKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fc3RhcnRBdXRvUmVmcmVzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wcyBhbiBhY3RpdmUgYXV0byByZWZyZXNoIHByb2Nlc3MgcnVubmluZyBpbiB0aGUgYmFja2dyb3VuZCAoaWYgYW55KS5cbiAgICAgKlxuICAgICAqIElmIHlvdSBjYWxsIHRoaXMgbWV0aG9kIGFueSBtYW5hZ2VkIHZpc2liaWxpdHkgY2hhbmdlIGNhbGxiYWNrIHdpbGwgYmVcbiAgICAgKiByZW1vdmVkIGFuZCB5b3UgbXVzdCBtYW5hZ2UgdmlzaWJpbGl0eSBjaGFuZ2VzIG9uIHlvdXIgb3duLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayAjc3RhcnRBdXRvUmVmcmVzaH0gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBzdG9wQXV0b1JlZnJlc2goKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2soKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fc3RvcEF1dG9SZWZyZXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIGF1dG8gcmVmcmVzaCB0b2tlbiB0aWNrLlxuICAgICAqL1xuICAgIGFzeW5jIF9hdXRvUmVmcmVzaFRva2VuVGljaygpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfYXV0b1JlZnJlc2hUb2tlblRpY2soKScsICdiZWdpbicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soMCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiB7IHNlc3Npb24gfSwgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb24gfHwgIXNlc3Npb24ucmVmcmVzaF90b2tlbiB8fCAhc2Vzc2lvbi5leHBpcmVzX2F0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCknLCAnbm8gc2Vzc2lvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlc3Npb24gd2lsbCBleHBpcmUgaW4gdGhpcyBtYW55IHRpY2tzIChvciBoYXMgYWxyZWFkeSBleHBpcmVkIGlmIDw9IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwaXJlc0luVGlja3MgPSBNYXRoLmZsb29yKChzZXNzaW9uLmV4cGlyZXNfYXQgKiAxMDAwIC0gbm93KSAvIEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hdXRvUmVmcmVzaFRva2VuVGljaygpJywgYGFjY2VzcyB0b2tlbiBleHBpcmVzIGluICR7ZXhwaXJlc0luVGlja3N9IHRpY2tzLCBhIHRpY2sgbGFzdHMgJHtBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTl9NU31tcywgcmVmcmVzaCB0aHJlc2hvbGQgaXMgJHtBVVRPX1JFRlJFU0hfVElDS19USFJFU0hPTER9IHRpY2tzYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGlyZXNJblRpY2tzIDw9IEFVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9jYWxsUmVmcmVzaFRva2VuKHNlc3Npb24ucmVmcmVzaF90b2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F1dG8gcmVmcmVzaCB0aWNrIGZhaWxlZCB3aXRoIGVycm9yLiBUaGlzIGlzIGxpa2VseSBhIHRyYW5zaWVudCBlcnJvci4nLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfYXV0b1JlZnJlc2hUb2tlblRpY2soKScsICdlbmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUuaXNBY3F1aXJlVGltZW91dCB8fCBlIGluc3RhbmNlb2YgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnYXV0byByZWZyZXNoIHRva2VuIHRpY2sgbG9jayBub3QgYXZhaWxhYmxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBjYWxsYmFja3Mgb24gdGhlIGJyb3dzZXIgLyBwbGF0Zm9ybSwgd2hpY2ggaW4tdHVybiBydW5cbiAgICAgKiBhbGdvcml0aG1zIHdoZW4gdGhlIGJyb3dzZXIgd2luZG93L3RhYiBhcmUgaW4gZm9yZWdyb3VuZC4gT24gbm9uLWJyb3dzZXJcbiAgICAgKiBwbGF0Zm9ybXMgaXQgYXNzdW1lcyBhbHdheXMgZm9yZWdyb3VuZC5cbiAgICAgKi9cbiAgICBhc3luYyBfaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpJyk7XG4gICAgICAgIGlmICghaXNCcm93c2VyKCkgfHwgISh3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudHMgdGhlIHJlZnJlc2ggdG9rZW4gdGlja2VyIHJ1bnMgYWx3YXlzXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEF1dG9SZWZyZXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjayA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9vblZpc2liaWxpdHlDaGFuZ2VkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjdmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaycsICdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2spO1xuICAgICAgICAgICAgLy8gbm93IGltbWVkaWF0ZWx5IGNhbGwgdGhlIHZpc2JpbGl0eSBjaGFuZ2VkIGNhbGxiYWNrIHRvIHNldHVwIHdpdGggdGhlXG4gICAgICAgICAgICAvLyBjdXJyZW50IHZpc2JpbGl0eSBzdGF0ZVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fb25WaXNpYmlsaXR5Q2hhbmdlZCh0cnVlKTsgLy8gaW5pdGlhbCBjYWxsXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdfaGFuZGxlVmlzaWJpbGl0eUNoYW5nZScsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayByZWdpc3RlcmVkIHdpdGggYHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJylgLlxuICAgICAqL1xuICAgIGFzeW5jIF9vblZpc2liaWxpdHlDaGFuZ2VkKGNhbGxlZEZyb21Jbml0aWFsaXplKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZE5hbWUgPSBgI19vblZpc2liaWxpdHlDaGFuZ2VkKCR7Y2FsbGVkRnJvbUluaXRpYWxpemV9KWA7XG4gICAgICAgIHRoaXMuX2RlYnVnKG1ldGhvZE5hbWUsICd2aXNpYmlsaXR5U3RhdGUnLCBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUpO1xuICAgICAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAndmlzaWJsZScpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBpbiBicm93c2VyIGVudmlyb25tZW50cyB0aGUgcmVmcmVzaCB0b2tlbiB0aWNrZXIgcnVucyBvbmx5IG9uIGZvY3VzZWQgdGFic1xuICAgICAgICAgICAgICAgIC8vIHdoaWNoIHByZXZlbnRzIHJhY2UgY29uZGl0aW9uc1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0QXV0b1JlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2FsbGVkRnJvbUluaXRpYWxpemUpIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxsZWQgd2hlbiB0aGUgdmlzaWJpbGl0eSBoYXMgY2hhbmdlZCwgaS5lLiB0aGUgYnJvd3NlclxuICAgICAgICAgICAgICAgIC8vIHRyYW5zaXRpb25lZCBmcm9tIGhpZGRlbiAtPiB2aXNpYmxlIHNvIHdlIG5lZWQgdG8gc2VlIGlmIHRoZSBzZXNzaW9uXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIHJlY292ZXJlZCBpbW1lZGlhdGVseS4uLiBidXQgdG8gZG8gdGhhdCB3ZSBuZWVkIHRvIGFjcXVpcmVcbiAgICAgICAgICAgICAgICAvLyB0aGUgbG9jayBmaXJzdCBhc3luY2hyb25vdXNseVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2sodGhpcy5sb2NrQWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSAhPT0gJ3Zpc2libGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhtZXRob2ROYW1lLCAnYWNxdWlyZWQgdGhlIGxvY2sgdG8gcmVjb3ZlciB0aGUgc2Vzc2lvbiwgYnV0IHRoZSBicm93c2VyIHZpc2liaWxpdHlTdGF0ZSBpcyBubyBsb25nZXIgdmlzaWJsZSwgYWJvcnRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZpc2liaWxpdHkgaGFzIGNoYW5nZWQgd2hpbGUgd2FpdGluZyBmb3IgdGhlIGxvY2ssIGFib3J0XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjb3ZlciB0aGUgc2Vzc2lvblxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZWNvdmVyQW5kUmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9wQXV0b1JlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgdGhlIHJlbGV2YW50IGxvZ2luIFVSTCBmb3IgYSB0aGlyZC1wYXJ0eSBwcm92aWRlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZWRpcmVjdFRvIEEgVVJMIG9yIG1vYmlsZSBhZGRyZXNzIHRvIHNlbmQgdGhlIHVzZXIgdG8gYWZ0ZXIgdGhleSBhcmUgY29uZmlybWVkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnNjb3BlcyBBIHNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIHNjb3BlcyBncmFudGVkIHRvIHRoZSBPQXV0aCBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5xdWVyeVBhcmFtcyBBbiBvYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIGNvbnRhaW5pbmcgcXVlcnkgcGFyYW1ldGVycyBncmFudGVkIHRvIHRoZSBPQXV0aCBhcHBsaWNhdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBfZ2V0VXJsRm9yUHJvdmlkZXIodXJsLCBwcm92aWRlciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBbYHByb3ZpZGVyPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHByb3ZpZGVyKX1gXTtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZWRpcmVjdFRvKSB7XG4gICAgICAgICAgICB1cmxQYXJhbXMucHVzaChgcmVkaXJlY3RfdG89JHtlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy5yZWRpcmVjdFRvKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNjb3Blcykge1xuICAgICAgICAgICAgdXJsUGFyYW1zLnB1c2goYHNjb3Blcz0ke2VuY29kZVVSSUNvbXBvbmVudChvcHRpb25zLnNjb3Blcyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICAgICAgY29uc3QgW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICBjb25zdCBmbG93UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGAke2VuY29kZVVSSUNvbXBvbmVudChjb2RlQ2hhbGxlbmdlKX1gLFxuICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGNvZGVDaGFsbGVuZ2VNZXRob2QpfWAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVybFBhcmFtcy5wdXNoKGZsb3dQYXJhbXMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5xdWVyeVBhcmFtcykge1xuICAgICAgICAgICAgY29uc3QgcXVlcnkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdGlvbnMucXVlcnlQYXJhbXMpO1xuICAgICAgICAgICAgdXJsUGFyYW1zLnB1c2gocXVlcnkudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5za2lwQnJvd3NlclJlZGlyZWN0KSB7XG4gICAgICAgICAgICB1cmxQYXJhbXMucHVzaChgc2tpcF9odHRwX3JlZGlyZWN0PSR7b3B0aW9ucy5za2lwQnJvd3NlclJlZGlyZWN0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt1cmx9PyR7dXJsUGFyYW1zLmpvaW4oJyYnKX1gO1xuICAgIH1cbiAgICBhc3luYyBfdW5lbnJvbGwocGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0RFTEVURScsIGAke3RoaXMudXJsfS9mYWN0b3JzLyR7cGFyYW1zLmZhY3RvcklkfWAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IChfYSA9IHNlc3Npb25EYXRhID09PSBudWxsIHx8IHNlc3Npb25EYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXNzaW9uRGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2Vucm9sbChwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gT2JqZWN0LmFzc2lnbih7IGZyaWVuZGx5X25hbWU6IHBhcmFtcy5mcmllbmRseU5hbWUsIGZhY3Rvcl90eXBlOiBwYXJhbXMuZmFjdG9yVHlwZSB9LCAocGFyYW1zLmZhY3RvclR5cGUgPT09ICdwaG9uZSdcbiAgICAgICAgICAgICAgICAgICAgPyB7IHBob25lOiBwYXJhbXMucGhvbmUgfVxuICAgICAgICAgICAgICAgICAgICA6IHBhcmFtcy5mYWN0b3JUeXBlID09PSAndG90cCdcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyBpc3N1ZXI6IHBhcmFtcy5pc3N1ZXIgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IChhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9mYWN0b3JzYCwge1xuICAgICAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogKF9hID0gc2Vzc2lvbkRhdGEgPT09IG51bGwgfHwgc2Vzc2lvbkRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb25EYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmFjdG9yVHlwZSA9PT0gJ3RvdHAnICYmIGRhdGEudHlwZSA9PT0gJ3RvdHAnICYmICgoX2IgPSBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEudG90cCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnFyX2NvZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEudG90cC5xcl9jb2RlID0gYGRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGYtOCwke2RhdGEudG90cC5xcl9jb2RlfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhLCBlcnJvcjogbnVsbCB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF92ZXJpZnkocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gT2JqZWN0LmFzc2lnbih7IGNoYWxsZW5nZV9pZDogcGFyYW1zLmNoYWxsZW5nZUlkIH0sICgnd2ViYXV0aG4nIGluIHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2ViYXV0aG46IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zLndlYmF1dGhuKSwgeyBjcmVkZW50aWFsX3Jlc3BvbnNlOiBwYXJhbXMud2ViYXV0aG4udHlwZSA9PT0gJ2NyZWF0ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2VyaWFsaXplQ3JlZGVudGlhbENyZWF0aW9uUmVzcG9uc2UocGFyYW1zLndlYmF1dGhuLmNyZWRlbnRpYWxfcmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHNlcmlhbGl6ZUNyZWRlbnRpYWxSZXF1ZXN0UmVzcG9uc2UocGFyYW1zLndlYmF1dGhuLmNyZWRlbnRpYWxfcmVzcG9uc2UpIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7IGNvZGU6IHBhcmFtcy5jb2RlIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vZmFjdG9ycy8ke3BhcmFtcy5mYWN0b3JJZH0vdmVyaWZ5YCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGp3dDogKF9hID0gc2Vzc2lvbkRhdGEgPT09IG51bGwgfHwgc2Vzc2lvbkRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb25EYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihPYmplY3QuYXNzaWduKHsgZXhwaXJlc19hdDogTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCkgKyBkYXRhLmV4cGlyZXNfaW4gfSwgZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnTUZBX0NIQUxMRU5HRV9WRVJJRklFRCcsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YSwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfY2hhbGxlbmdlKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWNxdWlyZUxvY2sodGhpcy5sb2NrQWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSAoYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vZmFjdG9ycy8ke3BhcmFtcy5mYWN0b3JJZH0vY2hhbGxlbmdlYCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgand0OiAoX2EgPSBzZXNzaW9uRGF0YSA9PT0gbnVsbCB8fCBzZXNzaW9uRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Vzc2lvbkRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEgfSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS50eXBlICE9PSAnd2ViYXV0aG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZGF0YS53ZWJhdXRobi50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjcmVhdGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0YSksIHsgd2ViYXV0aG46IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0YS53ZWJhdXRobiksIHsgY3JlZGVudGlhbF9vcHRpb25zOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEud2ViYXV0aG4uY3JlZGVudGlhbF9vcHRpb25zKSwgeyBwdWJsaWNLZXk6IGRlc2VyaWFsaXplQ3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucyhkYXRhLndlYmF1dGhuLmNyZWRlbnRpYWxfb3B0aW9ucy5wdWJsaWNLZXkpIH0pIH0pIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVxdWVzdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRhKSwgeyB3ZWJhdXRobjogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRhLndlYmF1dGhuKSwgeyBjcmVkZW50aWFsX29wdGlvbnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0YS53ZWJhdXRobi5jcmVkZW50aWFsX29wdGlvbnMpLCB7IHB1YmxpY0tleTogZGVzZXJpYWxpemVDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnMoZGF0YS53ZWJhdXRobi5jcmVkZW50aWFsX29wdGlvbnMucHVibGljS2V5KSB9KSB9KSB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BzZWUgR29UcnVlTUZBQXBpI2NoYWxsZW5nZUFuZFZlcmlmeX1cbiAgICAgKi9cbiAgICBhc3luYyBfY2hhbGxlbmdlQW5kVmVyaWZ5KHBhcmFtcykge1xuICAgICAgICAvLyBib3RoIF9jaGFsbGVuZ2UgYW5kIF92ZXJpZnkgaW5kZXBlbmRlbnRseSBhY3F1aXJlIHRoZSBsb2NrLCBzbyBubyBuZWVkXG4gICAgICAgIC8vIHRvIGFjcXVpcmUgaXQgaGVyZVxuICAgICAgICBjb25zdCB7IGRhdGE6IGNoYWxsZW5nZURhdGEsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9ID0gYXdhaXQgdGhpcy5fY2hhbGxlbmdlKHtcbiAgICAgICAgICAgIGZhY3RvcklkOiBwYXJhbXMuZmFjdG9ySWQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2hhbGxlbmdlRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogY2hhbGxlbmdlRXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3ZlcmlmeSh7XG4gICAgICAgICAgICBmYWN0b3JJZDogcGFyYW1zLmZhY3RvcklkLFxuICAgICAgICAgICAgY2hhbGxlbmdlSWQ6IGNoYWxsZW5nZURhdGEuaWQsXG4gICAgICAgICAgICBjb2RlOiBwYXJhbXMuY29kZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSNsaXN0RmFjdG9yc31cbiAgICAgKi9cbiAgICBhc3luYyBfbGlzdEZhY3RvcnMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gdXNlICNnZXRVc2VyIGluc3RlYWQgb2YgI19nZXRVc2VyIGFzIHRoZSBmb3JtZXIgYWNxdWlyZXMgYSBsb2NrXG4gICAgICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0sIGVycm9yOiB1c2VyRXJyb3IsIH0gPSBhd2FpdCB0aGlzLmdldFVzZXIoKTtcbiAgICAgICAgaWYgKHVzZXJFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHVzZXJFcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBhbGw6IFtdLFxuICAgICAgICAgICAgcGhvbmU6IFtdLFxuICAgICAgICAgICAgdG90cDogW10sXG4gICAgICAgICAgICB3ZWJhdXRobjogW10sXG4gICAgICAgIH07XG4gICAgICAgIC8vIGxvb3Agb3ZlciB0aGUgZmFjdG9ycyBPTkNFXG4gICAgICAgIGZvciAoY29uc3QgZmFjdG9yIG9mIChfYSA9IHVzZXIgPT09IG51bGwgfHwgdXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXNlci5mYWN0b3JzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSkge1xuICAgICAgICAgICAgZGF0YS5hbGwucHVzaChmYWN0b3IpO1xuICAgICAgICAgICAgaWYgKGZhY3Rvci5zdGF0dXMgPT09ICd2ZXJpZmllZCcpIHtcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgZGF0YVtmYWN0b3IuZmFjdG9yX3R5cGVdLnB1c2goZmFjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QHNlZSBHb1RydWVNRkFBcGkjZ2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsfVxuICAgICAqL1xuICAgIGFzeW5jIF9nZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWwoand0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgaWYgKGp3dCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBheWxvYWQgfSA9IGRlY29kZUpXVChqd3QpO1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50TGV2ZWwgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLmFhbCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBwYXlsb2FkLmFhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG5leHRMZXZlbCA9IGN1cnJlbnRMZXZlbDtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9LCBlcnJvcjogdXNlckVycm9yLCB9ID0gYXdhaXQgdGhpcy5nZXRVc2VyKGp3dCk7XG4gICAgICAgICAgICAgICAgaWYgKHVzZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IHVzZXJFcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdmVyaWZpZWRGYWN0b3JzID0gKF9iID0gKF9hID0gdXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLmZhY3RvcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maWx0ZXIoKGZhY3RvcikgPT4gZmFjdG9yLnN0YXR1cyA9PT0gJ3ZlcmlmaWVkJykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJpZmllZEZhY3RvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0TGV2ZWwgPSAnYWFsMic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRBdXRoZW50aWNhdGlvbk1ldGhvZHMgPSBwYXlsb2FkLmFtciB8fCBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IGN1cnJlbnRMZXZlbCwgbmV4dExldmVsLCBjdXJyZW50QXV0aGVudGljYXRpb25NZXRob2RzIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBkYXRhOiB7IHNlc3Npb24gfSwgZXJyb3I6IHNlc3Npb25FcnJvciwgfSA9IGF3YWl0IHRoaXMuZ2V0U2Vzc2lvbigpO1xuICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogeyBjdXJyZW50TGV2ZWw6IG51bGwsIG5leHRMZXZlbDogbnVsbCwgY3VycmVudEF1dGhlbnRpY2F0aW9uTWV0aG9kczogW10gfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwYXlsb2FkIH0gPSBkZWNvZGVKV1Qoc2Vzc2lvbi5hY2Nlc3NfdG9rZW4pO1xuICAgICAgICBsZXQgY3VycmVudExldmVsID0gbnVsbDtcbiAgICAgICAgaWYgKHBheWxvYWQuYWFsKSB7XG4gICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBwYXlsb2FkLmFhbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dExldmVsID0gY3VycmVudExldmVsO1xuICAgICAgICBjb25zdCB2ZXJpZmllZEZhY3RvcnMgPSAoX2QgPSAoX2MgPSBzZXNzaW9uLnVzZXIuZmFjdG9ycykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmZpbHRlcigoZmFjdG9yKSA9PiBmYWN0b3Iuc3RhdHVzID09PSAndmVyaWZpZWQnKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogW107XG4gICAgICAgIGlmICh2ZXJpZmllZEZhY3RvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbmV4dExldmVsID0gJ2FhbDInO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRBdXRoZW50aWNhdGlvbk1ldGhvZHMgPSBwYXlsb2FkLmFtciB8fCBbXTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBjdXJyZW50TGV2ZWwsIG5leHRMZXZlbCwgY3VycmVudEF1dGhlbnRpY2F0aW9uTWV0aG9kcyB9LCBlcnJvcjogbnVsbCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgZGV0YWlscyBhYm91dCBhbiBPQXV0aCBhdXRob3JpemF0aW9uIHJlcXVlc3QuXG4gICAgICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYXV0aG9yaXphdGlvbiBkZXRhaWxzIGluY2x1ZGluZyBjbGllbnQgaW5mbywgc2NvcGVzLCBhbmQgdXNlciBpbmZvcm1hdGlvbi5cbiAgICAgKiBJZiB0aGUgcmVzcG9uc2UgaW5jbHVkZXMgb25seSBhIHJlZGlyZWN0X3VybCBmaWVsZCwgaXQgbWVhbnMgY29uc2VudCB3YXMgYWxyZWFkeSBnaXZlbiAtIHRoZSBjYWxsZXJcbiAgICAgKiBzaG91bGQgaGFuZGxlIHRoZSByZWRpcmVjdCBtYW51YWxseSBpZiBuZWVkZWQuXG4gICAgICovXG4gICAgYXN5bmMgX2dldEF1dGhvcml6YXRpb25EZXRhaWxzKGF1dGhvcml6YXRpb25JZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yOiBzZXNzaW9uRXJyb3IsIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L29hdXRoL2F1dGhvcml6YXRpb25zLyR7YXV0aG9yaXphdGlvbklkfWAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IHNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogKGRhdGEpID0+ICh7IGRhdGEsIGVycm9yOiBudWxsIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwcm92ZXMgYW4gT0F1dGggYXV0aG9yaXphdGlvbiByZXF1ZXN0LlxuICAgICAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gICAgICovXG4gICAgYXN5bmMgX2FwcHJvdmVBdXRob3JpemF0aW9uKGF1dGhvcml6YXRpb25JZCwgb3B0aW9ucykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yOiBzZXNzaW9uRXJyb3IsIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vb2F1dGgvYXV0aG9yaXphdGlvbnMvJHthdXRob3JpemF0aW9uSWR9L2NvbnNlbnRgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiBzZXNzaW9uLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICAgICAgYm9keTogeyBhY3Rpb246ICdhcHByb3ZlJyB9LFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogKGRhdGEpID0+ICh7IGRhdGEsIGVycm9yOiBudWxsIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5kYXRhICYmIHJlc3BvbnNlLmRhdGEucmVkaXJlY3RfdXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEF1dG9tYXRpY2FsbHkgcmVkaXJlY3QgaW4gYnJvd3NlciB1bmxlc3Mgc2tpcEJyb3dzZXJSZWRpcmVjdCBpcyB0cnVlXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Jyb3dzZXIoKSAmJiAhKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5za2lwQnJvd3NlclJlZGlyZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbihyZXNwb25zZS5kYXRhLnJlZGlyZWN0X3VybCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVuaWVzIGFuIE9BdXRoIGF1dGhvcml6YXRpb24gcmVxdWVzdC5cbiAgICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgICAqL1xuICAgIGFzeW5jIF9kZW55QXV0aG9yaXphdGlvbihhdXRob3JpemF0aW9uSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9LCBlcnJvcjogc2Vzc2lvbkVycm9yLCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L29hdXRoL2F1dGhvcml6YXRpb25zLyR7YXV0aG9yaXphdGlvbklkfS9jb25zZW50YCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHsgYWN0aW9uOiAnZGVueScgfSxcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IChkYXRhKSA9PiAoeyBkYXRhLCBlcnJvcjogbnVsbCB9KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YSAmJiByZXNwb25zZS5kYXRhLnJlZGlyZWN0X3VybCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBdXRvbWF0aWNhbGx5IHJlZGlyZWN0IGluIGJyb3dzZXIgdW5sZXNzIHNraXBCcm93c2VyUmVkaXJlY3QgaXMgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCcm93c2VyKCkgJiYgIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2tpcEJyb3dzZXJSZWRpcmVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24ocmVzcG9uc2UuZGF0YS5yZWRpcmVjdF91cmwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIGFsbCBPQXV0aCBncmFudHMgdGhhdCB0aGUgYXV0aGVudGljYXRlZCB1c2VyIGhhcyBhdXRob3JpemVkLlxuICAgICAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gICAgICovXG4gICAgYXN5bmMgX2xpc3RPQXV0aEdyYW50cygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9LCBlcnJvcjogc2Vzc2lvbkVycm9yLCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS91c2VyL29hdXRoL2dyYW50c2AsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IHNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogKGRhdGEpID0+ICh7IGRhdGEsIGVycm9yOiBudWxsIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV2b2tlcyBhIHVzZXIncyBPQXV0aCBncmFudCBmb3IgYSBzcGVjaWZpYyBjbGllbnQuXG4gICAgICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAgICAgKi9cbiAgICBhc3luYyBfcmV2b2tlT0F1dGhHcmFudChvcHRpb25zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiB7IHNlc3Npb24gfSwgZXJyb3I6IHNlc3Npb25FcnJvciwgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yOiBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0RFTEVURScsIGAke3RoaXMudXJsfS91c2VyL29hdXRoL2dyYW50c2AsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IHNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeTogeyBjbGllbnRfaWQ6IG9wdGlvbnMuY2xpZW50SWQgfSxcbiAgICAgICAgICAgICAgICAgICAgbm9SZXNvbHZlSnNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7fSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZldGNoSndrKGtpZCwgandrcyA9IHsga2V5czogW10gfSkge1xuICAgICAgICAvLyB0cnkgZmV0Y2hpbmcgZnJvbSB0aGUgc3VwcGxpZWQgandrc1xuICAgICAgICBsZXQgandrID0gandrcy5rZXlzLmZpbmQoKGtleSkgPT4ga2V5LmtpZCA9PT0ga2lkKTtcbiAgICAgICAgaWYgKGp3aykge1xuICAgICAgICAgICAgcmV0dXJuIGp3aztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAvLyB0cnkgZmV0Y2hpbmcgZnJvbSBjYWNoZVxuICAgICAgICBqd2sgPSB0aGlzLmp3a3Mua2V5cy5maW5kKChrZXkpID0+IGtleS5raWQgPT09IGtpZCk7XG4gICAgICAgIC8vIGp3ayBleGlzdHMgYW5kIGp3a3MgaXNuJ3Qgc3RhbGVcbiAgICAgICAgaWYgKGp3ayAmJiB0aGlzLmp3a3NfY2FjaGVkX2F0ICsgSldLU19UVEwgPiBub3cpIHtcbiAgICAgICAgICAgIHJldHVybiBqd2s7XG4gICAgICAgIH1cbiAgICAgICAgLy8gandrIGlzbid0IGNhY2hlZCBpbiBtZW1vcnkgc28gd2UgbmVlZCB0byBmZXRjaCBpdCBmcm9tIHRoZSB3ZWxsLWtub3duIGVuZHBvaW50XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vLndlbGwta25vd24vandrcy5qc29uYCwge1xuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGEua2V5cyB8fCBkYXRhLmtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmp3a3MgPSBkYXRhO1xuICAgICAgICB0aGlzLmp3a3NfY2FjaGVkX2F0ID0gbm93O1xuICAgICAgICAvLyBGaW5kIHRoZSBzaWduaW5nIGtleVxuICAgICAgICBqd2sgPSBkYXRhLmtleXMuZmluZCgoa2V5KSA9PiBrZXkua2lkID09PSBraWQpO1xuICAgICAgICBpZiAoIWp3aykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGp3aztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIEpXVCBjbGFpbXMgcHJlc2VudCBpbiB0aGUgYWNjZXNzIHRva2VuIGJ5IGZpcnN0IHZlcmlmeWluZyB0aGVcbiAgICAgKiBKV1QgYWdhaW5zdCB0aGUgc2VydmVyJ3MgSlNPTiBXZWIgS2V5IFNldCBlbmRwb2ludFxuICAgICAqIGAvLndlbGwta25vd24vandrcy5qc29uYCB3aGljaCBpcyBvZnRlbiBjYWNoZWQsIHJlc3VsdGluZyBpbiBzaWduaWZpY2FudGx5XG4gICAgICogZmFzdGVyIHJlc3BvbnNlcy4gUHJlZmVyIHRoaXMgbWV0aG9kIG92ZXIge0BsaW5rICNnZXRVc2VyfSB3aGljaCBhbHdheXNcbiAgICAgKiBzZW5kcyBhIHJlcXVlc3QgdG8gdGhlIEF1dGggc2VydmVyIGZvciBlYWNoIEpXVC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBwcm9qZWN0IGlzIG5vdCB1c2luZyBhbiBhc3ltbWV0cmljIEpXVCBzaWduaW5nIGtleSAobGlrZSBFQ0Mgb3JcbiAgICAgKiBSU0EpIGl0IGFsd2F5cyBzZW5kcyBhIHJlcXVlc3QgdG8gdGhlIEF1dGggc2VydmVyIChzaW1pbGFyIHRvIHtAbGlua1xuICAgICAqICNnZXRVc2VyfSkgdG8gdmVyaWZ5IHRoZSBKV1QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gand0IEFuIG9wdGlvbmFsIHNwZWNpZmljIEpXVCB5b3Ugd2lzaCB0byB2ZXJpZnksIG5vdCB0aGUgb25lIHlvdVxuICAgICAqICAgICAgICAgICAgY2FuIG9idGFpbiBmcm9tIHtAbGluayAjZ2V0U2Vzc2lvbn0uXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVmFyaW91cyBhZGRpdGlvbmFsIG9wdGlvbnMgdGhhdCBhbGxvdyB5b3UgdG8gY3VzdG9taXplIHRoZVxuICAgICAqICAgICAgICAgICAgICAgIGJlaGF2aW9yIG9mIHRoaXMgbWV0aG9kLlxuICAgICAqL1xuICAgIGFzeW5jIGdldENsYWltcyhqd3QsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHRva2VuID0gand0O1xuICAgICAgICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuZ2V0U2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciB8fCAhZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBkYXRhLnNlc3Npb24uYWNjZXNzX3Rva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBoZWFkZXIsIHBheWxvYWQsIHNpZ25hdHVyZSwgcmF3OiB7IGhlYWRlcjogcmF3SGVhZGVyLCBwYXlsb2FkOiByYXdQYXlsb2FkIH0sIH0gPSBkZWNvZGVKV1QodG9rZW4pO1xuICAgICAgICAgICAgaWYgKCEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFsbG93RXhwaXJlZCkpIHtcbiAgICAgICAgICAgICAgICAvLyBSZWplY3QgZXhwaXJlZCBKV1RzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiBqd3QgYXJndW1lbnQgd2FzIHBhc3NlZFxuICAgICAgICAgICAgICAgIHZhbGlkYXRlRXhwKHBheWxvYWQuZXhwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNpZ25pbmdLZXkgPSAhaGVhZGVyLmFsZyB8fFxuICAgICAgICAgICAgICAgIGhlYWRlci5hbGcuc3RhcnRzV2l0aCgnSFMnKSB8fFxuICAgICAgICAgICAgICAgICFoZWFkZXIua2lkIHx8XG4gICAgICAgICAgICAgICAgISgnY3J5cHRvJyBpbiBnbG9iYWxUaGlzICYmICdzdWJ0bGUnIGluIGdsb2JhbFRoaXMuY3J5cHRvKVxuICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgIDogYXdhaXQgdGhpcy5mZXRjaEp3ayhoZWFkZXIua2lkLCAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmtleXMpID8geyBrZXlzOiBvcHRpb25zLmtleXMgfSA6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5qd2tzKTtcbiAgICAgICAgICAgIC8vIElmIHN5bW1ldHJpYyBhbGdvcml0aG0gb3IgV2ViQ3J5cHRvIEFQSSBpcyB1bmF2YWlsYWJsZSwgZmFsbGJhY2sgdG8gZ2V0VXNlcigpXG4gICAgICAgICAgICBpZiAoIXNpZ25pbmdLZXkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCB0aGlzLmdldFVzZXIodG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZ2V0VXNlciBzdWNjZWVkcyBzbyB0aGUgY2xhaW1zIGluIHRoZSBKV1QgY2FuIGJlIHRydXN0ZWRcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFpbXM6IHBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhbGdvcml0aG0gPSBnZXRBbGdvcml0aG0oaGVhZGVyLmFsZyk7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IEpXSyB0byBDcnlwdG9LZXlcbiAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdqd2snLCBzaWduaW5nS2V5LCBhbGdvcml0aG0sIHRydWUsIFtcbiAgICAgICAgICAgICAgICAndmVyaWZ5JyxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgLy8gVmVyaWZ5IHRoZSBzaWduYXR1cmVcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCBjcnlwdG8uc3VidGxlLnZlcmlmeShhbGdvcml0aG0sIHB1YmxpY0tleSwgc2lnbmF0dXJlLCBzdHJpbmdUb1VpbnQ4QXJyYXkoYCR7cmF3SGVhZGVyfS4ke3Jhd1BheWxvYWR9YCkpO1xuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbnZhbGlkSnd0RXJyb3IoJ0ludmFsaWQgSldUIHNpZ25hdHVyZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdmVyaWZpY2F0aW9uIHN1Y2NlZWRzLCBkZWNvZGUgYW5kIHJldHVybiBjbGFpbXNcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjbGFpbXM6IHBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcixcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufVxuR29UcnVlQ2xpZW50Lm5leHRJbnN0YW5jZUlEID0ge307XG5leHBvcnQgZGVmYXVsdCBHb1RydWVDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Hb1RydWVDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIkdvVHJ1ZUFkbWluQXBpIiwiQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVMiLCJBVVRPX1JFRlJFU0hfVElDS19USFJFU0hPTEQiLCJERUZBVUxUX0hFQURFUlMiLCJFWFBJUllfTUFSR0lOX01TIiwiR09UUlVFX1VSTCIsIkpXS1NfVFRMIiwiU1RPUkFHRV9LRVkiLCJBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IiLCJBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IiLCJBdXRoSW52YWxpZEp3dEVycm9yIiwiQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IiLCJBdXRoUEtDRUNvZGVWZXJpZmllck1pc3NpbmdFcnJvciIsIkF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvciIsIkF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yIiwiQXV0aFVua25vd25FcnJvciIsImlzQXV0aEFwaUVycm9yIiwiaXNBdXRoRXJyb3IiLCJpc0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciIsImlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IiLCJpc0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yIiwiX3JlcXVlc3QiLCJfc2Vzc2lvblJlc3BvbnNlIiwiX3Nlc3Npb25SZXNwb25zZVBhc3N3b3JkIiwiX3Nzb1Jlc3BvbnNlIiwiX3VzZXJSZXNwb25zZSIsImRlY29kZUpXVCIsImRlZXBDbG9uZSIsIkRlZmVycmVkIiwiZ2VuZXJhdGVDYWxsYmFja0lkIiwiZ2V0QWxnb3JpdGhtIiwiZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCIsImdldEl0ZW1Bc3luYyIsImluc2VjdXJlVXNlcldhcm5pbmdQcm94eSIsImlzQnJvd3NlciIsInBhcnNlUGFyYW1ldGVyc0Zyb21VUkwiLCJyZW1vdmVJdGVtQXN5bmMiLCJyZXNvbHZlRmV0Y2giLCJyZXRyeWFibGUiLCJzZXRJdGVtQXN5bmMiLCJzbGVlcCIsInN1cHBvcnRzTG9jYWxTdG9yYWdlIiwidXNlck5vdEF2YWlsYWJsZVByb3h5IiwidmFsaWRhdGVFeHAiLCJtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyIiwiTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IiLCJuYXZpZ2F0b3JMb2NrIiwicG9seWZpbGxHbG9iYWxUaGlzIiwidmVyc2lvbiIsImJ5dGVzVG9CYXNlNjRVUkwiLCJzdHJpbmdUb1VpbnQ4QXJyYXkiLCJjcmVhdGVTaXdlTWVzc2FnZSIsImZyb21IZXgiLCJnZXRBZGRyZXNzIiwidG9IZXgiLCJkZXNlcmlhbGl6ZUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMiLCJkZXNlcmlhbGl6ZUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9ucyIsInNlcmlhbGl6ZUNyZWRlbnRpYWxDcmVhdGlvblJlc3BvbnNlIiwic2VyaWFsaXplQ3JlZGVudGlhbFJlcXVlc3RSZXNwb25zZSIsIldlYkF1dGhuQXBpIiwiREVGQVVMVF9PUFRJT05TIiwidXJsIiwic3RvcmFnZUtleSIsImF1dG9SZWZyZXNoVG9rZW4iLCJwZXJzaXN0U2Vzc2lvbiIsImRldGVjdFNlc3Npb25JblVybCIsImhlYWRlcnMiLCJmbG93VHlwZSIsImRlYnVnIiwiaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlciIsInRocm93T25FcnJvciIsImxvY2tBY3F1aXJlVGltZW91dCIsInNraXBBdXRvSW5pdGlhbGl6ZSIsImxvY2tOb09wIiwibmFtZSIsImFjcXVpcmVUaW1lb3V0IiwiZm4iLCJHTE9CQUxfSldLUyIsIkdvVHJ1ZUNsaWVudCIsImp3a3MiLCJfYSIsIl9iIiwia2V5cyIsInZhbHVlIiwiT2JqZWN0IiwiYXNzaWduIiwiandrc19jYWNoZWRfYXQiLCJjYWNoZWRBdCIsIk51bWJlciIsIk1JTl9TQUZFX0lOVEVHRVIiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJfYyIsInVzZXJTdG9yYWdlIiwibWVtb3J5U3RvcmFnZSIsInN0YXRlQ2hhbmdlRW1pdHRlcnMiLCJNYXAiLCJhdXRvUmVmcmVzaFRpY2tlciIsImF1dG9SZWZyZXNoVGlja1RpbWVvdXQiLCJ2aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrIiwicmVmcmVzaGluZ0RlZmVycmVkIiwiaW5pdGlhbGl6ZVByb21pc2UiLCJzdXBwcmVzc0dldFNlc3Npb25XYXJuaW5nIiwibG9ja0FjcXVpcmVkIiwicGVuZGluZ0luTG9jayIsImJyb2FkY2FzdENoYW5uZWwiLCJsb2dnZXIiLCJjb25zb2xlIiwibG9nIiwic2V0dGluZ3MiLCJpbnN0YW5jZUlEIiwibmV4dEluc3RhbmNlSUQiLCJsb2dEZWJ1Z01lc3NhZ2VzIiwibWVzc2FnZSIsIl9sb2dQcmVmaXgiLCJ3YXJuIiwidHJhY2UiLCJhZG1pbiIsImZldGNoIiwibG9jayIsImdsb2JhbFRoaXMiLCJuYXZpZ2F0b3IiLCJsb2NrcyIsIm1mYSIsInZlcmlmeSIsIl92ZXJpZnkiLCJiaW5kIiwiZW5yb2xsIiwiX2Vucm9sbCIsInVuZW5yb2xsIiwiX3VuZW5yb2xsIiwiY2hhbGxlbmdlIiwiX2NoYWxsZW5nZSIsImxpc3RGYWN0b3JzIiwiX2xpc3RGYWN0b3JzIiwiY2hhbGxlbmdlQW5kVmVyaWZ5IiwiX2NoYWxsZW5nZUFuZFZlcmlmeSIsImdldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbCIsIl9nZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWwiLCJ3ZWJhdXRobiIsIm9hdXRoIiwiZ2V0QXV0aG9yaXphdGlvbkRldGFpbHMiLCJfZ2V0QXV0aG9yaXphdGlvbkRldGFpbHMiLCJhcHByb3ZlQXV0aG9yaXphdGlvbiIsIl9hcHByb3ZlQXV0aG9yaXphdGlvbiIsImRlbnlBdXRob3JpemF0aW9uIiwiX2RlbnlBdXRob3JpemF0aW9uIiwibGlzdEdyYW50cyIsIl9saXN0T0F1dGhHcmFudHMiLCJyZXZva2VHcmFudCIsIl9yZXZva2VPQXV0aEdyYW50Iiwic3RvcmFnZSIsImxvY2FsU3RvcmFnZSIsIkJyb2FkY2FzdENoYW5uZWwiLCJlIiwiZXJyb3IiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJfZGVidWciLCJfbm90aWZ5QWxsU3Vic2NyaWJlcnMiLCJkYXRhIiwic2Vzc2lvbiIsImluaXRpYWxpemUiLCJjYXRjaCIsImlzVGhyb3dPbkVycm9yRW5hYmxlZCIsIl9yZXR1cm5SZXN1bHQiLCJyZXN1bHQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJhcmdzIiwiX2FjcXVpcmVMb2NrIiwiX2luaXRpYWxpemUiLCJwYXJhbXMiLCJjYWxsYmFja1VybFR5cGUiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhyZWYiLCJfaXNJbXBsaWNpdEdyYW50Q2FsbGJhY2siLCJfaXNQS0NFQ2FsbGJhY2siLCJfZ2V0U2Vzc2lvbkZyb21VUkwiLCJlcnJvckNvZGUiLCJkZXRhaWxzIiwiY29kZSIsInJlZGlyZWN0VHlwZSIsIl9zYXZlU2Vzc2lvbiIsInNldFRpbWVvdXQiLCJfcmVjb3ZlckFuZFJlZnJlc2giLCJfaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSIsInNpZ25JbkFub255bW91c2x5IiwiY3JlZGVudGlhbHMiLCJyZXMiLCJib2R5IiwiZ290cnVlX21ldGFfc2VjdXJpdHkiLCJjYXB0Y2hhX3Rva2VuIiwiY2FwdGNoYVRva2VuIiwieGZvcm0iLCJ1c2VyIiwic2lnblVwIiwiZW1haWwiLCJwYXNzd29yZCIsImNvZGVDaGFsbGVuZ2UiLCJjb2RlQ2hhbGxlbmdlTWV0aG9kIiwicmVkaXJlY3RUbyIsImVtYWlsUmVkaXJlY3RUbyIsImNvZGVfY2hhbGxlbmdlIiwiY29kZV9jaGFsbGVuZ2VfbWV0aG9kIiwicGhvbmUiLCJjaGFubmVsIiwic2lnbkluV2l0aFBhc3N3b3JkIiwiaW52YWxpZFRva2VuRXJyb3IiLCJ3ZWFrX3Bhc3N3b3JkIiwid2Vha1Bhc3N3b3JkIiwic2lnbkluV2l0aE9BdXRoIiwiX2QiLCJfaGFuZGxlUHJvdmlkZXJTaWduSW4iLCJwcm92aWRlciIsInNjb3BlcyIsInF1ZXJ5UGFyYW1zIiwic2tpcEJyb3dzZXJSZWRpcmVjdCIsImV4Y2hhbmdlQ29kZUZvclNlc3Npb24iLCJhdXRoQ29kZSIsIl9leGNoYW5nZUNvZGVGb3JTZXNzaW9uIiwic2lnbkluV2l0aFdlYjMiLCJjaGFpbiIsInNpZ25JbldpdGhFdGhlcmV1bSIsInNpZ25JbldpdGhTb2xhbmEiLCJFcnJvciIsIl9lIiwiX2YiLCJfZyIsIl9oIiwiX2oiLCJfayIsIl9sIiwic2lnbmF0dXJlIiwid2FsbGV0Iiwic3RhdGVtZW50IiwicmVzb2x2ZWRXYWxsZXQiLCJ3aW5kb3dBbnkiLCJldGhlcmV1bSIsInJlcXVlc3QiLCJVUkwiLCJhY2NvdW50cyIsIm1ldGhvZCIsInRoZW4iLCJhY2NzIiwibGVuZ3RoIiwiYWRkcmVzcyIsImNoYWluSWQiLCJjaGFpbklkSGV4Iiwic2l3ZU1lc3NhZ2UiLCJkb21haW4iLCJob3N0IiwidXJpIiwibm9uY2UiLCJpc3N1ZWRBdCIsImV4cGlyYXRpb25UaW1lIiwibm90QmVmb3JlIiwicmVxdWVzdElkIiwicmVzb3VyY2VzIiwiX20iLCJzb2xhbmEiLCJzaWduSW4iLCJzaWduTWVzc2FnZSIsIm91dHB1dCIsIm91dHB1dFRvUHJvY2VzcyIsIkFycmF5IiwiaXNBcnJheSIsInNpZ25lZE1lc3NhZ2UiLCJVaW50OEFycmF5IiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJwdWJsaWNLZXkiLCJ0b0Jhc2U1OCIsIm1hcCIsInJlc291cmNlIiwiam9pbiIsIm1heWJlU2lnbmF0dXJlIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJzdG9yYWdlSXRlbSIsImNvZGVWZXJpZmllciIsInNwbGl0IiwiYXV0aF9jb2RlIiwiY29kZV92ZXJpZmllciIsInNpZ25JbldpdGhJZFRva2VuIiwidG9rZW4iLCJhY2Nlc3NfdG9rZW4iLCJpZF90b2tlbiIsInNpZ25JbldpdGhPdHAiLCJjcmVhdGVfdXNlciIsInNob3VsZENyZWF0ZVVzZXIiLCJtZXNzYWdlSWQiLCJtZXNzYWdlX2lkIiwidmVyaWZ5T3RwIiwidW5kZWZpbmVkIiwidG9rZW5WZXJpZmljYXRpb25FcnJvciIsInR5cGUiLCJzaWduSW5XaXRoU1NPIiwicHJvdmlkZXJfaWQiLCJwcm92aWRlcklkIiwicmVkaXJlY3RfdG8iLCJza2lwX2h0dHBfcmVkaXJlY3QiLCJyZWF1dGhlbnRpY2F0ZSIsIl9yZWF1dGhlbnRpY2F0ZSIsIl91c2VTZXNzaW9uIiwic2Vzc2lvbkVycm9yIiwiand0IiwicmVzZW5kIiwiZW5kcG9pbnQiLCJnZXRTZXNzaW9uIiwibGFzdCIsIlByb21pc2UiLCJyZXNvbHZlIiwicHVzaCIsIndhaXRPbiIsImFsbCIsInNwbGljZSIsIl9fbG9hZFNlc3Npb24iLCJzdGFjayIsImN1cnJlbnRTZXNzaW9uIiwibWF5YmVTZXNzaW9uIiwiX2lzVmFsaWRTZXNzaW9uIiwiX3JlbW92ZVNlc3Npb24iLCJoYXNFeHBpcmVkIiwiZXhwaXJlc19hdCIsIm5vdyIsIm1heWJlVXNlciIsImlzU2VydmVyIiwiX19pc1VzZXJOb3RBdmFpbGFibGVQcm94eSIsInN1cHByZXNzV2FybmluZ1JlZiIsIl9jYWxsUmVmcmVzaFRva2VuIiwicmVmcmVzaF90b2tlbiIsImdldFVzZXIiLCJfZ2V0VXNlciIsInVwZGF0ZVVzZXIiLCJhdHRyaWJ1dGVzIiwiX3VwZGF0ZVVzZXIiLCJzZXNzaW9uRGF0YSIsInVzZXJFcnJvciIsInNldFNlc3Npb24iLCJfc2V0U2Vzc2lvbiIsInRpbWVOb3ciLCJleHBpcmVzQXQiLCJwYXlsb2FkIiwiZXhwIiwicmVmcmVzaGVkU2Vzc2lvbiIsInRva2VuX3R5cGUiLCJleHBpcmVzX2luIiwicmVmcmVzaFNlc3Npb24iLCJfcmVmcmVzaFNlc3Npb24iLCJlcnJvcl9kZXNjcmlwdGlvbiIsImVycm9yX2NvZGUiLCJzZWFyY2hQYXJhbXMiLCJkZWxldGUiLCJoaXN0b3J5IiwicmVwbGFjZVN0YXRlIiwic3RhdGUiLCJ0b1N0cmluZyIsInByb3ZpZGVyX3Rva2VuIiwicHJvdmlkZXJfcmVmcmVzaF90b2tlbiIsIk1hdGgiLCJyb3VuZCIsImV4cGlyZXNJbiIsInBhcnNlSW50IiwiYWN0dWFsbHlFeHBpcmVzSW4iLCJoYXNoIiwiQm9vbGVhbiIsImN1cnJlbnRTdG9yYWdlQ29udGVudCIsInNpZ25PdXQiLCJzY29wZSIsIl9zaWduT3V0IiwiYWNjZXNzVG9rZW4iLCJzdGF0dXMiLCJvbkF1dGhTdGF0ZUNoYW5nZSIsImNhbGxiYWNrIiwiaWQiLCJzdWJzY3JpcHRpb24iLCJ1bnN1YnNjcmliZSIsInNldCIsIl9lbWl0SW5pdGlhbFNlc3Npb24iLCJnZXQiLCJlcnIiLCJyZXNldFBhc3N3b3JkRm9yRW1haWwiLCJnZXRVc2VySWRlbnRpdGllcyIsImlkZW50aXRpZXMiLCJsaW5rSWRlbnRpdHkiLCJsaW5rSWRlbnRpdHlJZFRva2VuIiwibGlua0lkZW50aXR5T0F1dGgiLCJfZ2V0VXJsRm9yUHJvdmlkZXIiLCJsaW5rX2lkZW50aXR5IiwidW5saW5rSWRlbnRpdHkiLCJpZGVudGl0eSIsImlkZW50aXR5X2lkIiwiX3JlZnJlc2hBY2Nlc3NUb2tlbiIsInJlZnJlc2hUb2tlbiIsImRlYnVnTmFtZSIsInN1YnN0cmluZyIsInN0YXJ0ZWRBdCIsImF0dGVtcHQiLCJwb3ciLCJuZXh0QmFja09mZkludGVydmFsIiwiaXNWYWxpZFNlc3Npb24iLCJpcyIsInNlcGFyYXRlVXNlciIsImV4cGlyZXNXaXRoTWFyZ2luIiwiSW5maW5pdHkiLCJnZXRVc2VyRXJyb3IiLCJwcm9taXNlIiwicmVqZWN0IiwiYnJvYWRjYXN0IiwicG9zdE1lc3NhZ2UiLCJlcnJvcnMiLCJwcm9taXNlcyIsImZyb20iLCJ2YWx1ZXMiLCJ4IiwiaSIsInNlc3Npb25Ub1Byb2Nlc3MiLCJ1c2VySXNQcm94eSIsIm1haW5TZXNzaW9uRGF0YSIsImNsb25lZE1haW5TZXNzaW9uRGF0YSIsImNsb25lZFNlc3Npb24iLCJfcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjayIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJfc3RhcnRBdXRvUmVmcmVzaCIsIl9zdG9wQXV0b1JlZnJlc2giLCJ0aWNrZXIiLCJzZXRJbnRlcnZhbCIsIl9hdXRvUmVmcmVzaFRva2VuVGljayIsInVucmVmIiwiRGVubyIsInVucmVmVGltZXIiLCJ0aW1lb3V0IiwiY2xlYXJJbnRlcnZhbCIsImNsZWFyVGltZW91dCIsInN0YXJ0QXV0b1JlZnJlc2giLCJzdG9wQXV0b1JlZnJlc2giLCJleHBpcmVzSW5UaWNrcyIsImZsb29yIiwiaXNBY3F1aXJlVGltZW91dCIsIl9vblZpc2liaWxpdHlDaGFuZ2VkIiwiY2FsbGVkRnJvbUluaXRpYWxpemUiLCJtZXRob2ROYW1lIiwiZG9jdW1lbnQiLCJ2aXNpYmlsaXR5U3RhdGUiLCJ1cmxQYXJhbXMiLCJlbmNvZGVVUklDb21wb25lbnQiLCJmbG93UGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwicXVlcnkiLCJmYWN0b3JJZCIsImZyaWVuZGx5X25hbWUiLCJmcmllbmRseU5hbWUiLCJmYWN0b3JfdHlwZSIsImZhY3RvclR5cGUiLCJpc3N1ZXIiLCJ0b3RwIiwicXJfY29kZSIsImNoYWxsZW5nZV9pZCIsImNoYWxsZW5nZUlkIiwiY3JlZGVudGlhbF9yZXNwb25zZSIsInJlc3BvbnNlIiwiY3JlZGVudGlhbF9vcHRpb25zIiwiY2hhbGxlbmdlRGF0YSIsImNoYWxsZW5nZUVycm9yIiwiZmFjdG9yIiwiZmFjdG9ycyIsImN1cnJlbnRMZXZlbCIsImFhbCIsIm5leHRMZXZlbCIsInZlcmlmaWVkRmFjdG9ycyIsImZpbHRlciIsImN1cnJlbnRBdXRoZW50aWNhdGlvbk1ldGhvZHMiLCJhbXIiLCJhdXRob3JpemF0aW9uSWQiLCJhY3Rpb24iLCJyZWRpcmVjdF91cmwiLCJjbGllbnRfaWQiLCJjbGllbnRJZCIsIm5vUmVzb2x2ZUpzb24iLCJmZXRjaEp3ayIsImtpZCIsImp3ayIsImZpbmQiLCJrZXkiLCJnZXRDbGFpbXMiLCJoZWFkZXIiLCJyYXciLCJyYXdIZWFkZXIiLCJyYXdQYXlsb2FkIiwiYWxsb3dFeHBpcmVkIiwic2lnbmluZ0tleSIsImFsZyIsInN0YXJ0c1dpdGgiLCJjcnlwdG8iLCJjbGFpbXMiLCJhbGdvcml0aG0iLCJzdWJ0bGUiLCJpbXBvcnRLZXkiLCJpc1ZhbGlkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthAdminApi: () => (/* reexport safe */ _AuthAdminApi__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   AuthApiError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthApiError),\n/* harmony export */   AuthClient: () => (/* reexport safe */ _AuthClient__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   AuthError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthError),\n/* harmony export */   AuthImplicitGrantRedirectError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthImplicitGrantRedirectError),\n/* harmony export */   AuthInvalidCredentialsError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthInvalidCredentialsError),\n/* harmony export */   AuthInvalidJwtError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthInvalidJwtError),\n/* harmony export */   AuthInvalidTokenResponseError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthInvalidTokenResponseError),\n/* harmony export */   AuthPKCECodeVerifierMissingError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthPKCECodeVerifierMissingError),\n/* harmony export */   AuthPKCEGrantCodeExchangeError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthPKCEGrantCodeExchangeError),\n/* harmony export */   AuthRetryableFetchError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthRetryableFetchError),\n/* harmony export */   AuthSessionMissingError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthSessionMissingError),\n/* harmony export */   AuthUnknownError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthUnknownError),\n/* harmony export */   AuthWeakPasswordError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthWeakPasswordError),\n/* harmony export */   CustomAuthError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.CustomAuthError),\n/* harmony export */   GoTrueAdminApi: () => (/* reexport safe */ _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   GoTrueClient: () => (/* reexport safe */ _GoTrueClient__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   NavigatorLockAcquireTimeoutError: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.NavigatorLockAcquireTimeoutError),\n/* harmony export */   SIGN_OUT_SCOPES: () => (/* reexport safe */ _lib_types__WEBPACK_IMPORTED_MODULE_4__.SIGN_OUT_SCOPES),\n/* harmony export */   isAuthApiError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthApiError),\n/* harmony export */   isAuthError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthError),\n/* harmony export */   isAuthImplicitGrantRedirectError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthImplicitGrantRedirectError),\n/* harmony export */   isAuthPKCECodeVerifierMissingError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthPKCECodeVerifierMissingError),\n/* harmony export */   isAuthRetryableFetchError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthRetryableFetchError),\n/* harmony export */   isAuthSessionMissingError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthSessionMissingError),\n/* harmony export */   isAuthWeakPasswordError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthWeakPasswordError),\n/* harmony export */   lockInternals: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.internals),\n/* harmony export */   navigatorLock: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.navigatorLock),\n/* harmony export */   processLock: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.processLock)\n/* harmony export */ });\n/* harmony import */ var _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueAdminApi */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\");\n/* harmony import */ var _GoTrueClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GoTrueClient */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js\");\n/* harmony import */ var _AuthAdminApi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AuthAdminApi */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js\");\n/* harmony import */ var _AuthClient__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AuthClient */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/AuthClient.js\");\n/* harmony import */ var _lib_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/types */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/types.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/errors */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n/* harmony import */ var _lib_locks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/locks */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js\");\n\n\n\n\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQThDO0FBQ0o7QUFDQTtBQUNKO0FBQzRCO0FBQ3RDO0FBQ0M7QUFDMkYsQ0FDeEgsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5jaG9yLXdvcmtmbG93cy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9pbmRleC5qcz81NTA4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBHb1RydWVBZG1pbkFwaSBmcm9tICcuL0dvVHJ1ZUFkbWluQXBpJztcbmltcG9ydCBHb1RydWVDbGllbnQgZnJvbSAnLi9Hb1RydWVDbGllbnQnO1xuaW1wb3J0IEF1dGhBZG1pbkFwaSBmcm9tICcuL0F1dGhBZG1pbkFwaSc7XG5pbXBvcnQgQXV0aENsaWVudCBmcm9tICcuL0F1dGhDbGllbnQnO1xuZXhwb3J0IHsgR29UcnVlQWRtaW5BcGksIEdvVHJ1ZUNsaWVudCwgQXV0aEFkbWluQXBpLCBBdXRoQ2xpZW50IH07XG5leHBvcnQgKiBmcm9tICcuL2xpYi90eXBlcyc7XG5leHBvcnQgKiBmcm9tICcuL2xpYi9lcnJvcnMnO1xuZXhwb3J0IHsgbmF2aWdhdG9yTG9jaywgTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IsIGludGVybmFscyBhcyBsb2NrSW50ZXJuYWxzLCBwcm9jZXNzTG9jaywgfSBmcm9tICcuL2xpYi9sb2Nrcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiR29UcnVlQWRtaW5BcGkiLCJHb1RydWVDbGllbnQiLCJBdXRoQWRtaW5BcGkiLCJBdXRoQ2xpZW50IiwibmF2aWdhdG9yTG9jayIsIk5hdmlnYXRvckxvY2tBY3F1aXJlVGltZW91dEVycm9yIiwiaW50ZXJuYWxzIiwibG9ja0ludGVybmFscyIsInByb2Nlc3NMb2NrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/base64url.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/base64url.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base64UrlToUint8Array: () => (/* binding */ base64UrlToUint8Array),\n/* harmony export */   byteFromBase64URL: () => (/* binding */ byteFromBase64URL),\n/* harmony export */   byteToBase64URL: () => (/* binding */ byteToBase64URL),\n/* harmony export */   bytesToBase64URL: () => (/* binding */ bytesToBase64URL),\n/* harmony export */   codepointToUTF8: () => (/* binding */ codepointToUTF8),\n/* harmony export */   stringFromBase64URL: () => (/* binding */ stringFromBase64URL),\n/* harmony export */   stringFromUTF8: () => (/* binding */ stringFromUTF8),\n/* harmony export */   stringToBase64URL: () => (/* binding */ stringToBase64URL),\n/* harmony export */   stringToUTF8: () => (/* binding */ stringToUTF8),\n/* harmony export */   stringToUint8Array: () => (/* binding */ stringToUint8Array)\n/* harmony export */ });\n/**\n * Avoid modifying this file. It's part of\n * https://github.com/supabase-community/base64url-js.  Submit all fixes on\n * that repo!\n */ /**\n * An array of characters that encode 6 bits into a Base64-URL alphabet\n * character.\n */ const TO_BASE64URL = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\".split(\"\");\n/**\n * An array of characters that can appear in a Base64-URL encoded string but\n * should be ignored.\n */ const IGNORE_BASE64URL = \" \t\\n\\r=\".split(\"\");\n/**\n * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2\n * used to skip the character, or if -1 used to error out.\n */ const FROM_BASE64URL = (()=>{\n    const charMap = new Array(128);\n    for(let i = 0; i < charMap.length; i += 1){\n        charMap[i] = -1;\n    }\n    for(let i = 0; i < IGNORE_BASE64URL.length; i += 1){\n        charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;\n    }\n    for(let i = 0; i < TO_BASE64URL.length; i += 1){\n        charMap[TO_BASE64URL[i].charCodeAt(0)] = i;\n    }\n    return charMap;\n})();\n/**\n * Converts a byte to a Base64-URL string.\n *\n * @param byte The byte to convert, or null to flush at the end of the byte sequence.\n * @param state The Base64 conversion state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next Base64 character when ready.\n */ function byteToBase64URL(byte, state, emit) {\n    if (byte !== null) {\n        state.queue = state.queue << 8 | byte;\n        state.queuedBits += 8;\n        while(state.queuedBits >= 6){\n            const pos = state.queue >> state.queuedBits - 6 & 63;\n            emit(TO_BASE64URL[pos]);\n            state.queuedBits -= 6;\n        }\n    } else if (state.queuedBits > 0) {\n        state.queue = state.queue << 6 - state.queuedBits;\n        state.queuedBits = 6;\n        while(state.queuedBits >= 6){\n            const pos = state.queue >> state.queuedBits - 6 & 63;\n            emit(TO_BASE64URL[pos]);\n            state.queuedBits -= 6;\n        }\n    }\n}\n/**\n * Converts a String char code (extracted using `string.charCodeAt(position)`) to a sequence of Base64-URL characters.\n *\n * @param charCode The char code of the JavaScript string.\n * @param state The Base64 state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next byte.\n */ function byteFromBase64URL(charCode, state, emit) {\n    const bits = FROM_BASE64URL[charCode];\n    if (bits > -1) {\n        // valid Base64-URL character\n        state.queue = state.queue << 6 | bits;\n        state.queuedBits += 6;\n        while(state.queuedBits >= 8){\n            emit(state.queue >> state.queuedBits - 8 & 0xff);\n            state.queuedBits -= 8;\n        }\n    } else if (bits === -2) {\n        // ignore spaces, tabs, newlines, =\n        return;\n    } else {\n        throw new Error(`Invalid Base64-URL character \"${String.fromCharCode(charCode)}\"`);\n    }\n}\n/**\n * Converts a JavaScript string (which may include any valid character) into a\n * Base64-URL encoded string. The string is first encoded in UTF-8 which is\n * then encoded as Base64-URL.\n *\n * @param str The string to convert.\n */ function stringToBase64URL(str) {\n    const base64 = [];\n    const emitter = (char)=>{\n        base64.push(char);\n    };\n    const state = {\n        queue: 0,\n        queuedBits: 0\n    };\n    stringToUTF8(str, (byte)=>{\n        byteToBase64URL(byte, state, emitter);\n    });\n    byteToBase64URL(null, state, emitter);\n    return base64.join(\"\");\n}\n/**\n * Converts a Base64-URL encoded string into a JavaScript string. It is assumed\n * that the underlying string has been encoded as UTF-8.\n *\n * @param str The Base64-URL encoded string.\n */ function stringFromBase64URL(str) {\n    const conv = [];\n    const utf8Emit = (codepoint)=>{\n        conv.push(String.fromCodePoint(codepoint));\n    };\n    const utf8State = {\n        utf8seq: 0,\n        codepoint: 0\n    };\n    const b64State = {\n        queue: 0,\n        queuedBits: 0\n    };\n    const byteEmit = (byte)=>{\n        stringFromUTF8(byte, utf8State, utf8Emit);\n    };\n    for(let i = 0; i < str.length; i += 1){\n        byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit);\n    }\n    return conv.join(\"\");\n}\n/**\n * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.\n *\n * @param codepoint The Unicode codepoint.\n * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.\n */ function codepointToUTF8(codepoint, emit) {\n    if (codepoint <= 0x7f) {\n        emit(codepoint);\n        return;\n    } else if (codepoint <= 0x7ff) {\n        emit(0xc0 | codepoint >> 6);\n        emit(0x80 | codepoint & 0x3f);\n        return;\n    } else if (codepoint <= 0xffff) {\n        emit(0xe0 | codepoint >> 12);\n        emit(0x80 | codepoint >> 6 & 0x3f);\n        emit(0x80 | codepoint & 0x3f);\n        return;\n    } else if (codepoint <= 0x10ffff) {\n        emit(0xf0 | codepoint >> 18);\n        emit(0x80 | codepoint >> 12 & 0x3f);\n        emit(0x80 | codepoint >> 6 & 0x3f);\n        emit(0x80 | codepoint & 0x3f);\n        return;\n    }\n    throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);\n}\n/**\n * Converts a JavaScript string to a sequence of UTF-8 bytes.\n *\n * @param str  The string to convert to UTF-8.\n * @param emit Function which will be called for each UTF-8 byte of the string.\n */ function stringToUTF8(str, emit) {\n    for(let i = 0; i < str.length; i += 1){\n        let codepoint = str.charCodeAt(i);\n        if (codepoint > 0xd7ff && codepoint <= 0xdbff) {\n            // most UTF-16 codepoints are Unicode codepoints, except values in this\n            // range where the next UTF-16 codepoint needs to be combined with the\n            // current one to get the Unicode codepoint\n            const highSurrogate = (codepoint - 0xd800) * 0x400 & 0xffff;\n            const lowSurrogate = str.charCodeAt(i + 1) - 0xdc00 & 0xffff;\n            codepoint = (lowSurrogate | highSurrogate) + 0x10000;\n            i += 1;\n        }\n        codepointToUTF8(codepoint, emit);\n    }\n}\n/**\n * Converts a UTF-8 byte to a Unicode codepoint.\n *\n * @param byte  The UTF-8 byte next in the sequence.\n * @param state The shared state between consecutive UTF-8 bytes in the\n *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.\n * @param emit  Function which will be called for each codepoint.\n */ function stringFromUTF8(byte, state, emit) {\n    if (state.utf8seq === 0) {\n        if (byte <= 0x7f) {\n            emit(byte);\n            return;\n        }\n        // count the number of 1 leading bits until you reach 0\n        for(let leadingBit = 1; leadingBit < 6; leadingBit += 1){\n            if ((byte >> 7 - leadingBit & 1) === 0) {\n                state.utf8seq = leadingBit;\n                break;\n            }\n        }\n        if (state.utf8seq === 2) {\n            state.codepoint = byte & 31;\n        } else if (state.utf8seq === 3) {\n            state.codepoint = byte & 15;\n        } else if (state.utf8seq === 4) {\n            state.codepoint = byte & 7;\n        } else {\n            throw new Error(\"Invalid UTF-8 sequence\");\n        }\n        state.utf8seq -= 1;\n    } else if (state.utf8seq > 0) {\n        if (byte <= 0x7f) {\n            throw new Error(\"Invalid UTF-8 sequence\");\n        }\n        state.codepoint = state.codepoint << 6 | byte & 63;\n        state.utf8seq -= 1;\n        if (state.utf8seq === 0) {\n            emit(state.codepoint);\n        }\n    }\n}\n/**\n * Helper functions to convert different types of strings to Uint8Array\n */ function base64UrlToUint8Array(str) {\n    const result = [];\n    const state = {\n        queue: 0,\n        queuedBits: 0\n    };\n    const onByte = (byte)=>{\n        result.push(byte);\n    };\n    for(let i = 0; i < str.length; i += 1){\n        byteFromBase64URL(str.charCodeAt(i), state, onByte);\n    }\n    return new Uint8Array(result);\n}\nfunction stringToUint8Array(str) {\n    const result = [];\n    stringToUTF8(str, (byte)=>result.push(byte));\n    return new Uint8Array(result);\n}\nfunction bytesToBase64URL(bytes) {\n    const result = [];\n    const state = {\n        queue: 0,\n        queuedBits: 0\n    };\n    const onChar = (char)=>{\n        result.push(char);\n    };\n    bytes.forEach((byte)=>byteToBase64URL(byte, state, onChar));\n    // always call with `null` after processing all bytes\n    byteToBase64URL(null, state, onChar);\n    return result.join(\"\");\n} //# sourceMappingURL=base64url.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2Jhc2U2NHVybC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Q0FJQyxHQUNEOzs7Q0FHQyxHQUNELE1BQU1BLGVBQWUsbUVBQW1FQyxLQUFLLENBQUM7QUFDOUY7OztDQUdDLEdBQ0QsTUFBTUMsbUJBQW1CLFVBQVdELEtBQUssQ0FBQztBQUMxQzs7O0NBR0MsR0FDRCxNQUFNRSxpQkFBaUIsQ0FBQztJQUNwQixNQUFNQyxVQUFVLElBQUlDLE1BQU07SUFDMUIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLFFBQVFHLE1BQU0sRUFBRUQsS0FBSyxFQUFHO1FBQ3hDRixPQUFPLENBQUNFLEVBQUUsR0FBRyxDQUFDO0lBQ2xCO0lBQ0EsSUFBSyxJQUFJQSxJQUFJLEdBQUdBLElBQUlKLGlCQUFpQkssTUFBTSxFQUFFRCxLQUFLLEVBQUc7UUFDakRGLE9BQU8sQ0FBQ0YsZ0JBQWdCLENBQUNJLEVBQUUsQ0FBQ0UsVUFBVSxDQUFDLEdBQUcsR0FBRyxDQUFDO0lBQ2xEO0lBQ0EsSUFBSyxJQUFJRixJQUFJLEdBQUdBLElBQUlOLGFBQWFPLE1BQU0sRUFBRUQsS0FBSyxFQUFHO1FBQzdDRixPQUFPLENBQUNKLFlBQVksQ0FBQ00sRUFBRSxDQUFDRSxVQUFVLENBQUMsR0FBRyxHQUFHRjtJQUM3QztJQUNBLE9BQU9GO0FBQ1g7QUFDQTs7Ozs7O0NBTUMsR0FDTSxTQUFTSyxnQkFBZ0JDLElBQUksRUFBRUMsS0FBSyxFQUFFQyxJQUFJO0lBQzdDLElBQUlGLFNBQVMsTUFBTTtRQUNmQyxNQUFNRSxLQUFLLEdBQUcsTUFBT0EsS0FBSyxJQUFJLElBQUtIO1FBQ25DQyxNQUFNRyxVQUFVLElBQUk7UUFDcEIsTUFBT0gsTUFBTUcsVUFBVSxJQUFJLEVBQUc7WUFDMUIsTUFBTUMsTUFBTSxNQUFPRixLQUFLLElBQUtGLE1BQU1HLFVBQVUsR0FBRyxJQUFN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O0FBQzFCO0FBQ08sU0FBU0ksaUJBQWlCQyxLQUFLO0lBQ2xDLE1BQU1MLFNBQVMsRUFBRTtJQUNqQixNQUFNbkMsUUFBUTtRQUFFRSxPQUFPO1FBQUdDLFlBQVk7SUFBRTtJQUN4QyxNQUFNc0MsU0FBUyxDQUFDMUI7UUFDWm9CLE9BQU9uQixJQUFJLENBQUNEO0lBQ2hCO0lBQ0F5QixNQUFNRSxPQUFPLENBQUMsQ0FBQzNDLE9BQVNELGdCQUFnQkMsTUFBTUMsT0FBT3lDO0lBQ3JELHFEQUFxRDtJQUNyRDNDLGdCQUFnQixNQUFNRSxPQUFPeUM7SUFDN0IsT0FBT04sT0FBT2pCLElBQUksQ0FBQztBQUN2QixFQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FuY2hvci13b3JrZmxvd3MvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2Jhc2U2NHVybC5qcz8xNWRlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQXZvaWQgbW9kaWZ5aW5nIHRoaXMgZmlsZS4gSXQncyBwYXJ0IG9mXG4gKiBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2UtY29tbXVuaXR5L2Jhc2U2NHVybC1qcy4gIFN1Ym1pdCBhbGwgZml4ZXMgb25cbiAqIHRoYXQgcmVwbyFcbiAqL1xuLyoqXG4gKiBBbiBhcnJheSBvZiBjaGFyYWN0ZXJzIHRoYXQgZW5jb2RlIDYgYml0cyBpbnRvIGEgQmFzZTY0LVVSTCBhbHBoYWJldFxuICogY2hhcmFjdGVyLlxuICovXG5jb25zdCBUT19CQVNFNjRVUkwgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXycuc3BsaXQoJycpO1xuLyoqXG4gKiBBbiBhcnJheSBvZiBjaGFyYWN0ZXJzIHRoYXQgY2FuIGFwcGVhciBpbiBhIEJhc2U2NC1VUkwgZW5jb2RlZCBzdHJpbmcgYnV0XG4gKiBzaG91bGQgYmUgaWdub3JlZC5cbiAqL1xuY29uc3QgSUdOT1JFX0JBU0U2NFVSTCA9ICcgXFx0XFxuXFxyPScuc3BsaXQoJycpO1xuLyoqXG4gKiBBbiBhcnJheSBvZiAxMjggbnVtYmVycyB0aGF0IG1hcCBhIEJhc2U2NC1VUkwgY2hhcmFjdGVyIHRvIDYgYml0cywgb3IgaWYgLTJcbiAqIHVzZWQgdG8gc2tpcCB0aGUgY2hhcmFjdGVyLCBvciBpZiAtMSB1c2VkIHRvIGVycm9yIG91dC5cbiAqL1xuY29uc3QgRlJPTV9CQVNFNjRVUkwgPSAoKCkgPT4ge1xuICAgIGNvbnN0IGNoYXJNYXAgPSBuZXcgQXJyYXkoMTI4KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJNYXAubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY2hhck1hcFtpXSA9IC0xO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IElHTk9SRV9CQVNFNjRVUkwubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY2hhck1hcFtJR05PUkVfQkFTRTY0VVJMW2ldLmNoYXJDb2RlQXQoMCldID0gLTI7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgVE9fQkFTRTY0VVJMLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNoYXJNYXBbVE9fQkFTRTY0VVJMW2ldLmNoYXJDb2RlQXQoMCldID0gaTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJNYXA7XG59KSgpO1xuLyoqXG4gKiBDb252ZXJ0cyBhIGJ5dGUgdG8gYSBCYXNlNjQtVVJMIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gYnl0ZSBUaGUgYnl0ZSB0byBjb252ZXJ0LCBvciBudWxsIHRvIGZsdXNoIGF0IHRoZSBlbmQgb2YgdGhlIGJ5dGUgc2VxdWVuY2UuXG4gKiBAcGFyYW0gc3RhdGUgVGhlIEJhc2U2NCBjb252ZXJzaW9uIHN0YXRlLiBQYXNzIGFuIGluaXRpYWwgdmFsdWUgb2YgYHsgcXVldWU6IDAsIHF1ZXVlZEJpdHM6IDAgfWAuXG4gKiBAcGFyYW0gZW1pdCBBIGZ1bmN0aW9uIGNhbGxlZCB3aXRoIHRoZSBuZXh0IEJhc2U2NCBjaGFyYWN0ZXIgd2hlbiByZWFkeS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVUb0Jhc2U2NFVSTChieXRlLCBzdGF0ZSwgZW1pdCkge1xuICAgIGlmIChieXRlICE9PSBudWxsKSB7XG4gICAgICAgIHN0YXRlLnF1ZXVlID0gKHN0YXRlLnF1ZXVlIDw8IDgpIHwgYnl0ZTtcbiAgICAgICAgc3RhdGUucXVldWVkQml0cyArPSA4O1xuICAgICAgICB3aGlsZSAoc3RhdGUucXVldWVkQml0cyA+PSA2KSB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSAoc3RhdGUucXVldWUgPj4gKHN0YXRlLnF1ZXVlZEJpdHMgLSA2KSkgJiA2MztcbiAgICAgICAgICAgIGVtaXQoVE9fQkFTRTY0VVJMW3Bvc10pO1xuICAgICAgICAgICAgc3RhdGUucXVldWVkQml0cyAtPSA2O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXRlLnF1ZXVlZEJpdHMgPiAwKSB7XG4gICAgICAgIHN0YXRlLnF1ZXVlID0gc3RhdGUucXVldWUgPDwgKDYgLSBzdGF0ZS5xdWV1ZWRCaXRzKTtcbiAgICAgICAgc3RhdGUucXVldWVkQml0cyA9IDY7XG4gICAgICAgIHdoaWxlIChzdGF0ZS5xdWV1ZWRCaXRzID49IDYpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IChzdGF0ZS5xdWV1ZSA+PiAoc3RhdGUucXVldWVkQml0cyAtIDYpKSAmIDYzO1xuICAgICAgICAgICAgZW1pdChUT19CQVNFNjRVUkxbcG9zXSk7XG4gICAgICAgICAgICBzdGF0ZS5xdWV1ZWRCaXRzIC09IDY7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIGEgU3RyaW5nIGNoYXIgY29kZSAoZXh0cmFjdGVkIHVzaW5nIGBzdHJpbmcuY2hhckNvZGVBdChwb3NpdGlvbilgKSB0byBhIHNlcXVlbmNlIG9mIEJhc2U2NC1VUkwgY2hhcmFjdGVycy5cbiAqXG4gKiBAcGFyYW0gY2hhckNvZGUgVGhlIGNoYXIgY29kZSBvZiB0aGUgSmF2YVNjcmlwdCBzdHJpbmcuXG4gKiBAcGFyYW0gc3RhdGUgVGhlIEJhc2U2NCBzdGF0ZS4gUGFzcyBhbiBpbml0aWFsIHZhbHVlIG9mIGB7IHF1ZXVlOiAwLCBxdWV1ZWRCaXRzOiAwIH1gLlxuICogQHBhcmFtIGVtaXQgQSBmdW5jdGlvbiBjYWxsZWQgd2l0aCB0aGUgbmV4dCBieXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZUZyb21CYXNlNjRVUkwoY2hhckNvZGUsIHN0YXRlLCBlbWl0KSB7XG4gICAgY29uc3QgYml0cyA9IEZST01fQkFTRTY0VVJMW2NoYXJDb2RlXTtcbiAgICBpZiAoYml0cyA+IC0xKSB7XG4gICAgICAgIC8vIHZhbGlkIEJhc2U2NC1VUkwgY2hhcmFjdGVyXG4gICAgICAgIHN0YXRlLnF1ZXVlID0gKHN0YXRlLnF1ZXVlIDw8IDYpIHwgYml0cztcbiAgICAgICAgc3RhdGUucXVldWVkQml0cyArPSA2O1xuICAgICAgICB3aGlsZSAoc3RhdGUucXVldWVkQml0cyA+PSA4KSB7XG4gICAgICAgICAgICBlbWl0KChzdGF0ZS5xdWV1ZSA+PiAoc3RhdGUucXVldWVkQml0cyAtIDgpKSAmIDB4ZmYpO1xuICAgICAgICAgICAgc3RhdGUucXVldWVkQml0cyAtPSA4O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGJpdHMgPT09IC0yKSB7XG4gICAgICAgIC8vIGlnbm9yZSBzcGFjZXMsIHRhYnMsIG5ld2xpbmVzLCA9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBCYXNlNjQtVVJMIGNoYXJhY3RlciBcIiR7U3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSl9XCJgKTtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIGEgSmF2YVNjcmlwdCBzdHJpbmcgKHdoaWNoIG1heSBpbmNsdWRlIGFueSB2YWxpZCBjaGFyYWN0ZXIpIGludG8gYVxuICogQmFzZTY0LVVSTCBlbmNvZGVkIHN0cmluZy4gVGhlIHN0cmluZyBpcyBmaXJzdCBlbmNvZGVkIGluIFVURi04IHdoaWNoIGlzXG4gKiB0aGVuIGVuY29kZWQgYXMgQmFzZTY0LVVSTC5cbiAqXG4gKiBAcGFyYW0gc3RyIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ1RvQmFzZTY0VVJMKHN0cikge1xuICAgIGNvbnN0IGJhc2U2NCA9IFtdO1xuICAgIGNvbnN0IGVtaXR0ZXIgPSAoY2hhcikgPT4ge1xuICAgICAgICBiYXNlNjQucHVzaChjaGFyKTtcbiAgICB9O1xuICAgIGNvbnN0IHN0YXRlID0geyBxdWV1ZTogMCwgcXVldWVkQml0czogMCB9O1xuICAgIHN0cmluZ1RvVVRGOChzdHIsIChieXRlKSA9PiB7XG4gICAgICAgIGJ5dGVUb0Jhc2U2NFVSTChieXRlLCBzdGF0ZSwgZW1pdHRlcik7XG4gICAgfSk7XG4gICAgYnl0ZVRvQmFzZTY0VVJMKG51bGwsIHN0YXRlLCBlbWl0dGVyKTtcbiAgICByZXR1cm4gYmFzZTY0LmpvaW4oJycpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIEJhc2U2NC1VUkwgZW5jb2RlZCBzdHJpbmcgaW50byBhIEphdmFTY3JpcHQgc3RyaW5nLiBJdCBpcyBhc3N1bWVkXG4gKiB0aGF0IHRoZSB1bmRlcmx5aW5nIHN0cmluZyBoYXMgYmVlbiBlbmNvZGVkIGFzIFVURi04LlxuICpcbiAqIEBwYXJhbSBzdHIgVGhlIEJhc2U2NC1VUkwgZW5jb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdGcm9tQmFzZTY0VVJMKHN0cikge1xuICAgIGNvbnN0IGNvbnYgPSBbXTtcbiAgICBjb25zdCB1dGY4RW1pdCA9IChjb2RlcG9pbnQpID0+IHtcbiAgICAgICAgY29udi5wdXNoKFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGVwb2ludCkpO1xuICAgIH07XG4gICAgY29uc3QgdXRmOFN0YXRlID0ge1xuICAgICAgICB1dGY4c2VxOiAwLFxuICAgICAgICBjb2RlcG9pbnQ6IDAsXG4gICAgfTtcbiAgICBjb25zdCBiNjRTdGF0ZSA9IHsgcXVldWU6IDAsIHF1ZXVlZEJpdHM6IDAgfTtcbiAgICBjb25zdCBieXRlRW1pdCA9IChieXRlKSA9PiB7XG4gICAgICAgIHN0cmluZ0Zyb21VVEY4KGJ5dGUsIHV0ZjhTdGF0ZSwgdXRmOEVtaXQpO1xuICAgIH07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYnl0ZUZyb21CYXNlNjRVUkwoc3RyLmNoYXJDb2RlQXQoaSksIGI2NFN0YXRlLCBieXRlRW1pdCk7XG4gICAgfVxuICAgIHJldHVybiBjb252LmpvaW4oJycpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgY29kZXBvaW50IHRvIGEgbXVsdGktYnl0ZSBVVEYtOCBzZXF1ZW5jZS5cbiAqXG4gKiBAcGFyYW0gY29kZXBvaW50IFRoZSBVbmljb2RlIGNvZGVwb2ludC5cbiAqIEBwYXJhbSBlbWl0ICAgICAgRnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggVVRGLTggYnl0ZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNvZGVwb2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvZGVwb2ludFRvVVRGOChjb2RlcG9pbnQsIGVtaXQpIHtcbiAgICBpZiAoY29kZXBvaW50IDw9IDB4N2YpIHtcbiAgICAgICAgZW1pdChjb2RlcG9pbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGVwb2ludCA8PSAweDdmZikge1xuICAgICAgICBlbWl0KDB4YzAgfCAoY29kZXBvaW50ID4+IDYpKTtcbiAgICAgICAgZW1pdCgweDgwIHwgKGNvZGVwb2ludCAmIDB4M2YpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlcG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgIGVtaXQoMHhlMCB8IChjb2RlcG9pbnQgPj4gMTIpKTtcbiAgICAgICAgZW1pdCgweDgwIHwgKChjb2RlcG9pbnQgPj4gNikgJiAweDNmKSk7XG4gICAgICAgIGVtaXQoMHg4MCB8IChjb2RlcG9pbnQgJiAweDNmKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZXBvaW50IDw9IDB4MTBmZmZmKSB7XG4gICAgICAgIGVtaXQoMHhmMCB8IChjb2RlcG9pbnQgPj4gMTgpKTtcbiAgICAgICAgZW1pdCgweDgwIHwgKChjb2RlcG9pbnQgPj4gMTIpICYgMHgzZikpO1xuICAgICAgICBlbWl0KDB4ODAgfCAoKGNvZGVwb2ludCA+PiA2KSAmIDB4M2YpKTtcbiAgICAgICAgZW1pdCgweDgwIHwgKGNvZGVwb2ludCAmIDB4M2YpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBVbmljb2RlIGNvZGVwb2ludDogJHtjb2RlcG9pbnQudG9TdHJpbmcoMTYpfWApO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIEphdmFTY3JpcHQgc3RyaW5nIHRvIGEgc2VxdWVuY2Ugb2YgVVRGLTggYnl0ZXMuXG4gKlxuICogQHBhcmFtIHN0ciAgVGhlIHN0cmluZyB0byBjb252ZXJ0IHRvIFVURi04LlxuICogQHBhcmFtIGVtaXQgRnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggVVRGLTggYnl0ZSBvZiB0aGUgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nVG9VVEY4KHN0ciwgZW1pdCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCBjb2RlcG9pbnQgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGVwb2ludCA+IDB4ZDdmZiAmJiBjb2RlcG9pbnQgPD0gMHhkYmZmKSB7XG4gICAgICAgICAgICAvLyBtb3N0IFVURi0xNiBjb2RlcG9pbnRzIGFyZSBVbmljb2RlIGNvZGVwb2ludHMsIGV4Y2VwdCB2YWx1ZXMgaW4gdGhpc1xuICAgICAgICAgICAgLy8gcmFuZ2Ugd2hlcmUgdGhlIG5leHQgVVRGLTE2IGNvZGVwb2ludCBuZWVkcyB0byBiZSBjb21iaW5lZCB3aXRoIHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCBvbmUgdG8gZ2V0IHRoZSBVbmljb2RlIGNvZGVwb2ludFxuICAgICAgICAgICAgY29uc3QgaGlnaFN1cnJvZ2F0ZSA9ICgoY29kZXBvaW50IC0gMHhkODAwKSAqIDB4NDAwKSAmIDB4ZmZmZjtcbiAgICAgICAgICAgIGNvbnN0IGxvd1N1cnJvZ2F0ZSA9IChzdHIuY2hhckNvZGVBdChpICsgMSkgLSAweGRjMDApICYgMHhmZmZmO1xuICAgICAgICAgICAgY29kZXBvaW50ID0gKGxvd1N1cnJvZ2F0ZSB8IGhpZ2hTdXJyb2dhdGUpICsgMHgxMDAwMDtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBjb2RlcG9pbnRUb1VURjgoY29kZXBvaW50LCBlbWl0KTtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIGEgVVRGLTggYnl0ZSB0byBhIFVuaWNvZGUgY29kZXBvaW50LlxuICpcbiAqIEBwYXJhbSBieXRlICBUaGUgVVRGLTggYnl0ZSBuZXh0IGluIHRoZSBzZXF1ZW5jZS5cbiAqIEBwYXJhbSBzdGF0ZSBUaGUgc2hhcmVkIHN0YXRlIGJldHdlZW4gY29uc2VjdXRpdmUgVVRGLTggYnl0ZXMgaW4gdGhlXG4gKiAgICAgICAgICAgICAgc2VxdWVuY2UsIGFuIG9iamVjdCB3aXRoIHRoZSBzaGFwZSBgeyB1dGY4c2VxOiAwLCBjb2RlcG9pbnQ6IDAgfWAuXG4gKiBAcGFyYW0gZW1pdCAgRnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggY29kZXBvaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nRnJvbVVURjgoYnl0ZSwgc3RhdGUsIGVtaXQpIHtcbiAgICBpZiAoc3RhdGUudXRmOHNlcSA9PT0gMCkge1xuICAgICAgICBpZiAoYnl0ZSA8PSAweDdmKSB7XG4gICAgICAgICAgICBlbWl0KGJ5dGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvdW50IHRoZSBudW1iZXIgb2YgMSBsZWFkaW5nIGJpdHMgdW50aWwgeW91IHJlYWNoIDBcbiAgICAgICAgZm9yIChsZXQgbGVhZGluZ0JpdCA9IDE7IGxlYWRpbmdCaXQgPCA2OyBsZWFkaW5nQml0ICs9IDEpIHtcbiAgICAgICAgICAgIGlmICgoKGJ5dGUgPj4gKDcgLSBsZWFkaW5nQml0KSkgJiAxKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnV0ZjhzZXEgPSBsZWFkaW5nQml0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS51dGY4c2VxID09PSAyKSB7XG4gICAgICAgICAgICBzdGF0ZS5jb2RlcG9pbnQgPSBieXRlICYgMzE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUudXRmOHNlcSA9PT0gMykge1xuICAgICAgICAgICAgc3RhdGUuY29kZXBvaW50ID0gYnl0ZSAmIDE1O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLnV0ZjhzZXEgPT09IDQpIHtcbiAgICAgICAgICAgIHN0YXRlLmNvZGVwb2ludCA9IGJ5dGUgJiA3O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFVURi04IHNlcXVlbmNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUudXRmOHNlcSAtPSAxO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZS51dGY4c2VxID4gMCkge1xuICAgICAgICBpZiAoYnl0ZSA8PSAweDdmKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgVVRGLTggc2VxdWVuY2UnKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5jb2RlcG9pbnQgPSAoc3RhdGUuY29kZXBvaW50IDw8IDYpIHwgKGJ5dGUgJiA2Myk7XG4gICAgICAgIHN0YXRlLnV0ZjhzZXEgLT0gMTtcbiAgICAgICAgaWYgKHN0YXRlLnV0ZjhzZXEgPT09IDApIHtcbiAgICAgICAgICAgIGVtaXQoc3RhdGUuY29kZXBvaW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9ucyB0byBjb252ZXJ0IGRpZmZlcmVudCB0eXBlcyBvZiBzdHJpbmdzIHRvIFVpbnQ4QXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NFVybFRvVWludDhBcnJheShzdHIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBzdGF0ZSA9IHsgcXVldWU6IDAsIHF1ZXVlZEJpdHM6IDAgfTtcbiAgICBjb25zdCBvbkJ5dGUgPSAoYnl0ZSkgPT4ge1xuICAgICAgICByZXN1bHQucHVzaChieXRlKTtcbiAgICB9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGJ5dGVGcm9tQmFzZTY0VVJMKHN0ci5jaGFyQ29kZUF0KGkpLCBzdGF0ZSwgb25CeXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nVG9VaW50OEFycmF5KHN0cikge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHN0cmluZ1RvVVRGOChzdHIsIChieXRlKSA9PiByZXN1bHQucHVzaChieXRlKSk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0Jhc2U2NFVSTChieXRlcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IHN0YXRlID0geyBxdWV1ZTogMCwgcXVldWVkQml0czogMCB9O1xuICAgIGNvbnN0IG9uQ2hhciA9IChjaGFyKSA9PiB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGNoYXIpO1xuICAgIH07XG4gICAgYnl0ZXMuZm9yRWFjaCgoYnl0ZSkgPT4gYnl0ZVRvQmFzZTY0VVJMKGJ5dGUsIHN0YXRlLCBvbkNoYXIpKTtcbiAgICAvLyBhbHdheXMgY2FsbCB3aXRoIGBudWxsYCBhZnRlciBwcm9jZXNzaW5nIGFsbCBieXRlc1xuICAgIGJ5dGVUb0Jhc2U2NFVSTChudWxsLCBzdGF0ZSwgb25DaGFyKTtcbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTY0dXJsLmpzLm1hcCJdLCJuYW1lcyI6WyJUT19CQVNFNjRVUkwiLCJzcGxpdCIsIklHTk9SRV9CQVNFNjRVUkwiLCJGUk9NX0JBU0U2NFVSTCIsImNoYXJNYXAiLCJBcnJheSIsImkiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwiYnl0ZVRvQmFzZTY0VVJMIiwiYnl0ZSIsInN0YXRlIiwiZW1pdCIsInF1ZXVlIiwicXVldWVkQml0cyIsInBvcyIsImJ5dGVGcm9tQmFzZTY0VVJMIiwiY2hhckNvZGUiLCJiaXRzIiwiRXJyb3IiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJzdHJpbmdUb0Jhc2U2NFVSTCIsInN0ciIsImJhc2U2NCIsImVtaXR0ZXIiLCJjaGFyIiwicHVzaCIsInN0cmluZ1RvVVRGOCIsImpvaW4iLCJzdHJpbmdGcm9tQmFzZTY0VVJMIiwiY29udiIsInV0ZjhFbWl0IiwiY29kZXBvaW50IiwiZnJvbUNvZGVQb2ludCIsInV0ZjhTdGF0ZSIsInV0ZjhzZXEiLCJiNjRTdGF0ZSIsImJ5dGVFbWl0Iiwic3RyaW5nRnJvbVVURjgiLCJjb2RlcG9pbnRUb1VURjgiLCJ0b1N0cmluZyIsImhpZ2hTdXJyb2dhdGUiLCJsb3dTdXJyb2dhdGUiLCJsZWFkaW5nQml0IiwiYmFzZTY0VXJsVG9VaW50OEFycmF5IiwicmVzdWx0Iiwib25CeXRlIiwiVWludDhBcnJheSIsInN0cmluZ1RvVWludDhBcnJheSIsImJ5dGVzVG9CYXNlNjRVUkwiLCJieXRlcyIsIm9uQ2hhciIsImZvckVhY2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/base64url.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/constants.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   API_VERSIONS: () => (/* binding */ API_VERSIONS),\n/* harmony export */   API_VERSION_HEADER_NAME: () => (/* binding */ API_VERSION_HEADER_NAME),\n/* harmony export */   AUDIENCE: () => (/* binding */ AUDIENCE),\n/* harmony export */   AUTO_REFRESH_TICK_DURATION_MS: () => (/* binding */ AUTO_REFRESH_TICK_DURATION_MS),\n/* harmony export */   AUTO_REFRESH_TICK_THRESHOLD: () => (/* binding */ AUTO_REFRESH_TICK_THRESHOLD),\n/* harmony export */   BASE64URL_REGEX: () => (/* binding */ BASE64URL_REGEX),\n/* harmony export */   DEFAULT_HEADERS: () => (/* binding */ DEFAULT_HEADERS),\n/* harmony export */   EXPIRY_MARGIN_MS: () => (/* binding */ EXPIRY_MARGIN_MS),\n/* harmony export */   GOTRUE_URL: () => (/* binding */ GOTRUE_URL),\n/* harmony export */   JWKS_TTL: () => (/* binding */ JWKS_TTL),\n/* harmony export */   NETWORK_FAILURE: () => (/* binding */ NETWORK_FAILURE),\n/* harmony export */   STORAGE_KEY: () => (/* binding */ STORAGE_KEY)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/version.js\");\n\n/** Current session will be checked for refresh at this interval. */ const AUTO_REFRESH_TICK_DURATION_MS = 30 * 1000;\n/**\n * A token refresh will be attempted this many ticks before the current session expires. */ const AUTO_REFRESH_TICK_THRESHOLD = 3;\n/*\n * Earliest time before an access token expires that the session should be refreshed.\n */ const EXPIRY_MARGIN_MS = AUTO_REFRESH_TICK_THRESHOLD * AUTO_REFRESH_TICK_DURATION_MS;\nconst GOTRUE_URL = \"http://localhost:9999\";\nconst STORAGE_KEY = \"supabase.auth.token\";\nconst AUDIENCE = \"\";\nconst DEFAULT_HEADERS = {\n    \"X-Client-Info\": `gotrue-js/${_version__WEBPACK_IMPORTED_MODULE_0__.version}`\n};\nconst NETWORK_FAILURE = {\n    MAX_RETRIES: 10,\n    RETRY_INTERVAL: 2\n};\nconst API_VERSION_HEADER_NAME = \"X-Supabase-Api-Version\";\nconst API_VERSIONS = {\n    \"2024-01-01\": {\n        timestamp: Date.parse(\"2024-01-01T00:00:00.0Z\"),\n        name: \"2024-01-01\"\n    }\n};\nconst BASE64URL_REGEX = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i;\nconst JWKS_TTL = 10 * 60 * 1000; // 10 minutes\n //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQW9DO0FBQ3BDLGtFQUFrRSxHQUMzRCxNQUFNQyxnQ0FBZ0MsS0FBSyxLQUFLO0FBQ3ZEO3lGQUN5RixHQUNsRixNQUFNQyw4QkFBOEIsRUFBRTtBQUM3Qzs7Q0FFQyxHQUNNLE1BQU1DLG1CQUFtQkQsOEJBQThCRCw4QkFBOEI7QUFDckYsTUFBTUcsYUFBYSx3QkFBd0I7QUFDM0MsTUFBTUMsY0FBYyxzQkFBc0I7QUFDMUMsTUFBTUMsV0FBVyxHQUFHO0FBQ3BCLE1BQU1DLGtCQUFrQjtJQUFFLGlCQUFpQixDQUFDLFVBQVUsRUFBRVAsNkNBQU9BLENBQUMsQ0FBQztBQUFDLEVBQUU7QUFDcEUsTUFBTVEsa0JBQWtCO0lBQzNCQyxhQUFhO0lBQ2JDLGdCQUFnQjtBQUNwQixFQUFFO0FBQ0ssTUFBTUMsMEJBQTBCLHlCQUF5QjtBQUN6RCxNQUFNQyxlQUFlO0lBQ3hCLGNBQWM7UUFDVkMsV0FBV0MsS0FBS0MsS0FBSyxDQUFDO1FBQ3RCQyxNQUFNO0lBQ1Y7QUFDSixFQUFFO0FBQ0ssTUFBTUMsa0JBQWtCLHVEQUF1RDtBQUMvRSxNQUFNQyxXQUFXLEtBQUssS0FBSyxLQUFLLENBQUMsYUFBYTtDQUNyRCxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmNob3Itd29ya2Zsb3dzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2xpYi9jb25zdGFudHMuanM/ZjA0OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uJztcbi8qKiBDdXJyZW50IHNlc3Npb24gd2lsbCBiZSBjaGVja2VkIGZvciByZWZyZXNoIGF0IHRoaXMgaW50ZXJ2YWwuICovXG5leHBvcnQgY29uc3QgQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVMgPSAzMCAqIDEwMDA7XG4vKipcbiAqIEEgdG9rZW4gcmVmcmVzaCB3aWxsIGJlIGF0dGVtcHRlZCB0aGlzIG1hbnkgdGlja3MgYmVmb3JlIHRoZSBjdXJyZW50IHNlc3Npb24gZXhwaXJlcy4gKi9cbmV4cG9ydCBjb25zdCBBVVRPX1JFRlJFU0hfVElDS19USFJFU0hPTEQgPSAzO1xuLypcbiAqIEVhcmxpZXN0IHRpbWUgYmVmb3JlIGFuIGFjY2VzcyB0b2tlbiBleHBpcmVzIHRoYXQgdGhlIHNlc3Npb24gc2hvdWxkIGJlIHJlZnJlc2hlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IEVYUElSWV9NQVJHSU5fTVMgPSBBVVRPX1JFRlJFU0hfVElDS19USFJFU0hPTEQgKiBBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTl9NUztcbmV4cG9ydCBjb25zdCBHT1RSVUVfVVJMID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6OTk5OSc7XG5leHBvcnQgY29uc3QgU1RPUkFHRV9LRVkgPSAnc3VwYWJhc2UuYXV0aC50b2tlbic7XG5leHBvcnQgY29uc3QgQVVESUVOQ0UgPSAnJztcbmV4cG9ydCBjb25zdCBERUZBVUxUX0hFQURFUlMgPSB7ICdYLUNsaWVudC1JbmZvJzogYGdvdHJ1ZS1qcy8ke3ZlcnNpb259YCB9O1xuZXhwb3J0IGNvbnN0IE5FVFdPUktfRkFJTFVSRSA9IHtcbiAgICBNQVhfUkVUUklFUzogMTAsXG4gICAgUkVUUllfSU5URVJWQUw6IDIsIC8vIGluIGRlY2lzZWNvbmRzXG59O1xuZXhwb3J0IGNvbnN0IEFQSV9WRVJTSU9OX0hFQURFUl9OQU1FID0gJ1gtU3VwYWJhc2UtQXBpLVZlcnNpb24nO1xuZXhwb3J0IGNvbnN0IEFQSV9WRVJTSU9OUyA9IHtcbiAgICAnMjAyNC0wMS0wMSc6IHtcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLnBhcnNlKCcyMDI0LTAxLTAxVDAwOjAwOjAwLjBaJyksXG4gICAgICAgIG5hbWU6ICcyMDI0LTAxLTAxJyxcbiAgICB9LFxufTtcbmV4cG9ydCBjb25zdCBCQVNFNjRVUkxfUkVHRVggPSAvXihbYS16MC05Xy1dezR9KSooJHxbYS16MC05Xy1dezN9JHxbYS16MC05Xy1dezJ9JCkkL2k7XG5leHBvcnQgY29uc3QgSldLU19UVEwgPSAxMCAqIDYwICogMTAwMDsgLy8gMTAgbWludXRlc1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJ2ZXJzaW9uIiwiQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVMiLCJBVVRPX1JFRlJFU0hfVElDS19USFJFU0hPTEQiLCJFWFBJUllfTUFSR0lOX01TIiwiR09UUlVFX1VSTCIsIlNUT1JBR0VfS0VZIiwiQVVESUVOQ0UiLCJERUZBVUxUX0hFQURFUlMiLCJORVRXT1JLX0ZBSUxVUkUiLCJNQVhfUkVUUklFUyIsIlJFVFJZX0lOVEVSVkFMIiwiQVBJX1ZFUlNJT05fSEVBREVSX05BTUUiLCJBUElfVkVSU0lPTlMiLCJ0aW1lc3RhbXAiLCJEYXRlIiwicGFyc2UiLCJuYW1lIiwiQkFTRTY0VVJMX1JFR0VYIiwiSldLU19UVEwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/errors.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthApiError: () => (/* binding */ AuthApiError),\n/* harmony export */   AuthError: () => (/* binding */ AuthError),\n/* harmony export */   AuthImplicitGrantRedirectError: () => (/* binding */ AuthImplicitGrantRedirectError),\n/* harmony export */   AuthInvalidCredentialsError: () => (/* binding */ AuthInvalidCredentialsError),\n/* harmony export */   AuthInvalidJwtError: () => (/* binding */ AuthInvalidJwtError),\n/* harmony export */   AuthInvalidTokenResponseError: () => (/* binding */ AuthInvalidTokenResponseError),\n/* harmony export */   AuthPKCECodeVerifierMissingError: () => (/* binding */ AuthPKCECodeVerifierMissingError),\n/* harmony export */   AuthPKCEGrantCodeExchangeError: () => (/* binding */ AuthPKCEGrantCodeExchangeError),\n/* harmony export */   AuthRetryableFetchError: () => (/* binding */ AuthRetryableFetchError),\n/* harmony export */   AuthSessionMissingError: () => (/* binding */ AuthSessionMissingError),\n/* harmony export */   AuthUnknownError: () => (/* binding */ AuthUnknownError),\n/* harmony export */   AuthWeakPasswordError: () => (/* binding */ AuthWeakPasswordError),\n/* harmony export */   CustomAuthError: () => (/* binding */ CustomAuthError),\n/* harmony export */   isAuthApiError: () => (/* binding */ isAuthApiError),\n/* harmony export */   isAuthError: () => (/* binding */ isAuthError),\n/* harmony export */   isAuthImplicitGrantRedirectError: () => (/* binding */ isAuthImplicitGrantRedirectError),\n/* harmony export */   isAuthPKCECodeVerifierMissingError: () => (/* binding */ isAuthPKCECodeVerifierMissingError),\n/* harmony export */   isAuthRetryableFetchError: () => (/* binding */ isAuthRetryableFetchError),\n/* harmony export */   isAuthSessionMissingError: () => (/* binding */ isAuthSessionMissingError),\n/* harmony export */   isAuthWeakPasswordError: () => (/* binding */ isAuthWeakPasswordError)\n/* harmony export */ });\n/**\n * Base error thrown by Supabase Auth helpers.\n *\n * @example\n * ```ts\n * import { AuthError } from '@supabase/auth-js'\n *\n * throw new AuthError('Unexpected auth error', 500, 'unexpected')\n * ```\n */ class AuthError extends Error {\n    constructor(message, status, code){\n        super(message);\n        this.__isAuthError = true;\n        this.name = \"AuthError\";\n        this.status = status;\n        this.code = code;\n    }\n}\nfunction isAuthError(error) {\n    return typeof error === \"object\" && error !== null && \"__isAuthError\" in error;\n}\n/**\n * Error returned directly from the GoTrue REST API.\n *\n * @example\n * ```ts\n * import { AuthApiError } from '@supabase/auth-js'\n *\n * throw new AuthApiError('Invalid credentials', 400, 'invalid_credentials')\n * ```\n */ class AuthApiError extends AuthError {\n    constructor(message, status, code){\n        super(message, status, code);\n        this.name = \"AuthApiError\";\n        this.status = status;\n        this.code = code;\n    }\n}\nfunction isAuthApiError(error) {\n    return isAuthError(error) && error.name === \"AuthApiError\";\n}\n/**\n * Wraps non-standard errors so callers can inspect the root cause.\n *\n * @example\n * ```ts\n * import { AuthUnknownError } from '@supabase/auth-js'\n *\n * try {\n *   await someAuthCall()\n * } catch (err) {\n *   throw new AuthUnknownError('Auth failed', err)\n * }\n * ```\n */ class AuthUnknownError extends AuthError {\n    constructor(message, originalError){\n        super(message);\n        this.name = \"AuthUnknownError\";\n        this.originalError = originalError;\n    }\n}\n/**\n * Flexible error class used to create named auth errors at runtime.\n *\n * @example\n * ```ts\n * import { CustomAuthError } from '@supabase/auth-js'\n *\n * throw new CustomAuthError('My custom auth error', 'MyAuthError', 400, 'custom_code')\n * ```\n */ class CustomAuthError extends AuthError {\n    constructor(message, name, status, code){\n        super(message, status, code);\n        this.name = name;\n        this.status = status;\n    }\n}\n/**\n * Error thrown when an operation requires a session but none is present.\n *\n * @example\n * ```ts\n * import { AuthSessionMissingError } from '@supabase/auth-js'\n *\n * throw new AuthSessionMissingError()\n * ```\n */ class AuthSessionMissingError extends CustomAuthError {\n    constructor(){\n        super(\"Auth session missing!\", \"AuthSessionMissingError\", 400, undefined);\n    }\n}\nfunction isAuthSessionMissingError(error) {\n    return isAuthError(error) && error.name === \"AuthSessionMissingError\";\n}\n/**\n * Error thrown when the token response is malformed.\n *\n * @example\n * ```ts\n * import { AuthInvalidTokenResponseError } from '@supabase/auth-js'\n *\n * throw new AuthInvalidTokenResponseError()\n * ```\n */ class AuthInvalidTokenResponseError extends CustomAuthError {\n    constructor(){\n        super(\"Auth session or user missing\", \"AuthInvalidTokenResponseError\", 500, undefined);\n    }\n}\n/**\n * Error thrown when email/password credentials are invalid.\n *\n * @example\n * ```ts\n * import { AuthInvalidCredentialsError } from '@supabase/auth-js'\n *\n * throw new AuthInvalidCredentialsError('Email or password is incorrect')\n * ```\n */ class AuthInvalidCredentialsError extends CustomAuthError {\n    constructor(message){\n        super(message, \"AuthInvalidCredentialsError\", 400, undefined);\n    }\n}\n/**\n * Error thrown when implicit grant redirects contain an error.\n *\n * @example\n * ```ts\n * import { AuthImplicitGrantRedirectError } from '@supabase/auth-js'\n *\n * throw new AuthImplicitGrantRedirectError('OAuth redirect failed', {\n *   error: 'access_denied',\n *   code: 'oauth_error',\n * })\n * ```\n */ class AuthImplicitGrantRedirectError extends CustomAuthError {\n    constructor(message, details = null){\n        super(message, \"AuthImplicitGrantRedirectError\", 500, undefined);\n        this.details = null;\n        this.details = details;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            details: this.details\n        };\n    }\n}\nfunction isAuthImplicitGrantRedirectError(error) {\n    return isAuthError(error) && error.name === \"AuthImplicitGrantRedirectError\";\n}\n/**\n * Error thrown during PKCE code exchanges.\n *\n * @example\n * ```ts\n * import { AuthPKCEGrantCodeExchangeError } from '@supabase/auth-js'\n *\n * throw new AuthPKCEGrantCodeExchangeError('PKCE exchange failed')\n * ```\n */ class AuthPKCEGrantCodeExchangeError extends CustomAuthError {\n    constructor(message, details = null){\n        super(message, \"AuthPKCEGrantCodeExchangeError\", 500, undefined);\n        this.details = null;\n        this.details = details;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            details: this.details\n        };\n    }\n}\n/**\n * Error thrown when the PKCE code verifier is not found in storage.\n * This typically happens when the auth flow was initiated in a different\n * browser, device, or the storage was cleared.\n *\n * @example\n * ```ts\n * import { AuthPKCECodeVerifierMissingError } from '@supabase/auth-js'\n *\n * throw new AuthPKCECodeVerifierMissingError()\n * ```\n */ class AuthPKCECodeVerifierMissingError extends CustomAuthError {\n    constructor(){\n        super(\"PKCE code verifier not found in storage. \" + \"This can happen if the auth flow was initiated in a different browser or device, \" + \"or if the storage was cleared. For SSR frameworks (Next.js, SvelteKit, etc.), \" + \"use @supabase/ssr on both the server and client to store the code verifier in cookies.\", \"AuthPKCECodeVerifierMissingError\", 400, \"pkce_code_verifier_not_found\");\n    }\n}\nfunction isAuthPKCECodeVerifierMissingError(error) {\n    return isAuthError(error) && error.name === \"AuthPKCECodeVerifierMissingError\";\n}\n/**\n * Error thrown when a transient fetch issue occurs.\n *\n * @example\n * ```ts\n * import { AuthRetryableFetchError } from '@supabase/auth-js'\n *\n * throw new AuthRetryableFetchError('Service temporarily unavailable', 503)\n * ```\n */ class AuthRetryableFetchError extends CustomAuthError {\n    constructor(message, status){\n        super(message, \"AuthRetryableFetchError\", status, undefined);\n    }\n}\nfunction isAuthRetryableFetchError(error) {\n    return isAuthError(error) && error.name === \"AuthRetryableFetchError\";\n}\n/**\n * This error is thrown on certain methods when the password used is deemed\n * weak. Inspect the reasons to identify what password strength rules are\n * inadequate.\n */ /**\n * Error thrown when a supplied password is considered weak.\n *\n * @example\n * ```ts\n * import { AuthWeakPasswordError } from '@supabase/auth-js'\n *\n * throw new AuthWeakPasswordError('Password too short', 400, ['min_length'])\n * ```\n */ class AuthWeakPasswordError extends CustomAuthError {\n    constructor(message, status, reasons){\n        super(message, \"AuthWeakPasswordError\", status, \"weak_password\");\n        this.reasons = reasons;\n    }\n}\nfunction isAuthWeakPasswordError(error) {\n    return isAuthError(error) && error.name === \"AuthWeakPasswordError\";\n}\n/**\n * Error thrown when a JWT cannot be verified or parsed.\n *\n * @example\n * ```ts\n * import { AuthInvalidJwtError } from '@supabase/auth-js'\n *\n * throw new AuthInvalidJwtError('Token signature is invalid')\n * ```\n */ class AuthInvalidJwtError extends CustomAuthError {\n    constructor(message){\n        super(message, \"AuthInvalidJwtError\", 400, \"invalid_jwt\");\n    }\n} //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Q0FTQyxHQUNNLE1BQU1BLGtCQUFrQkM7SUFDM0JDLFlBQVlDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxJQUFJLENBQUU7UUFDL0IsS0FBSyxDQUFDRjtRQUNOLElBQUksQ0FBQ0csYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDSCxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxJQUFJLEdBQUdBO0lBQ2hCO0FBQ0o7QUFDTyxTQUFTRyxZQUFZQyxLQUFLO0lBQzdCLE9BQU8sT0FBT0EsVUFBVSxZQUFZQSxVQUFVLFFBQVEsbUJBQW1CQTtBQUM3RTtBQUNBOzs7Ozs7Ozs7Q0FTQyxHQUNNLE1BQU1DLHFCQUFxQlY7SUFDOUJFLFlBQVlDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxJQUFJLENBQUU7UUFDL0IsS0FBSyxDQUFDRixTQUFTQyxRQUFRQztRQUN2QixJQUFJLENBQUNFLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0gsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtJQUNoQjtBQUNKO0FBQ08sU0FBU00sZUFBZUYsS0FBSztJQUNoQyxPQUFPRCxZQUFZQyxVQUFVQSxNQUFNRixJQUFJLEtBQUs7QUFDaEQ7QUFDQTs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ00sTUFBTUsseUJBQXlCWjtJQUNsQ0UsWUFBWUMsT0FBTyxFQUFFVSxhQUFhLENBQUU7UUFDaEMsS0FBSyxDQUFDVjtRQUNOLElBQUksQ0FBQ0ksSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDTSxhQUFhLEdBQUdBO0lBQ3pCO0FBQ0o7QUFDQTs7Ozs7Ozs7O0NBU0MsR0FDTSxNQUFNQyx3QkFBd0JkO0lBQ2pDRSxZQUFZQyxPQUFPLEVBQUVJ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QyxVQUFVQSxNQUFNRixJQUFJLEtBQUs7QUFDaEQ7QUFDQTs7Ozs7Ozs7O0NBU0MsR0FDTSxNQUFNeUIsNEJBQTRCbEI7SUFDckNaLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUNBLFNBQVMsdUJBQXVCLEtBQUs7SUFDL0M7QUFDSixFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FuY2hvci13b3JrZmxvd3MvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2Vycm9ycy5qcz9kZGVkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQmFzZSBlcnJvciB0aHJvd24gYnkgU3VwYWJhc2UgQXV0aCBoZWxwZXJzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXV0aEVycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gKlxuICogdGhyb3cgbmV3IEF1dGhFcnJvcignVW5leHBlY3RlZCBhdXRoIGVycm9yJywgNTAwLCAndW5leHBlY3RlZCcpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMsIGNvZGUpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuX19pc0F1dGhFcnJvciA9IHRydWU7XG4gICAgICAgIHRoaXMubmFtZSA9ICdBdXRoRXJyb3InO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPT0gbnVsbCAmJiAnX19pc0F1dGhFcnJvcicgaW4gZXJyb3I7XG59XG4vKipcbiAqIEVycm9yIHJldHVybmVkIGRpcmVjdGx5IGZyb20gdGhlIEdvVHJ1ZSBSRVNUIEFQSS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEF1dGhBcGlFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICpcbiAqIHRocm93IG5ldyBBdXRoQXBpRXJyb3IoJ0ludmFsaWQgY3JlZGVudGlhbHMnLCA0MDAsICdpbnZhbGlkX2NyZWRlbnRpYWxzJylcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQXV0aEFwaUVycm9yIGV4dGVuZHMgQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMsIGNvZGUpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgc3RhdHVzLCBjb2RlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0F1dGhBcGlFcnJvcic7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0F1dGhBcGlFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBpc0F1dGhFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gJ0F1dGhBcGlFcnJvcic7XG59XG4vKipcbiAqIFdyYXBzIG5vbi1zdGFuZGFyZCBlcnJvcnMgc28gY2FsbGVycyBjYW4gaW5zcGVjdCB0aGUgcm9vdCBjYXVzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEF1dGhVbmtub3duRXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiB0cnkge1xuICogICBhd2FpdCBzb21lQXV0aENhbGwoKVxuICogfSBjYXRjaCAoZXJyKSB7XG4gKiAgIHRocm93IG5ldyBBdXRoVW5rbm93bkVycm9yKCdBdXRoIGZhaWxlZCcsIGVycilcbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQXV0aFVua25vd25FcnJvciBleHRlbmRzIEF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgb3JpZ2luYWxFcnJvcikge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0F1dGhVbmtub3duRXJyb3InO1xuICAgICAgICB0aGlzLm9yaWdpbmFsRXJyb3IgPSBvcmlnaW5hbEVycm9yO1xuICAgIH1cbn1cbi8qKlxuICogRmxleGlibGUgZXJyb3IgY2xhc3MgdXNlZCB0byBjcmVhdGUgbmFtZWQgYXV0aCBlcnJvcnMgYXQgcnVudGltZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEN1c3RvbUF1dGhFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICpcbiAqIHRocm93IG5ldyBDdXN0b21BdXRoRXJyb3IoJ015IGN1c3RvbSBhdXRoIGVycm9yJywgJ015QXV0aEVycm9yJywgNDAwLCAnY3VzdG9tX2NvZGUnKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBDdXN0b21BdXRoRXJyb3IgZXh0ZW5kcyBBdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG5hbWUsIHN0YXR1cywgY29kZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCBzdGF0dXMsIGNvZGUpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB9XG59XG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiByZXF1aXJlcyBhIHNlc3Npb24gYnV0IG5vbmUgaXMgcHJlc2VudC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gKlxuICogdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKClcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignQXV0aCBzZXNzaW9uIG1pc3NpbmchJywgJ0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yJywgNDAwLCB1bmRlZmluZWQpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGlzQXV0aEVycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSAnQXV0aFNlc3Npb25NaXNzaW5nRXJyb3InO1xufVxuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiB0aGUgdG9rZW4gcmVzcG9uc2UgaXMgbWFsZm9ybWVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiB0aHJvdyBuZXcgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IoKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdBdXRoIHNlc3Npb24gb3IgdXNlciBtaXNzaW5nJywgJ0F1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yJywgNTAwLCB1bmRlZmluZWQpO1xuICAgIH1cbn1cbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gZW1haWwvcGFzc3dvcmQgY3JlZGVudGlhbHMgYXJlIGludmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiB0aHJvdyBuZXcgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKCdFbWFpbCBvciBwYXNzd29yZCBpcyBpbmNvcnJlY3QnKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcicsIDQwMCwgdW5kZWZpbmVkKTtcbiAgICB9XG59XG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIGltcGxpY2l0IGdyYW50IHJlZGlyZWN0cyBjb250YWluIGFuIGVycm9yLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gKlxuICogdGhyb3cgbmV3IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcignT0F1dGggcmVkaXJlY3QgZmFpbGVkJywge1xuICogICBlcnJvcjogJ2FjY2Vzc19kZW5pZWQnLFxuICogICBjb2RlOiAnb2F1dGhfZXJyb3InLFxuICogfSlcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBkZXRhaWxzID0gbnVsbCkge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCAnQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yJywgNTAwLCB1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICAgICAgZGV0YWlsczogdGhpcy5kZXRhaWxzLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBpc0F1dGhFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gJ0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcic7XG59XG4vKipcbiAqIEVycm9yIHRocm93biBkdXJpbmcgUEtDRSBjb2RlIGV4Y2hhbmdlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICpcbiAqIHRocm93IG5ldyBBdXRoUEtDRUdyYW50Q29kZUV4Y2hhbmdlRXJyb3IoJ1BLQ0UgZXhjaGFuZ2UgZmFpbGVkJylcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBkZXRhaWxzID0gbnVsbCkge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCAnQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yJywgNTAwLCB1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICAgICAgZGV0YWlsczogdGhpcy5kZXRhaWxzLFxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlIFBLQ0UgY29kZSB2ZXJpZmllciBpcyBub3QgZm91bmQgaW4gc3RvcmFnZS5cbiAqIFRoaXMgdHlwaWNhbGx5IGhhcHBlbnMgd2hlbiB0aGUgYXV0aCBmbG93IHdhcyBpbml0aWF0ZWQgaW4gYSBkaWZmZXJlbnRcbiAqIGJyb3dzZXIsIGRldmljZSwgb3IgdGhlIHN0b3JhZ2Ugd2FzIGNsZWFyZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBdXRoUEtDRUNvZGVWZXJpZmllck1pc3NpbmdFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICpcbiAqIHRocm93IG5ldyBBdXRoUEtDRUNvZGVWZXJpZmllck1pc3NpbmdFcnJvcigpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhQS0NFQ29kZVZlcmlmaWVyTWlzc2luZ0Vycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ1BLQ0UgY29kZSB2ZXJpZmllciBub3QgZm91bmQgaW4gc3RvcmFnZS4gJyArXG4gICAgICAgICAgICAnVGhpcyBjYW4gaGFwcGVuIGlmIHRoZSBhdXRoIGZsb3cgd2FzIGluaXRpYXRlZCBpbiBhIGRpZmZlcmVudCBicm93c2VyIG9yIGRldmljZSwgJyArXG4gICAgICAgICAgICAnb3IgaWYgdGhlIHN0b3JhZ2Ugd2FzIGNsZWFyZWQuIEZvciBTU1IgZnJhbWV3b3JrcyAoTmV4dC5qcywgU3ZlbHRlS2l0LCBldGMuKSwgJyArXG4gICAgICAgICAgICAndXNlIEBzdXBhYmFzZS9zc3Igb24gYm90aCB0aGUgc2VydmVyIGFuZCBjbGllbnQgdG8gc3RvcmUgdGhlIGNvZGUgdmVyaWZpZXIgaW4gY29va2llcy4nLCAnQXV0aFBLQ0VDb2RlVmVyaWZpZXJNaXNzaW5nRXJyb3InLCA0MDAsICdwa2NlX2NvZGVfdmVyaWZpZXJfbm90X2ZvdW5kJyk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aFBLQ0VDb2RlVmVyaWZpZXJNaXNzaW5nRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoUEtDRUNvZGVWZXJpZmllck1pc3NpbmdFcnJvcic7XG59XG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIGEgdHJhbnNpZW50IGZldGNoIGlzc3VlIG9jY3Vycy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEF1dGhSZXRyeWFibGVGZXRjaEVycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gKlxuICogdGhyb3cgbmV3IEF1dGhSZXRyeWFibGVGZXRjaEVycm9yKCdTZXJ2aWNlIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlJywgNTAzKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcicsIHN0YXR1cywgdW5kZWZpbmVkKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBpc0F1dGhFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gJ0F1dGhSZXRyeWFibGVGZXRjaEVycm9yJztcbn1cbi8qKlxuICogVGhpcyBlcnJvciBpcyB0aHJvd24gb24gY2VydGFpbiBtZXRob2RzIHdoZW4gdGhlIHBhc3N3b3JkIHVzZWQgaXMgZGVlbWVkXG4gKiB3ZWFrLiBJbnNwZWN0IHRoZSByZWFzb25zIHRvIGlkZW50aWZ5IHdoYXQgcGFzc3dvcmQgc3RyZW5ndGggcnVsZXMgYXJlXG4gKiBpbmFkZXF1YXRlLlxuICovXG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIGEgc3VwcGxpZWQgcGFzc3dvcmQgaXMgY29uc2lkZXJlZCB3ZWFrLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXV0aFdlYWtQYXNzd29yZEVycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gKlxuICogdGhyb3cgbmV3IEF1dGhXZWFrUGFzc3dvcmRFcnJvcignUGFzc3dvcmQgdG9vIHNob3J0JywgNDAwLCBbJ21pbl9sZW5ndGgnXSlcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQXV0aFdlYWtQYXNzd29yZEVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMsIHJlYXNvbnMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhXZWFrUGFzc3dvcmRFcnJvcicsIHN0YXR1cywgJ3dlYWtfcGFzc3dvcmQnKTtcbiAgICAgICAgdGhpcy5yZWFzb25zID0gcmVhc29ucztcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoV2Vha1Bhc3N3b3JkRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoV2Vha1Bhc3N3b3JkRXJyb3InO1xufVxuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiBhIEpXVCBjYW5ub3QgYmUgdmVyaWZpZWQgb3IgcGFyc2VkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXV0aEludmFsaWRKd3RFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICpcbiAqIHRocm93IG5ldyBBdXRoSW52YWxpZEp3dEVycm9yKCdUb2tlbiBzaWduYXR1cmUgaXMgaW52YWxpZCcpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhJbnZhbGlkSnd0RXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhJbnZhbGlkSnd0RXJyb3InLCA0MDAsICdpbnZhbGlkX2p3dCcpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiXSwibmFtZXMiOlsiQXV0aEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJzdGF0dXMiLCJjb2RlIiwiX19pc0F1dGhFcnJvciIsIm5hbWUiLCJpc0F1dGhFcnJvciIsImVycm9yIiwiQXV0aEFwaUVycm9yIiwiaXNBdXRoQXBpRXJyb3IiLCJBdXRoVW5rbm93bkVycm9yIiwib3JpZ2luYWxFcnJvciIsIkN1c3RvbUF1dGhFcnJvciIsIkF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yIiwidW5kZWZpbmVkIiwiaXNBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciIsIkF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yIiwiQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yIiwiQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yIiwiZGV0YWlscyIsInRvSlNPTiIsImlzQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yIiwiQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yIiwiQXV0aFBLQ0VDb2RlVmVyaWZpZXJNaXNzaW5nRXJyb3IiLCJpc0F1dGhQS0NFQ29kZVZlcmlmaWVyTWlzc2luZ0Vycm9yIiwiQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IiLCJpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yIiwiQXV0aFdlYWtQYXNzd29yZEVycm9yIiwicmVhc29ucyIsImlzQXV0aFdlYWtQYXNzd29yZEVycm9yIiwiQXV0aEludmFsaWRKd3RFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/fetch.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _generateLinkResponse: () => (/* binding */ _generateLinkResponse),\n/* harmony export */   _noResolveJsonResponse: () => (/* binding */ _noResolveJsonResponse),\n/* harmony export */   _request: () => (/* binding */ _request),\n/* harmony export */   _sessionResponse: () => (/* binding */ _sessionResponse),\n/* harmony export */   _sessionResponsePassword: () => (/* binding */ _sessionResponsePassword),\n/* harmony export */   _ssoResponse: () => (/* binding */ _ssoResponse),\n/* harmony export */   _userResponse: () => (/* binding */ _userResponse),\n/* harmony export */   handleError: () => (/* binding */ handleError)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n\n\n\n\nconst _getErrorMessage = (err)=>err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\nconst NETWORK_ERROR_CODES = [\n    502,\n    503,\n    504\n];\nasync function handleError(error) {\n    var _a;\n    if (!(0,_helpers__WEBPACK_IMPORTED_MODULE_1__.looksLikeFetchResponse)(error)) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError(_getErrorMessage(error), 0);\n    }\n    if (NETWORK_ERROR_CODES.includes(error.status)) {\n        // status in 500...599 range - server had an error, request might be retryed.\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError(_getErrorMessage(error), error.status);\n    }\n    let data;\n    try {\n        data = await error.json();\n    } catch (e) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthUnknownError(_getErrorMessage(e), e);\n    }\n    let errorCode = undefined;\n    const responseAPIVersion = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.parseResponseAPIVersion)(error);\n    if (responseAPIVersion && responseAPIVersion.getTime() >= _constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSIONS[\"2024-01-01\"].timestamp && typeof data === \"object\" && data && typeof data.code === \"string\") {\n        errorCode = data.code;\n    } else if (typeof data === \"object\" && data && typeof data.error_code === \"string\") {\n        errorCode = data.error_code;\n    }\n    if (!errorCode) {\n        // Legacy support for weak password errors, when there were no error codes\n        if (typeof data === \"object\" && data && typeof data.weak_password === \"object\" && data.weak_password && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.reasons.reduce((a, i)=>a && typeof i === \"string\", true)) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthWeakPasswordError(_getErrorMessage(data), error.status, data.weak_password.reasons);\n        }\n    } else if (errorCode === \"weak_password\") {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthWeakPasswordError(_getErrorMessage(data), error.status, ((_a = data.weak_password) === null || _a === void 0 ? void 0 : _a.reasons) || []);\n    } else if (errorCode === \"session_not_found\") {\n        // The `session_id` inside the JWT does not correspond to a row in the\n        // `sessions` table. This usually means the user has signed out, has been\n        // deleted, or their session has somehow been terminated.\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n    }\n    throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthApiError(_getErrorMessage(data), error.status || 500, errorCode);\n}\nconst _getRequestParams = (method, options, parameters, body)=>{\n    const params = {\n        method,\n        headers: (options === null || options === void 0 ? void 0 : options.headers) || {}\n    };\n    if (method === \"GET\") {\n        return params;\n    }\n    params.headers = Object.assign({\n        \"Content-Type\": \"application/json;charset=UTF-8\"\n    }, options === null || options === void 0 ? void 0 : options.headers);\n    params.body = JSON.stringify(body);\n    return Object.assign(Object.assign({}, params), parameters);\n};\nasync function _request(fetcher, method, url, options) {\n    var _a;\n    const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);\n    if (!headers[_constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSION_HEADER_NAME]) {\n        headers[_constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSION_HEADER_NAME] = _constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSIONS[\"2024-01-01\"].name;\n    }\n    if (options === null || options === void 0 ? void 0 : options.jwt) {\n        headers[\"Authorization\"] = `Bearer ${options.jwt}`;\n    }\n    const qs = (_a = options === null || options === void 0 ? void 0 : options.query) !== null && _a !== void 0 ? _a : {};\n    if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n        qs[\"redirect_to\"] = options.redirectTo;\n    }\n    const queryString = Object.keys(qs).length ? \"?\" + new URLSearchParams(qs).toString() : \"\";\n    const data = await _handleRequest(fetcher, method, url + queryString, {\n        headers,\n        noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson\n    }, {}, options === null || options === void 0 ? void 0 : options.body);\n    return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : {\n        data: Object.assign({}, data),\n        error: null\n    };\n}\nasync function _handleRequest(fetcher, method, url, options, parameters, body) {\n    const requestParams = _getRequestParams(method, options, parameters, body);\n    let result;\n    try {\n        result = await fetcher(url, Object.assign({}, requestParams));\n    } catch (e) {\n        console.error(e);\n        // fetch failed, likely due to a network or CORS error\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError(_getErrorMessage(e), 0);\n    }\n    if (!result.ok) {\n        await handleError(result);\n    }\n    if (options === null || options === void 0 ? void 0 : options.noResolveJson) {\n        return result;\n    }\n    try {\n        return await result.json();\n    } catch (e) {\n        await handleError(e);\n    }\n}\nfunction _sessionResponse(data) {\n    var _a;\n    let session = null;\n    if (hasSession(data)) {\n        session = Object.assign({}, data);\n        if (!data.expires_at) {\n            session.expires_at = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.expiresAt)(data.expires_in);\n        }\n    }\n    const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n    return {\n        data: {\n            session,\n            user\n        },\n        error: null\n    };\n}\nfunction _sessionResponsePassword(data) {\n    const response = _sessionResponse(data);\n    if (!response.error && data.weak_password && typeof data.weak_password === \"object\" && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.message && typeof data.weak_password.message === \"string\" && data.weak_password.reasons.reduce((a, i)=>a && typeof i === \"string\", true)) {\n        response.data.weak_password = data.weak_password;\n    }\n    return response;\n}\nfunction _userResponse(data) {\n    var _a;\n    const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n    return {\n        data: {\n            user\n        },\n        error: null\n    };\n}\nfunction _ssoResponse(data) {\n    return {\n        data,\n        error: null\n    };\n}\nfunction _generateLinkResponse(data) {\n    const { action_link, email_otp, hashed_token, redirect_to, verification_type } = data, rest = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__rest)(data, [\n        \"action_link\",\n        \"email_otp\",\n        \"hashed_token\",\n        \"redirect_to\",\n        \"verification_type\"\n    ]);\n    const properties = {\n        action_link,\n        email_otp,\n        hashed_token,\n        redirect_to,\n        verification_type\n    };\n    const user = Object.assign({}, rest);\n    return {\n        data: {\n            properties,\n            user\n        },\n        error: null\n    };\n}\nfunction _noResolveJsonResponse(data) {\n    return data;\n}\n/**\n * hasSession checks if the response object contains a valid session\n * @param data A response object\n * @returns true if a session is in the response\n */ function hasSession(data) {\n    return data.access_token && data.refresh_token && data.expires_in;\n} //# sourceMappingURL=fetch.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2ZldGNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUNxQztBQUNtQjtBQUM2QztBQUNwSSxNQUFNVyxtQkFBbUIsQ0FBQ0MsTUFBUUEsSUFBSUMsR0FBRyxJQUFJRCxJQUFJRSxPQUFPLElBQUlGLElBQUlHLGlCQUFpQixJQUFJSCxJQUFJSSxLQUFLLElBQUlDLEtBQUtDLFNBQVMsQ0FBQ047QUFDakgsTUFBTU8sc0JBQXNCO0lBQUM7SUFBSztJQUFLO0NBQUk7QUFDcEMsZUFBZUMsWUFBWUosS0FBSztJQUNuQyxJQUFJSztJQUNKLElBQUksQ0FBQ2pCLGdFQUFzQkEsQ0FBQ1ksUUFBUTtRQUNoQyxNQUFNLElBQUlULDREQUF1QkEsQ0FBQ0ksaUJBQWlCSyxRQUFRO0lBQy9EO0lBQ0EsSUFBSUcsb0JBQW9CRyxRQUFRLENBQUNOLE1BQU1PLE1BQU0sR0FBRztRQUM1Qyw2RUFBNkU7UUFDN0UsTUFBTSxJQUFJaEIsNERBQXVCQSxDQUFDSSxpQkFBaUJLLFFBQVFBLE1BQU1PLE1BQU07SUFDM0U7SUFDQSxJQUFJQztJQUNKLElBQUk7UUFDQUEsT0FBTyxNQUFNUixNQUFNUyxJQUFJO0lBQzNCLEVBQ0EsT0FBT0MsR0FBRztRQUNOLE1BQU0sSUFBSWpCLHFEQUFnQkEsQ0FBQ0UsaUJBQWlCZSxJQUFJQTtJQUNwRDtJQUNBLElBQUlDLFlBQVlDO0lBQ2hCLE1BQU1DLHFCQUFxQnhCLGlFQUF1QkEsQ0FBQ1c7SUFDbkQsSUFBSWEsc0JBQ0FBLG1CQUFtQkMsT0FBTyxNQUFNN0Isb0RBQVksQ0FBQyxhQUFhLENBQUM4QixTQUFTLElBQ3BFLE9BQU9QLFNBQVMsWUFDaEJBLFFBQ0EsT0FBT0EsS0FBS1EsSUFBSSxLQUFLLFVBQVU7UUFDL0JMLFlBQVlILEtBQUtRLElBQUk7SUFDekIsT0FDSyxJQUFJLE9BQU9SLFNBQVMsWUFBWUEsUUFBUSxPQUFP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QUNVLGFBQWEsR0FBR1YsS0FBS1UsYUFBYTtJQUNwRDtJQUNBLE9BQU8yQztBQUNYO0FBQ08sU0FBU0MsY0FBY3RELElBQUk7SUFDOUIsSUFBSUg7SUFDSixNQUFNc0QsT0FBTyxDQUFDdEQsS0FBS0csS0FBS21ELElBQUksTUFBTSxRQUFRdEQsT0FBTyxLQUFLLElBQUlBLEtBQUtHO0lBQy9ELE9BQU87UUFBRUEsTUFBTTtZQUFFbUQ7UUFBSztRQUFHM0QsT0FBTztJQUFLO0FBQ3pDO0FBQ08sU0FBUytELGFBQWF2RCxJQUFJO0lBQzdCLE9BQU87UUFBRUE7UUFBTVIsT0FBTztJQUFLO0FBQy9CO0FBQ08sU0FBU2dFLHNCQUFzQnhELElBQUk7SUFDdEMsTUFBTSxFQUFFeUQsV0FBVyxFQUFFQyxTQUFTLEVBQUVDLFlBQVksRUFBRUMsV0FBVyxFQUFFQyxpQkFBaUIsRUFBRSxHQUFHN0QsTUFBTThELE9BQU90Riw2Q0FBTUEsQ0FBQ3dCLE1BQU07UUFBQztRQUFlO1FBQWE7UUFBZ0I7UUFBZTtLQUFvQjtJQUMzTCxNQUFNK0QsYUFBYTtRQUNmTjtRQUNBQztRQUNBQztRQUNBQztRQUNBQztJQUNKO0lBQ0EsTUFBTVYsT0FBTzFCLE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdvQztJQUMvQixPQUFPO1FBQ0g5RCxNQUFNO1lBQ0YrRDtZQUNBWjtRQUNKO1FBQ0EzRCxPQUFPO0lBQ1g7QUFDSjtBQUNPLFNBQVN3RSx1QkFBdUJoRSxJQUFJO0lBQ3ZDLE9BQU9BO0FBQ1g7QUFDQTs7OztDQUlDLEdBQ0QsU0FBU2dELFdBQVdoRCxJQUFJO0lBQ3BCLE9BQU9BLEtBQUtpRSxZQUFZLElBQUlqRSxLQUFLa0UsYUFBYSxJQUFJbEUsS0FBS2tELFVBQVU7QUFDckUsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmNob3Itd29ya2Zsb3dzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2xpYi9mZXRjaC5qcz8wMjMwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fcmVzdCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgQVBJX1ZFUlNJT05TLCBBUElfVkVSU0lPTl9IRUFERVJfTkFNRSB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IGV4cGlyZXNBdCwgbG9va3NMaWtlRmV0Y2hSZXNwb25zZSwgcGFyc2VSZXNwb25zZUFQSVZlcnNpb24gfSBmcm9tICcuL2hlbHBlcnMnO1xuaW1wb3J0IHsgQXV0aEFwaUVycm9yLCBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciwgQXV0aFdlYWtQYXNzd29yZEVycm9yLCBBdXRoVW5rbm93bkVycm9yLCBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciwgfSBmcm9tICcuL2Vycm9ycyc7XG5jb25zdCBfZ2V0RXJyb3JNZXNzYWdlID0gKGVycikgPT4gZXJyLm1zZyB8fCBlcnIubWVzc2FnZSB8fCBlcnIuZXJyb3JfZGVzY3JpcHRpb24gfHwgZXJyLmVycm9yIHx8IEpTT04uc3RyaW5naWZ5KGVycik7XG5jb25zdCBORVRXT1JLX0VSUk9SX0NPREVTID0gWzUwMiwgNTAzLCA1MDRdO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycm9yKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghbG9va3NMaWtlRmV0Y2hSZXNwb25zZShlcnJvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhSZXRyeWFibGVGZXRjaEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyb3IpLCAwKTtcbiAgICB9XG4gICAgaWYgKE5FVFdPUktfRVJST1JfQ09ERVMuaW5jbHVkZXMoZXJyb3Iuc3RhdHVzKSkge1xuICAgICAgICAvLyBzdGF0dXMgaW4gNTAwLi4uNTk5IHJhbmdlIC0gc2VydmVyIGhhZCBhbiBlcnJvciwgcmVxdWVzdCBtaWdodCBiZSByZXRyeWVkLlxuICAgICAgICB0aHJvdyBuZXcgQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnJvciksIGVycm9yLnN0YXR1cyk7XG4gICAgfVxuICAgIGxldCBkYXRhO1xuICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBhd2FpdCBlcnJvci5qc29uKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoVW5rbm93bkVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZSksIGUpO1xuICAgIH1cbiAgICBsZXQgZXJyb3JDb2RlID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJlc3BvbnNlQVBJVmVyc2lvbiA9IHBhcnNlUmVzcG9uc2VBUElWZXJzaW9uKGVycm9yKTtcbiAgICBpZiAocmVzcG9uc2VBUElWZXJzaW9uICYmXG4gICAgICAgIHJlc3BvbnNlQVBJVmVyc2lvbi5nZXRUaW1lKCkgPj0gQVBJX1ZFUlNJT05TWycyMDI0LTAxLTAxJ10udGltZXN0YW1wICYmXG4gICAgICAgIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBkYXRhICYmXG4gICAgICAgIHR5cGVvZiBkYXRhLmNvZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVycm9yQ29kZSA9IGRhdGEuY29kZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGRhdGEgJiYgdHlwZW9mIGRhdGEuZXJyb3JfY29kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZXJyb3JDb2RlID0gZGF0YS5lcnJvcl9jb2RlO1xuICAgIH1cbiAgICBpZiAoIWVycm9yQ29kZSkge1xuICAgICAgICAvLyBMZWdhY3kgc3VwcG9ydCBmb3Igd2VhayBwYXNzd29yZCBlcnJvcnMsIHdoZW4gdGhlcmUgd2VyZSBubyBlcnJvciBjb2Rlc1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBkYXRhICYmXG4gICAgICAgICAgICB0eXBlb2YgZGF0YS53ZWFrX3Bhc3N3b3JkID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zKSAmJlxuICAgICAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMubGVuZ3RoICYmXG4gICAgICAgICAgICBkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucy5yZWR1Y2UoKGEsIGkpID0+IGEgJiYgdHlwZW9mIGkgPT09ICdzdHJpbmcnLCB0cnVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhXZWFrUGFzc3dvcmRFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGRhdGEpLCBlcnJvci5zdGF0dXMsIGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvckNvZGUgPT09ICd3ZWFrX3Bhc3N3b3JkJykge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aFdlYWtQYXNzd29yZEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZGF0YSksIGVycm9yLnN0YXR1cywgKChfYSA9IGRhdGEud2Vha19wYXNzd29yZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlYXNvbnMpIHx8IFtdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3JDb2RlID09PSAnc2Vzc2lvbl9ub3RfZm91bmQnKSB7XG4gICAgICAgIC8vIFRoZSBgc2Vzc2lvbl9pZGAgaW5zaWRlIHRoZSBKV1QgZG9lcyBub3QgY29ycmVzcG9uZCB0byBhIHJvdyBpbiB0aGVcbiAgICAgICAgLy8gYHNlc3Npb25zYCB0YWJsZS4gVGhpcyB1c3VhbGx5IG1lYW5zIHRoZSB1c2VyIGhhcyBzaWduZWQgb3V0LCBoYXMgYmVlblxuICAgICAgICAvLyBkZWxldGVkLCBvciB0aGVpciBzZXNzaW9uIGhhcyBzb21laG93IGJlZW4gdGVybWluYXRlZC5cbiAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBBdXRoQXBpRXJyb3IoX2dldEVycm9yTWVzc2FnZShkYXRhKSwgZXJyb3Iuc3RhdHVzIHx8IDUwMCwgZXJyb3JDb2RlKTtcbn1cbmNvbnN0IF9nZXRSZXF1ZXN0UGFyYW1zID0gKG1ldGhvZCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkgPT4ge1xuICAgIGNvbnN0IHBhcmFtcyA9IHsgbWV0aG9kLCBoZWFkZXJzOiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpIHx8IHt9IH07XG4gICAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgcGFyYW1zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9VVRGLTgnIH0sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKTtcbiAgICBwYXJhbXMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHBhcmFtZXRlcnMpO1xufTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBfcmVxdWVzdChmZXRjaGVyLCBtZXRob2QsIHVybCwgb3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpO1xuICAgIGlmICghaGVhZGVyc1tBUElfVkVSU0lPTl9IRUFERVJfTkFNRV0pIHtcbiAgICAgICAgaGVhZGVyc1tBUElfVkVSU0lPTl9IRUFERVJfTkFNRV0gPSBBUElfVkVSU0lPTlNbJzIwMjQtMDEtMDEnXS5uYW1lO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmp3dCkge1xuICAgICAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7b3B0aW9ucy5qd3R9YDtcbiAgICB9XG4gICAgY29uc3QgcXMgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucXVlcnkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVkaXJlY3RUbykge1xuICAgICAgICBxc1sncmVkaXJlY3RfdG8nXSA9IG9wdGlvbnMucmVkaXJlY3RUbztcbiAgICB9XG4gICAgY29uc3QgcXVlcnlTdHJpbmcgPSBPYmplY3Qua2V5cyhxcykubGVuZ3RoID8gJz8nICsgbmV3IFVSTFNlYXJjaFBhcmFtcyhxcykudG9TdHJpbmcoKSA6ICcnO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCBtZXRob2QsIHVybCArIHF1ZXJ5U3RyaW5nLCB7XG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIG5vUmVzb2x2ZUpzb246IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ub1Jlc29sdmVKc29uLFxuICAgIH0sIHt9LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYm9keSk7XG4gICAgcmV0dXJuIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMueGZvcm0pID8gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnhmb3JtKGRhdGEpIDogeyBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBkYXRhKSwgZXJyb3I6IG51bGwgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsIG1ldGhvZCwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KSB7XG4gICAgY29uc3QgcmVxdWVzdFBhcmFtcyA9IF9nZXRSZXF1ZXN0UGFyYW1zKG1ldGhvZCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBhd2FpdCBmZXRjaGVyKHVybCwgT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdFBhcmFtcykpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAvLyBmZXRjaCBmYWlsZWQsIGxpa2VseSBkdWUgdG8gYSBuZXR3b3JrIG9yIENPUlMgZXJyb3JcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhSZXRyeWFibGVGZXRjaEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZSksIDApO1xuICAgIH1cbiAgICBpZiAoIXJlc3VsdC5vaykge1xuICAgICAgICBhd2FpdCBoYW5kbGVFcnJvcihyZXN1bHQpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm5vUmVzb2x2ZUpzb24pIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3VsdC5qc29uKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVycm9yKGUpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBfc2Vzc2lvblJlc3BvbnNlKGRhdGEpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHNlc3Npb24gPSBudWxsO1xuICAgIGlmIChoYXNTZXNzaW9uKGRhdGEpKSB7XG4gICAgICAgIHNlc3Npb24gPSBPYmplY3QuYXNzaWduKHt9LCBkYXRhKTtcbiAgICAgICAgaWYgKCFkYXRhLmV4cGlyZXNfYXQpIHtcbiAgICAgICAgICAgIHNlc3Npb24uZXhwaXJlc19hdCA9IGV4cGlyZXNBdChkYXRhLmV4cGlyZXNfaW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHVzZXIgPSAoX2EgPSBkYXRhLnVzZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRhdGE7XG4gICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uLCB1c2VyIH0sIGVycm9yOiBudWxsIH07XG59XG5leHBvcnQgZnVuY3Rpb24gX3Nlc3Npb25SZXNwb25zZVBhc3N3b3JkKGRhdGEpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IF9zZXNzaW9uUmVzcG9uc2UoZGF0YSk7XG4gICAgaWYgKCFyZXNwb25zZS5lcnJvciAmJlxuICAgICAgICBkYXRhLndlYWtfcGFzc3dvcmQgJiZcbiAgICAgICAgdHlwZW9mIGRhdGEud2Vha19wYXNzd29yZCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheShkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucykgJiZcbiAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMubGVuZ3RoICYmXG4gICAgICAgIGRhdGEud2Vha19wYXNzd29yZC5tZXNzYWdlICYmXG4gICAgICAgIHR5cGVvZiBkYXRhLndlYWtfcGFzc3dvcmQubWVzc2FnZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMucmVkdWNlKChhLCBpKSA9PiBhICYmIHR5cGVvZiBpID09PSAnc3RyaW5nJywgdHJ1ZSkpIHtcbiAgICAgICAgcmVzcG9uc2UuZGF0YS53ZWFrX3Bhc3N3b3JkID0gZGF0YS53ZWFrX3Bhc3N3b3JkO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gX3VzZXJSZXNwb25zZShkYXRhKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHVzZXIgPSAoX2EgPSBkYXRhLnVzZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRhdGE7XG4gICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyIH0sIGVycm9yOiBudWxsIH07XG59XG5leHBvcnQgZnVuY3Rpb24gX3Nzb1Jlc3BvbnNlKGRhdGEpIHtcbiAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIF9nZW5lcmF0ZUxpbmtSZXNwb25zZShkYXRhKSB7XG4gICAgY29uc3QgeyBhY3Rpb25fbGluaywgZW1haWxfb3RwLCBoYXNoZWRfdG9rZW4sIHJlZGlyZWN0X3RvLCB2ZXJpZmljYXRpb25fdHlwZSB9ID0gZGF0YSwgcmVzdCA9IF9fcmVzdChkYXRhLCBbXCJhY3Rpb25fbGlua1wiLCBcImVtYWlsX290cFwiLCBcImhhc2hlZF90b2tlblwiLCBcInJlZGlyZWN0X3RvXCIsIFwidmVyaWZpY2F0aW9uX3R5cGVcIl0pO1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIGFjdGlvbl9saW5rLFxuICAgICAgICBlbWFpbF9vdHAsXG4gICAgICAgIGhhc2hlZF90b2tlbixcbiAgICAgICAgcmVkaXJlY3RfdG8sXG4gICAgICAgIHZlcmlmaWNhdGlvbl90eXBlLFxuICAgIH07XG4gICAgY29uc3QgdXNlciA9IE9iamVjdC5hc3NpZ24oe30sIHJlc3QpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgICB1c2VyLFxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIF9ub1Jlc29sdmVKc29uUmVzcG9uc2UoZGF0YSkge1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBoYXNTZXNzaW9uIGNoZWNrcyBpZiB0aGUgcmVzcG9uc2Ugb2JqZWN0IGNvbnRhaW5zIGEgdmFsaWQgc2Vzc2lvblxuICogQHBhcmFtIGRhdGEgQSByZXNwb25zZSBvYmplY3RcbiAqIEByZXR1cm5zIHRydWUgaWYgYSBzZXNzaW9uIGlzIGluIHRoZSByZXNwb25zZVxuICovXG5mdW5jdGlvbiBoYXNTZXNzaW9uKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5hY2Nlc3NfdG9rZW4gJiYgZGF0YS5yZWZyZXNoX3Rva2VuICYmIGRhdGEuZXhwaXJlc19pbjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLmpzLm1hcCJdLCJuYW1lcyI6WyJfX3Jlc3QiLCJBUElfVkVSU0lPTlMiLCJBUElfVkVSU0lPTl9IRUFERVJfTkFNRSIsImV4cGlyZXNBdCIsImxvb2tzTGlrZUZldGNoUmVzcG9uc2UiLCJwYXJzZVJlc3BvbnNlQVBJVmVyc2lvbiIsIkF1dGhBcGlFcnJvciIsIkF1dGhSZXRyeWFibGVGZXRjaEVycm9yIiwiQXV0aFdlYWtQYXNzd29yZEVycm9yIiwiQXV0aFVua25vd25FcnJvciIsIkF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yIiwiX2dldEVycm9yTWVzc2FnZSIsImVyciIsIm1zZyIsIm1lc3NhZ2UiLCJlcnJvcl9kZXNjcmlwdGlvbiIsImVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsIk5FVFdPUktfRVJST1JfQ09ERVMiLCJoYW5kbGVFcnJvciIsIl9hIiwiaW5jbHVkZXMiLCJzdGF0dXMiLCJkYXRhIiwianNvbiIsImUiLCJlcnJvckNvZGUiLCJ1bmRlZmluZWQiLCJyZXNwb25zZUFQSVZlcnNpb24iLCJnZXRUaW1lIiwidGltZXN0YW1wIiwiY29kZSIsImVycm9yX2NvZGUiLCJ3ZWFrX3Bhc3N3b3JkIiwiQXJyYXkiLCJpc0FycmF5IiwicmVhc29ucyIsImxlbmd0aCIsInJlZHVjZSIsImEiLCJpIiwiX2dldFJlcXVlc3RQYXJhbXMiLCJtZXRob2QiLCJvcHRpb25zIiwicGFyYW1ldGVycyIsImJvZHkiLCJwYXJhbXMiLCJoZWFkZXJzIiwiT2JqZWN0IiwiYXNzaWduIiwiX3JlcXVlc3QiLCJmZXRjaGVyIiwidXJsIiwibmFtZSIsImp3dCIsInFzIiwicXVlcnkiLCJyZWRpcmVjdFRvIiwicXVlcnlTdHJpbmciLCJrZXlzIiwiVVJMU2VhcmNoUGFyYW1zIiwidG9TdHJpbmciLCJfaGFuZGxlUmVxdWVzdCIsIm5vUmVzb2x2ZUpzb24iLCJ4Zm9ybSIsInJlcXVlc3RQYXJhbXMiLCJyZXN1bHQiLCJjb25zb2xlIiwib2siLCJfc2Vzc2lvblJlc3BvbnNlIiwic2Vzc2lvbiIsImhhc1Nlc3Npb24iLCJleHBpcmVzX2F0IiwiZXhwaXJlc19pbiIsInVzZXIiLCJfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQiLCJyZXNwb25zZSIsIl91c2VyUmVzcG9uc2UiLCJfc3NvUmVzcG9uc2UiLCJfZ2VuZXJhdGVMaW5rUmVzcG9uc2UiLCJhY3Rpb25fbGluayIsImVtYWlsX290cCIsImhhc2hlZF90b2tlbiIsInJlZGlyZWN0X3RvIiwidmVyaWZpY2F0aW9uX3R5cGUiLCJyZXN0IiwicHJvcGVydGllcyIsIl9ub1Jlc29sdmVKc29uUmVzcG9uc2UiLCJhY2Nlc3NfdG9rZW4iLCJyZWZyZXNoX3Rva2VuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/helpers.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Deferred: () => (/* binding */ Deferred),\n/* harmony export */   decodeJWT: () => (/* binding */ decodeJWT),\n/* harmony export */   deepClone: () => (/* binding */ deepClone),\n/* harmony export */   expiresAt: () => (/* binding */ expiresAt),\n/* harmony export */   generateCallbackId: () => (/* binding */ generateCallbackId),\n/* harmony export */   generatePKCEChallenge: () => (/* binding */ generatePKCEChallenge),\n/* harmony export */   generatePKCEVerifier: () => (/* binding */ generatePKCEVerifier),\n/* harmony export */   getAlgorithm: () => (/* binding */ getAlgorithm),\n/* harmony export */   getCodeChallengeAndMethod: () => (/* binding */ getCodeChallengeAndMethod),\n/* harmony export */   getItemAsync: () => (/* binding */ getItemAsync),\n/* harmony export */   insecureUserWarningProxy: () => (/* binding */ insecureUserWarningProxy),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   looksLikeFetchResponse: () => (/* binding */ looksLikeFetchResponse),\n/* harmony export */   parseParametersFromURL: () => (/* binding */ parseParametersFromURL),\n/* harmony export */   parseResponseAPIVersion: () => (/* binding */ parseResponseAPIVersion),\n/* harmony export */   removeItemAsync: () => (/* binding */ removeItemAsync),\n/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch),\n/* harmony export */   retryable: () => (/* binding */ retryable),\n/* harmony export */   setItemAsync: () => (/* binding */ setItemAsync),\n/* harmony export */   sleep: () => (/* binding */ sleep),\n/* harmony export */   supportsLocalStorage: () => (/* binding */ supportsLocalStorage),\n/* harmony export */   userNotAvailableProxy: () => (/* binding */ userNotAvailableProxy),\n/* harmony export */   validateExp: () => (/* binding */ validateExp),\n/* harmony export */   validateUUID: () => (/* binding */ validateUUID)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n/* harmony import */ var _base64url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base64url */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/base64url.js\");\n\n\n\nfunction expiresAt(expiresIn) {\n    const timeNow = Math.round(Date.now() / 1000);\n    return timeNow + expiresIn;\n}\n/**\n * Generates a unique identifier for internal callback subscriptions.\n *\n * This function uses JavaScript Symbols to create guaranteed-unique identifiers\n * for auth state change callbacks. Symbols are ideal for this use case because:\n * - They are guaranteed unique by the JavaScript runtime\n * - They work in all environments (browser, SSR, Node.js)\n * - They avoid issues with Next.js 16 deterministic rendering requirements\n * - They are perfect for internal, non-serializable identifiers\n *\n * Note: This function is only used for internal subscription management,\n * not for security-critical operations like session tokens.\n */ function generateCallbackId() {\n    return Symbol(\"auth-callback\");\n}\nconst isBrowser = ()=> false && 0;\nconst localStorageWriteTests = {\n    tested: false,\n    writable: false\n};\n/**\n * Checks whether localStorage is supported on this browser.\n */ const supportsLocalStorage = ()=>{\n    if (!isBrowser()) {\n        return false;\n    }\n    try {\n        if (typeof globalThis.localStorage !== \"object\") {\n            return false;\n        }\n    } catch (e) {\n        // DOM exception when accessing `localStorage`\n        return false;\n    }\n    if (localStorageWriteTests.tested) {\n        return localStorageWriteTests.writable;\n    }\n    const randomKey = `lswt-${Math.random()}${Math.random()}`;\n    try {\n        globalThis.localStorage.setItem(randomKey, randomKey);\n        globalThis.localStorage.removeItem(randomKey);\n        localStorageWriteTests.tested = true;\n        localStorageWriteTests.writable = true;\n    } catch (e) {\n        // localStorage can't be written to\n        // https://www.chromium.org/for-testers/bug-reporting-guidelines/uncaught-securityerror-failed-to-read-the-localstorage-property-from-window-access-is-denied-for-this-document\n        localStorageWriteTests.tested = true;\n        localStorageWriteTests.writable = false;\n    }\n    return localStorageWriteTests.writable;\n};\n/**\n * Extracts parameters encoded in the URL both in the query and fragment.\n */ function parseParametersFromURL(href) {\n    const result = {};\n    const url = new URL(href);\n    if (url.hash && url.hash[0] === \"#\") {\n        try {\n            const hashSearchParams = new URLSearchParams(url.hash.substring(1));\n            hashSearchParams.forEach((value, key)=>{\n                result[key] = value;\n            });\n        } catch (e) {\n        // hash is not a query string\n        }\n    }\n    // search parameters take precedence over hash parameters\n    url.searchParams.forEach((value, key)=>{\n        result[key] = value;\n    });\n    return result;\n}\nconst resolveFetch = (customFetch)=>{\n    if (customFetch) {\n        return (...args)=>customFetch(...args);\n    }\n    return (...args)=>fetch(...args);\n};\nconst looksLikeFetchResponse = (maybeResponse)=>{\n    return typeof maybeResponse === \"object\" && maybeResponse !== null && \"status\" in maybeResponse && \"ok\" in maybeResponse && \"json\" in maybeResponse && typeof maybeResponse.json === \"function\";\n};\n// Storage helpers\nconst setItemAsync = async (storage, key, data)=>{\n    await storage.setItem(key, JSON.stringify(data));\n};\nconst getItemAsync = async (storage, key)=>{\n    const value = await storage.getItem(key);\n    if (!value) {\n        return null;\n    }\n    try {\n        return JSON.parse(value);\n    } catch (_a) {\n        return value;\n    }\n};\nconst removeItemAsync = async (storage, key)=>{\n    await storage.removeItem(key);\n};\n/**\n * A deferred represents some asynchronous work that is not yet finished, which\n * may or may not culminate in a value.\n * Taken from: https://github.com/mike-north/types/blob/master/src/async.ts\n */ class Deferred {\n    constructor(){\n        // eslint-disable-next-line @typescript-eslint/no-extra-semi\n        ;\n        this.promise = new Deferred.promiseConstructor((res, rej)=>{\n            // eslint-disable-next-line @typescript-eslint/no-extra-semi\n            ;\n            this.resolve = res;\n            this.reject = rej;\n        });\n    }\n}\nDeferred.promiseConstructor = Promise;\nfunction decodeJWT(token) {\n    const parts = token.split(\".\");\n    if (parts.length !== 3) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthInvalidJwtError(\"Invalid JWT structure\");\n    }\n    // Regex checks for base64url format\n    for(let i = 0; i < parts.length; i++){\n        if (!_constants__WEBPACK_IMPORTED_MODULE_0__.BASE64URL_REGEX.test(parts[i])) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthInvalidJwtError(\"JWT not in base64url format\");\n        }\n    }\n    const data = {\n        // using base64url lib\n        header: JSON.parse((0,_base64url__WEBPACK_IMPORTED_MODULE_2__.stringFromBase64URL)(parts[0])),\n        payload: JSON.parse((0,_base64url__WEBPACK_IMPORTED_MODULE_2__.stringFromBase64URL)(parts[1])),\n        signature: (0,_base64url__WEBPACK_IMPORTED_MODULE_2__.base64UrlToUint8Array)(parts[2]),\n        raw: {\n            header: parts[0],\n            payload: parts[1]\n        }\n    };\n    return data;\n}\n/**\n * Creates a promise that resolves to null after some time.\n */ async function sleep(time) {\n    return await new Promise((accept)=>{\n        setTimeout(()=>accept(null), time);\n    });\n}\n/**\n * Converts the provided async function into a retryable function. Each result\n * or thrown error is sent to the isRetryable function which should return true\n * if the function should run again.\n */ function retryable(fn, isRetryable) {\n    const promise = new Promise((accept, reject)=>{\n        // eslint-disable-next-line @typescript-eslint/no-extra-semi\n        ;\n        (async ()=>{\n            for(let attempt = 0; attempt < Infinity; attempt++){\n                try {\n                    const result = await fn(attempt);\n                    if (!isRetryable(attempt, null, result)) {\n                        accept(result);\n                        return;\n                    }\n                } catch (e) {\n                    if (!isRetryable(attempt, e)) {\n                        reject(e);\n                        return;\n                    }\n                }\n            }\n        })();\n    });\n    return promise;\n}\nfunction dec2hex(dec) {\n    return (\"0\" + dec.toString(16)).substr(-2);\n}\n// Functions below taken from: https://stackoverflow.com/questions/63309409/creating-a-code-verifier-and-challenge-for-pkce-auth-on-spotify-api-in-reactjs\nfunction generatePKCEVerifier() {\n    const verifierLength = 56;\n    const array = new Uint32Array(verifierLength);\n    if (typeof crypto === \"undefined\") {\n        const charSet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~\";\n        const charSetLen = charSet.length;\n        let verifier = \"\";\n        for(let i = 0; i < verifierLength; i++){\n            verifier += charSet.charAt(Math.floor(Math.random() * charSetLen));\n        }\n        return verifier;\n    }\n    crypto.getRandomValues(array);\n    return Array.from(array, dec2hex).join(\"\");\n}\nasync function sha256(randomString) {\n    const encoder = new TextEncoder();\n    const encodedData = encoder.encode(randomString);\n    const hash = await crypto.subtle.digest(\"SHA-256\", encodedData);\n    const bytes = new Uint8Array(hash);\n    return Array.from(bytes).map((c)=>String.fromCharCode(c)).join(\"\");\n}\nasync function generatePKCEChallenge(verifier) {\n    const hasCryptoSupport = typeof crypto !== \"undefined\" && typeof crypto.subtle !== \"undefined\" && typeof TextEncoder !== \"undefined\";\n    if (!hasCryptoSupport) {\n        console.warn(\"WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.\");\n        return verifier;\n    }\n    const hashed = await sha256(verifier);\n    return btoa(hashed).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\nasync function getCodeChallengeAndMethod(storage, storageKey, isPasswordRecovery = false) {\n    const codeVerifier = generatePKCEVerifier();\n    let storedCodeVerifier = codeVerifier;\n    if (isPasswordRecovery) {\n        storedCodeVerifier += \"/PASSWORD_RECOVERY\";\n    }\n    await setItemAsync(storage, `${storageKey}-code-verifier`, storedCodeVerifier);\n    const codeChallenge = await generatePKCEChallenge(codeVerifier);\n    const codeChallengeMethod = codeVerifier === codeChallenge ? \"plain\" : \"s256\";\n    return [\n        codeChallenge,\n        codeChallengeMethod\n    ];\n}\n/** Parses the API version which is 2YYY-MM-DD. */ const API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;\nfunction parseResponseAPIVersion(response) {\n    const apiVersion = response.headers.get(_constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSION_HEADER_NAME);\n    if (!apiVersion) {\n        return null;\n    }\n    if (!apiVersion.match(API_VERSION_REGEX)) {\n        return null;\n    }\n    try {\n        const date = new Date(`${apiVersion}T00:00:00.0Z`);\n        return date;\n    } catch (e) {\n        return null;\n    }\n}\nfunction validateExp(exp) {\n    if (!exp) {\n        throw new Error(\"Missing exp claim\");\n    }\n    const timeNow = Math.floor(Date.now() / 1000);\n    if (exp <= timeNow) {\n        throw new Error(\"JWT has expired\");\n    }\n}\nfunction getAlgorithm(alg) {\n    switch(alg){\n        case \"RS256\":\n            return {\n                name: \"RSASSA-PKCS1-v1_5\",\n                hash: {\n                    name: \"SHA-256\"\n                }\n            };\n        case \"ES256\":\n            return {\n                name: \"ECDSA\",\n                namedCurve: \"P-256\",\n                hash: {\n                    name: \"SHA-256\"\n                }\n            };\n        default:\n            throw new Error(\"Invalid alg claim\");\n    }\n}\nconst UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;\nfunction validateUUID(str) {\n    if (!UUID_REGEX.test(str)) {\n        throw new Error(\"@supabase/auth-js: Expected parameter to be UUID but is not\");\n    }\n}\nfunction userNotAvailableProxy() {\n    const proxyTarget = {};\n    return new Proxy(proxyTarget, {\n        get: (target, prop)=>{\n            if (prop === \"__isUserNotAvailableProxy\") {\n                return true;\n            }\n            // Preventative check for common problematic symbols during cloning/inspection\n            // These symbols might be accessed by structuredClone or other internal mechanisms.\n            if (typeof prop === \"symbol\") {\n                const sProp = prop.toString();\n                if (sProp === \"Symbol(Symbol.toPrimitive)\" || sProp === \"Symbol(Symbol.toStringTag)\" || sProp === \"Symbol(util.inspect.custom)\") {\n                    // Node.js util.inspect\n                    return undefined;\n                }\n            }\n            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the \"${prop}\" property of the session object is not supported. Please use getUser() instead.`);\n        },\n        set: (_target, prop)=>{\n            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the \"${prop}\" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);\n        },\n        deleteProperty: (_target, prop)=>{\n            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the \"${prop}\" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);\n        }\n    });\n}\n/**\n * Creates a proxy around a user object that warns when properties are accessed on the server.\n * This is used to alert developers that using user data from getSession() on the server is insecure.\n *\n * @param user The actual user object to wrap\n * @param suppressWarningRef An object with a 'value' property that controls warning suppression\n * @returns A proxied user object that warns on property access\n */ function insecureUserWarningProxy(user, suppressWarningRef) {\n    return new Proxy(user, {\n        get: (target, prop, receiver)=>{\n            // Allow internal checks without warning\n            if (prop === \"__isInsecureUserWarningProxy\") {\n                return true;\n            }\n            // Preventative check for common problematic symbols during cloning/inspection\n            // These symbols might be accessed by structuredClone or other internal mechanisms\n            if (typeof prop === \"symbol\") {\n                const sProp = prop.toString();\n                if (sProp === \"Symbol(Symbol.toPrimitive)\" || sProp === \"Symbol(Symbol.toStringTag)\" || sProp === \"Symbol(util.inspect.custom)\" || sProp === \"Symbol(nodejs.util.inspect.custom)\") {\n                    // Return the actual value for these symbols to allow proper inspection\n                    return Reflect.get(target, prop, receiver);\n                }\n            }\n            // Emit warning on first property access\n            if (!suppressWarningRef.value && typeof prop === \"string\") {\n                console.warn(\"Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server.\");\n                suppressWarningRef.value = true;\n            }\n            return Reflect.get(target, prop, receiver);\n        }\n    });\n}\n/**\n * Deep clones a JSON-serializable object using JSON.parse(JSON.stringify(obj)).\n * Note: Only works for JSON-safe data.\n */ function deepClone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n} //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVFO0FBQ3hCO0FBQzBCO0FBQ2xFLFNBQVNLLFVBQVVDLFNBQVM7SUFDL0IsTUFBTUMsVUFBVUMsS0FBS0MsS0FBSyxDQUFDQyxLQUFLQyxHQUFHLEtBQUs7SUFDeEMsT0FBT0osVUFBVUQ7QUFDckI7QUFDQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDTSxTQUFTTTtJQUNaLE9BQU9DLE9BQU87QUFDbEI7QUFDTyxNQUFNQyxZQUFZLElBQU0sTUFBa0IsSUFBZSxDQUFvQixDQUFZO0FBQ2hHLE1BQU1FLHlCQUF5QjtJQUMzQkMsUUFBUTtJQUNSQyxVQUFVO0FBQ2Q7QUFDQTs7Q0FFQyxHQUNNLE1BQU1DLHVCQUF1QjtJQUNoQyxJQUFJLENBQUNMLGFBQWE7UUFDZCxPQUFPO0lBQ1g7SUFDQSxJQUFJO1FBQ0EsSUFBSSxPQUFPTSxXQUFXQyxZQUFZLEtBQUssVUFBVTtZQUM3QyxPQUFPO1FBQ1g7SUFDSixFQUNBLE9BQU9DLEdBQUc7UUFDTiw4Q0FBOEM7UUFDOUMsT0FBTztJQUNYO0lBQ0EsSUFBSU4sdUJBQXVCQyxNQUFNLEVBQUU7UUFDL0IsT0FBT0QsdUJBQXVCRSxRQUFRO0lBQzFDO0lBQ0EsTUFBTUssWUFBWSxDQUFDLEtBQUssRUFBRWYsS0FBS2dCLE1BQU0sR0FBRyxFQUFFaEIsS0FBS2dCLE1BQU0sR0FBRyxDQUFDO0lBQ3pELElBQUk7UUFDQUosV0FBV0MsWUFBWSxDQUFDSSxPQUFPLENBQUNGLFdBQVdBO1FBQzNDSCxXQUFXQyxZQUFZLENBQUNLLFVBQVUsQ0FBQ0g7UUFDbkNQLHVCQUF1QkMsTUFBTSxHQUFHO1FBQ2hDRCx1QkFBdUJFLFFBQVEsR0FBRztJQUN0QyxFQUNBLE9BQU9JLEdBQUc7UUFDTixtQ0FBbUM7UUFDbkMsK0tBQStLO1FBQy9LTix1QkFB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O2dCQUMxQixNQUFNQyxRQUFRRCxLQUFLbEUsUUFBUTtnQkFDM0IsSUFBSW1FLFVBQVUsZ0NBQ1ZBLFVBQVUsZ0NBQ1ZBLFVBQVUsaUNBQ1ZBLFVBQVUsc0NBQXNDO29CQUNoRCx1RUFBdUU7b0JBQ3ZFLE9BQU9TLFFBQVEzQixHQUFHLENBQUNnQixRQUFRQyxNQUFNUztnQkFDckM7WUFDSjtZQUNBLHdDQUF3QztZQUN4QyxJQUFJLENBQUNELG1CQUFtQjdILEtBQUssSUFBSSxPQUFPcUgsU0FBUyxVQUFVO2dCQUN2RGxDLFFBQVFDLElBQUksQ0FBQztnQkFDYnlDLG1CQUFtQjdILEtBQUssR0FBRztZQUMvQjtZQUNBLE9BQU8rSCxRQUFRM0IsR0FBRyxDQUFDZ0IsUUFBUUMsTUFBTVM7UUFDckM7SUFDSjtBQUNKO0FBQ0E7OztDQUdDLEdBQ00sU0FBU0UsVUFBVUMsR0FBRztJQUN6QixPQUFPcEgsS0FBS0ksS0FBSyxDQUFDSixLQUFLQyxTQUFTLENBQUNtSDtBQUNyQyxFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FuY2hvci13b3JrZmxvd3MvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2hlbHBlcnMuanM/NWE2OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBUElfVkVSU0lPTl9IRUFERVJfTkFNRSwgQkFTRTY0VVJMX1JFR0VYIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgQXV0aEludmFsaWRKd3RFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IGJhc2U2NFVybFRvVWludDhBcnJheSwgc3RyaW5nRnJvbUJhc2U2NFVSTCB9IGZyb20gJy4vYmFzZTY0dXJsJztcbmV4cG9ydCBmdW5jdGlvbiBleHBpcmVzQXQoZXhwaXJlc0luKSB7XG4gICAgY29uc3QgdGltZU5vdyA9IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgIHJldHVybiB0aW1lTm93ICsgZXhwaXJlc0luO1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgaW50ZXJuYWwgY2FsbGJhY2sgc3Vic2NyaXB0aW9ucy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHVzZXMgSmF2YVNjcmlwdCBTeW1ib2xzIHRvIGNyZWF0ZSBndWFyYW50ZWVkLXVuaXF1ZSBpZGVudGlmaWVyc1xuICogZm9yIGF1dGggc3RhdGUgY2hhbmdlIGNhbGxiYWNrcy4gU3ltYm9scyBhcmUgaWRlYWwgZm9yIHRoaXMgdXNlIGNhc2UgYmVjYXVzZTpcbiAqIC0gVGhleSBhcmUgZ3VhcmFudGVlZCB1bmlxdWUgYnkgdGhlIEphdmFTY3JpcHQgcnVudGltZVxuICogLSBUaGV5IHdvcmsgaW4gYWxsIGVudmlyb25tZW50cyAoYnJvd3NlciwgU1NSLCBOb2RlLmpzKVxuICogLSBUaGV5IGF2b2lkIGlzc3VlcyB3aXRoIE5leHQuanMgMTYgZGV0ZXJtaW5pc3RpYyByZW5kZXJpbmcgcmVxdWlyZW1lbnRzXG4gKiAtIFRoZXkgYXJlIHBlcmZlY3QgZm9yIGludGVybmFsLCBub24tc2VyaWFsaXphYmxlIGlkZW50aWZpZXJzXG4gKlxuICogTm90ZTogVGhpcyBmdW5jdGlvbiBpcyBvbmx5IHVzZWQgZm9yIGludGVybmFsIHN1YnNjcmlwdGlvbiBtYW5hZ2VtZW50LFxuICogbm90IGZvciBzZWN1cml0eS1jcml0aWNhbCBvcGVyYXRpb25zIGxpa2Ugc2Vzc2lvbiB0b2tlbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUNhbGxiYWNrSWQoKSB7XG4gICAgcmV0dXJuIFN5bWJvbCgnYXV0aC1jYWxsYmFjaycpO1xufVxuZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9ICgpID0+IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5jb25zdCBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzID0ge1xuICAgIHRlc3RlZDogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlLFxufTtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgbG9jYWxTdG9yYWdlIGlzIHN1cHBvcnRlZCBvbiB0aGlzIGJyb3dzZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBzdXBwb3J0c0xvY2FsU3RvcmFnZSA9ICgpID0+IHtcbiAgICBpZiAoIWlzQnJvd3NlcigpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBET00gZXhjZXB0aW9uIHdoZW4gYWNjZXNzaW5nIGBsb2NhbFN0b3JhZ2VgXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMudGVzdGVkKSB7XG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLndyaXRhYmxlO1xuICAgIH1cbiAgICBjb25zdCByYW5kb21LZXkgPSBgbHN3dC0ke01hdGgucmFuZG9tKCl9JHtNYXRoLnJhbmRvbSgpfWA7XG4gICAgdHJ5IHtcbiAgICAgICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShyYW5kb21LZXksIHJhbmRvbUtleSk7XG4gICAgICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0ocmFuZG9tS2V5KTtcbiAgICAgICAgbG9jYWxTdG9yYWdlV3JpdGVUZXN0cy50ZXN0ZWQgPSB0cnVlO1xuICAgICAgICBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gbG9jYWxTdG9yYWdlIGNhbid0IGJlIHdyaXR0ZW4gdG9cbiAgICAgICAgLy8gaHR0cHM6Ly93d3cuY2hyb21pdW0ub3JnL2Zvci10ZXN0ZXJzL2J1Zy1yZXBvcnRpbmctZ3VpZGVsaW5lcy91bmNhdWdodC1zZWN1cml0eWVycm9yLWZhaWxlZC10by1yZWFkLXRoZS1sb2NhbHN0b3JhZ2UtcHJvcGVydHktZnJvbS13aW5kb3ctYWNjZXNzLWlzLWRlbmllZC1mb3ItdGhpcy1kb2N1bWVudFxuICAgICAgICBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLnRlc3RlZCA9IHRydWU7XG4gICAgICAgIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMud3JpdGFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMud3JpdGFibGU7XG59O1xuLyoqXG4gKiBFeHRyYWN0cyBwYXJhbWV0ZXJzIGVuY29kZWQgaW4gdGhlIFVSTCBib3RoIGluIHRoZSBxdWVyeSBhbmQgZnJhZ21lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVBhcmFtZXRlcnNGcm9tVVJMKGhyZWYpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGhyZWYpO1xuICAgIGlmICh1cmwuaGFzaCAmJiB1cmwuaGFzaFswXSA9PT0gJyMnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBoYXNoU2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh1cmwuaGFzaC5zdWJzdHJpbmcoMSkpO1xuICAgICAgICAgICAgaGFzaFNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBoYXNoIGlzIG5vdCBhIHF1ZXJ5IHN0cmluZ1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHNlYXJjaCBwYXJhbWV0ZXJzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGhhc2ggcGFyYW1ldGVyc1xuICAgIHVybC5zZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgY29uc3QgcmVzb2x2ZUZldGNoID0gKGN1c3RvbUZldGNoKSA9PiB7XG4gICAgaWYgKGN1c3RvbUZldGNoKSB7XG4gICAgICAgIHJldHVybiAoLi4uYXJncykgPT4gY3VzdG9tRmV0Y2goLi4uYXJncyk7XG4gICAgfVxuICAgIHJldHVybiAoLi4uYXJncykgPT4gZmV0Y2goLi4uYXJncyk7XG59O1xuZXhwb3J0IGNvbnN0IGxvb2tzTGlrZUZldGNoUmVzcG9uc2UgPSAobWF5YmVSZXNwb25zZSkgPT4ge1xuICAgIHJldHVybiAodHlwZW9mIG1heWJlUmVzcG9uc2UgPT09ICdvYmplY3QnICYmXG4gICAgICAgIG1heWJlUmVzcG9uc2UgIT09IG51bGwgJiZcbiAgICAgICAgJ3N0YXR1cycgaW4gbWF5YmVSZXNwb25zZSAmJlxuICAgICAgICAnb2snIGluIG1heWJlUmVzcG9uc2UgJiZcbiAgICAgICAgJ2pzb24nIGluIG1heWJlUmVzcG9uc2UgJiZcbiAgICAgICAgdHlwZW9mIG1heWJlUmVzcG9uc2UuanNvbiA9PT0gJ2Z1bmN0aW9uJyk7XG59O1xuLy8gU3RvcmFnZSBoZWxwZXJzXG5leHBvcnQgY29uc3Qgc2V0SXRlbUFzeW5jID0gYXN5bmMgKHN0b3JhZ2UsIGtleSwgZGF0YSkgPT4ge1xuICAgIGF3YWl0IHN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbn07XG5leHBvcnQgY29uc3QgZ2V0SXRlbUFzeW5jID0gYXN5bmMgKHN0b3JhZ2UsIGtleSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgc3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgcmVtb3ZlSXRlbUFzeW5jID0gYXN5bmMgKHN0b3JhZ2UsIGtleSkgPT4ge1xuICAgIGF3YWl0IHN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xufTtcbi8qKlxuICogQSBkZWZlcnJlZCByZXByZXNlbnRzIHNvbWUgYXN5bmNocm9ub3VzIHdvcmsgdGhhdCBpcyBub3QgeWV0IGZpbmlzaGVkLCB3aGljaFxuICogbWF5IG9yIG1heSBub3QgY3VsbWluYXRlIGluIGEgdmFsdWUuXG4gKiBUYWtlbiBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbWlrZS1ub3J0aC90eXBlcy9ibG9iL21hc3Rlci9zcmMvYXN5bmMudHNcbiAqL1xuZXhwb3J0IGNsYXNzIERlZmVycmVkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYS1zZW1pXG4gICAgICAgIDtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IERlZmVycmVkLnByb21pc2VDb25zdHJ1Y3RvcigocmVzLCByZWopID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmEtc2VtaVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlID0gcmVzO1xuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSByZWo7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbkRlZmVycmVkLnByb21pc2VDb25zdHJ1Y3RvciA9IFByb21pc2U7XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlSldUKHRva2VuKSB7XG4gICAgY29uc3QgcGFydHMgPSB0b2tlbi5zcGxpdCgnLicpO1xuICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhJbnZhbGlkSnd0RXJyb3IoJ0ludmFsaWQgSldUIHN0cnVjdHVyZScpO1xuICAgIH1cbiAgICAvLyBSZWdleCBjaGVja3MgZm9yIGJhc2U2NHVybCBmb3JtYXRcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghQkFTRTY0VVJMX1JFR0VYLnRlc3QocGFydHNbaV0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRKd3RFcnJvcignSldUIG5vdCBpbiBiYXNlNjR1cmwgZm9ybWF0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgLy8gdXNpbmcgYmFzZTY0dXJsIGxpYlxuICAgICAgICBoZWFkZXI6IEpTT04ucGFyc2Uoc3RyaW5nRnJvbUJhc2U2NFVSTChwYXJ0c1swXSkpLFxuICAgICAgICBwYXlsb2FkOiBKU09OLnBhcnNlKHN0cmluZ0Zyb21CYXNlNjRVUkwocGFydHNbMV0pKSxcbiAgICAgICAgc2lnbmF0dXJlOiBiYXNlNjRVcmxUb1VpbnQ4QXJyYXkocGFydHNbMl0pLFxuICAgICAgICByYXc6IHtcbiAgICAgICAgICAgIGhlYWRlcjogcGFydHNbMF0sXG4gICAgICAgICAgICBwYXlsb2FkOiBwYXJ0c1sxXSxcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIG51bGwgYWZ0ZXIgc29tZSB0aW1lLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2xlZXAodGltZSkge1xuICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgoYWNjZXB0KSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gYWNjZXB0KG51bGwpLCB0aW1lKTtcbiAgICB9KTtcbn1cbi8qKlxuICogQ29udmVydHMgdGhlIHByb3ZpZGVkIGFzeW5jIGZ1bmN0aW9uIGludG8gYSByZXRyeWFibGUgZnVuY3Rpb24uIEVhY2ggcmVzdWx0XG4gKiBvciB0aHJvd24gZXJyb3IgaXMgc2VudCB0byB0aGUgaXNSZXRyeWFibGUgZnVuY3Rpb24gd2hpY2ggc2hvdWxkIHJldHVybiB0cnVlXG4gKiBpZiB0aGUgZnVuY3Rpb24gc2hvdWxkIHJ1biBhZ2Fpbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldHJ5YWJsZShmbiwgaXNSZXRyeWFibGUpIHtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKGFjY2VwdCwgcmVqZWN0KSA9PiB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmEtc2VtaVxuICAgICAgICA7XG4gICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8IEluZmluaXR5OyBhdHRlbXB0KyspIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmbihhdHRlbXB0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1JldHJ5YWJsZShhdHRlbXB0LCBudWxsLCByZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NlcHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmV0cnlhYmxlKGF0dGVtcHQsIGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5mdW5jdGlvbiBkZWMyaGV4KGRlYykge1xuICAgIHJldHVybiAoJzAnICsgZGVjLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC0yKTtcbn1cbi8vIEZ1bmN0aW9ucyBiZWxvdyB0YWtlbiBmcm9tOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82MzMwOTQwOS9jcmVhdGluZy1hLWNvZGUtdmVyaWZpZXItYW5kLWNoYWxsZW5nZS1mb3ItcGtjZS1hdXRoLW9uLXNwb3RpZnktYXBpLWluLXJlYWN0anNcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVBLQ0VWZXJpZmllcigpIHtcbiAgICBjb25zdCB2ZXJpZmllckxlbmd0aCA9IDU2O1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQzMkFycmF5KHZlcmlmaWVyTGVuZ3RoKTtcbiAgICBpZiAodHlwZW9mIGNyeXB0byA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgY2hhclNldCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS0uX34nO1xuICAgICAgICBjb25zdCBjaGFyU2V0TGVuID0gY2hhclNldC5sZW5ndGg7XG4gICAgICAgIGxldCB2ZXJpZmllciA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcmlmaWVyTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZlcmlmaWVyICs9IGNoYXJTZXQuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJTZXRMZW4pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmVyaWZpZXI7XG4gICAgfVxuICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyYXkpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKGFycmF5LCBkZWMyaGV4KS5qb2luKCcnKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNoYTI1NihyYW5kb21TdHJpbmcpIHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgY29uc3QgZW5jb2RlZERhdGEgPSBlbmNvZGVyLmVuY29kZShyYW5kb21TdHJpbmcpO1xuICAgIGNvbnN0IGhhc2ggPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIGVuY29kZWREYXRhKTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGhhc2gpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKGJ5dGVzKVxuICAgICAgICAubWFwKChjKSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKVxuICAgICAgICAuam9pbignJyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVQS0NFQ2hhbGxlbmdlKHZlcmlmaWVyKSB7XG4gICAgY29uc3QgaGFzQ3J5cHRvU3VwcG9ydCA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHR5cGVvZiBjcnlwdG8uc3VidGxlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB0eXBlb2YgVGV4dEVuY29kZXIgIT09ICd1bmRlZmluZWQnO1xuICAgIGlmICghaGFzQ3J5cHRvU3VwcG9ydCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dlYkNyeXB0byBBUEkgaXMgbm90IHN1cHBvcnRlZC4gQ29kZSBjaGFsbGVuZ2UgbWV0aG9kIHdpbGwgZGVmYXVsdCB0byB1c2UgcGxhaW4gaW5zdGVhZCBvZiBzaGEyNTYuJyk7XG4gICAgICAgIHJldHVybiB2ZXJpZmllcjtcbiAgICB9XG4gICAgY29uc3QgaGFzaGVkID0gYXdhaXQgc2hhMjU2KHZlcmlmaWVyKTtcbiAgICByZXR1cm4gYnRvYShoYXNoZWQpLnJlcGxhY2UoL1xcKy9nLCAnLScpLnJlcGxhY2UoL1xcLy9nLCAnXycpLnJlcGxhY2UoLz0rJC8sICcnKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKHN0b3JhZ2UsIHN0b3JhZ2VLZXksIGlzUGFzc3dvcmRSZWNvdmVyeSA9IGZhbHNlKSB7XG4gICAgY29uc3QgY29kZVZlcmlmaWVyID0gZ2VuZXJhdGVQS0NFVmVyaWZpZXIoKTtcbiAgICBsZXQgc3RvcmVkQ29kZVZlcmlmaWVyID0gY29kZVZlcmlmaWVyO1xuICAgIGlmIChpc1Bhc3N3b3JkUmVjb3ZlcnkpIHtcbiAgICAgICAgc3RvcmVkQ29kZVZlcmlmaWVyICs9ICcvUEFTU1dPUkRfUkVDT1ZFUlknO1xuICAgIH1cbiAgICBhd2FpdCBzZXRJdGVtQXN5bmMoc3RvcmFnZSwgYCR7c3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmAsIHN0b3JlZENvZGVWZXJpZmllcik7XG4gICAgY29uc3QgY29kZUNoYWxsZW5nZSA9IGF3YWl0IGdlbmVyYXRlUEtDRUNoYWxsZW5nZShjb2RlVmVyaWZpZXIpO1xuICAgIGNvbnN0IGNvZGVDaGFsbGVuZ2VNZXRob2QgPSBjb2RlVmVyaWZpZXIgPT09IGNvZGVDaGFsbGVuZ2UgPyAncGxhaW4nIDogJ3MyNTYnO1xuICAgIHJldHVybiBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF07XG59XG4vKiogUGFyc2VzIHRoZSBBUEkgdmVyc2lvbiB3aGljaCBpcyAyWVlZLU1NLURELiAqL1xuY29uc3QgQVBJX1ZFUlNJT05fUkVHRVggPSAvXjJbMC05XXszfS0oMFsxLTldfDFbMC0yXSktKDBbMS05XXwxWzAtOV18MlswLTldfDNbMC0xXSkkL2k7XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSZXNwb25zZUFQSVZlcnNpb24ocmVzcG9uc2UpIHtcbiAgICBjb25zdCBhcGlWZXJzaW9uID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoQVBJX1ZFUlNJT05fSEVBREVSX05BTUUpO1xuICAgIGlmICghYXBpVmVyc2lvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFhcGlWZXJzaW9uLm1hdGNoKEFQSV9WRVJTSU9OX1JFR0VYKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGAke2FwaVZlcnNpb259VDAwOjAwOjAwLjBaYCk7XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVFeHAoZXhwKSB7XG4gICAgaWYgKCFleHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGV4cCBjbGFpbScpO1xuICAgIH1cbiAgICBjb25zdCB0aW1lTm93ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgaWYgKGV4cCA8PSB0aW1lTm93KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSldUIGhhcyBleHBpcmVkJyk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsZ29yaXRobShhbGcpIHtcbiAgICBzd2l0Y2ggKGFsZykge1xuICAgICAgICBjYXNlICdSUzI1Nic6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdSU0FTU0EtUEtDUzEtdjFfNScsXG4gICAgICAgICAgICAgICAgaGFzaDogeyBuYW1lOiAnU0hBLTI1NicgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ0VTMjU2JzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ0VDRFNBJyxcbiAgICAgICAgICAgICAgICBuYW1lZEN1cnZlOiAnUC0yNTYnLFxuICAgICAgICAgICAgICAgIGhhc2g6IHsgbmFtZTogJ1NIQS0yNTYnIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFsZyBjbGFpbScpO1xuICAgIH1cbn1cbmNvbnN0IFVVSURfUkVHRVggPSAvXlswLTlhLWZdezh9LVswLTlhLWZdezR9LVswLTlhLWZdezR9LVswLTlhLWZdezR9LVswLTlhLWZdezEyfSQvO1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlVVVJRChzdHIpIHtcbiAgICBpZiAoIVVVSURfUkVHRVgudGVzdChzdHIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQHN1cGFiYXNlL2F1dGgtanM6IEV4cGVjdGVkIHBhcmFtZXRlciB0byBiZSBVVUlEIGJ1dCBpcyBub3QnKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlck5vdEF2YWlsYWJsZVByb3h5KCkge1xuICAgIGNvbnN0IHByb3h5VGFyZ2V0ID0ge307XG4gICAgcmV0dXJuIG5ldyBQcm94eShwcm94eVRhcmdldCwge1xuICAgICAgICBnZXQ6ICh0YXJnZXQsIHByb3ApID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnX19pc1VzZXJOb3RBdmFpbGFibGVQcm94eScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByZXZlbnRhdGl2ZSBjaGVjayBmb3IgY29tbW9uIHByb2JsZW1hdGljIHN5bWJvbHMgZHVyaW5nIGNsb25pbmcvaW5zcGVjdGlvblxuICAgICAgICAgICAgLy8gVGhlc2Ugc3ltYm9scyBtaWdodCBiZSBhY2Nlc3NlZCBieSBzdHJ1Y3R1cmVkQ2xvbmUgb3Igb3RoZXIgaW50ZXJuYWwgbWVjaGFuaXNtcy5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzUHJvcCA9IHByb3AudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAoc1Byb3AgPT09ICdTeW1ib2woU3ltYm9sLnRvUHJpbWl0aXZlKScgfHxcbiAgICAgICAgICAgICAgICAgICAgc1Byb3AgPT09ICdTeW1ib2woU3ltYm9sLnRvU3RyaW5nVGFnKScgfHxcbiAgICAgICAgICAgICAgICAgICAgc1Byb3AgPT09ICdTeW1ib2wodXRpbC5pbnNwZWN0LmN1c3RvbSknKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vZGUuanMgdXRpbC5pbnNwZWN0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogY2xpZW50IHdhcyBjcmVhdGVkIHdpdGggdXNlclN0b3JhZ2Ugb3B0aW9uIGFuZCB0aGVyZSB3YXMgbm8gdXNlciBzdG9yZWQgaW4gdGhlIHVzZXIgc3RvcmFnZS4gQWNjZXNzaW5nIHRoZSBcIiR7cHJvcH1cIiBwcm9wZXJ0eSBvZiB0aGUgc2Vzc2lvbiBvYmplY3QgaXMgbm90IHN1cHBvcnRlZC4gUGxlYXNlIHVzZSBnZXRVc2VyKCkgaW5zdGVhZC5gKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiAoX3RhcmdldCwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogY2xpZW50IHdhcyBjcmVhdGVkIHdpdGggdXNlclN0b3JhZ2Ugb3B0aW9uIGFuZCB0aGVyZSB3YXMgbm8gdXNlciBzdG9yZWQgaW4gdGhlIHVzZXIgc3RvcmFnZS4gU2V0dGluZyB0aGUgXCIke3Byb3B9XCIgcHJvcGVydHkgb2YgdGhlIHNlc3Npb24gb2JqZWN0IGlzIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgZ2V0VXNlcigpIHRvIGZldGNoIGEgdXNlciBvYmplY3QgeW91IGNhbiBtYW5pcHVsYXRlLmApO1xuICAgICAgICB9LFxuICAgICAgICBkZWxldGVQcm9wZXJ0eTogKF90YXJnZXQsIHByb3ApID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IGNsaWVudCB3YXMgY3JlYXRlZCB3aXRoIHVzZXJTdG9yYWdlIG9wdGlvbiBhbmQgdGhlcmUgd2FzIG5vIHVzZXIgc3RvcmVkIGluIHRoZSB1c2VyIHN0b3JhZ2UuIERlbGV0aW5nIHRoZSBcIiR7cHJvcH1cIiBwcm9wZXJ0eSBvZiB0aGUgc2Vzc2lvbiBvYmplY3QgaXMgbm90IHN1cHBvcnRlZC4gUGxlYXNlIHVzZSBnZXRVc2VyKCkgdG8gZmV0Y2ggYSB1c2VyIG9iamVjdCB5b3UgY2FuIG1hbmlwdWxhdGUuYCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBwcm94eSBhcm91bmQgYSB1c2VyIG9iamVjdCB0aGF0IHdhcm5zIHdoZW4gcHJvcGVydGllcyBhcmUgYWNjZXNzZWQgb24gdGhlIHNlcnZlci5cbiAqIFRoaXMgaXMgdXNlZCB0byBhbGVydCBkZXZlbG9wZXJzIHRoYXQgdXNpbmcgdXNlciBkYXRhIGZyb20gZ2V0U2Vzc2lvbigpIG9uIHRoZSBzZXJ2ZXIgaXMgaW5zZWN1cmUuXG4gKlxuICogQHBhcmFtIHVzZXIgVGhlIGFjdHVhbCB1c2VyIG9iamVjdCB0byB3cmFwXG4gKiBAcGFyYW0gc3VwcHJlc3NXYXJuaW5nUmVmIEFuIG9iamVjdCB3aXRoIGEgJ3ZhbHVlJyBwcm9wZXJ0eSB0aGF0IGNvbnRyb2xzIHdhcm5pbmcgc3VwcHJlc3Npb25cbiAqIEByZXR1cm5zIEEgcHJveGllZCB1c2VyIG9iamVjdCB0aGF0IHdhcm5zIG9uIHByb3BlcnR5IGFjY2Vzc1xuICovXG5leHBvcnQgZnVuY3Rpb24gaW5zZWN1cmVVc2VyV2FybmluZ1Byb3h5KHVzZXIsIHN1cHByZXNzV2FybmluZ1JlZikge1xuICAgIHJldHVybiBuZXcgUHJveHkodXNlciwge1xuICAgICAgICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiB7XG4gICAgICAgICAgICAvLyBBbGxvdyBpbnRlcm5hbCBjaGVja3Mgd2l0aG91dCB3YXJuaW5nXG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ19faXNJbnNlY3VyZVVzZXJXYXJuaW5nUHJveHknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcmV2ZW50YXRpdmUgY2hlY2sgZm9yIGNvbW1vbiBwcm9ibGVtYXRpYyBzeW1ib2xzIGR1cmluZyBjbG9uaW5nL2luc3BlY3Rpb25cbiAgICAgICAgICAgIC8vIFRoZXNlIHN5bWJvbHMgbWlnaHQgYmUgYWNjZXNzZWQgYnkgc3RydWN0dXJlZENsb25lIG9yIG90aGVyIGludGVybmFsIG1lY2hhbmlzbXNcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzUHJvcCA9IHByb3AudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAoc1Byb3AgPT09ICdTeW1ib2woU3ltYm9sLnRvUHJpbWl0aXZlKScgfHxcbiAgICAgICAgICAgICAgICAgICAgc1Byb3AgPT09ICdTeW1ib2woU3ltYm9sLnRvU3RyaW5nVGFnKScgfHxcbiAgICAgICAgICAgICAgICAgICAgc1Byb3AgPT09ICdTeW1ib2wodXRpbC5pbnNwZWN0LmN1c3RvbSknIHx8XG4gICAgICAgICAgICAgICAgICAgIHNQcm9wID09PSAnU3ltYm9sKG5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tKScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBhY3R1YWwgdmFsdWUgZm9yIHRoZXNlIHN5bWJvbHMgdG8gYWxsb3cgcHJvcGVyIGluc3BlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVtaXQgd2FybmluZyBvbiBmaXJzdCBwcm9wZXJ0eSBhY2Nlc3NcbiAgICAgICAgICAgIGlmICghc3VwcHJlc3NXYXJuaW5nUmVmLnZhbHVlICYmIHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVXNpbmcgdGhlIHVzZXIgb2JqZWN0IGFzIHJldHVybmVkIGZyb20gc3VwYWJhc2UuYXV0aC5nZXRTZXNzaW9uKCkgb3IgZnJvbSBzb21lIHN1cGFiYXNlLmF1dGgub25BdXRoU3RhdGVDaGFuZ2UoKSBldmVudHMgY291bGQgYmUgaW5zZWN1cmUhIFRoaXMgdmFsdWUgY29tZXMgZGlyZWN0bHkgZnJvbSB0aGUgc3RvcmFnZSBtZWRpdW0gKHVzdWFsbHkgY29va2llcyBvbiB0aGUgc2VydmVyKSBhbmQgbWF5IG5vdCBiZSBhdXRoZW50aWMuIFVzZSBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKSBpbnN0ZWFkIHdoaWNoIGF1dGhlbnRpY2F0ZXMgdGhlIGRhdGEgYnkgY29udGFjdGluZyB0aGUgU3VwYWJhc2UgQXV0aCBzZXJ2ZXIuJyk7XG4gICAgICAgICAgICAgICAgc3VwcHJlc3NXYXJuaW5nUmVmLnZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogRGVlcCBjbG9uZXMgYSBKU09OLXNlcmlhbGl6YWJsZSBvYmplY3QgdXNpbmcgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKS5cbiAqIE5vdGU6IE9ubHkgd29ya3MgZm9yIEpTT04tc2FmZSBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVlcENsb25lKG9iaikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVycy5qcy5tYXAiXSwibmFtZXMiOlsiQVBJX1ZFUlNJT05fSEVBREVSX05BTUUiLCJCQVNFNjRVUkxfUkVHRVgiLCJBdXRoSW52YWxpZEp3dEVycm9yIiwiYmFzZTY0VXJsVG9VaW50OEFycmF5Iiwic3RyaW5nRnJvbUJhc2U2NFVSTCIsImV4cGlyZXNBdCIsImV4cGlyZXNJbiIsInRpbWVOb3ciLCJNYXRoIiwicm91bmQiLCJEYXRlIiwibm93IiwiZ2VuZXJhdGVDYWxsYmFja0lkIiwiU3ltYm9sIiwiaXNCcm93c2VyIiwiZG9jdW1lbnQiLCJsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzIiwidGVzdGVkIiwid3JpdGFibGUiLCJzdXBwb3J0c0xvY2FsU3RvcmFnZSIsImdsb2JhbFRoaXMiLCJsb2NhbFN0b3JhZ2UiLCJlIiwicmFuZG9tS2V5IiwicmFuZG9tIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJwYXJzZVBhcmFtZXRlcnNGcm9tVVJMIiwiaHJlZiIsInJlc3VsdCIsInVybCIsIlVSTCIsImhhc2giLCJoYXNoU2VhcmNoUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwic3Vic3RyaW5nIiwiZm9yRWFjaCIsInZhbHVlIiwia2V5Iiwic2VhcmNoUGFyYW1zIiwicmVzb2x2ZUZldGNoIiwiY3VzdG9tRmV0Y2giLCJhcmdzIiwiZmV0Y2giLCJsb29rc0xpa2VGZXRjaFJlc3BvbnNlIiwibWF5YmVSZXNwb25zZSIsImpzb24iLCJzZXRJdGVtQXN5bmMiLCJzdG9yYWdlIiwiZGF0YSIsIkpTT04iLCJzdHJpbmdpZnkiLCJnZXRJdGVtQXN5bmMiLCJnZXRJdGVtIiwicGFyc2UiLCJfYSIsInJlbW92ZUl0ZW1Bc3luYyIsIkRlZmVycmVkIiwiY29uc3RydWN0b3IiLCJwcm9taXNlIiwicHJvbWlzZUNvbnN0cnVjdG9yIiwicmVzIiwicmVqIiwicmVzb2x2ZSIsInJlamVjdCIsIlByb21pc2UiLCJkZWNvZGVKV1QiLCJ0b2tlbiIsInBhcnRzIiwic3BsaXQiLCJsZW5ndGgiLCJpIiwidGVzdCIsImhlYWRlciIsInBheWxvYWQiLCJzaWduYXR1cmUiLCJyYXciLCJzbGVlcCIsInRpbWUiLCJhY2NlcHQiLCJzZXRUaW1lb3V0IiwicmV0cnlhYmxlIiwiZm4iLCJpc1JldHJ5YWJsZSIsImF0dGVtcHQiLCJJbmZpbml0eSIsImRlYzJoZXgiLCJkZWMiLCJ0b1N0cmluZyIsInN1YnN0ciIsImdlbmVyYXRlUEtDRVZlcmlmaWVyIiwidmVyaWZpZXJMZW5ndGgiLCJhcnJheSIsIlVpbnQzMkFycmF5IiwiY3J5cHRvIiwiY2hhclNldCIsImNoYXJTZXRMZW4iLCJ2ZXJpZmllciIsImNoYXJBdCIsImZsb29yIiwiZ2V0UmFuZG9tVmFsdWVzIiwiQXJyYXkiLCJmcm9tIiwiam9pbiIsInNoYTI1NiIsInJhbmRvbVN0cmluZyIsImVuY29kZXIiLCJUZXh0RW5jb2RlciIsImVuY29kZWREYXRhIiwiZW5jb2RlIiwic3VidGxlIiwiZGlnZXN0IiwiYnl0ZXMiLCJVaW50OEFycmF5IiwibWFwIiwiYyIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImdlbmVyYXRlUEtDRUNoYWxsZW5nZSIsImhhc0NyeXB0b1N1cHBvcnQiLCJjb25zb2xlIiwid2FybiIsImhhc2hlZCIsImJ0b2EiLCJyZXBsYWNlIiwiZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCIsInN0b3JhZ2VLZXkiLCJpc1Bhc3N3b3JkUmVjb3ZlcnkiLCJjb2RlVmVyaWZpZXIiLCJzdG9yZWRDb2RlVmVyaWZpZXIiLCJjb2RlQ2hhbGxlbmdlIiwiY29kZUNoYWxsZW5nZU1ldGhvZCIsIkFQSV9WRVJTSU9OX1JFR0VYIiwicGFyc2VSZXNwb25zZUFQSVZlcnNpb24iLCJyZXNwb25zZSIsImFwaVZlcnNpb24iLCJoZWFkZXJzIiwiZ2V0IiwibWF0Y2giLCJkYXRlIiwidmFsaWRhdGVFeHAiLCJleHAiLCJFcnJvciIsImdldEFsZ29yaXRobSIsImFsZyIsIm5hbWUiLCJuYW1lZEN1cnZlIiwiVVVJRF9SRUdFWCIsInZhbGlkYXRlVVVJRCIsInN0ciIsInVzZXJOb3RBdmFpbGFibGVQcm94eSIsInByb3h5VGFyZ2V0IiwiUHJveHkiLCJ0YXJnZXQiLCJwcm9wIiwic1Byb3AiLCJ1bmRlZmluZWQiLCJzZXQiLCJfdGFyZ2V0IiwiZGVsZXRlUHJvcGVydHkiLCJpbnNlY3VyZVVzZXJXYXJuaW5nUHJveHkiLCJ1c2VyIiwic3VwcHJlc3NXYXJuaW5nUmVmIiwicmVjZWl2ZXIiLCJSZWZsZWN0IiwiZGVlcENsb25lIiwib2JqIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   memoryLocalStorageAdapter: () => (/* binding */ memoryLocalStorageAdapter)\n/* harmony export */ });\n/**\n * Returns a localStorage-like object that stores the key-value pairs in\n * memory.\n */ function memoryLocalStorageAdapter(store = {}) {\n    return {\n        getItem: (key)=>{\n            return store[key] || null;\n        },\n        setItem: (key, value)=>{\n            store[key] = value;\n        },\n        removeItem: (key)=>{\n            delete store[key];\n        }\n    };\n} //# sourceMappingURL=local-storage.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2xvY2FsLXN0b3JhZ2UuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Q0FHQyxHQUNNLFNBQVNBLDBCQUEwQkMsUUFBUSxDQUFDLENBQUM7SUFDaEQsT0FBTztRQUNIQyxTQUFTLENBQUNDO1lBQ04sT0FBT0YsS0FBSyxDQUFDRSxJQUFJLElBQUk7UUFDekI7UUFDQUMsU0FBUyxDQUFDRCxLQUFLRTtZQUNYSixLQUFLLENBQUNFLElBQUksR0FBR0U7UUFDakI7UUFDQUMsWUFBWSxDQUFDSDtZQUNULE9BQU9GLEtBQUssQ0FBQ0UsSUFBSTtRQUNyQjtJQUNKO0FBQ0osRUFDQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmNob3Itd29ya2Zsb3dzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2xpYi9sb2NhbC1zdG9yYWdlLmpzPzIzYzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSZXR1cm5zIGEgbG9jYWxTdG9yYWdlLWxpa2Ugb2JqZWN0IHRoYXQgc3RvcmVzIHRoZSBrZXktdmFsdWUgcGFpcnMgaW5cbiAqIG1lbW9yeS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIoc3RvcmUgPSB7fSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldEl0ZW06IChrZXkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdG9yZVtrZXldIHx8IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEl0ZW06IChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBzdG9yZVtrZXldID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUl0ZW06IChrZXkpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSBzdG9yZVtrZXldO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbC1zdG9yYWdlLmpzLm1hcCJdLCJuYW1lcyI6WyJtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyIiwic3RvcmUiLCJnZXRJdGVtIiwia2V5Iiwic2V0SXRlbSIsInZhbHVlIiwicmVtb3ZlSXRlbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/locks.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LockAcquireTimeoutError: () => (/* binding */ LockAcquireTimeoutError),\n/* harmony export */   NavigatorLockAcquireTimeoutError: () => (/* binding */ NavigatorLockAcquireTimeoutError),\n/* harmony export */   ProcessLockAcquireTimeoutError: () => (/* binding */ ProcessLockAcquireTimeoutError),\n/* harmony export */   internals: () => (/* binding */ internals),\n/* harmony export */   navigatorLock: () => (/* binding */ navigatorLock),\n/* harmony export */   processLock: () => (/* binding */ processLock)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n\n/**\n * @experimental\n */ const internals = {\n    /**\n     * @experimental\n     */ debug: !!(globalThis && (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.supportsLocalStorage)() && globalThis.localStorage && globalThis.localStorage.getItem(\"supabase.gotrue-js.locks.debug\") === \"true\")\n};\n/**\n * An error thrown when a lock cannot be acquired after some amount of time.\n *\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\n *\n * @example\n * ```ts\n * import { LockAcquireTimeoutError } from '@supabase/auth-js'\n *\n * class CustomLockError extends LockAcquireTimeoutError {\n *   constructor() {\n *     super('Lock timed out')\n *   }\n * }\n * ```\n */ class LockAcquireTimeoutError extends Error {\n    constructor(message){\n        super(message);\n        this.isAcquireTimeout = true;\n    }\n}\n/**\n * Error thrown when the browser Navigator Lock API fails to acquire a lock.\n *\n * @example\n * ```ts\n * import { NavigatorLockAcquireTimeoutError } from '@supabase/auth-js'\n *\n * throw new NavigatorLockAcquireTimeoutError('Lock timed out')\n * ```\n */ class NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\n/**\n * Error thrown when the process-level lock helper cannot acquire a lock.\n *\n * @example\n * ```ts\n * import { ProcessLockAcquireTimeoutError } from '@supabase/auth-js'\n *\n * throw new ProcessLockAcquireTimeoutError('Lock timed out')\n * ```\n */ class ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\n/**\n * Implements a global exclusive lock using the Navigator LockManager API. It\n * is available on all browsers released after 2022-03-15 with Safari being the\n * last one to release support. If the API is not available, this function will\n * throw. Make sure you check availablility before configuring {@link\n * GoTrueClient}.\n *\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\n * local storage item to `true`.\n *\n * Internals:\n *\n * Since the LockManager API does not preserve stack traces for the async\n * function passed in the `request` method, a trick is used where acquiring the\n * lock releases a previously started promise to run the operation in the `fn`\n * function. The lock waits for that promise to finish (with or without error),\n * while the function will finally wait for the result anyway.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n * @example\n * ```ts\n * await navigatorLock('sync-user', 1000, async () => {\n *   await refreshSession()\n * })\n * ```\n */ async function navigatorLock(name, acquireTimeout, fn) {\n    if (internals.debug) {\n        console.log(\"@supabase/gotrue-js: navigatorLock: acquire lock\", name, acquireTimeout);\n    }\n    const abortController = new globalThis.AbortController();\n    if (acquireTimeout > 0) {\n        setTimeout(()=>{\n            abortController.abort();\n            if (internals.debug) {\n                console.log(\"@supabase/gotrue-js: navigatorLock acquire timed out\", name);\n            }\n        }, acquireTimeout);\n    }\n    // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\n    // Wrapping with await Promise.resolve() is done as some libraries like zone.js\n    // patch the Promise object to track execution context. We use await instead of\n    // .then() to avoid Firefox content script security errors where accessing .then()\n    // on cross-context promises is forbidden.\n    await Promise.resolve();\n    try {\n        return await globalThis.navigator.locks.request(name, acquireTimeout === 0 ? {\n            mode: \"exclusive\",\n            ifAvailable: true\n        } : {\n            mode: \"exclusive\",\n            signal: abortController.signal\n        }, async (lock)=>{\n            if (lock) {\n                if (internals.debug) {\n                    console.log(\"@supabase/gotrue-js: navigatorLock: acquired\", name, lock.name);\n                }\n                try {\n                    return await fn();\n                } finally{\n                    if (internals.debug) {\n                        console.log(\"@supabase/gotrue-js: navigatorLock: released\", name, lock.name);\n                    }\n                }\n            } else {\n                if (acquireTimeout === 0) {\n                    if (internals.debug) {\n                        console.log(\"@supabase/gotrue-js: navigatorLock: not immediately available\", name);\n                    }\n                    throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \"${name}\" immediately failed`);\n                } else {\n                    if (internals.debug) {\n                        try {\n                            const result = await globalThis.navigator.locks.query();\n                            console.log(\"@supabase/gotrue-js: Navigator LockManager state\", JSON.stringify(result, null, \"  \"));\n                        } catch (e) {\n                            console.warn(\"@supabase/gotrue-js: Error when querying Navigator LockManager state\", e);\n                        }\n                    }\n                    // Browser is not following the Navigator LockManager spec, it\n                    // returned a null lock when we didn't use ifAvailable. So we can\n                    // pretend the lock is acquired in the name of backward compatibility\n                    // and user experience and just run the function.\n                    console.warn(\"@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\");\n                    return await fn();\n                }\n            }\n        });\n    } catch (e) {\n        // When the AbortController times out, navigator.locks.request rejects with\n        // a DOMException named 'AbortError'. Convert this to NavigatorLockAcquireTimeoutError\n        // so callers can check error.isAcquireTimeout as documented.\n        if ((e === null || e === void 0 ? void 0 : e.name) === \"AbortError\") {\n            throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \"${name}\" timed out waiting ${acquireTimeout}ms`);\n        }\n        throw e;\n    }\n}\nconst PROCESS_LOCKS = {};\n/**\n * Implements a global exclusive lock that works only in the current process.\n * Useful for environments like React Native or other non-browser\n * single-process (i.e. no concept of \"tabs\") environments.\n *\n * Use {@link #navigatorLock} in browser environments.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n * @example\n * ```ts\n * await processLock('migrate', 5000, async () => {\n *   await runMigration()\n * })\n * ```\n */ async function processLock(name, acquireTimeout, fn) {\n    var _a;\n    const previousOperation = (_a = PROCESS_LOCKS[name]) !== null && _a !== void 0 ? _a : Promise.resolve();\n    // Wrap previousOperation to handle errors without using .catch()\n    // This avoids Firefox content script security errors\n    const previousOperationHandled = (async ()=>{\n        try {\n            await previousOperation;\n            return null;\n        } catch (e) {\n            // ignore error of previous operation that we're waiting to finish\n            return null;\n        }\n    })();\n    const currentOperation = (async ()=>{\n        let timeoutId = null;\n        try {\n            // Wait for either previous operation or timeout\n            const timeoutPromise = acquireTimeout >= 0 ? new Promise((_, reject)=>{\n                timeoutId = setTimeout(()=>{\n                    console.warn(`@supabase/gotrue-js: Lock \"${name}\" acquisition timed out after ${acquireTimeout}ms. ` + \"This may be caused by another operation holding the lock. \" + \"Consider increasing lockAcquireTimeout or checking for stuck operations.\");\n                    reject(new ProcessLockAcquireTimeoutError(`Acquiring process lock with name \"${name}\" timed out`));\n                }, acquireTimeout);\n            }) : null;\n            await Promise.race([\n                previousOperationHandled,\n                timeoutPromise\n            ].filter((x)=>x));\n            // If we reach here, previousOperationHandled won the race\n            // Clear the timeout to prevent false warnings\n            if (timeoutId !== null) {\n                clearTimeout(timeoutId);\n            }\n        } catch (e) {\n            // Clear the timeout on error path as well\n            if (timeoutId !== null) {\n                clearTimeout(timeoutId);\n            }\n            // Re-throw timeout errors, ignore others\n            if (e && e.isAcquireTimeout) {\n                throw e;\n            }\n        // Fall through to run fn() - previous operation finished with error\n        }\n        // Previous operations finished and we didn't get a race on the acquire\n        // timeout, so the current operation can finally start\n        return await fn();\n    })();\n    PROCESS_LOCKS[name] = (async ()=>{\n        try {\n            return await currentOperation;\n        } catch (e) {\n            if (e && e.isAcquireTimeout) {\n                // if the current operation timed out, it doesn't mean that the previous\n                // operation finished, so we need continue waiting for it to finish\n                try {\n                    await previousOperation;\n                } catch (prevError) {\n                // Ignore previous operation errors\n                }\n                return null;\n            }\n            throw e;\n        }\n    })();\n    // finally wait for the current operation to finish successfully, with an\n    // error or with an acquire timeout error\n    return await currentOperation;\n} //# sourceMappingURL=locks.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2xvY2tzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBaUQ7QUFDakQ7O0NBRUMsR0FDTSxNQUFNQyxZQUFZO0lBQ3JCOztLQUVDLEdBQ0RDLE9BQU8sQ0FBQyxDQUFFQyxDQUFBQSxjQUNOSCw4REFBb0JBLE1BQ3BCRyxXQUFXQyxZQUFZLElBQ3ZCRCxXQUFXQyxZQUFZLENBQUNDLE9BQU8sQ0FBQyxzQ0FBc0MsTUFBSztBQUNuRixFQUFFO0FBQ0Y7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ00sTUFBTUMsZ0NBQWdDQztJQUN6Q0MsWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNDLGdCQUFnQixHQUFHO0lBQzVCO0FBQ0o7QUFDQTs7Ozs7Ozs7O0NBU0MsR0FDTSxNQUFNQyx5Q0FBeUNMO0FBQ3REO0FBQ0E7Ozs7Ozs7OztDQVNDLEdBQ00sTUFBTU0sdUNBQXVDTjtBQUNwRDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E4QkMsR0FDTSxlQUFlTyxjQUFjQyxJQUFJLEVBQUVDLGNBQWMsRUFBRUMsRUFBRTtJQUN4RCxJQUFJZixVQUFVQyxLQUFLLEVBQUU7UUFDakJlLFFBQVFDLEdBQUcsQ0FBQyxvREFBb0RKLE1BQU1DO0lBQzFFO0lBQ0EsTUFBTUksa0JBQWtCLElBQUloQixXQUFXaUIsZUFBZTtJQUN0RCxJQUFJTCxpQkFBaUIsR0FBRztRQUNwQk0sV0FBVztZQUNQRixnQkFBZ0JHLEtBQUs7WUFDckIsSUFBSXJCLFVBQVVDLEtBQUssRUFBRTtnQkFDakJlLFFBQVFDLEdBQUcsQ0FBQyx3REFBd0RKO1lBQ3hFO1FBQ0osR0FBR0M7SUFDUDtJQUNBLG9GQUFvRjtJQUNwRiwrRUFBK0U7SUFDL0UsK0VBQStFO0lBQy9FLGtGQUFrRjtJQUNsRiwwQ0FBMEM7SUFDMUMsTUFBTVEsUUFBUUMsT0FBTztJQUNy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QUdDO1lBQ1AsS0FDRTtZQUNOLE1BQU1RLFFBQVF5QixJQUFJLENBQUM7Z0JBQUNOO2dCQUEwQkc7YUFBZSxDQUFDSSxNQUFNLENBQUMsQ0FBQ0MsSUFBTUE7WUFDNUUsMERBQTBEO1lBQzFELDhDQUE4QztZQUM5QyxJQUFJTixjQUFjLE1BQU07Z0JBQ3BCTyxhQUFhUDtZQUNqQjtRQUNKLEVBQ0EsT0FBT1IsR0FBRztZQUNOLDBDQUEwQztZQUMxQyxJQUFJUSxjQUFjLE1BQU07Z0JBQ3BCTyxhQUFhUDtZQUNqQjtZQUNBLHlDQUF5QztZQUN6QyxJQUFJUixLQUFLQSxFQUFFMUIsZ0JBQWdCLEVBQUU7Z0JBQ3pCLE1BQU0wQjtZQUNWO1FBQ0Esb0VBQW9FO1FBQ3hFO1FBQ0EsdUVBQXVFO1FBQ3ZFLHNEQUFzRDtRQUN0RCxPQUFPLE1BQU1wQjtJQUNqQjtJQUNBc0IsYUFBYSxDQUFDeEIsS0FBSyxHQUFHLENBQUM7UUFDbkIsSUFBSTtZQUNBLE9BQU8sTUFBTTZCO1FBQ2pCLEVBQ0EsT0FBT1AsR0FBRztZQUNOLElBQUlBLEtBQUtBLEVBQUUxQixnQkFBZ0IsRUFBRTtnQkFDekIsd0VBQXdFO2dCQUN4RSxtRUFBbUU7Z0JBQ25FLElBQUk7b0JBQ0EsTUFBTStCO2dCQUNWLEVBQ0EsT0FBT1csV0FBVztnQkFDZCxtQ0FBbUM7Z0JBQ3ZDO2dCQUNBLE9BQU87WUFDWDtZQUNBLE1BQU1oQjtRQUNWO0lBQ0o7SUFDQSx5RUFBeUU7SUFDekUseUNBQXlDO0lBQ3pDLE9BQU8sTUFBTU87QUFDakIsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmNob3Itd29ya2Zsb3dzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2xpYi9sb2Nrcy5qcz8wMzg3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN1cHBvcnRzTG9jYWxTdG9yYWdlIH0gZnJvbSAnLi9oZWxwZXJzJztcbi8qKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBkZWJ1ZzogISEoZ2xvYmFsVGhpcyAmJlxuICAgICAgICBzdXBwb3J0c0xvY2FsU3RvcmFnZSgpICYmXG4gICAgICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlICYmXG4gICAgICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3N1cGFiYXNlLmdvdHJ1ZS1qcy5sb2Nrcy5kZWJ1ZycpID09PSAndHJ1ZScpLFxufTtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gYSBsb2NrIGNhbm5vdCBiZSBhY3F1aXJlZCBhZnRlciBzb21lIGFtb3VudCBvZiB0aW1lLlxuICpcbiAqIFVzZSB0aGUge0BsaW5rICNpc0FjcXVpcmVUaW1lb3V0fSBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGNoZWNraW5nIHdpdGggYGluc3RhbmNlb2ZgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiBjbGFzcyBDdXN0b21Mb2NrRXJyb3IgZXh0ZW5kcyBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciB7XG4gKiAgIGNvbnN0cnVjdG9yKCkge1xuICogICAgIHN1cGVyKCdMb2NrIHRpbWVkIG91dCcpXG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5pc0FjcXVpcmVUaW1lb3V0ID0gdHJ1ZTtcbiAgICB9XG59XG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIHRoZSBicm93c2VyIE5hdmlnYXRvciBMb2NrIEFQSSBmYWlscyB0byBhY3F1aXJlIGEgbG9jay5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IE5hdmlnYXRvckxvY2tBY3F1aXJlVGltZW91dEVycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gKlxuICogdGhyb3cgbmV3IE5hdmlnYXRvckxvY2tBY3F1aXJlVGltZW91dEVycm9yKCdMb2NrIHRpbWVkIG91dCcpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIE5hdmlnYXRvckxvY2tBY3F1aXJlVGltZW91dEVycm9yIGV4dGVuZHMgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3Ige1xufVxuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiB0aGUgcHJvY2Vzcy1sZXZlbCBsb2NrIGhlbHBlciBjYW5ub3QgYWNxdWlyZSBhIGxvY2suXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBQcm9jZXNzTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiB0aHJvdyBuZXcgUHJvY2Vzc0xvY2tBY3F1aXJlVGltZW91dEVycm9yKCdMb2NrIHRpbWVkIG91dCcpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFByb2Nlc3NMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciBleHRlbmRzIExvY2tBY3F1aXJlVGltZW91dEVycm9yIHtcbn1cbi8qKlxuICogSW1wbGVtZW50cyBhIGdsb2JhbCBleGNsdXNpdmUgbG9jayB1c2luZyB0aGUgTmF2aWdhdG9yIExvY2tNYW5hZ2VyIEFQSS4gSXRcbiAqIGlzIGF2YWlsYWJsZSBvbiBhbGwgYnJvd3NlcnMgcmVsZWFzZWQgYWZ0ZXIgMjAyMi0wMy0xNSB3aXRoIFNhZmFyaSBiZWluZyB0aGVcbiAqIGxhc3Qgb25lIHRvIHJlbGVhc2Ugc3VwcG9ydC4gSWYgdGhlIEFQSSBpcyBub3QgYXZhaWxhYmxlLCB0aGlzIGZ1bmN0aW9uIHdpbGxcbiAqIHRocm93LiBNYWtlIHN1cmUgeW91IGNoZWNrIGF2YWlsYWJsaWxpdHkgYmVmb3JlIGNvbmZpZ3VyaW5nIHtAbGlua1xuICogR29UcnVlQ2xpZW50fS5cbiAqXG4gKiBZb3UgY2FuIHR1cm4gb24gZGVidWdnaW5nIGJ5IHNldHRpbmcgdGhlIGBzdXBhYmFzZS5nb3RydWUtanMubG9ja3MuZGVidWdgXG4gKiBsb2NhbCBzdG9yYWdlIGl0ZW0gdG8gYHRydWVgLlxuICpcbiAqIEludGVybmFsczpcbiAqXG4gKiBTaW5jZSB0aGUgTG9ja01hbmFnZXIgQVBJIGRvZXMgbm90IHByZXNlcnZlIHN0YWNrIHRyYWNlcyBmb3IgdGhlIGFzeW5jXG4gKiBmdW5jdGlvbiBwYXNzZWQgaW4gdGhlIGByZXF1ZXN0YCBtZXRob2QsIGEgdHJpY2sgaXMgdXNlZCB3aGVyZSBhY3F1aXJpbmcgdGhlXG4gKiBsb2NrIHJlbGVhc2VzIGEgcHJldmlvdXNseSBzdGFydGVkIHByb21pc2UgdG8gcnVuIHRoZSBvcGVyYXRpb24gaW4gdGhlIGBmbmBcbiAqIGZ1bmN0aW9uLiBUaGUgbG9jayB3YWl0cyBmb3IgdGhhdCBwcm9taXNlIHRvIGZpbmlzaCAod2l0aCBvciB3aXRob3V0IGVycm9yKSxcbiAqIHdoaWxlIHRoZSBmdW5jdGlvbiB3aWxsIGZpbmFsbHkgd2FpdCBmb3IgdGhlIHJlc3VsdCBhbnl3YXkuXG4gKlxuICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgbG9jayB0byBiZSBhY3F1aXJlZC5cbiAqIEBwYXJhbSBhY3F1aXJlVGltZW91dCBJZiBuZWdhdGl2ZSwgbm8gdGltZW91dC4gSWYgMCBhbiBlcnJvciBpcyB0aHJvd24gaWZcbiAqICAgICAgICAgICAgICAgICAgICAgICB0aGUgbG9jayBjYW4ndCBiZSBhY3F1aXJlZCB3aXRob3V0IHdhaXRpbmcuIElmIHBvc2l0aXZlLCB0aGUgbG9jayBhY3F1aXJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgd2lsbCB0aW1lIG91dCBhZnRlciBzbyBtYW55IG1pbGxpc2Vjb25kcy4gQW4gZXJyb3IgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgICBhIHRpbWVvdXQgaWYgaXQgaGFzIGBpc0FjcXVpcmVUaW1lb3V0YCBzZXQgdG8gdHJ1ZS5cbiAqIEBwYXJhbSBmbiBUaGUgb3BlcmF0aW9uIHRvIHJ1biBvbmNlIHRoZSBsb2NrIGlzIGFjcXVpcmVkLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBhd2FpdCBuYXZpZ2F0b3JMb2NrKCdzeW5jLXVzZXInLCAxMDAwLCBhc3luYyAoKSA9PiB7XG4gKiAgIGF3YWl0IHJlZnJlc2hTZXNzaW9uKClcbiAqIH0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG5hdmlnYXRvckxvY2sobmFtZSwgYWNxdWlyZVRpbWVvdXQsIGZuKSB7XG4gICAgaWYgKGludGVybmFscy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogbmF2aWdhdG9yTG9jazogYWNxdWlyZSBsb2NrJywgbmFtZSwgYWNxdWlyZVRpbWVvdXQpO1xuICAgIH1cbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgZ2xvYmFsVGhpcy5BYm9ydENvbnRyb2xsZXIoKTtcbiAgICBpZiAoYWNxdWlyZVRpbWVvdXQgPiAwKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IG5hdmlnYXRvckxvY2sgYWNxdWlyZSB0aW1lZCBvdXQnLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgYWNxdWlyZVRpbWVvdXQpO1xuICAgIH1cbiAgICAvLyBNRE4gYXJ0aWNsZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0xvY2tNYW5hZ2VyL3JlcXVlc3RcbiAgICAvLyBXcmFwcGluZyB3aXRoIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpIGlzIGRvbmUgYXMgc29tZSBsaWJyYXJpZXMgbGlrZSB6b25lLmpzXG4gICAgLy8gcGF0Y2ggdGhlIFByb21pc2Ugb2JqZWN0IHRvIHRyYWNrIGV4ZWN1dGlvbiBjb250ZXh0LiBXZSB1c2UgYXdhaXQgaW5zdGVhZCBvZlxuICAgIC8vIC50aGVuKCkgdG8gYXZvaWQgRmlyZWZveCBjb250ZW50IHNjcmlwdCBzZWN1cml0eSBlcnJvcnMgd2hlcmUgYWNjZXNzaW5nIC50aGVuKClcbiAgICAvLyBvbiBjcm9zcy1jb250ZXh0IHByb21pc2VzIGlzIGZvcmJpZGRlbi5cbiAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgZ2xvYmFsVGhpcy5uYXZpZ2F0b3IubG9ja3MucmVxdWVzdChuYW1lLCBhY3F1aXJlVGltZW91dCA9PT0gMFxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgbW9kZTogJ2V4Y2x1c2l2ZScsXG4gICAgICAgICAgICAgICAgaWZBdmFpbGFibGU6IHRydWUsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBtb2RlOiAnZXhjbHVzaXZlJyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgICB9LCBhc3luYyAobG9jaykgPT4ge1xuICAgICAgICAgICAgaWYgKGxvY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBuYXZpZ2F0b3JMb2NrOiBhY3F1aXJlZCcsIG5hbWUsIGxvY2submFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVybmFscy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IG5hdmlnYXRvckxvY2s6IHJlbGVhc2VkJywgbmFtZSwgbG9jay5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChhY3F1aXJlVGltZW91dCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogbmF2aWdhdG9yTG9jazogbm90IGltbWVkaWF0ZWx5IGF2YWlsYWJsZScsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOYXZpZ2F0b3JMb2NrQWNxdWlyZVRpbWVvdXRFcnJvcihgQWNxdWlyaW5nIGFuIGV4Y2x1c2l2ZSBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgbG9jayBcIiR7bmFtZX1cIiBpbW1lZGlhdGVseSBmYWlsZWRgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2xvYmFsVGhpcy5uYXZpZ2F0b3IubG9ja3MucXVlcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogTmF2aWdhdG9yIExvY2tNYW5hZ2VyIHN0YXRlJywgSlNPTi5zdHJpbmdpZnkocmVzdWx0LCBudWxsLCAnICAnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQHN1cGFiYXNlL2dvdHJ1ZS1qczogRXJyb3Igd2hlbiBxdWVyeWluZyBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgc3RhdGUnLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBCcm93c2VyIGlzIG5vdCBmb2xsb3dpbmcgdGhlIE5hdmlnYXRvciBMb2NrTWFuYWdlciBzcGVjLCBpdFxuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5lZCBhIG51bGwgbG9jayB3aGVuIHdlIGRpZG4ndCB1c2UgaWZBdmFpbGFibGUuIFNvIHdlIGNhblxuICAgICAgICAgICAgICAgICAgICAvLyBwcmV0ZW5kIHRoZSBsb2NrIGlzIGFjcXVpcmVkIGluIHRoZSBuYW1lIG9mIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHVzZXIgZXhwZXJpZW5jZSBhbmQganVzdCBydW4gdGhlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0BzdXBhYmFzZS9nb3RydWUtanM6IE5hdmlnYXRvciBMb2NrTWFuYWdlciByZXR1cm5lZCBhIG51bGwgbG9jayB3aGVuIHVzaW5nICNyZXF1ZXN0IHdpdGhvdXQgaWZBdmFpbGFibGUgc2V0IHRvIHRydWUsIGl0IGFwcGVhcnMgdGhpcyBicm93c2VyIGlzIG5vdCBmb2xsb3dpbmcgdGhlIExvY2tNYW5hZ2VyIHNwZWMgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0xvY2tNYW5hZ2VyL3JlcXVlc3QnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gV2hlbiB0aGUgQWJvcnRDb250cm9sbGVyIHRpbWVzIG91dCwgbmF2aWdhdG9yLmxvY2tzLnJlcXVlc3QgcmVqZWN0cyB3aXRoXG4gICAgICAgIC8vIGEgRE9NRXhjZXB0aW9uIG5hbWVkICdBYm9ydEVycm9yJy4gQ29udmVydCB0aGlzIHRvIE5hdmlnYXRvckxvY2tBY3F1aXJlVGltZW91dEVycm9yXG4gICAgICAgIC8vIHNvIGNhbGxlcnMgY2FuIGNoZWNrIGVycm9yLmlzQWNxdWlyZVRpbWVvdXQgYXMgZG9jdW1lbnRlZC5cbiAgICAgICAgaWYgKChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubmFtZSkgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5hdmlnYXRvckxvY2tBY3F1aXJlVGltZW91dEVycm9yKGBBY3F1aXJpbmcgYW4gZXhjbHVzaXZlIE5hdmlnYXRvciBMb2NrTWFuYWdlciBsb2NrIFwiJHtuYW1lfVwiIHRpbWVkIG91dCB3YWl0aW5nICR7YWNxdWlyZVRpbWVvdXR9bXNgKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbn1cbmNvbnN0IFBST0NFU1NfTE9DS1MgPSB7fTtcbi8qKlxuICogSW1wbGVtZW50cyBhIGdsb2JhbCBleGNsdXNpdmUgbG9jayB0aGF0IHdvcmtzIG9ubHkgaW4gdGhlIGN1cnJlbnQgcHJvY2Vzcy5cbiAqIFVzZWZ1bCBmb3IgZW52aXJvbm1lbnRzIGxpa2UgUmVhY3QgTmF0aXZlIG9yIG90aGVyIG5vbi1icm93c2VyXG4gKiBzaW5nbGUtcHJvY2VzcyAoaS5lLiBubyBjb25jZXB0IG9mIFwidGFic1wiKSBlbnZpcm9ubWVudHMuXG4gKlxuICogVXNlIHtAbGluayAjbmF2aWdhdG9yTG9ja30gaW4gYnJvd3NlciBlbnZpcm9ubWVudHMuXG4gKlxuICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgbG9jayB0byBiZSBhY3F1aXJlZC5cbiAqIEBwYXJhbSBhY3F1aXJlVGltZW91dCBJZiBuZWdhdGl2ZSwgbm8gdGltZW91dC4gSWYgMCBhbiBlcnJvciBpcyB0aHJvd24gaWZcbiAqICAgICAgICAgICAgICAgICAgICAgICB0aGUgbG9jayBjYW4ndCBiZSBhY3F1aXJlZCB3aXRob3V0IHdhaXRpbmcuIElmIHBvc2l0aXZlLCB0aGUgbG9jayBhY3F1aXJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgd2lsbCB0aW1lIG91dCBhZnRlciBzbyBtYW55IG1pbGxpc2Vjb25kcy4gQW4gZXJyb3IgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgICBhIHRpbWVvdXQgaWYgaXQgaGFzIGBpc0FjcXVpcmVUaW1lb3V0YCBzZXQgdG8gdHJ1ZS5cbiAqIEBwYXJhbSBmbiBUaGUgb3BlcmF0aW9uIHRvIHJ1biBvbmNlIHRoZSBsb2NrIGlzIGFjcXVpcmVkLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBhd2FpdCBwcm9jZXNzTG9jaygnbWlncmF0ZScsIDUwMDAsIGFzeW5jICgpID0+IHtcbiAqICAgYXdhaXQgcnVuTWlncmF0aW9uKClcbiAqIH0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NMb2NrKG5hbWUsIGFjcXVpcmVUaW1lb3V0LCBmbikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBwcmV2aW91c09wZXJhdGlvbiA9IChfYSA9IFBST0NFU1NfTE9DS1NbbmFtZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIC8vIFdyYXAgcHJldmlvdXNPcGVyYXRpb24gdG8gaGFuZGxlIGVycm9ycyB3aXRob3V0IHVzaW5nIC5jYXRjaCgpXG4gICAgLy8gVGhpcyBhdm9pZHMgRmlyZWZveCBjb250ZW50IHNjcmlwdCBzZWN1cml0eSBlcnJvcnNcbiAgICBjb25zdCBwcmV2aW91c09wZXJhdGlvbkhhbmRsZWQgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgcHJldmlvdXNPcGVyYXRpb247XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gaWdub3JlIGVycm9yIG9mIHByZXZpb3VzIG9wZXJhdGlvbiB0aGF0IHdlJ3JlIHdhaXRpbmcgdG8gZmluaXNoXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0pKCk7XG4gICAgY29uc3QgY3VycmVudE9wZXJhdGlvbiA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgIGxldCB0aW1lb3V0SWQgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2FpdCBmb3IgZWl0aGVyIHByZXZpb3VzIG9wZXJhdGlvbiBvciB0aW1lb3V0XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IGFjcXVpcmVUaW1lb3V0ID49IDBcbiAgICAgICAgICAgICAgICA/IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEBzdXBhYmFzZS9nb3RydWUtanM6IExvY2sgXCIke25hbWV9XCIgYWNxdWlzaXRpb24gdGltZWQgb3V0IGFmdGVyICR7YWNxdWlyZVRpbWVvdXR9bXMuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaGlzIG1heSBiZSBjYXVzZWQgYnkgYW5vdGhlciBvcGVyYXRpb24gaG9sZGluZyB0aGUgbG9jay4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0NvbnNpZGVyIGluY3JlYXNpbmcgbG9ja0FjcXVpcmVUaW1lb3V0IG9yIGNoZWNraW5nIGZvciBzdHVjayBvcGVyYXRpb25zLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBQcm9jZXNzTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IoYEFjcXVpcmluZyBwcm9jZXNzIGxvY2sgd2l0aCBuYW1lIFwiJHtuYW1lfVwiIHRpbWVkIG91dGApKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgYWNxdWlyZVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5yYWNlKFtwcmV2aW91c09wZXJhdGlvbkhhbmRsZWQsIHRpbWVvdXRQcm9taXNlXS5maWx0ZXIoKHgpID0+IHgpKTtcbiAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoIGhlcmUsIHByZXZpb3VzT3BlcmF0aW9uSGFuZGxlZCB3b24gdGhlIHJhY2VcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSB0aW1lb3V0IHRvIHByZXZlbnQgZmFsc2Ugd2FybmluZ3NcbiAgICAgICAgICAgIGlmICh0aW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIHRpbWVvdXQgb24gZXJyb3IgcGF0aCBhcyB3ZWxsXG4gICAgICAgICAgICBpZiAodGltZW91dElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZS10aHJvdyB0aW1lb3V0IGVycm9ycywgaWdub3JlIG90aGVyc1xuICAgICAgICAgICAgaWYgKGUgJiYgZS5pc0FjcXVpcmVUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZhbGwgdGhyb3VnaCB0byBydW4gZm4oKSAtIHByZXZpb3VzIG9wZXJhdGlvbiBmaW5pc2hlZCB3aXRoIGVycm9yXG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmlvdXMgb3BlcmF0aW9ucyBmaW5pc2hlZCBhbmQgd2UgZGlkbid0IGdldCBhIHJhY2Ugb24gdGhlIGFjcXVpcmVcbiAgICAgICAgLy8gdGltZW91dCwgc28gdGhlIGN1cnJlbnQgb3BlcmF0aW9uIGNhbiBmaW5hbGx5IHN0YXJ0XG4gICAgICAgIHJldHVybiBhd2FpdCBmbigpO1xuICAgIH0pKCk7XG4gICAgUFJPQ0VTU19MT0NLU1tuYW1lXSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgY3VycmVudE9wZXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgJiYgZS5pc0FjcXVpcmVUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgb3BlcmF0aW9uIHRpbWVkIG91dCwgaXQgZG9lc24ndCBtZWFuIHRoYXQgdGhlIHByZXZpb3VzXG4gICAgICAgICAgICAgICAgLy8gb3BlcmF0aW9uIGZpbmlzaGVkLCBzbyB3ZSBuZWVkIGNvbnRpbnVlIHdhaXRpbmcgZm9yIGl0IHRvIGZpbmlzaFxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHByZXZpb3VzT3BlcmF0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAocHJldkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBwcmV2aW91cyBvcGVyYXRpb24gZXJyb3JzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH0pKCk7XG4gICAgLy8gZmluYWxseSB3YWl0IGZvciB0aGUgY3VycmVudCBvcGVyYXRpb24gdG8gZmluaXNoIHN1Y2Nlc3NmdWxseSwgd2l0aCBhblxuICAgIC8vIGVycm9yIG9yIHdpdGggYW4gYWNxdWlyZSB0aW1lb3V0IGVycm9yXG4gICAgcmV0dXJuIGF3YWl0IGN1cnJlbnRPcGVyYXRpb247XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2Nrcy5qcy5tYXAiXSwibmFtZXMiOlsic3VwcG9ydHNMb2NhbFN0b3JhZ2UiLCJpbnRlcm5hbHMiLCJkZWJ1ZyIsImdsb2JhbFRoaXMiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsImlzQWNxdWlyZVRpbWVvdXQiLCJOYXZpZ2F0b3JMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciIsIlByb2Nlc3NMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciIsIm5hdmlnYXRvckxvY2siLCJuYW1lIiwiYWNxdWlyZVRpbWVvdXQiLCJmbiIsImNvbnNvbGUiLCJsb2ciLCJhYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJzZXRUaW1lb3V0IiwiYWJvcnQiLCJQcm9taXNlIiwicmVzb2x2ZSIsIm5hdmlnYXRvciIsImxvY2tzIiwicmVxdWVzdCIsIm1vZGUiLCJpZkF2YWlsYWJsZSIsInNpZ25hbCIsImxvY2siLCJyZXN1bHQiLCJxdWVyeSIsIkpTT04iLCJzdHJpbmdpZnkiLCJlIiwid2FybiIsIlBST0NFU1NfTE9DS1MiLCJwcm9jZXNzTG9jayIsIl9hIiwicHJldmlvdXNPcGVyYXRpb24iLCJwcmV2aW91c09wZXJhdGlvbkhhbmRsZWQiLCJjdXJyZW50T3BlcmF0aW9uIiwidGltZW91dElkIiwidGltZW91dFByb21pc2UiLCJfIiwicmVqZWN0IiwicmFjZSIsImZpbHRlciIsIngiLCJjbGVhclRpbWVvdXQiLCJwcmV2RXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   polyfillGlobalThis: () => (/* binding */ polyfillGlobalThis)\n/* harmony export */ });\n/**\n * https://mathiasbynens.be/notes/globalthis\n */ function polyfillGlobalThis() {\n    if (typeof globalThis === \"object\") return;\n    try {\n        Object.defineProperty(Object.prototype, \"__magic__\", {\n            get: function() {\n                return this;\n            },\n            configurable: true\n        });\n        // @ts-expect-error 'Allow access to magic'\n        __magic__.globalThis = __magic__;\n        // @ts-expect-error 'Allow access to magic'\n        delete Object.prototype.__magic__;\n    } catch (e) {\n        if (typeof self !== \"undefined\") {\n            // @ts-expect-error 'Allow access to globals'\n            self.globalThis = self;\n        }\n    }\n} //# sourceMappingURL=polyfills.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3BvbHlmaWxscy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0NBRUMsR0FDTSxTQUFTQTtJQUNaLElBQUksT0FBT0MsZUFBZSxVQUN0QjtJQUNKLElBQUk7UUFDQUMsT0FBT0MsY0FBYyxDQUFDRCxPQUFPRSxTQUFTLEVBQUUsYUFBYTtZQUNqREMsS0FBSztnQkFDRCxPQUFPLElBQUk7WUFDZjtZQUNBQyxjQUFjO1FBQ2xCO1FBQ0EsMkNBQTJDO1FBQzNDQyxVQUFVTixVQUFVLEdBQUdNO1FBQ3ZCLDJDQUEyQztRQUMzQyxPQUFPTCxPQUFPRSxTQUFTLENBQUNHLFNBQVM7SUFDckMsRUFDQSxPQUFPQyxHQUFHO1FBQ04sSUFBSSxPQUFPQyxTQUFTLGFBQWE7WUFDN0IsNkNBQTZDO1lBQzdDQSxLQUFLUixVQUFVLEdBQUdRO1FBQ3RCO0lBQ0o7QUFDSixFQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FuY2hvci13b3JrZmxvd3MvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3BvbHlmaWxscy5qcz82M2U1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2dsb2JhbHRoaXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvbHlmaWxsR2xvYmFsVGhpcygpIHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm47XG4gICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdC5wcm90b3R5cGUsICdfX21hZ2ljX18nLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yICdBbGxvdyBhY2Nlc3MgdG8gbWFnaWMnXG4gICAgICAgIF9fbWFnaWNfXy5nbG9iYWxUaGlzID0gX19tYWdpY19fO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yICdBbGxvdyBhY2Nlc3MgdG8gbWFnaWMnXG4gICAgICAgIGRlbGV0ZSBPYmplY3QucHJvdG90eXBlLl9fbWFnaWNfXztcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAnQWxsb3cgYWNjZXNzIHRvIGdsb2JhbHMnXG4gICAgICAgICAgICBzZWxmLmdsb2JhbFRoaXMgPSBzZWxmO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9seWZpbGxzLmpzLm1hcCJdLCJuYW1lcyI6WyJwb2x5ZmlsbEdsb2JhbFRoaXMiLCJnbG9iYWxUaGlzIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJwcm90b3R5cGUiLCJnZXQiLCJjb25maWd1cmFibGUiLCJfX21hZ2ljX18iLCJlIiwic2VsZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/types.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/types.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SIGN_OUT_SCOPES: () => (/* binding */ SIGN_OUT_SCOPES)\n/* harmony export */ });\nconst WeakPasswordReasons = [\n    \"length\",\n    \"characters\",\n    \"pwned\"\n];\nconst AMRMethods = [\n    \"password\",\n    \"otp\",\n    \"oauth\",\n    \"totp\",\n    \"mfa/totp\",\n    \"mfa/phone\",\n    \"mfa/webauthn\",\n    \"anonymous\",\n    \"sso/saml\",\n    \"magiclink\",\n    \"web3\",\n    \"oauth_provider/authorization_code\"\n];\nconst FactorTypes = [\n    \"totp\",\n    \"phone\",\n    \"webauthn\"\n];\nconst FactorVerificationStatuses = [\n    \"verified\",\n    \"unverified\"\n];\nconst MFATOTPChannels = [\n    \"sms\",\n    \"whatsapp\"\n];\nconst SIGN_OUT_SCOPES = [\n    \"global\",\n    \"local\",\n    \"others\"\n]; //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3R5cGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxzQkFBc0I7SUFBQztJQUFVO0lBQWM7Q0FBUTtBQUM3RCxNQUFNQyxhQUFhO0lBQ2Y7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDRCxNQUFNQyxjQUFjO0lBQUM7SUFBUTtJQUFTO0NBQVc7QUFDakQsTUFBTUMsNkJBQTZCO0lBQUM7SUFBWTtDQUFhO0FBQzdELE1BQU1DLGtCQUFrQjtJQUFDO0lBQU87Q0FBVztBQUNwQyxNQUFNQyxrQkFBa0I7SUFBQztJQUFVO0lBQVM7Q0FBUyxDQUFDLENBQzdELGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FuY2hvci13b3JrZmxvd3MvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3R5cGVzLmpzPzFmNjEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgV2Vha1Bhc3N3b3JkUmVhc29ucyA9IFsnbGVuZ3RoJywgJ2NoYXJhY3RlcnMnLCAncHduZWQnXTtcbmNvbnN0IEFNUk1ldGhvZHMgPSBbXG4gICAgJ3Bhc3N3b3JkJyxcbiAgICAnb3RwJyxcbiAgICAnb2F1dGgnLFxuICAgICd0b3RwJyxcbiAgICAnbWZhL3RvdHAnLFxuICAgICdtZmEvcGhvbmUnLFxuICAgICdtZmEvd2ViYXV0aG4nLFxuICAgICdhbm9ueW1vdXMnLFxuICAgICdzc28vc2FtbCcsXG4gICAgJ21hZ2ljbGluaycsXG4gICAgJ3dlYjMnLFxuICAgICdvYXV0aF9wcm92aWRlci9hdXRob3JpemF0aW9uX2NvZGUnLFxuXTtcbmNvbnN0IEZhY3RvclR5cGVzID0gWyd0b3RwJywgJ3Bob25lJywgJ3dlYmF1dGhuJ107XG5jb25zdCBGYWN0b3JWZXJpZmljYXRpb25TdGF0dXNlcyA9IFsndmVyaWZpZWQnLCAndW52ZXJpZmllZCddO1xuY29uc3QgTUZBVE9UUENoYW5uZWxzID0gWydzbXMnLCAnd2hhdHNhcHAnXTtcbmV4cG9ydCBjb25zdCBTSUdOX09VVF9TQ09QRVMgPSBbJ2dsb2JhbCcsICdsb2NhbCcsICdvdGhlcnMnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJXZWFrUGFzc3dvcmRSZWFzb25zIiwiQU1STWV0aG9kcyIsIkZhY3RvclR5cGVzIiwiRmFjdG9yVmVyaWZpY2F0aW9uU3RhdHVzZXMiLCJNRkFUT1RQQ2hhbm5lbHMiLCJTSUdOX09VVF9TQ09QRVMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/version.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/version.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n// Generated automatically during releases by scripts/update-version-files.ts\n// This file provides runtime access to the package version for:\n// - HTTP request headers (e.g., X-Client-Info header for API requests)\n// - Debugging and support (identifying which version is running)\n// - Telemetry and logging (version reporting in errors/analytics)\n// - Ensuring build artifacts match the published package version\nconst version = \"2.97.0\"; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLDZFQUE2RTtBQUM3RSxnRUFBZ0U7QUFDaEUsdUVBQXVFO0FBQ3ZFLGlFQUFpRTtBQUNqRSxrRUFBa0U7QUFDbEUsaUVBQWlFO0FBQzFELE1BQU1BLFVBQVUsU0FBUyxDQUNoQyxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmNob3Itd29ya2Zsb3dzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2xpYi92ZXJzaW9uLmpzPzk3N2MiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gR2VuZXJhdGVkIGF1dG9tYXRpY2FsbHkgZHVyaW5nIHJlbGVhc2VzIGJ5IHNjcmlwdHMvdXBkYXRlLXZlcnNpb24tZmlsZXMudHNcbi8vIFRoaXMgZmlsZSBwcm92aWRlcyBydW50aW1lIGFjY2VzcyB0byB0aGUgcGFja2FnZSB2ZXJzaW9uIGZvcjpcbi8vIC0gSFRUUCByZXF1ZXN0IGhlYWRlcnMgKGUuZy4sIFgtQ2xpZW50LUluZm8gaGVhZGVyIGZvciBBUEkgcmVxdWVzdHMpXG4vLyAtIERlYnVnZ2luZyBhbmQgc3VwcG9ydCAoaWRlbnRpZnlpbmcgd2hpY2ggdmVyc2lvbiBpcyBydW5uaW5nKVxuLy8gLSBUZWxlbWV0cnkgYW5kIGxvZ2dpbmcgKHZlcnNpb24gcmVwb3J0aW5nIGluIGVycm9ycy9hbmFseXRpY3MpXG4vLyAtIEVuc3VyaW5nIGJ1aWxkIGFydGlmYWN0cyBtYXRjaCB0aGUgcHVibGlzaGVkIHBhY2thZ2UgdmVyc2lvblxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMi45Ny4wJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/web3/ethereum.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/web3/ethereum.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSiweMessage: () => (/* binding */ createSiweMessage),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   getAddress: () => (/* binding */ getAddress),\n/* harmony export */   toHex: () => (/* binding */ toHex)\n/* harmony export */ });\n// types and functions copied over from viem so this library doesn't depend on it\nfunction getAddress(address) {\n    if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {\n        throw new Error(`@supabase/auth-js: Address \"${address}\" is invalid.`);\n    }\n    return address.toLowerCase();\n}\nfunction fromHex(hex) {\n    return parseInt(hex, 16);\n}\nfunction toHex(value) {\n    const bytes = new TextEncoder().encode(value);\n    const hex = Array.from(bytes, (byte)=>byte.toString(16).padStart(2, \"0\")).join(\"\");\n    return \"0x\" + hex;\n}\n/**\n * Creates EIP-4361 formatted message.\n */ function createSiweMessage(parameters) {\n    var _a;\n    const { chainId, domain, expirationTime, issuedAt = new Date(), nonce, notBefore, requestId, resources, scheme, uri, version } = parameters;\n    // Validate fields\n    {\n        if (!Number.isInteger(chainId)) throw new Error(`@supabase/auth-js: Invalid SIWE message field \"chainId\". Chain ID must be a EIP-155 chain ID. Provided value: ${chainId}`);\n        if (!domain) throw new Error(`@supabase/auth-js: Invalid SIWE message field \"domain\". Domain must be provided.`);\n        if (nonce && nonce.length < 8) throw new Error(`@supabase/auth-js: Invalid SIWE message field \"nonce\". Nonce must be at least 8 characters. Provided value: ${nonce}`);\n        if (!uri) throw new Error(`@supabase/auth-js: Invalid SIWE message field \"uri\". URI must be provided.`);\n        if (version !== \"1\") throw new Error(`@supabase/auth-js: Invalid SIWE message field \"version\". Version must be '1'. Provided value: ${version}`);\n        if ((_a = parameters.statement) === null || _a === void 0 ? void 0 : _a.includes(\"\\n\")) throw new Error(`@supabase/auth-js: Invalid SIWE message field \"statement\". Statement must not include '\\\\n'. Provided value: ${parameters.statement}`);\n    }\n    // Construct message\n    const address = getAddress(parameters.address);\n    const origin = scheme ? `${scheme}://${domain}` : domain;\n    const statement = parameters.statement ? `${parameters.statement}\\n` : \"\";\n    const prefix = `${origin} wants you to sign in with your Ethereum account:\\n${address}\\n\\n${statement}`;\n    let suffix = `URI: ${uri}\\nVersion: ${version}\\nChain ID: ${chainId}${nonce ? `\\nNonce: ${nonce}` : \"\"}\\nIssued At: ${issuedAt.toISOString()}`;\n    if (expirationTime) suffix += `\\nExpiration Time: ${expirationTime.toISOString()}`;\n    if (notBefore) suffix += `\\nNot Before: ${notBefore.toISOString()}`;\n    if (requestId) suffix += `\\nRequest ID: ${requestId}`;\n    if (resources) {\n        let content = \"\\nResources:\";\n        for (const resource of resources){\n            if (!resource || typeof resource !== \"string\") throw new Error(`@supabase/auth-js: Invalid SIWE message field \"resources\". Every resource must be a valid string. Provided value: ${resource}`);\n            content += `\\n- ${resource}`;\n        }\n        suffix += content;\n    }\n    return `${prefix}\\n${suffix}`;\n} //# sourceMappingURL=ethereum.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3dlYjMvZXRoZXJldW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLGlGQUFpRjtBQUMxRSxTQUFTQSxXQUFXQyxPQUFPO0lBQzlCLElBQUksQ0FBQyxzQkFBc0JDLElBQUksQ0FBQ0QsVUFBVTtRQUN0QyxNQUFNLElBQUlFLE1BQU0sQ0FBQyw0QkFBNEIsRUFBRUYsUUFBUSxhQUFhLENBQUM7SUFDekU7SUFDQSxPQUFPQSxRQUFRRyxXQUFXO0FBQzlCO0FBQ08sU0FBU0MsUUFBUUMsR0FBRztJQUN2QixPQUFPQyxTQUFTRCxLQUFLO0FBQ3pCO0FBQ08sU0FBU0UsTUFBTUMsS0FBSztJQUN2QixNQUFNQyxRQUFRLElBQUlDLGNBQWNDLE1BQU0sQ0FBQ0g7SUFDdkMsTUFBTUgsTUFBTU8sTUFBTUMsSUFBSSxDQUFDSixPQUFPLENBQUNLLE9BQVNBLEtBQUtDLFFBQVEsQ0FBQyxJQUFJQyxRQUFRLENBQUMsR0FBRyxNQUFNQyxJQUFJLENBQUM7SUFDakYsT0FBUSxPQUFPWjtBQUNuQjtBQUNBOztDQUVDLEdBQ00sU0FBU2Esa0JBQWtCQyxVQUFVO0lBQ3hDLElBQUlDO0lBQ0osTUFBTSxFQUFFQyxPQUFPLEVBQUVDLE1BQU0sRUFBRUMsY0FBYyxFQUFFQyxXQUFXLElBQUlDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxTQUFTLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFQyxNQUFNLEVBQUVDLEdBQUcsRUFBRUMsT0FBTyxFQUFHLEdBQUdiO0lBQ2xJLGtCQUFrQjtJQUNsQjtRQUNJLElBQUksQ0FBQ2MsT0FBT0MsU0FBUyxDQUFDYixVQUNsQixNQUFNLElBQUluQixNQUFNLENBQUMsOEdBQThHLEVBQUVtQixRQUFRLENBQUM7UUFDOUksSUFBSSxDQUFDQyxRQUNELE1BQU0sSUFBSXBCLE1BQU0sQ0FBQyxnRkFBZ0YsQ0FBQztRQUN0RyxJQUFJd0IsU0FBU0EsTUFBTVMsTUFBTSxHQUFHLEdBQ3hCLE1BQU0sSUFBSWpDLE1BQU0sQ0FBQyw0R0FBNEcsRUFBRXdCLE1BQU0sQ0FBQztRQUMxSSxJQUFJLENBQUNLLEtBQ0QsTUFBTSxJQUFJN0IsTUFBTSxDQUFDLDBFQUEwRSxDQUFDO1FBQ2hHLElBQUk4QixZQUFZLEtBQ1osTUFBTSxJQUFJOUIsTUFBTSxDQUFDLDhGQUE4RixFQUFFOEIsUUFBUSxDQUFDO1FBQzlILElBQUksQ0FBQ1osS0FBS0QsV0FBV2lCLFNBQVMsTUFBTSxRQUFRaEIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHaUIsUUFBUSxDQUFDLE9BQzdFLE1BQU0sSUFBSW5DLE1BQU0sQ0FBQyw2R0FBNkcsRUFBRWlCLFdBQVdpQixTQUFTLENBQUMsQ0FBQztJQUM5SjtJQUNBLG9CQUFvQjtJQUNwQixNQUFNcEMsVUFBVUQsV0FBV29CLFdBQVduQixPQUFPO0lBQzdDLE1BQU1zQyxTQUFTUixTQUFTLENBQUMsRUFBRUEsT0FBTyxHQUFHLEVBQUVSLE9BQU8sQ0FBQyxHQUFHQTtJQUNsRCxNQUFNYyxZQUFZakIsV0FBV2lCLFNBQVMsR0FBRyxDQUFDLEVBQUVqQixXQUFXaUIsU0FBUyxDQUFDLEVBQUUsQ0FBQyxHQUFHO0lBQ3ZFLE1BQU1HLFNBQVMsQ0FBQyxFQUFFRCxPQUFPLG1EQUFtRCxFQUFFdEMsUUFBUSxJQUFJLEVBQUVvQyxVQUFVLENBQUM7SUFDdkcsSUFBSUksU0FBUyxDQUFDLEtBQUssRUFBRVQsSUFBSSxXQUFXLEVBQUVDLFFBQVEsWUFBWSxFQUFFWCxRQUFRLEVBQUVLLFFBQVEsQ0FBQyxTQUFTLEVBQUVBLE1BQU0sQ0FBQyxHQUFHLEdBQUcsYUFBYSxFQUFFRixTQUFTaUIsV0FBVyxHQUFHLENBQUM7SUFDOUksSUFBSWxCLGdCQUNBaUIsVUFBVSxDQUFDLG1CQUFtQixFQUFFakIsZUFBZWtCLFdBQVcsR0FBRyxDQUFDO0lBQ2xFLElBQUlkLFdBQ0FhLFVBQVUsQ0FBQyxjQUFjLEVBQUViLFVBQVVjLFdBQVcsR0FBRyxDQUFDO0lBQ3hELElBQUliLFdBQ0FZLFVBQVUsQ0FBQyxjQUFjLEVBQUVaLFVBQVUsQ0FBQztJQUMxQyxJQUFJQyxXQUFXO1FBQ1gsSUFBSWEsVUFBVTtRQUNkLEtBQUssTUFBTUMsWUFBWWQsVUFBVztZQUM5QixJQUFJLENBQUNjLFlBQVksT0FBT0EsYUFBYSxVQUNqQyxNQUFNLElBQUl6QyxNQUFNLENBQUMsa0hBQWtILEVBQUV5QyxTQUFTLENBQUM7WUFDbkpELFdBQVcsQ0FBQyxJQUFJLEVBQUVDLFNBQVMsQ0FBQztRQUNoQztRQUNBSCxVQUFVRTtJQUNkO0lBQ0EsT0FBTyxDQUFDLEVBQUVILE9BQU8sRUFBRSxFQUFFQyxPQUFPLENBQUM7QUFDakMsRUFDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmNob3Itd29ya2Zsb3dzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2xpYi93ZWIzL2V0aGVyZXVtLmpzPzIwZDUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdHlwZXMgYW5kIGZ1bmN0aW9ucyBjb3BpZWQgb3ZlciBmcm9tIHZpZW0gc28gdGhpcyBsaWJyYXJ5IGRvZXNuJ3QgZGVwZW5kIG9uIGl0XG5leHBvcnQgZnVuY3Rpb24gZ2V0QWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgaWYgKCEvXjB4W2EtZkEtRjAtOV17NDB9JC8udGVzdChhZGRyZXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBBZGRyZXNzIFwiJHthZGRyZXNzfVwiIGlzIGludmFsaWQuYCk7XG4gICAgfVxuICAgIHJldHVybiBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZnJvbUhleChoZXgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoaGV4LCAxNik7XG59XG5leHBvcnQgZnVuY3Rpb24gdG9IZXgodmFsdWUpIHtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XG4gICAgY29uc3QgaGV4ID0gQXJyYXkuZnJvbShieXRlcywgKGJ5dGUpID0+IGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJycpO1xuICAgIHJldHVybiAoJzB4JyArIGhleCk7XG59XG4vKipcbiAqIENyZWF0ZXMgRUlQLTQzNjEgZm9ybWF0dGVkIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTaXdlTWVzc2FnZShwYXJhbWV0ZXJzKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgY2hhaW5JZCwgZG9tYWluLCBleHBpcmF0aW9uVGltZSwgaXNzdWVkQXQgPSBuZXcgRGF0ZSgpLCBub25jZSwgbm90QmVmb3JlLCByZXF1ZXN0SWQsIHJlc291cmNlcywgc2NoZW1lLCB1cmksIHZlcnNpb24sIH0gPSBwYXJhbWV0ZXJzO1xuICAgIC8vIFZhbGlkYXRlIGZpZWxkc1xuICAgIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNoYWluSWQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogSW52YWxpZCBTSVdFIG1lc3NhZ2UgZmllbGQgXCJjaGFpbklkXCIuIENoYWluIElEIG11c3QgYmUgYSBFSVAtMTU1IGNoYWluIElELiBQcm92aWRlZCB2YWx1ZTogJHtjaGFpbklkfWApO1xuICAgICAgICBpZiAoIWRvbWFpbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IEludmFsaWQgU0lXRSBtZXNzYWdlIGZpZWxkIFwiZG9tYWluXCIuIERvbWFpbiBtdXN0IGJlIHByb3ZpZGVkLmApO1xuICAgICAgICBpZiAobm9uY2UgJiYgbm9uY2UubGVuZ3RoIDwgOClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IEludmFsaWQgU0lXRSBtZXNzYWdlIGZpZWxkIFwibm9uY2VcIi4gTm9uY2UgbXVzdCBiZSBhdCBsZWFzdCA4IGNoYXJhY3RlcnMuIFByb3ZpZGVkIHZhbHVlOiAke25vbmNlfWApO1xuICAgICAgICBpZiAoIXVyaSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IEludmFsaWQgU0lXRSBtZXNzYWdlIGZpZWxkIFwidXJpXCIuIFVSSSBtdXN0IGJlIHByb3ZpZGVkLmApO1xuICAgICAgICBpZiAodmVyc2lvbiAhPT0gJzEnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogSW52YWxpZCBTSVdFIG1lc3NhZ2UgZmllbGQgXCJ2ZXJzaW9uXCIuIFZlcnNpb24gbXVzdCBiZSAnMScuIFByb3ZpZGVkIHZhbHVlOiAke3ZlcnNpb259YCk7XG4gICAgICAgIGlmICgoX2EgPSBwYXJhbWV0ZXJzLnN0YXRlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKCdcXG4nKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IEludmFsaWQgU0lXRSBtZXNzYWdlIGZpZWxkIFwic3RhdGVtZW50XCIuIFN0YXRlbWVudCBtdXN0IG5vdCBpbmNsdWRlICdcXFxcbicuIFByb3ZpZGVkIHZhbHVlOiAke3BhcmFtZXRlcnMuc3RhdGVtZW50fWApO1xuICAgIH1cbiAgICAvLyBDb25zdHJ1Y3QgbWVzc2FnZVxuICAgIGNvbnN0IGFkZHJlc3MgPSBnZXRBZGRyZXNzKHBhcmFtZXRlcnMuYWRkcmVzcyk7XG4gICAgY29uc3Qgb3JpZ2luID0gc2NoZW1lID8gYCR7c2NoZW1lfTovLyR7ZG9tYWlufWAgOiBkb21haW47XG4gICAgY29uc3Qgc3RhdGVtZW50ID0gcGFyYW1ldGVycy5zdGF0ZW1lbnQgPyBgJHtwYXJhbWV0ZXJzLnN0YXRlbWVudH1cXG5gIDogJyc7XG4gICAgY29uc3QgcHJlZml4ID0gYCR7b3JpZ2lufSB3YW50cyB5b3UgdG8gc2lnbiBpbiB3aXRoIHlvdXIgRXRoZXJldW0gYWNjb3VudDpcXG4ke2FkZHJlc3N9XFxuXFxuJHtzdGF0ZW1lbnR9YDtcbiAgICBsZXQgc3VmZml4ID0gYFVSSTogJHt1cml9XFxuVmVyc2lvbjogJHt2ZXJzaW9ufVxcbkNoYWluIElEOiAke2NoYWluSWR9JHtub25jZSA/IGBcXG5Ob25jZTogJHtub25jZX1gIDogJyd9XFxuSXNzdWVkIEF0OiAke2lzc3VlZEF0LnRvSVNPU3RyaW5nKCl9YDtcbiAgICBpZiAoZXhwaXJhdGlvblRpbWUpXG4gICAgICAgIHN1ZmZpeCArPSBgXFxuRXhwaXJhdGlvbiBUaW1lOiAke2V4cGlyYXRpb25UaW1lLnRvSVNPU3RyaW5nKCl9YDtcbiAgICBpZiAobm90QmVmb3JlKVxuICAgICAgICBzdWZmaXggKz0gYFxcbk5vdCBCZWZvcmU6ICR7bm90QmVmb3JlLnRvSVNPU3RyaW5nKCl9YDtcbiAgICBpZiAocmVxdWVzdElkKVxuICAgICAgICBzdWZmaXggKz0gYFxcblJlcXVlc3QgSUQ6ICR7cmVxdWVzdElkfWA7XG4gICAgaWYgKHJlc291cmNlcykge1xuICAgICAgICBsZXQgY29udGVudCA9ICdcXG5SZXNvdXJjZXM6JztcbiAgICAgICAgZm9yIChjb25zdCByZXNvdXJjZSBvZiByZXNvdXJjZXMpIHtcbiAgICAgICAgICAgIGlmICghcmVzb3VyY2UgfHwgdHlwZW9mIHJlc291cmNlICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBJbnZhbGlkIFNJV0UgbWVzc2FnZSBmaWVsZCBcInJlc291cmNlc1wiLiBFdmVyeSByZXNvdXJjZSBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nLiBQcm92aWRlZCB2YWx1ZTogJHtyZXNvdXJjZX1gKTtcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gYFxcbi0gJHtyZXNvdXJjZX1gO1xuICAgICAgICB9XG4gICAgICAgIHN1ZmZpeCArPSBjb250ZW50O1xuICAgIH1cbiAgICByZXR1cm4gYCR7cHJlZml4fVxcbiR7c3VmZml4fWA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldGhlcmV1bS5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0QWRkcmVzcyIsImFkZHJlc3MiLCJ0ZXN0IiwiRXJyb3IiLCJ0b0xvd2VyQ2FzZSIsImZyb21IZXgiLCJoZXgiLCJwYXJzZUludCIsInRvSGV4IiwidmFsdWUiLCJieXRlcyIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiQXJyYXkiLCJmcm9tIiwiYnl0ZSIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJqb2luIiwiY3JlYXRlU2l3ZU1lc3NhZ2UiLCJwYXJhbWV0ZXJzIiwiX2EiLCJjaGFpbklkIiwiZG9tYWluIiwiZXhwaXJhdGlvblRpbWUiLCJpc3N1ZWRBdCIsIkRhdGUiLCJub25jZSIsIm5vdEJlZm9yZSIsInJlcXVlc3RJZCIsInJlc291cmNlcyIsInNjaGVtZSIsInVyaSIsInZlcnNpb24iLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJsZW5ndGgiLCJzdGF0ZW1lbnQiLCJpbmNsdWRlcyIsIm9yaWdpbiIsInByZWZpeCIsInN1ZmZpeCIsInRvSVNPU3RyaW5nIiwiY29udGVudCIsInJlc291cmNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/web3/ethereum.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.errors.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/webauthn.errors.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebAuthnError: () => (/* binding */ WebAuthnError),\n/* harmony export */   WebAuthnUnknownError: () => (/* binding */ WebAuthnUnknownError),\n/* harmony export */   identifyAuthenticationError: () => (/* binding */ identifyAuthenticationError),\n/* harmony export */   identifyRegistrationError: () => (/* binding */ identifyRegistrationError),\n/* harmony export */   isWebAuthnError: () => (/* binding */ isWebAuthnError)\n/* harmony export */ });\n/* harmony import */ var _webauthn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webauthn */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.js\");\n/* eslint-disable @typescript-eslint/ban-ts-comment */ \n/**\n * A custom Error used to return a more nuanced error detailing _why_ one of the eight documented\n * errors in the spec was raised after calling `navigator.credentials.create()` or\n * `navigator.credentials.get()`:\n *\n * - `AbortError`\n * - `ConstraintError`\n * - `InvalidStateError`\n * - `NotAllowedError`\n * - `NotSupportedError`\n * - `SecurityError`\n * - `TypeError`\n * - `UnknownError`\n *\n * Error messages were determined through investigation of the spec to determine under which\n * scenarios a given error would be raised.\n */ class WebAuthnError extends Error {\n    constructor({ message, code, cause, name }){\n        var _a;\n        // @ts-ignore: help Rollup understand that `cause` is okay to set\n        super(message, {\n            cause\n        });\n        this.__isWebAuthnError = true;\n        this.name = (_a = name !== null && name !== void 0 ? name : cause instanceof Error ? cause.name : undefined) !== null && _a !== void 0 ? _a : \"Unknown Error\";\n        this.code = code;\n    }\n}\n/**\n * Error class for unknown WebAuthn errors.\n * Wraps unexpected errors that don't match known WebAuthn error conditions.\n */ class WebAuthnUnknownError extends WebAuthnError {\n    constructor(message, originalError){\n        super({\n            code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n            cause: originalError,\n            message\n        });\n        this.name = \"WebAuthnUnknownError\";\n        this.originalError = originalError;\n    }\n}\n/**\n * Type guard to check if an error is a WebAuthnError.\n * @param {unknown} error - The error to check\n * @returns {boolean} True if the error is a WebAuthnError\n */ function isWebAuthnError(error) {\n    return typeof error === \"object\" && error !== null && \"__isWebAuthnError\" in error;\n}\n/**\n * Attempt to intuit _why_ an error was raised after calling `navigator.credentials.create()`.\n * Maps browser errors to specific WebAuthn error codes for better debugging.\n * @param {Object} params - Error identification parameters\n * @param {Error} params.error - The error thrown by the browser\n * @param {CredentialCreationOptions} params.options - The options passed to credentials.create()\n * @returns {WebAuthnError} A WebAuthnError with a specific error code\n * @see {@link https://w3c.github.io/webauthn/#sctn-createCredential W3C WebAuthn Spec - Create Credential}\n */ function identifyRegistrationError({ error, options }) {\n    var _a, _b, _c;\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error(\"options was missing required publicKey property\");\n    }\n    if (error.name === \"AbortError\") {\n        if (options.signal instanceof AbortSignal) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 16)\n            return new WebAuthnError({\n                message: \"Registration ceremony was sent an abort signal\",\n                code: \"ERROR_CEREMONY_ABORTED\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"ConstraintError\") {\n        if (((_a = publicKey.authenticatorSelection) === null || _a === void 0 ? void 0 : _a.requireResidentKey) === true) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 4)\n            return new WebAuthnError({\n                message: \"Discoverable credentials were required but no available authenticator supported it\",\n                code: \"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT\",\n                cause: error\n            });\n        } else if (// @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024\n        options.mediation === \"conditional\" && ((_b = publicKey.authenticatorSelection) === null || _b === void 0 ? void 0 : _b.userVerification) === \"required\") {\n            // https://w3c.github.io/webauthn/#sctn-createCredential (Step 22.4)\n            return new WebAuthnError({\n                message: \"User verification was required during automatic registration but it could not be performed\",\n                code: \"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE\",\n                cause: error\n            });\n        } else if (((_c = publicKey.authenticatorSelection) === null || _c === void 0 ? void 0 : _c.userVerification) === \"required\") {\n            // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 5)\n            return new WebAuthnError({\n                message: \"User verification was required but no available authenticator supported it\",\n                code: \"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"InvalidStateError\") {\n        // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 20)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 3)\n        return new WebAuthnError({\n            message: \"The authenticator was previously registered\",\n            code: \"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED\",\n            cause: error\n        });\n    } else if (error.name === \"NotAllowedError\") {\n        /**\n         * Pass the error directly through. Platforms are overloading this error beyond what the spec\n         * defines and we don't want to overwrite potentially useful error messages.\n         */ return new WebAuthnError({\n            message: error.message,\n            code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n            cause: error\n        });\n    } else if (error.name === \"NotSupportedError\") {\n        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param)=>param.type === \"public-key\");\n        if (validPubKeyCredParams.length === 0) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 10)\n            return new WebAuthnError({\n                message: 'No entry in pubKeyCredParams was of type \"public-key\"',\n                code: \"ERROR_MALFORMED_PUBKEYCREDPARAMS\",\n                cause: error\n            });\n        }\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 2)\n        return new WebAuthnError({\n            message: \"No available authenticator supported any of the specified pubKeyCredParams algorithms\",\n            code: \"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG\",\n            cause: error\n        });\n    } else if (error.name === \"SecurityError\") {\n        const effectiveDomain = window.location.hostname;\n        if (!(0,_webauthn__WEBPACK_IMPORTED_MODULE_0__.isValidDomain)(effectiveDomain)) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 7)\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: \"ERROR_INVALID_DOMAIN\",\n                cause: error\n            });\n        } else if (publicKey.rp.id !== effectiveDomain) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 8)\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rp.id}\" is invalid for this domain`,\n                code: \"ERROR_INVALID_RP_ID\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"TypeError\") {\n        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 5)\n            return new WebAuthnError({\n                message: \"User ID was not between 1 and 64 characters\",\n                code: \"ERROR_INVALID_USER_ID_LENGTH\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"UnknownError\") {\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 1)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 8)\n        return new WebAuthnError({\n            message: \"The authenticator was unable to process the specified options, or could not create a new credential\",\n            code: \"ERROR_AUTHENTICATOR_GENERAL_ERROR\",\n            cause: error\n        });\n    }\n    return new WebAuthnError({\n        message: \"a Non-Webauthn related error has occurred\",\n        code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n        cause: error\n    });\n}\n/**\n * Attempt to intuit _why_ an error was raised after calling `navigator.credentials.get()`.\n * Maps browser errors to specific WebAuthn error codes for better debugging.\n * @param {Object} params - Error identification parameters\n * @param {Error} params.error - The error thrown by the browser\n * @param {CredentialRequestOptions} params.options - The options passed to credentials.get()\n * @returns {WebAuthnError} A WebAuthnError with a specific error code\n * @see {@link https://w3c.github.io/webauthn/#sctn-getAssertion W3C WebAuthn Spec - Get Assertion}\n */ function identifyAuthenticationError({ error, options }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error(\"options was missing required publicKey property\");\n    }\n    if (error.name === \"AbortError\") {\n        if (options.signal instanceof AbortSignal) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 16)\n            return new WebAuthnError({\n                message: \"Authentication ceremony was sent an abort signal\",\n                code: \"ERROR_CEREMONY_ABORTED\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"NotAllowedError\") {\n        /**\n         * Pass the error directly through. Platforms are overloading this error beyond what the spec\n         * defines and we don't want to overwrite potentially useful error messages.\n         */ return new WebAuthnError({\n            message: error.message,\n            code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n            cause: error\n        });\n    } else if (error.name === \"SecurityError\") {\n        const effectiveDomain = window.location.hostname;\n        if (!(0,_webauthn__WEBPACK_IMPORTED_MODULE_0__.isValidDomain)(effectiveDomain)) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-discover-from-external-source (Step 5)\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: \"ERROR_INVALID_DOMAIN\",\n                cause: error\n            });\n        } else if (publicKey.rpId !== effectiveDomain) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-discover-from-external-source (Step 6)\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rpId}\" is invalid for this domain`,\n                code: \"ERROR_INVALID_RP_ID\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"UnknownError\") {\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion (Step 1)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion (Step 12)\n        return new WebAuthnError({\n            message: \"The authenticator was unable to process the specified options, or could not create a new assertion signature\",\n            code: \"ERROR_AUTHENTICATOR_GENERAL_ERROR\",\n            cause: error\n        });\n    }\n    return new WebAuthnError({\n        message: \"a Non-Webauthn related error has occurred\",\n        code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n        cause: error\n    });\n} //# sourceMappingURL=webauthn.errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3dlYmF1dGhuLmVycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSxvREFBb0QsR0FDVDtBQUMzQzs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNNLE1BQU1DLHNCQUFzQkM7SUFDL0JDLFlBQVksRUFBRUMsT0FBTyxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFHLENBQUU7UUFDekMsSUFBSUM7UUFDSixpRUFBaUU7UUFDakUsS0FBSyxDQUFDSixTQUFTO1lBQUVFO1FBQU07UUFDdkIsSUFBSSxDQUFDRyxpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUNGLElBQUksR0FBRyxDQUFDQyxLQUFLRCxTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJQSxPQUFRRCxpQkFBaUJKLFFBQVFJLE1BQU1DLElBQUksR0FBR0csU0FBUyxNQUFPLFFBQVFGLE9BQU8sS0FBSyxJQUFJQSxLQUFLO1FBQ2hKLElBQUksQ0FBQ0gsSUFBSSxHQUFHQTtJQUNoQjtBQUNKO0FBQ0E7OztDQUdDLEdBQ00sTUFBTU0sNkJBQTZCVjtJQUN0Q0UsWUFBWUMsT0FBTyxFQUFFUSxhQUFhLENBQUU7UUFDaEMsS0FBSyxDQUFDO1lBQ0ZQLE1BQU07WUFDTkMsT0FBT007WUFDUFI7UUFDSjtRQUNBLElBQUksQ0FBQ0csSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDSyxhQUFhLEdBQUdBO0lBQ3pCO0FBQ0o7QUFDQTs7OztDQUlDLEdBQ00sU0FBU0MsZ0JBQWdCQyxLQUFLO0lBQ2pDLE9BQU8sT0FBT0EsVUFBVSxZQUFZQSxVQUFVLFFBQVEsdUJBQXVCQTtBQUNqRjtBQUNBOzs7Ozs7OztDQVFDLEdBQ00sU0FBU0MsMEJBQTBCLEVBQUVELEtBQUssRUFBRUUsT0FBTyxFQUFHO0lBQ3pELElBQUlSLElBQUlTLElBQUlDO0lBQ1osTUFBTSxFQUFFQyxTQUFTLEVBQUUsR0FBR0g7SUFDdEIsSUFBSSxDQUFDRyxXQUFXO1FBQ1osTUFBTWpCLE1BQU07SUFDaEI7SUFDQSxJQUFJWSxNQUFNUCxJQUFJLEtBQUssY0FBYztRQUM3QixJQUFJUyxRQUFRSSxNQUFNLFlBQVlDLGFBQWE7WUFDdkMsb0VBQW9FO1lBQ3BFLE9BQU8sSUFBSXBCLGNBQWM7Z0JBQ3JCRyxTQUFTO2dCQUNUQyxNQUFNO2dCQUNOQyxPQUFPUTtZQUNYO1FBQ0o7SUFDSixPQUNLLElBQUlBLE1BQU1QLElBQUksS0FBSyxtQkFBbUI7UUFDdkMsSUFBSSxDQUFDLENBQUNDLEtBQUtXLFVBQVVHLHNCQUFzQixNQUFNLFFBQVFkLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2Usa0JBQWtCLE1BQU0sTUFBTTtZQUMvRywrREFBK0Q7WUFDL0QsT0FBTyxJQUFJdEIsY0FBYztnQkFDckJHLFNBQVM7Z0JBQ1RDLE1BQU07Z0JBQ05DLE9BQU9RO1lBQ1g7UUFDSixPQUNLLElBQ0wsMkdBQTJHO1FBQzNHRSxRQUFRUSxTQUFTLEtBQUssaUJBQ2xCLENBQUMsQ0FBQ1AsS0FBS0UsVUFBVUcsc0JBQXNCLE1BQU0sUUFBUUwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHUSxnQkFBZ0IsTUFBTSxZQUFZO1lBQ25ILG9FQUFvRTtZQUNwRSxPQUFPLElBQUl4QixjQUFjO2dCQUNyQkcsU0FBUztnQkFDVEMsTUFBTTtnQkFDTkMsT0FBT1E7WUFDWDtRQUNKLE9BQ0ssSUFBSSxDQUFDLENBQUNJLEtBQUtDLFVBQVVHLHNCQUFzQixNQUFNLFFBQVFKLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR08sZ0JBQWdCLE1BQU0sWUFBWTtZQUN4SCwrREFBK0Q7WUFDL0QsT0FBTyxJQUFJeEIsY0FBYztnQkFDckJHLFNBQVM7Z0JBQ1RDLE1BQU07Z0JBQ05DLE9BQU9RO1lBQ1g7UUFDSjtJQUNKLE9BQ0ssSUFBSUEsTUFBTVAsSUFBSSxLQUFLLHFCQUFxQjtRQUN6QyxvRUFBb0U7UUFDcEUsK0RBQStEO1FBQy9ELE9BQU8sSUFBSU4sY0FBYztZQUNyQkcsU0FBUztZQUNUQyxNQUFNO1lBQ05DLE9BQU9RO1FBQ1g7SUFDSixPQUNLLElBQUlBLE1BQU1QLElBQUksS0FBSyxtQkFBbUI7UUFDdkM7OztTQUdDLEdBQ0QsT0FBTyxJQUFJTixjQUFjO1lBQ3JCRyxTQUFTVSxNQUFNVixPQUFPO1lBQ3RCQyxNQUFNO1lBQ05DLE9BQU9RO1FBQ1g7SUFDSixPQUNLLElBQUlBLE1BQU1QLElBQUksS0FBSyxxQkFBcUI7UUFDekMsTUFBTW1CLHdCQUF3QlAsVUFBVVEsZ0JBQWdCLENBQUNDLE1BQU0sQ0FBQyxDQUFDQyxRQUFVQSxNQUFNQyxJQUFJLEtBQUs7UUFDMUYsSUFBSUosc0JBQXNCSyxNQUFNLEtBQUssR0FBRztZQUNwQyxvRUFBb0U7WUFDcEUsT0FBTyxJQUFJOUIsY0FBYztnQkFDckJHLFNBQVM7Z0JBQ1RDLE1BQU07Z0JBQ05DLE9BQU9RO1lBQ1g7UUFDSjtRQUNBLCtEQUErRDtRQUMvRCxPQUFPLElBQUliLGNBQWM7WUFDckJHLFNBQVM7WUFDVEMsTUFBTTtZQUNOQyxPQUFPUTtRQUNYO0lBQ0osT0FDSyxJQUFJQSxNQUFNUCxJQUFJLEtBQUssaUJBQWlCO1FBQ3JDLE1BQU15QixrQkFBa0JDLE9BQU9DLFFBQVEsQ0FBQ0MsUUFBUTtRQUNoRCxJQUFJLENBQUNuQyx3REFBYUEsQ0FBQ2dDLGtCQUFrQjtZQUNqQyxtRUFBbUU7WUFDbkUsT0FBTyxJQUFJL0IsY0FBYztnQkFDckJHLFNBQVMsQ0FBQyxFQUFFNkIsT0FBT0MsUUFBUSxDQUFDQyxRQUFRLENBQUMscUJBQXFCLENBQUM7Z0JBQzNEOUIsTUFBTTtnQkFDTkMsT0FBT1E7WUFDWDtRQUNKLE9BQ0ssSUFBSUssVUFBVWlCLEVBQUUsQ0FBQ0MsRUFBRSxLQUFLTCxpQkFBaUI7WUFDMUMsbUVBQW1FO1lBQ25FLE9BQU8sSUFBSS9CLGNBQWM7Z0JBQ3JCRyxTQUFTLENBQUMsV0FBVyxFQUFFZSxVQUFVaUIsRUFBRSxDQUFDQyxFQUFFLENBQUMsNEJBQTRCLENBQUM7Z0JBQ3BFaEMsTUFBTTtnQkFDTkMsT0FBT1E7WUFDWDtRQUNKO0lBQ0osT0FDSyxJQUFJQSxNQUFNUCxJQUFJLEtBQUssYUFBYTtRQUNqQyxJQUFJWSxVQUFVbUIsSUFBSSxDQUFDRCxFQUFFLENBQUNFLFVBQVUsR0FBRyxLQUFLcEIsVUFBVW1CLElBQUksQ0FBQ0QsRUFBRSxDQUFDRSxVQUFVLEdBQUcsSUFBSTtZQUN2RSxtRUFBbUU7WUFDbkUsT0FBTyxJQUFJdEMsY0FBYztnQkFDckJHLFNBQVM7Z0JBQ1RDLE1BQU07Z0JBQ05DLE9BQU9RO1lBQ1g7UUFDSjtJQUNKLE9BQ0ssSUFBSUEsTUFBTVAsSUFBSSxLQUFLLGdCQUFnQjtRQUNwQywrREFBK0Q7UUFDL0QsK0RBQStEO1FBQy9ELE9BQU8sSUFBSU4sY0FBYztZQUNyQkcsU0FBUztZQUNUQyxNQUFNO1lBQ05DLE9BQU9RO1FBQ1g7SUFDSjtJQUNBLE9BQU8sSUFBSWIsY0FBYztRQUNyQkcsU0FBUztRQUNUQyxNQUFNO1FBQ05DLE9BQU9RO0lBQ1g7QUFDSjtBQUNBOzs7Ozs7OztDQVFDLEdBQ00sU0FBUzBCLDRCQUE0QixFQUFFMUIsS0FBSyxFQUFFRSxPQUFPLEVBQUc7SUFDM0QsTUFBTSxFQUFFRyxTQUFTLEVBQUUsR0FBR0g7SUFDdEIsSUFBSSxDQUFDRyxXQUFXO1FBQ1osTUFBTWpCLE1BQU07SUFDaEI7SUFDQSxJQUFJWSxNQUFNUCxJQUFJLEtBQUssY0FBYztRQUM3QixJQUFJUyxRQUFRSSxNQUFNLFlBQVlDLGFBQWE7WUFDdkMsb0VBQW9FO1lBQ3BFLE9BQU8sSUFBSXBCLGNBQWM7Z0JBQ3JCRyxTQUFTO2dCQUNUQyxNQUFNO2dCQUNOQyxPQUFPUTtZQUNYO1FBQ0o7SUFDSixPQUNLLElBQUlBLE1BQU1QLElBQUksS0FBSyxtQkFBbUI7UUFDdkM7OztTQUdDLEdBQ0QsT0FBTyxJQUFJTixjQUFjO1lBQ3JCRyxTQUFTVSxNQUFNVixPQUFPO1lBQ3RCQyxNQUFNO1lBQ05DLE9BQU9RO1FBQ1g7SUFDSixPQUNLLElBQUlBLE1BQU1QLElBQUksS0FBSyxpQkFBaUI7UUFDckMsTUFBTXlCLGtCQUFrQkMsT0FBT0MsUUFBUSxDQUFDQyxRQUFRO1FBQ2hELElBQUksQ0FBQ25DLHdEQUFhQSxDQUFDZ0Msa0JBQWtCO1lBQ2pDLGdGQUFnRjtZQUNoRixPQUFPLElBQUkvQixjQUFjO2dCQUNyQkcsU0FBUyxDQUFDLEVBQUU2QixPQUFPQyxRQUFRLENBQUNDLFFBQVEsQ0FBQyxxQkFBcUIsQ0FBQztnQkFDM0Q5QixNQUFNO2dCQUNOQyxPQUFPUTtZQUNYO1FBQ0osT0FDSyxJQUFJSyxVQUFVc0IsSUFBSSxLQUFLVCxpQkFBaUI7WUFDekMsZ0ZBQWdGO1lBQ2hGLE9BQU8sSUFBSS9CLGNBQWM7Z0JBQ3JCRyxTQUFTLENBQUMsV0FBVyxFQUFFZSxVQUFVc0IsSUFBSSxDQUFDLDRCQUE0QixDQUFDO2dCQUNuRXBDLE1BQU07Z0JBQ05DLE9BQU9RO1lBQ1g7UUFDSjtJQUNKLE9BQ0ssSUFBSUEsTUFBTVAsSUFBSSxLQUFLLGdCQUFnQjtRQUNwQyxtRUFBbUU7UUFDbkUsb0VBQW9FO1FBQ3BFLE9BQU8sSUFBSU4sY0FBYztZQUNyQkcsU0FBUztZQUNUQyxNQUFNO1lBQ05DLE9BQU9RO1FBQ1g7SUFDSjtJQUNBLE9BQU8sSUFBSWIsY0FBYztRQUNyQkcsU0FBUztRQUNUQyxNQUFNO1FBQ05DLE9BQU9RO0lBQ1g7QUFDSixFQUNBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FuY2hvci13b3JrZmxvd3MvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3dlYmF1dGhuLmVycm9ycy5qcz9iOTVjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudCAqL1xuaW1wb3J0IHsgaXNWYWxpZERvbWFpbiB9IGZyb20gJy4vd2ViYXV0aG4nO1xuLyoqXG4gKiBBIGN1c3RvbSBFcnJvciB1c2VkIHRvIHJldHVybiBhIG1vcmUgbnVhbmNlZCBlcnJvciBkZXRhaWxpbmcgX3doeV8gb25lIG9mIHRoZSBlaWdodCBkb2N1bWVudGVkXG4gKiBlcnJvcnMgaW4gdGhlIHNwZWMgd2FzIHJhaXNlZCBhZnRlciBjYWxsaW5nIGBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuY3JlYXRlKClgIG9yXG4gKiBgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmdldCgpYDpcbiAqXG4gKiAtIGBBYm9ydEVycm9yYFxuICogLSBgQ29uc3RyYWludEVycm9yYFxuICogLSBgSW52YWxpZFN0YXRlRXJyb3JgXG4gKiAtIGBOb3RBbGxvd2VkRXJyb3JgXG4gKiAtIGBOb3RTdXBwb3J0ZWRFcnJvcmBcbiAqIC0gYFNlY3VyaXR5RXJyb3JgXG4gKiAtIGBUeXBlRXJyb3JgXG4gKiAtIGBVbmtub3duRXJyb3JgXG4gKlxuICogRXJyb3IgbWVzc2FnZXMgd2VyZSBkZXRlcm1pbmVkIHRocm91Z2ggaW52ZXN0aWdhdGlvbiBvZiB0aGUgc3BlYyB0byBkZXRlcm1pbmUgdW5kZXIgd2hpY2hcbiAqIHNjZW5hcmlvcyBhIGdpdmVuIGVycm9yIHdvdWxkIGJlIHJhaXNlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFdlYkF1dGhuRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBtZXNzYWdlLCBjb2RlLCBjYXVzZSwgbmFtZSwgfSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIEB0cy1pZ25vcmU6IGhlbHAgUm9sbHVwIHVuZGVyc3RhbmQgdGhhdCBgY2F1c2VgIGlzIG9rYXkgdG8gc2V0XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIHsgY2F1c2UgfSk7XG4gICAgICAgIHRoaXMuX19pc1dlYkF1dGhuRXJyb3IgPSB0cnVlO1xuICAgICAgICB0aGlzLm5hbWUgPSAoX2EgPSBuYW1lICE9PSBudWxsICYmIG5hbWUgIT09IHZvaWQgMCA/IG5hbWUgOiAoY2F1c2UgaW5zdGFuY2VvZiBFcnJvciA/IGNhdXNlLm5hbWUgOiB1bmRlZmluZWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnVW5rbm93biBFcnJvcic7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxufVxuLyoqXG4gKiBFcnJvciBjbGFzcyBmb3IgdW5rbm93biBXZWJBdXRobiBlcnJvcnMuXG4gKiBXcmFwcyB1bmV4cGVjdGVkIGVycm9ycyB0aGF0IGRvbid0IG1hdGNoIGtub3duIFdlYkF1dGhuIGVycm9yIGNvbmRpdGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJBdXRoblVua25vd25FcnJvciBleHRlbmRzIFdlYkF1dGhuRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgY29kZTogJ0VSUk9SX1BBU1NUSFJPVUdIX1NFRV9DQVVTRV9QUk9QRVJUWScsXG4gICAgICAgICAgICBjYXVzZTogb3JpZ2luYWxFcnJvcixcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2ViQXV0aG5Vbmtub3duRXJyb3InO1xuICAgICAgICB0aGlzLm9yaWdpbmFsRXJyb3IgPSBvcmlnaW5hbEVycm9yO1xuICAgIH1cbn1cbi8qKlxuICogVHlwZSBndWFyZCB0byBjaGVjayBpZiBhbiBlcnJvciBpcyBhIFdlYkF1dGhuRXJyb3IuXG4gKiBAcGFyYW0ge3Vua25vd259IGVycm9yIC0gVGhlIGVycm9yIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXJyb3IgaXMgYSBXZWJBdXRobkVycm9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1dlYkF1dGhuRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPT0gbnVsbCAmJiAnX19pc1dlYkF1dGhuRXJyb3InIGluIGVycm9yO1xufVxuLyoqXG4gKiBBdHRlbXB0IHRvIGludHVpdCBfd2h5XyBhbiBlcnJvciB3YXMgcmFpc2VkIGFmdGVyIGNhbGxpbmcgYG5hdmlnYXRvci5jcmVkZW50aWFscy5jcmVhdGUoKWAuXG4gKiBNYXBzIGJyb3dzZXIgZXJyb3JzIHRvIHNwZWNpZmljIFdlYkF1dGhuIGVycm9yIGNvZGVzIGZvciBiZXR0ZXIgZGVidWdnaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIEVycm9yIGlkZW50aWZpY2F0aW9uIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7RXJyb3J9IHBhcmFtcy5lcnJvciAtIFRoZSBlcnJvciB0aHJvd24gYnkgdGhlIGJyb3dzZXJcbiAqIEBwYXJhbSB7Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc30gcGFyYW1zLm9wdGlvbnMgLSBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gY3JlZGVudGlhbHMuY3JlYXRlKClcbiAqIEByZXR1cm5zIHtXZWJBdXRobkVycm9yfSBBIFdlYkF1dGhuRXJyb3Igd2l0aCBhIHNwZWNpZmljIGVycm9yIGNvZGVcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1jcmVhdGVDcmVkZW50aWFsIFczQyBXZWJBdXRobiBTcGVjIC0gQ3JlYXRlIENyZWRlbnRpYWx9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGlmeVJlZ2lzdHJhdGlvbkVycm9yKHsgZXJyb3IsIG9wdGlvbnMsIH0pIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCB7IHB1YmxpY0tleSB9ID0gb3B0aW9ucztcbiAgICBpZiAoIXB1YmxpY0tleSkge1xuICAgICAgICB0aHJvdyBFcnJvcignb3B0aW9ucyB3YXMgbWlzc2luZyByZXF1aXJlZCBwdWJsaWNLZXkgcHJvcGVydHknKTtcbiAgICB9XG4gICAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICBpZiAob3B0aW9ucy5zaWduYWwgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tY3JlYXRlQ3JlZGVudGlhbCAoU3RlcCAxNilcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1JlZ2lzdHJhdGlvbiBjZXJlbW9ueSB3YXMgc2VudCBhbiBhYm9ydCBzaWduYWwnLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9DRVJFTU9OWV9BQk9SVEVEJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnQ29uc3RyYWludEVycm9yJykge1xuICAgICAgICBpZiAoKChfYSA9IHB1YmxpY0tleS5hdXRoZW50aWNhdG9yU2VsZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVxdWlyZVJlc2lkZW50S2V5KSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tb3AtbWFrZS1jcmVkIChTdGVwIDQpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdEaXNjb3ZlcmFibGUgY3JlZGVudGlhbHMgd2VyZSByZXF1aXJlZCBidXQgbm8gYXZhaWxhYmxlIGF1dGhlbnRpY2F0b3Igc3VwcG9ydGVkIGl0JyxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfQVVUSEVOVElDQVRPUl9NSVNTSU5HX0RJU0NPVkVSQUJMRV9DUkVERU5USUFMX1NVUFBPUlQnLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAvLyBAdHMtaWdub3JlOiBgbWVkaWF0aW9uYCBkb2Vzbid0IHlldCBleGlzdCBvbiBDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zIGJ1dCBpdCdzIHBvc3NpYmxlIGFzIG9mIFNlcHQgMjAyNFxuICAgICAgICBvcHRpb25zLm1lZGlhdGlvbiA9PT0gJ2NvbmRpdGlvbmFsJyAmJlxuICAgICAgICAgICAgKChfYiA9IHB1YmxpY0tleS5hdXRoZW50aWNhdG9yU2VsZWN0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudXNlclZlcmlmaWNhdGlvbikgPT09ICdyZXF1aXJlZCcpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1jcmVhdGVDcmVkZW50aWFsIChTdGVwIDIyLjQpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdVc2VyIHZlcmlmaWNhdGlvbiB3YXMgcmVxdWlyZWQgZHVyaW5nIGF1dG9tYXRpYyByZWdpc3RyYXRpb24gYnV0IGl0IGNvdWxkIG5vdCBiZSBwZXJmb3JtZWQnLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9BVVRPX1JFR0lTVEVSX1VTRVJfVkVSSUZJQ0FUSU9OX0ZBSUxVUkUnLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgoX2MgPSBwdWJsaWNLZXkuYXV0aGVudGljYXRvclNlbGVjdGlvbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVzZXJWZXJpZmljYXRpb24pID09PSAncmVxdWlyZWQnKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1vcC1tYWtlLWNyZWQgKFN0ZXAgNSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1VzZXIgdmVyaWZpY2F0aW9uIHdhcyByZXF1aXJlZCBidXQgbm8gYXZhaWxhYmxlIGF1dGhlbnRpY2F0b3Igc3VwcG9ydGVkIGl0JyxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfQVVUSEVOVElDQVRPUl9NSVNTSU5HX1VTRVJfVkVSSUZJQ0FUSU9OX1NVUFBPUlQnLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdJbnZhbGlkU3RhdGVFcnJvcicpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tY3JlYXRlQ3JlZGVudGlhbCAoU3RlcCAyMClcbiAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tb3AtbWFrZS1jcmVkIChTdGVwIDMpXG4gICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiAnVGhlIGF1dGhlbnRpY2F0b3Igd2FzIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCcsXG4gICAgICAgICAgICBjb2RlOiAnRVJST1JfQVVUSEVOVElDQVRPUl9QUkVWSU9VU0xZX1JFR0lTVEVSRUQnLFxuICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcicpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhc3MgdGhlIGVycm9yIGRpcmVjdGx5IHRocm91Z2guIFBsYXRmb3JtcyBhcmUgb3ZlcmxvYWRpbmcgdGhpcyBlcnJvciBiZXlvbmQgd2hhdCB0aGUgc3BlY1xuICAgICAgICAgKiBkZWZpbmVzIGFuZCB3ZSBkb24ndCB3YW50IHRvIG92ZXJ3cml0ZSBwb3RlbnRpYWxseSB1c2VmdWwgZXJyb3IgbWVzc2FnZXMuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9QQVNTVEhST1VHSF9TRUVfQ0FVU0VfUFJPUEVSVFknLFxuICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ05vdFN1cHBvcnRlZEVycm9yJykge1xuICAgICAgICBjb25zdCB2YWxpZFB1YktleUNyZWRQYXJhbXMgPSBwdWJsaWNLZXkucHViS2V5Q3JlZFBhcmFtcy5maWx0ZXIoKHBhcmFtKSA9PiBwYXJhbS50eXBlID09PSAncHVibGljLWtleScpO1xuICAgICAgICBpZiAodmFsaWRQdWJLZXlDcmVkUGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tY3JlYXRlQ3JlZGVudGlhbCAoU3RlcCAxMClcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ05vIGVudHJ5IGluIHB1YktleUNyZWRQYXJhbXMgd2FzIG9mIHR5cGUgXCJwdWJsaWMta2V5XCInLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9NQUxGT1JNRURfUFVCS0VZQ1JFRFBBUkFNUycsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tb3AtbWFrZS1jcmVkIChTdGVwIDIpXG4gICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiAnTm8gYXZhaWxhYmxlIGF1dGhlbnRpY2F0b3Igc3VwcG9ydGVkIGFueSBvZiB0aGUgc3BlY2lmaWVkIHB1YktleUNyZWRQYXJhbXMgYWxnb3JpdGhtcycsXG4gICAgICAgICAgICBjb2RlOiAnRVJST1JfQVVUSEVOVElDQVRPUl9OT19TVVBQT1JURURfUFVCS0VZQ1JFRFBBUkFNU19BTEcnLFxuICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ1NlY3VyaXR5RXJyb3InKSB7XG4gICAgICAgIGNvbnN0IGVmZmVjdGl2ZURvbWFpbiA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkRG9tYWluKGVmZmVjdGl2ZURvbWFpbikpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgKFN0ZXAgNylcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYCR7d2luZG93LmxvY2F0aW9uLmhvc3RuYW1lfSBpcyBhbiBpbnZhbGlkIGRvbWFpbmAsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VSUk9SX0lOVkFMSURfRE9NQUlOJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwdWJsaWNLZXkucnAuaWQgIT09IGVmZmVjdGl2ZURvbWFpbikge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tY3JlYXRlQ3JlZGVudGlhbCAoU3RlcCA4KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgVGhlIFJQIElEIFwiJHtwdWJsaWNLZXkucnAuaWR9XCIgaXMgaW52YWxpZCBmb3IgdGhpcyBkb21haW5gLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9JTlZBTElEX1JQX0lEJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnVHlwZUVycm9yJykge1xuICAgICAgICBpZiAocHVibGljS2V5LnVzZXIuaWQuYnl0ZUxlbmd0aCA8IDEgfHwgcHVibGljS2V5LnVzZXIuaWQuYnl0ZUxlbmd0aCA+IDY0KSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1jcmVhdGVDcmVkZW50aWFsIChTdGVwIDUpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdVc2VyIElEIHdhcyBub3QgYmV0d2VlbiAxIGFuZCA2NCBjaGFyYWN0ZXJzJyxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfSU5WQUxJRF9VU0VSX0lEX0xFTkdUSCcsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ1Vua25vd25FcnJvcicpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tb3AtbWFrZS1jcmVkIChTdGVwIDEpXG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLW9wLW1ha2UtY3JlZCAoU3RlcCA4KVxuICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogJ1RoZSBhdXRoZW50aWNhdG9yIHdhcyB1bmFibGUgdG8gcHJvY2VzcyB0aGUgc3BlY2lmaWVkIG9wdGlvbnMsIG9yIGNvdWxkIG5vdCBjcmVhdGUgYSBuZXcgY3JlZGVudGlhbCcsXG4gICAgICAgICAgICBjb2RlOiAnRVJST1JfQVVUSEVOVElDQVRPUl9HRU5FUkFMX0VSUk9SJyxcbiAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6ICdhIE5vbi1XZWJhdXRobiByZWxhdGVkIGVycm9yIGhhcyBvY2N1cnJlZCcsXG4gICAgICAgIGNvZGU6ICdFUlJPUl9QQVNTVEhST1VHSF9TRUVfQ0FVU0VfUFJPUEVSVFknLFxuICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgfSk7XG59XG4vKipcbiAqIEF0dGVtcHQgdG8gaW50dWl0IF93aHlfIGFuIGVycm9yIHdhcyByYWlzZWQgYWZ0ZXIgY2FsbGluZyBgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmdldCgpYC5cbiAqIE1hcHMgYnJvd3NlciBlcnJvcnMgdG8gc3BlY2lmaWMgV2ViQXV0aG4gZXJyb3IgY29kZXMgZm9yIGJldHRlciBkZWJ1Z2dpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gRXJyb3IgaWRlbnRpZmljYXRpb24gcGFyYW1ldGVyc1xuICogQHBhcmFtIHtFcnJvcn0gcGFyYW1zLmVycm9yIC0gVGhlIGVycm9yIHRocm93biBieSB0aGUgYnJvd3NlclxuICogQHBhcmFtIHtDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnN9IHBhcmFtcy5vcHRpb25zIC0gVGhlIG9wdGlvbnMgcGFzc2VkIHRvIGNyZWRlbnRpYWxzLmdldCgpXG4gKiBAcmV0dXJucyB7V2ViQXV0aG5FcnJvcn0gQSBXZWJBdXRobkVycm9yIHdpdGggYSBzcGVjaWZpYyBlcnJvciBjb2RlXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tZ2V0QXNzZXJ0aW9uIFczQyBXZWJBdXRobiBTcGVjIC0gR2V0IEFzc2VydGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aWZ5QXV0aGVudGljYXRpb25FcnJvcih7IGVycm9yLCBvcHRpb25zLCB9KSB7XG4gICAgY29uc3QgeyBwdWJsaWNLZXkgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFwdWJsaWNLZXkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ29wdGlvbnMgd2FzIG1pc3NpbmcgcmVxdWlyZWQgcHVibGljS2V5IHByb3BlcnR5Jyk7XG4gICAgfVxuICAgIGlmIChlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsIGluc3RhbmNlb2YgQWJvcnRTaWduYWwpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgKFN0ZXAgMTYpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdBdXRoZW50aWNhdGlvbiBjZXJlbW9ueSB3YXMgc2VudCBhbiBhYm9ydCBzaWduYWwnLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9DRVJFTU9OWV9BQk9SVEVEJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnTm90QWxsb3dlZEVycm9yJykge1xuICAgICAgICAvKipcbiAgICAgICAgICogUGFzcyB0aGUgZXJyb3IgZGlyZWN0bHkgdGhyb3VnaC4gUGxhdGZvcm1zIGFyZSBvdmVybG9hZGluZyB0aGlzIGVycm9yIGJleW9uZCB3aGF0IHRoZSBzcGVjXG4gICAgICAgICAqIGRlZmluZXMgYW5kIHdlIGRvbid0IHdhbnQgdG8gb3ZlcndyaXRlIHBvdGVudGlhbGx5IHVzZWZ1bCBlcnJvciBtZXNzYWdlcy5cbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgY29kZTogJ0VSUk9SX1BBU1NUSFJPVUdIX1NFRV9DQVVTRV9QUk9QRVJUWScsXG4gICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnU2VjdXJpdHlFcnJvcicpIHtcbiAgICAgICAgY29uc3QgZWZmZWN0aXZlRG9tYWluID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xuICAgICAgICBpZiAoIWlzVmFsaWREb21haW4oZWZmZWN0aXZlRG9tYWluKSkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tZGlzY292ZXItZnJvbS1leHRlcm5hbC1zb3VyY2UgKFN0ZXAgNSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYCR7d2luZG93LmxvY2F0aW9uLmhvc3RuYW1lfSBpcyBhbiBpbnZhbGlkIGRvbWFpbmAsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VSUk9SX0lOVkFMSURfRE9NQUlOJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwdWJsaWNLZXkucnBJZCAhPT0gZWZmZWN0aXZlRG9tYWluKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1kaXNjb3Zlci1mcm9tLWV4dGVybmFsLXNvdXJjZSAoU3RlcCA2KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgVGhlIFJQIElEIFwiJHtwdWJsaWNLZXkucnBJZH1cIiBpcyBpbnZhbGlkIGZvciB0aGlzIGRvbWFpbmAsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VSUk9SX0lOVkFMSURfUlBfSUQnLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdVbmtub3duRXJyb3InKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLW9wLWdldC1hc3NlcnRpb24gKFN0ZXAgMSlcbiAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tb3AtZ2V0LWFzc2VydGlvbiAoU3RlcCAxMilcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGUgYXV0aGVudGljYXRvciB3YXMgdW5hYmxlIHRvIHByb2Nlc3MgdGhlIHNwZWNpZmllZCBvcHRpb25zLCBvciBjb3VsZCBub3QgY3JlYXRlIGEgbmV3IGFzc2VydGlvbiBzaWduYXR1cmUnLFxuICAgICAgICAgICAgY29kZTogJ0VSUk9SX0FVVEhFTlRJQ0FUT1JfR0VORVJBTF9FUlJPUicsXG4gICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiAnYSBOb24tV2ViYXV0aG4gcmVsYXRlZCBlcnJvciBoYXMgb2NjdXJyZWQnLFxuICAgICAgICBjb2RlOiAnRVJST1JfUEFTU1RIUk9VR0hfU0VFX0NBVVNFX1BST1BFUlRZJyxcbiAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViYXV0aG4uZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6WyJpc1ZhbGlkRG9tYWluIiwiV2ViQXV0aG5FcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwiY29kZSIsImNhdXNlIiwibmFtZSIsIl9hIiwiX19pc1dlYkF1dGhuRXJyb3IiLCJ1bmRlZmluZWQiLCJXZWJBdXRoblVua25vd25FcnJvciIsIm9yaWdpbmFsRXJyb3IiLCJpc1dlYkF1dGhuRXJyb3IiLCJlcnJvciIsImlkZW50aWZ5UmVnaXN0cmF0aW9uRXJyb3IiLCJvcHRpb25zIiwiX2IiLCJfYyIsInB1YmxpY0tleSIsInNpZ25hbCIsIkFib3J0U2lnbmFsIiwiYXV0aGVudGljYXRvclNlbGVjdGlvbiIsInJlcXVpcmVSZXNpZGVudEtleSIsIm1lZGlhdGlvbiIsInVzZXJWZXJpZmljYXRpb24iLCJ2YWxpZFB1YktleUNyZWRQYXJhbXMiLCJwdWJLZXlDcmVkUGFyYW1zIiwiZmlsdGVyIiwicGFyYW0iLCJ0eXBlIiwibGVuZ3RoIiwiZWZmZWN0aXZlRG9tYWluIiwid2luZG93IiwibG9jYXRpb24iLCJob3N0bmFtZSIsInJwIiwiaWQiLCJ1c2VyIiwiYnl0ZUxlbmd0aCIsImlkZW50aWZ5QXV0aGVudGljYXRpb25FcnJvciIsInJwSWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/webauthn.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_CREATION_OPTIONS: () => (/* binding */ DEFAULT_CREATION_OPTIONS),\n/* harmony export */   DEFAULT_REQUEST_OPTIONS: () => (/* binding */ DEFAULT_REQUEST_OPTIONS),\n/* harmony export */   WebAuthnAbortService: () => (/* binding */ WebAuthnAbortService),\n/* harmony export */   WebAuthnApi: () => (/* binding */ WebAuthnApi),\n/* harmony export */   WebAuthnError: () => (/* reexport safe */ _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.WebAuthnError),\n/* harmony export */   createCredential: () => (/* binding */ createCredential),\n/* harmony export */   deserializeCredentialCreationOptions: () => (/* binding */ deserializeCredentialCreationOptions),\n/* harmony export */   deserializeCredentialRequestOptions: () => (/* binding */ deserializeCredentialRequestOptions),\n/* harmony export */   getCredential: () => (/* binding */ getCredential),\n/* harmony export */   identifyAuthenticationError: () => (/* reexport safe */ _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.identifyAuthenticationError),\n/* harmony export */   identifyRegistrationError: () => (/* reexport safe */ _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.identifyRegistrationError),\n/* harmony export */   isValidDomain: () => (/* binding */ isValidDomain),\n/* harmony export */   isWebAuthnError: () => (/* reexport safe */ _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.isWebAuthnError),\n/* harmony export */   mergeCredentialCreationOptions: () => (/* binding */ mergeCredentialCreationOptions),\n/* harmony export */   mergeCredentialRequestOptions: () => (/* binding */ mergeCredentialRequestOptions),\n/* harmony export */   serializeCredentialCreationResponse: () => (/* binding */ serializeCredentialCreationResponse),\n/* harmony export */   serializeCredentialRequestResponse: () => (/* binding */ serializeCredentialRequestResponse),\n/* harmony export */   webAuthnAbortService: () => (/* binding */ webAuthnAbortService)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _base64url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base64url */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/base64url.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./webauthn.errors */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.errors.js\");\n\n\n\n\n\n\n/**\n * WebAuthn abort service to manage ceremony cancellation.\n * Ensures only one WebAuthn ceremony is active at a time to prevent \"operation already in progress\" errors.\n *\n * @experimental This class is experimental and may change in future releases\n * @see {@link https://w3c.github.io/webauthn/#sctn-automation-webdriver-capability W3C WebAuthn Spec - Aborting Ceremonies}\n */ class WebAuthnAbortService {\n    /**\n     * Create an abort signal for a new WebAuthn operation.\n     * Automatically cancels any existing operation.\n     *\n     * @returns {AbortSignal} Signal to pass to navigator.credentials.create() or .get()\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal MDN - AbortSignal}\n     */ createNewAbortSignal() {\n        // Abort any existing calls to navigator.credentials.create() or navigator.credentials.get()\n        if (this.controller) {\n            const abortError = new Error(\"Cancelling existing WebAuthn API call for new one\");\n            abortError.name = \"AbortError\";\n            this.controller.abort(abortError);\n        }\n        const newController = new AbortController();\n        this.controller = newController;\n        return newController.signal;\n    }\n    /**\n     * Manually cancel the current WebAuthn operation.\n     * Useful for cleaning up when user cancels or navigates away.\n     *\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort MDN - AbortController.abort}\n     */ cancelCeremony() {\n        if (this.controller) {\n            const abortError = new Error(\"Manually cancelling existing WebAuthn API call\");\n            abortError.name = \"AbortError\";\n            this.controller.abort(abortError);\n            this.controller = undefined;\n        }\n    }\n}\n/**\n * Singleton instance to ensure only one WebAuthn ceremony is active at a time.\n * This prevents \"operation already in progress\" errors when retrying WebAuthn operations.\n *\n * @experimental This instance is experimental and may change in future releases\n */ const webAuthnAbortService = new WebAuthnAbortService();\n/**\n * Convert base64url encoded strings in WebAuthn credential creation options to ArrayBuffers\n * as required by the WebAuthn browser API.\n * Supports both native WebAuthn Level 3 parseCreationOptionsFromJSON and manual fallback.\n *\n * @param {ServerCredentialCreationOptions} options - JSON options from server with base64url encoded fields\n * @returns {PublicKeyCredentialCreationOptionsFuture} Options ready for navigator.credentials.create()\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseCreationOptionsFromJSON W3C WebAuthn Spec - parseCreationOptionsFromJSON}\n */ function deserializeCredentialCreationOptions(options) {\n    if (!options) {\n        throw new Error(\"Credential creation options are required\");\n    }\n    // Check if the native parseCreationOptionsFromJSON method is available\n    if (typeof PublicKeyCredential !== \"undefined\" && \"parseCreationOptionsFromJSON\" in PublicKeyCredential && typeof PublicKeyCredential.parseCreationOptionsFromJSON === \"function\") {\n        // Use the native WebAuthn Level 3 method\n        return PublicKeyCredential.parseCreationOptionsFromJSON(/** we assert the options here as typescript still doesn't know about future webauthn types */ options);\n    }\n    // Fallback to manual parsing for browsers that don't support the native method\n    // Destructure to separate fields that need transformation\n    const { challenge: challengeStr, user: userOpts, excludeCredentials } = options, restOptions = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(options, [\n        \"challenge\",\n        \"user\",\n        \"excludeCredentials\"\n    ]);\n    // Convert challenge from base64url to ArrayBuffer\n    const challenge = (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.base64UrlToUint8Array)(challengeStr).buffer;\n    // Convert user.id from base64url to ArrayBuffer\n    const user = Object.assign(Object.assign({}, userOpts), {\n        id: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.base64UrlToUint8Array)(userOpts.id).buffer\n    });\n    // Build the result object\n    const result = Object.assign(Object.assign({}, restOptions), {\n        challenge,\n        user\n    });\n    // Only add excludeCredentials if it exists\n    if (excludeCredentials && excludeCredentials.length > 0) {\n        result.excludeCredentials = new Array(excludeCredentials.length);\n        for(let i = 0; i < excludeCredentials.length; i++){\n            const cred = excludeCredentials[i];\n            result.excludeCredentials[i] = Object.assign(Object.assign({}, cred), {\n                id: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.base64UrlToUint8Array)(cred.id).buffer,\n                type: cred.type || \"public-key\",\n                // Cast transports to handle future transport types like \"cable\"\n                transports: cred.transports\n            });\n        }\n    }\n    return result;\n}\n/**\n * Convert base64url encoded strings in WebAuthn credential request options to ArrayBuffers\n * as required by the WebAuthn browser API.\n * Supports both native WebAuthn Level 3 parseRequestOptionsFromJSON and manual fallback.\n *\n * @param {ServerCredentialRequestOptions} options - JSON options from server with base64url encoded fields\n * @returns {PublicKeyCredentialRequestOptionsFuture} Options ready for navigator.credentials.get()\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseRequestOptionsFromJSON W3C WebAuthn Spec - parseRequestOptionsFromJSON}\n */ function deserializeCredentialRequestOptions(options) {\n    if (!options) {\n        throw new Error(\"Credential request options are required\");\n    }\n    // Check if the native parseRequestOptionsFromJSON method is available\n    if (typeof PublicKeyCredential !== \"undefined\" && \"parseRequestOptionsFromJSON\" in PublicKeyCredential && typeof PublicKeyCredential.parseRequestOptionsFromJSON === \"function\") {\n        // Use the native WebAuthn Level 3 method\n        return PublicKeyCredential.parseRequestOptionsFromJSON(options);\n    }\n    // Fallback to manual parsing for browsers that don't support the native method\n    // Destructure to separate fields that need transformation\n    const { challenge: challengeStr, allowCredentials } = options, restOptions = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(options, [\n        \"challenge\",\n        \"allowCredentials\"\n    ]);\n    // Convert challenge from base64url to ArrayBuffer\n    const challenge = (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.base64UrlToUint8Array)(challengeStr).buffer;\n    // Build the result object\n    const result = Object.assign(Object.assign({}, restOptions), {\n        challenge\n    });\n    // Only add allowCredentials if it exists\n    if (allowCredentials && allowCredentials.length > 0) {\n        result.allowCredentials = new Array(allowCredentials.length);\n        for(let i = 0; i < allowCredentials.length; i++){\n            const cred = allowCredentials[i];\n            result.allowCredentials[i] = Object.assign(Object.assign({}, cred), {\n                id: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.base64UrlToUint8Array)(cred.id).buffer,\n                type: cred.type || \"public-key\",\n                // Cast transports to handle future transport types like \"cable\"\n                transports: cred.transports\n            });\n        }\n    }\n    return result;\n}\n/**\n * Convert a registration/enrollment credential response to server format.\n * Serializes binary fields to base64url for JSON transmission.\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\n *\n * @param {RegistrationCredential} credential - Credential from navigator.credentials.create()\n * @returns {RegistrationResponseJSON} JSON-serializable credential for server\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\n */ function serializeCredentialCreationResponse(credential) {\n    var _a;\n    // Check if the credential instance has the toJSON method\n    if (\"toJSON\" in credential && typeof credential.toJSON === \"function\") {\n        // Use the native WebAuthn Level 3 method\n        return credential.toJSON();\n    }\n    const credentialWithAttachment = credential;\n    return {\n        id: credential.id,\n        rawId: credential.id,\n        response: {\n            attestationObject: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(credential.response.attestationObject)),\n            clientDataJSON: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(credential.response.clientDataJSON))\n        },\n        type: \"public-key\",\n        clientExtensionResults: credential.getClientExtensionResults(),\n        // Convert null to undefined and cast to AuthenticatorAttachment type\n        authenticatorAttachment: (_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined\n    };\n}\n/**\n * Convert an authentication/verification credential response to server format.\n * Serializes binary fields to base64url for JSON transmission.\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\n *\n * @param {AuthenticationCredential} credential - Credential from navigator.credentials.get()\n * @returns {AuthenticationResponseJSON} JSON-serializable credential for server\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\n */ function serializeCredentialRequestResponse(credential) {\n    var _a;\n    // Check if the credential instance has the toJSON method\n    if (\"toJSON\" in credential && typeof credential.toJSON === \"function\") {\n        // Use the native WebAuthn Level 3 method\n        return credential.toJSON();\n    }\n    // Fallback to manual conversion for browsers that don't support toJSON\n    // Access authenticatorAttachment via type assertion to handle TypeScript version differences\n    // @simplewebauthn/types includes this property but base TypeScript 4.7.4 doesn't\n    const credentialWithAttachment = credential;\n    const clientExtensionResults = credential.getClientExtensionResults();\n    const assertionResponse = credential.response;\n    return {\n        id: credential.id,\n        rawId: credential.id,\n        response: {\n            authenticatorData: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(assertionResponse.authenticatorData)),\n            clientDataJSON: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(assertionResponse.clientDataJSON)),\n            signature: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(assertionResponse.signature)),\n            userHandle: assertionResponse.userHandle ? (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(assertionResponse.userHandle)) : undefined\n        },\n        type: \"public-key\",\n        clientExtensionResults,\n        // Convert null to undefined and cast to AuthenticatorAttachment type\n        authenticatorAttachment: (_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined\n    };\n}\n/**\n * A simple test to determine if a hostname is a properly-formatted domain name.\n * Considers localhost valid for development environments.\n *\n * A \"valid domain\" is defined here: https://url.spec.whatwg.org/#valid-domain\n *\n * Regex sourced from here:\n * https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch08s15.html\n *\n * @param {string} hostname - The hostname to validate\n * @returns {boolean} True if valid domain or localhost\n * @see {@link https://url.spec.whatwg.org/#valid-domain WHATWG URL Spec - Valid Domain}\n */ function isValidDomain(hostname) {\n    return(// Consider localhost valid as well since it's okay wrt Secure Contexts\n    hostname === \"localhost\" || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n/**\n * Determine if the browser is capable of WebAuthn.\n * Checks for necessary Web APIs: PublicKeyCredential and Credential Management.\n *\n * @returns {boolean} True if browser supports WebAuthn\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential#browser_compatibility MDN - PublicKeyCredential Browser Compatibility}\n */ function browserSupportsWebAuthn() {\n    var _a, _b;\n    return !!((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isBrowser)() && \"PublicKeyCredential\" in window && window.PublicKeyCredential && \"credentials\" in navigator && typeof ((_a = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _a === void 0 ? void 0 : _a.create) === \"function\" && typeof ((_b = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _b === void 0 ? void 0 : _b.get) === \"function\");\n}\n/**\n * Create a WebAuthn credential using the browser's credentials API.\n * Wraps navigator.credentials.create() with error handling.\n *\n * @param {CredentialCreationOptions} options - Options including publicKey parameters\n * @returns {Promise<RequestResult<RegistrationCredential, WebAuthnError>>} Created credential or error\n * @see {@link https://w3c.github.io/webauthn/#sctn-createCredential W3C WebAuthn Spec - Create Credential}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/create MDN - credentials.create}\n */ async function createCredential(options) {\n    try {\n        const response = await navigator.credentials.create(/** we assert the type here until typescript types are updated */ options);\n        if (!response) {\n            return {\n                data: null,\n                error: new _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.WebAuthnUnknownError(\"Empty credential response\", response)\n            };\n        }\n        if (!(response instanceof PublicKeyCredential)) {\n            return {\n                data: null,\n                error: new _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.WebAuthnUnknownError(\"Browser returned unexpected credential type\", response)\n            };\n        }\n        return {\n            data: response,\n            error: null\n        };\n    } catch (err) {\n        return {\n            data: null,\n            error: (0,_webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.identifyRegistrationError)({\n                error: err,\n                options\n            })\n        };\n    }\n}\n/**\n * Get a WebAuthn credential using the browser's credentials API.\n * Wraps navigator.credentials.get() with error handling.\n *\n * @param {CredentialRequestOptions} options - Options including publicKey parameters\n * @returns {Promise<RequestResult<AuthenticationCredential, WebAuthnError>>} Retrieved credential or error\n * @see {@link https://w3c.github.io/webauthn/#sctn-getAssertion W3C WebAuthn Spec - Get Assertion}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get MDN - credentials.get}\n */ async function getCredential(options) {\n    try {\n        const response = await navigator.credentials.get(/** we assert the type here until typescript types are updated */ options);\n        if (!response) {\n            return {\n                data: null,\n                error: new _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.WebAuthnUnknownError(\"Empty credential response\", response)\n            };\n        }\n        if (!(response instanceof PublicKeyCredential)) {\n            return {\n                data: null,\n                error: new _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.WebAuthnUnknownError(\"Browser returned unexpected credential type\", response)\n            };\n        }\n        return {\n            data: response,\n            error: null\n        };\n    } catch (err) {\n        return {\n            data: null,\n            error: (0,_webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.identifyAuthenticationError)({\n                error: err,\n                options\n            })\n        };\n    }\n}\nconst DEFAULT_CREATION_OPTIONS = {\n    hints: [\n        \"security-key\"\n    ],\n    authenticatorSelection: {\n        authenticatorAttachment: \"cross-platform\",\n        requireResidentKey: false,\n        /** set to preferred because older yubikeys don't have PIN/Biometric */ userVerification: \"preferred\",\n        residentKey: \"discouraged\"\n    },\n    attestation: \"direct\"\n};\nconst DEFAULT_REQUEST_OPTIONS = {\n    /** set to preferred because older yubikeys don't have PIN/Biometric */ userVerification: \"preferred\",\n    hints: [\n        \"security-key\"\n    ],\n    attestation: \"direct\"\n};\nfunction deepMerge(...sources) {\n    const isObject = (val)=>val !== null && typeof val === \"object\" && !Array.isArray(val);\n    const isArrayBufferLike = (val)=>val instanceof ArrayBuffer || ArrayBuffer.isView(val);\n    const result = {};\n    for (const source of sources){\n        if (!source) continue;\n        for(const key in source){\n            const value = source[key];\n            if (value === undefined) continue;\n            if (Array.isArray(value)) {\n                // preserve array reference, including unions like AuthenticatorTransport[]\n                result[key] = value;\n            } else if (isArrayBufferLike(value)) {\n                result[key] = value;\n            } else if (isObject(value)) {\n                const existing = result[key];\n                if (isObject(existing)) {\n                    result[key] = deepMerge(existing, value);\n                } else {\n                    result[key] = deepMerge(value);\n                }\n            } else {\n                result[key] = value;\n            }\n        }\n    }\n    return result;\n}\n/**\n * Merges WebAuthn credential creation options with overrides.\n * Sets sensible defaults for authenticator selection and extensions.\n *\n * @param {PublicKeyCredentialCreationOptionsFuture} baseOptions - The base options from the server\n * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Optional overrides to apply\n * @param {string} friendlyName - Optional friendly name for the credential\n * @returns {PublicKeyCredentialCreationOptionsFuture} Merged credential creation options\n * @see {@link https://w3c.github.io/webauthn/#dictdef-authenticatorselectioncriteria W3C WebAuthn Spec - AuthenticatorSelectionCriteria}\n */ function mergeCredentialCreationOptions(baseOptions, overrides) {\n    return deepMerge(DEFAULT_CREATION_OPTIONS, baseOptions, overrides || {});\n}\n/**\n * Merges WebAuthn credential request options with overrides.\n * Sets sensible defaults for user verification and hints.\n *\n * @param {PublicKeyCredentialRequestOptionsFuture} baseOptions - The base options from the server\n * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Optional overrides to apply\n * @returns {PublicKeyCredentialRequestOptionsFuture} Merged credential request options\n * @see {@link https://w3c.github.io/webauthn/#dictdef-publickeycredentialrequestoptions W3C WebAuthn Spec - PublicKeyCredentialRequestOptions}\n */ function mergeCredentialRequestOptions(baseOptions, overrides) {\n    return deepMerge(DEFAULT_REQUEST_OPTIONS, baseOptions, overrides || {});\n}\n/**\n * WebAuthn API wrapper for Supabase Auth.\n * Provides methods for enrolling, challenging, verifying, authenticating, and registering WebAuthn credentials.\n *\n * @experimental This API is experimental and may change in future releases\n * @see {@link https://w3c.github.io/webauthn/ W3C WebAuthn Specification}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API MDN - Web Authentication API}\n */ class WebAuthnApi {\n    constructor(client){\n        this.client = client;\n        // Bind all methods so they can be destructured\n        this.enroll = this._enroll.bind(this);\n        this.challenge = this._challenge.bind(this);\n        this.verify = this._verify.bind(this);\n        this.authenticate = this._authenticate.bind(this);\n        this.register = this._register.bind(this);\n    }\n    /**\n     * Enroll a new WebAuthn factor.\n     * Creates an unverified WebAuthn factor that must be verified with a credential.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Omit<MFAEnrollWebauthnParams, 'factorType'>} params - Enrollment parameters (friendlyName required)\n     * @returns {Promise<AuthMFAEnrollWebauthnResponse>} Enrolled factor details or error\n     * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registering a New Credential}\n     */ async _enroll(params) {\n        return this.client.mfa.enroll(Object.assign(Object.assign({}, params), {\n            factorType: \"webauthn\"\n        }));\n    }\n    /**\n     * Challenge for WebAuthn credential creation or authentication.\n     * Combines server challenge with browser credential operations.\n     * Handles both registration (create) and authentication (request) flows.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {MFAChallengeWebauthnParams & { friendlyName?: string; signal?: AbortSignal }} params - Challenge parameters including factorId\n     * @param {Object} overrides - Allows you to override the parameters passed to navigator.credentials\n     * @param {PublicKeyCredentialCreationOptionsFuture} overrides.create - Override options for credential creation\n     * @param {PublicKeyCredentialRequestOptionsFuture} overrides.request - Override options for credential request\n     * @returns {Promise<RequestResult>} Challenge response with credential or error\n     * @see {@link https://w3c.github.io/webauthn/#sctn-credential-creation W3C WebAuthn Spec - Credential Creation}\n     * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying Assertion}\n     */ async _challenge({ factorId, webauthn, friendlyName, signal }, overrides) {\n        var _a;\n        try {\n            // Get challenge from server using the client's MFA methods\n            const { data: challengeResponse, error: challengeError } = await this.client.mfa.challenge({\n                factorId,\n                webauthn\n            });\n            if (!challengeResponse) {\n                return {\n                    data: null,\n                    error: challengeError\n                };\n            }\n            const abortSignal = signal !== null && signal !== void 0 ? signal : webAuthnAbortService.createNewAbortSignal();\n            /** webauthn will fail if either of the name/displayname are blank */ if (challengeResponse.webauthn.type === \"create\") {\n                const { user } = challengeResponse.webauthn.credential_options.publicKey;\n                if (!user.name) {\n                    // Preserve original format: use friendlyName if provided, otherwise fetch fallback\n                    // This maintains backward compatibility with the ${user.id}:${name} format\n                    const nameToUse = friendlyName;\n                    if (!nameToUse) {\n                        // Only fetch user data if friendlyName is not provided (bug fix for null friendlyName)\n                        const currentUser = await this.client.getUser();\n                        const userData = currentUser.data.user;\n                        const fallbackName = ((_a = userData === null || userData === void 0 ? void 0 : userData.user_metadata) === null || _a === void 0 ? void 0 : _a.name) || (userData === null || userData === void 0 ? void 0 : userData.email) || (userData === null || userData === void 0 ? void 0 : userData.id) || \"User\";\n                        user.name = `${user.id}:${fallbackName}`;\n                    } else {\n                        user.name = `${user.id}:${nameToUse}`;\n                    }\n                }\n                if (!user.displayName) {\n                    user.displayName = user.name;\n                }\n            }\n            switch(challengeResponse.webauthn.type){\n                case \"create\":\n                    {\n                        const options = mergeCredentialCreationOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.create);\n                        const { data, error } = await createCredential({\n                            publicKey: options,\n                            signal: abortSignal\n                        });\n                        if (data) {\n                            return {\n                                data: {\n                                    factorId,\n                                    challengeId: challengeResponse.id,\n                                    webauthn: {\n                                        type: challengeResponse.webauthn.type,\n                                        credential_response: data\n                                    }\n                                },\n                                error: null\n                            };\n                        }\n                        return {\n                            data: null,\n                            error\n                        };\n                    }\n                case \"request\":\n                    {\n                        const options = mergeCredentialRequestOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.request);\n                        const { data, error } = await getCredential(Object.assign(Object.assign({}, challengeResponse.webauthn.credential_options), {\n                            publicKey: options,\n                            signal: abortSignal\n                        }));\n                        if (data) {\n                            return {\n                                data: {\n                                    factorId,\n                                    challengeId: challengeResponse.id,\n                                    webauthn: {\n                                        type: challengeResponse.webauthn.type,\n                                        credential_response: data\n                                    }\n                                },\n                                error: null\n                            };\n                        }\n                        return {\n                            data: null,\n                            error\n                        };\n                    }\n            }\n        } catch (error) {\n            if ((0,_errors__WEBPACK_IMPORTED_MODULE_1__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            return {\n                data: null,\n                error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthUnknownError(\"Unexpected error in challenge\", error)\n            };\n        }\n    }\n    /**\n     * Verify a WebAuthn credential with the server.\n     * Completes the WebAuthn ceremony by sending the credential to the server for verification.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Object} params - Verification parameters\n     * @param {string} params.challengeId - ID of the challenge being verified\n     * @param {string} params.factorId - ID of the WebAuthn factor\n     * @param {MFAVerifyWebauthnParams<T>['webauthn']} params.webauthn - WebAuthn credential response\n     * @returns {Promise<AuthMFAVerifyResponse>} Verification result with session or error\n     * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying an Authentication Assertion}\n     * */ async _verify({ challengeId, factorId, webauthn }) {\n        return this.client.mfa.verify({\n            factorId,\n            challengeId,\n            webauthn: webauthn\n        });\n    }\n    /**\n     * Complete WebAuthn authentication flow.\n     * Performs challenge and verification in a single operation for existing credentials.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Object} params - Authentication parameters\n     * @param {string} params.factorId - ID of the WebAuthn factor to authenticate with\n     * @param {Object} params.webauthn - WebAuthn configuration\n     * @param {string} params.webauthn.rpId - Relying Party ID (defaults to current hostname)\n     * @param {string[]} params.webauthn.rpOrigins - Allowed origins (defaults to current origin)\n     * @param {AbortSignal} params.webauthn.signal - Optional abort signal\n     * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Override options for navigator.credentials.get\n     * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Authentication result\n     * @see {@link https://w3c.github.io/webauthn/#sctn-authentication W3C WebAuthn Spec - Authentication Ceremony}\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions MDN - PublicKeyCredentialRequestOptions}\n     */ async _authenticate({ factorId, webauthn: { rpId =  false ? 0 : undefined, rpOrigins =  false ? 0 : undefined, signal } = {} }, overrides) {\n        if (!rpId) {\n            return {\n                data: null,\n                error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthError(\"rpId is required for WebAuthn authentication\")\n            };\n        }\n        try {\n            if (!browserSupportsWebAuthn()) {\n                return {\n                    data: null,\n                    error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthUnknownError(\"Browser does not support WebAuthn\", null)\n                };\n            }\n            // Get challenge and credential\n            const { data: challengeResponse, error: challengeError } = await this.challenge({\n                factorId,\n                webauthn: {\n                    rpId,\n                    rpOrigins\n                },\n                signal\n            }, {\n                request: overrides\n            });\n            if (!challengeResponse) {\n                return {\n                    data: null,\n                    error: challengeError\n                };\n            }\n            const { webauthn } = challengeResponse;\n            // Verify credential\n            return this._verify({\n                factorId,\n                challengeId: challengeResponse.challengeId,\n                webauthn: {\n                    type: webauthn.type,\n                    rpId,\n                    rpOrigins,\n                    credential_response: webauthn.credential_response\n                }\n            });\n        } catch (error) {\n            if ((0,_errors__WEBPACK_IMPORTED_MODULE_1__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            return {\n                data: null,\n                error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthUnknownError(\"Unexpected error in authenticate\", error)\n            };\n        }\n    }\n    /**\n     * Complete WebAuthn registration flow.\n     * Performs enrollment, challenge, and verification in a single operation for new credentials.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Object} params - Registration parameters\n     * @param {string} params.friendlyName - User-friendly name for the credential\n     * @param {string} params.rpId - Relying Party ID (defaults to current hostname)\n     * @param {string[]} params.rpOrigins - Allowed origins (defaults to current origin)\n     * @param {AbortSignal} params.signal - Optional abort signal\n     * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Override options for navigator.credentials.create\n     * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Registration result\n     * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registration Ceremony}\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions MDN - PublicKeyCredentialCreationOptions}\n     */ async _register({ friendlyName, webauthn: { rpId =  false ? 0 : undefined, rpOrigins =  false ? 0 : undefined, signal } = {} }, overrides) {\n        if (!rpId) {\n            return {\n                data: null,\n                error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthError(\"rpId is required for WebAuthn registration\")\n            };\n        }\n        try {\n            if (!browserSupportsWebAuthn()) {\n                return {\n                    data: null,\n                    error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthUnknownError(\"Browser does not support WebAuthn\", null)\n                };\n            }\n            // Enroll factor\n            const { data: factor, error: enrollError } = await this._enroll({\n                friendlyName\n            });\n            if (!factor) {\n                await this.client.mfa.listFactors().then((factors)=>{\n                    var _a;\n                    return (_a = factors.data) === null || _a === void 0 ? void 0 : _a.all.find((v)=>v.factor_type === \"webauthn\" && v.friendly_name === friendlyName && v.status !== \"unverified\");\n                }).then((factor)=>factor ? this.client.mfa.unenroll({\n                        factorId: factor === null || factor === void 0 ? void 0 : factor.id\n                    }) : void 0);\n                return {\n                    data: null,\n                    error: enrollError\n                };\n            }\n            // Get challenge and create credential\n            const { data: challengeResponse, error: challengeError } = await this._challenge({\n                factorId: factor.id,\n                friendlyName: factor.friendly_name,\n                webauthn: {\n                    rpId,\n                    rpOrigins\n                },\n                signal\n            }, {\n                create: overrides\n            });\n            if (!challengeResponse) {\n                return {\n                    data: null,\n                    error: challengeError\n                };\n            }\n            return this._verify({\n                factorId: factor.id,\n                challengeId: challengeResponse.challengeId,\n                webauthn: {\n                    rpId,\n                    rpOrigins,\n                    type: challengeResponse.webauthn.type,\n                    credential_response: challengeResponse.webauthn.credential_response\n                }\n            });\n        } catch (error) {\n            if ((0,_errors__WEBPACK_IMPORTED_MODULE_1__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            return {\n                data: null,\n                error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthUnknownError(\"Unexpected error in register\", error)\n            };\n        }\n    }\n} //# sourceMappingURL=webauthn.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3dlYmF1dGhuLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ3VDO0FBQ0Y7QUFDOUI7QUFDNEc7QUFDaEQ7QUFDbEc7Ozs7OztDQU1DLEdBQ00sTUFBTVk7SUFDVDs7Ozs7O0tBTUMsR0FDREMsdUJBQXVCO1FBQ25CLDRGQUE0RjtRQUM1RixJQUFJLElBQUksQ0FBQ0MsVUFBVSxFQUFFO1lBQ2pCLE1BQU1DLGFBQWEsSUFBSUMsTUFBTTtZQUM3QkQsV0FBV0UsSUFBSSxHQUFHO1lBQ2xCLElBQUksQ0FBQ0gsVUFBVSxDQUFDSSxLQUFLLENBQUNIO1FBQzFCO1FBQ0EsTUFBTUksZ0JBQWdCLElBQUlDO1FBQzFCLElBQUksQ0FBQ04sVUFBVSxHQUFHSztRQUNsQixPQUFPQSxjQUFjRSxNQUFNO0lBQy9CO0lBQ0E7Ozs7O0tBS0MsR0FDREMsaUJBQWlCO1FBQ2IsSUFBSSxJQUFJLENBQUNSLFVBQVUsRUFBRTtZQUNqQixNQUFNQyxhQUFhLElBQUlDLE1BQU07WUFDN0JELFdBQVdFLElBQUksR0FBRztZQUNsQixJQUFJLENBQUNILFVBQVUsQ0FBQ0ksS0FBSyxDQUFDSDtZQUN0QixJQUFJLENBQUNELFVBQVUsR0FBR1M7UUFDdEI7SUFDSjtBQUNKO0FBQ0E7Ozs7O0NBS0MsR0FDTSxNQUFNQyx1QkFBdUIsSUFBSVosdUJBQXVCO0FBQy9EOzs7Ozs7OztDQVFDLEdBQ00sU0FBU2EscUNBQXFDQyxPQUFPO0lBQ3hELElBQUksQ0FBQ0EsU0FBUztRQUNWLE1BQU0sSUFBSVYsTUFBTTtJQUNwQjtJQUNBLHVFQUF1RTtJQUN2RSxJQUFJLE9BQU9XLHdCQUF3QixlQUMvQixrQ0FBa0NBLHVCQUNsQyxPQUFPQSxvQkFDRkMsNEJBQTRCLEtBQUssWUFBWTtRQUNsRCx5Q0FBeUM7UUFDekMsT0FBT0Qsb0JBQW9CQyw0QkFBNEIsQ0FDdkQs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QWdDMkU7WUFDaEU7UUFDSjtJQUNKO0FBQ0osRUFDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmNob3Itd29ya2Zsb3dzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2xpYi93ZWJhdXRobi5qcz84OGNjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fcmVzdCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgYmFzZTY0VXJsVG9VaW50OEFycmF5LCBieXRlc1RvQmFzZTY0VVJMIH0gZnJvbSAnLi9iYXNlNjR1cmwnO1xuaW1wb3J0IHsgQXV0aEVycm9yLCBBdXRoVW5rbm93bkVycm9yLCBpc0F1dGhFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IGlzQnJvd3NlciB9IGZyb20gJy4vaGVscGVycyc7XG5pbXBvcnQgeyBpZGVudGlmeUF1dGhlbnRpY2F0aW9uRXJyb3IsIGlkZW50aWZ5UmVnaXN0cmF0aW9uRXJyb3IsIGlzV2ViQXV0aG5FcnJvciwgV2ViQXV0aG5FcnJvciwgV2ViQXV0aG5Vbmtub3duRXJyb3IsIH0gZnJvbSAnLi93ZWJhdXRobi5lcnJvcnMnO1xuZXhwb3J0IHsgV2ViQXV0aG5FcnJvciwgaXNXZWJBdXRobkVycm9yLCBpZGVudGlmeVJlZ2lzdHJhdGlvbkVycm9yLCBpZGVudGlmeUF1dGhlbnRpY2F0aW9uRXJyb3IgfTtcbi8qKlxuICogV2ViQXV0aG4gYWJvcnQgc2VydmljZSB0byBtYW5hZ2UgY2VyZW1vbnkgY2FuY2VsbGF0aW9uLlxuICogRW5zdXJlcyBvbmx5IG9uZSBXZWJBdXRobiBjZXJlbW9ueSBpcyBhY3RpdmUgYXQgYSB0aW1lIHRvIHByZXZlbnQgXCJvcGVyYXRpb24gYWxyZWFkeSBpbiBwcm9ncmVzc1wiIGVycm9ycy5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgY2xhc3MgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSByZWxlYXNlc1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLWF1dG9tYXRpb24td2ViZHJpdmVyLWNhcGFiaWxpdHkgVzNDIFdlYkF1dGhuIFNwZWMgLSBBYm9ydGluZyBDZXJlbW9uaWVzfVxuICovXG5leHBvcnQgY2xhc3MgV2ViQXV0aG5BYm9ydFNlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBhYm9ydCBzaWduYWwgZm9yIGEgbmV3IFdlYkF1dGhuIG9wZXJhdGlvbi5cbiAgICAgKiBBdXRvbWF0aWNhbGx5IGNhbmNlbHMgYW55IGV4aXN0aW5nIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBYm9ydFNpZ25hbH0gU2lnbmFsIHRvIHBhc3MgdG8gbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZSgpIG9yIC5nZXQoKVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BYm9ydFNpZ25hbCBNRE4gLSBBYm9ydFNpZ25hbH1cbiAgICAgKi9cbiAgICBjcmVhdGVOZXdBYm9ydFNpZ25hbCgpIHtcbiAgICAgICAgLy8gQWJvcnQgYW55IGV4aXN0aW5nIGNhbGxzIHRvIG5hdmlnYXRvci5jcmVkZW50aWFscy5jcmVhdGUoKSBvciBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuZ2V0KClcbiAgICAgICAgaWYgKHRoaXMuY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29uc3QgYWJvcnRFcnJvciA9IG5ldyBFcnJvcignQ2FuY2VsbGluZyBleGlzdGluZyBXZWJBdXRobiBBUEkgY2FsbCBmb3IgbmV3IG9uZScpO1xuICAgICAgICAgICAgYWJvcnRFcnJvci5uYW1lID0gJ0Fib3J0RXJyb3InO1xuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyLmFib3J0KGFib3J0RXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0NvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIHRoaXMuY29udHJvbGxlciA9IG5ld0NvbnRyb2xsZXI7XG4gICAgICAgIHJldHVybiBuZXdDb250cm9sbGVyLnNpZ25hbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFudWFsbHkgY2FuY2VsIHRoZSBjdXJyZW50IFdlYkF1dGhuIG9wZXJhdGlvbi5cbiAgICAgKiBVc2VmdWwgZm9yIGNsZWFuaW5nIHVwIHdoZW4gdXNlciBjYW5jZWxzIG9yIG5hdmlnYXRlcyBhd2F5LlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Fib3J0Q29udHJvbGxlci9hYm9ydCBNRE4gLSBBYm9ydENvbnRyb2xsZXIuYWJvcnR9XG4gICAgICovXG4gICAgY2FuY2VsQ2VyZW1vbnkoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoJ01hbnVhbGx5IGNhbmNlbGxpbmcgZXhpc3RpbmcgV2ViQXV0aG4gQVBJIGNhbGwnKTtcbiAgICAgICAgICAgIGFib3J0RXJyb3IubmFtZSA9ICdBYm9ydEVycm9yJztcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlci5hYm9ydChhYm9ydEVycm9yKTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogU2luZ2xldG9uIGluc3RhbmNlIHRvIGVuc3VyZSBvbmx5IG9uZSBXZWJBdXRobiBjZXJlbW9ueSBpcyBhY3RpdmUgYXQgYSB0aW1lLlxuICogVGhpcyBwcmV2ZW50cyBcIm9wZXJhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzXCIgZXJyb3JzIHdoZW4gcmV0cnlpbmcgV2ViQXV0aG4gb3BlcmF0aW9ucy5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgaW5zdGFuY2UgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSByZWxlYXNlc1xuICovXG5leHBvcnQgY29uc3Qgd2ViQXV0aG5BYm9ydFNlcnZpY2UgPSBuZXcgV2ViQXV0aG5BYm9ydFNlcnZpY2UoKTtcbi8qKlxuICogQ29udmVydCBiYXNlNjR1cmwgZW5jb2RlZCBzdHJpbmdzIGluIFdlYkF1dGhuIGNyZWRlbnRpYWwgY3JlYXRpb24gb3B0aW9ucyB0byBBcnJheUJ1ZmZlcnNcbiAqIGFzIHJlcXVpcmVkIGJ5IHRoZSBXZWJBdXRobiBicm93c2VyIEFQSS5cbiAqIFN1cHBvcnRzIGJvdGggbmF0aXZlIFdlYkF1dGhuIExldmVsIDMgcGFyc2VDcmVhdGlvbk9wdGlvbnNGcm9tSlNPTiBhbmQgbWFudWFsIGZhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7U2VydmVyQ3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc30gb3B0aW9ucyAtIEpTT04gb3B0aW9ucyBmcm9tIHNlcnZlciB3aXRoIGJhc2U2NHVybCBlbmNvZGVkIGZpZWxkc1xuICogQHJldHVybnMge1B1YmxpY0tleUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnNGdXR1cmV9IE9wdGlvbnMgcmVhZHkgZm9yIG5hdmlnYXRvci5jcmVkZW50aWFscy5jcmVhdGUoKVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLXBhcnNlQ3JlYXRpb25PcHRpb25zRnJvbUpTT04gVzNDIFdlYkF1dGhuIFNwZWMgLSBwYXJzZUNyZWF0aW9uT3B0aW9uc0Zyb21KU09OfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzZXJpYWxpemVDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDcmVkZW50aWFsIGNyZWF0aW9uIG9wdGlvbnMgYXJlIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIHRoZSBuYXRpdmUgcGFyc2VDcmVhdGlvbk9wdGlvbnNGcm9tSlNPTiBtZXRob2QgaXMgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiBQdWJsaWNLZXlDcmVkZW50aWFsICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAncGFyc2VDcmVhdGlvbk9wdGlvbnNGcm9tSlNPTicgaW4gUHVibGljS2V5Q3JlZGVudGlhbCAmJlxuICAgICAgICB0eXBlb2YgUHVibGljS2V5Q3JlZGVudGlhbFxuICAgICAgICAgICAgLnBhcnNlQ3JlYXRpb25PcHRpb25zRnJvbUpTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVXNlIHRoZSBuYXRpdmUgV2ViQXV0aG4gTGV2ZWwgMyBtZXRob2RcbiAgICAgICAgcmV0dXJuIFB1YmxpY0tleUNyZWRlbnRpYWwucGFyc2VDcmVhdGlvbk9wdGlvbnNGcm9tSlNPTihcbiAgICAgICAgLyoqIHdlIGFzc2VydCB0aGUgb3B0aW9ucyBoZXJlIGFzIHR5cGVzY3JpcHQgc3RpbGwgZG9lc24ndCBrbm93IGFib3V0IGZ1dHVyZSB3ZWJhdXRobiB0eXBlcyAqL1xuICAgICAgICBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgdG8gbWFudWFsIHBhcnNpbmcgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCB0aGUgbmF0aXZlIG1ldGhvZFxuICAgIC8vIERlc3RydWN0dXJlIHRvIHNlcGFyYXRlIGZpZWxkcyB0aGF0IG5lZWQgdHJhbnNmb3JtYXRpb25cbiAgICBjb25zdCB7IGNoYWxsZW5nZTogY2hhbGxlbmdlU3RyLCB1c2VyOiB1c2VyT3B0cywgZXhjbHVkZUNyZWRlbnRpYWxzIH0gPSBvcHRpb25zLCByZXN0T3B0aW9ucyA9IF9fcmVzdChvcHRpb25zXG4gICAgLy8gQ29udmVydCBjaGFsbGVuZ2UgZnJvbSBiYXNlNjR1cmwgdG8gQXJyYXlCdWZmZXJcbiAgICAsIFtcImNoYWxsZW5nZVwiLCBcInVzZXJcIiwgXCJleGNsdWRlQ3JlZGVudGlhbHNcIl0pO1xuICAgIC8vIENvbnZlcnQgY2hhbGxlbmdlIGZyb20gYmFzZTY0dXJsIHRvIEFycmF5QnVmZmVyXG4gICAgY29uc3QgY2hhbGxlbmdlID0gYmFzZTY0VXJsVG9VaW50OEFycmF5KGNoYWxsZW5nZVN0cikuYnVmZmVyO1xuICAgIC8vIENvbnZlcnQgdXNlci5pZCBmcm9tIGJhc2U2NHVybCB0byBBcnJheUJ1ZmZlclxuICAgIGNvbnN0IHVzZXIgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHVzZXJPcHRzKSwgeyBpZDogYmFzZTY0VXJsVG9VaW50OEFycmF5KHVzZXJPcHRzLmlkKS5idWZmZXIgfSk7XG4gICAgLy8gQnVpbGQgdGhlIHJlc3VsdCBvYmplY3RcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3RPcHRpb25zKSwgeyBjaGFsbGVuZ2UsXG4gICAgICAgIHVzZXIgfSk7XG4gICAgLy8gT25seSBhZGQgZXhjbHVkZUNyZWRlbnRpYWxzIGlmIGl0IGV4aXN0c1xuICAgIGlmIChleGNsdWRlQ3JlZGVudGlhbHMgJiYgZXhjbHVkZUNyZWRlbnRpYWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzdWx0LmV4Y2x1ZGVDcmVkZW50aWFscyA9IG5ldyBBcnJheShleGNsdWRlQ3JlZGVudGlhbHMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleGNsdWRlQ3JlZGVudGlhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNyZWQgPSBleGNsdWRlQ3JlZGVudGlhbHNbaV07XG4gICAgICAgICAgICByZXN1bHQuZXhjbHVkZUNyZWRlbnRpYWxzW2ldID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjcmVkKSwgeyBpZDogYmFzZTY0VXJsVG9VaW50OEFycmF5KGNyZWQuaWQpLmJ1ZmZlciwgdHlwZTogY3JlZC50eXBlIHx8ICdwdWJsaWMta2V5JywgXG4gICAgICAgICAgICAgICAgLy8gQ2FzdCB0cmFuc3BvcnRzIHRvIGhhbmRsZSBmdXR1cmUgdHJhbnNwb3J0IHR5cGVzIGxpa2UgXCJjYWJsZVwiXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0czogY3JlZC50cmFuc3BvcnRzIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIENvbnZlcnQgYmFzZTY0dXJsIGVuY29kZWQgc3RyaW5ncyBpbiBXZWJBdXRobiBjcmVkZW50aWFsIHJlcXVlc3Qgb3B0aW9ucyB0byBBcnJheUJ1ZmZlcnNcbiAqIGFzIHJlcXVpcmVkIGJ5IHRoZSBXZWJBdXRobiBicm93c2VyIEFQSS5cbiAqIFN1cHBvcnRzIGJvdGggbmF0aXZlIFdlYkF1dGhuIExldmVsIDMgcGFyc2VSZXF1ZXN0T3B0aW9uc0Zyb21KU09OIGFuZCBtYW51YWwgZmFsbGJhY2suXG4gKlxuICogQHBhcmFtIHtTZXJ2ZXJDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnN9IG9wdGlvbnMgLSBKU09OIG9wdGlvbnMgZnJvbSBzZXJ2ZXIgd2l0aCBiYXNlNjR1cmwgZW5jb2RlZCBmaWVsZHNcbiAqIEByZXR1cm5zIHtQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnNGdXR1cmV9IE9wdGlvbnMgcmVhZHkgZm9yIG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXQoKVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLXBhcnNlUmVxdWVzdE9wdGlvbnNGcm9tSlNPTiBXM0MgV2ViQXV0aG4gU3BlYyAtIHBhcnNlUmVxdWVzdE9wdGlvbnNGcm9tSlNPTn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc2VyaWFsaXplQ3JlZGVudGlhbFJlcXVlc3RPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDcmVkZW50aWFsIHJlcXVlc3Qgb3B0aW9ucyBhcmUgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlIG5hdGl2ZSBwYXJzZVJlcXVlc3RPcHRpb25zRnJvbUpTT04gbWV0aG9kIGlzIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2YgUHVibGljS2V5Q3JlZGVudGlhbCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgJ3BhcnNlUmVxdWVzdE9wdGlvbnNGcm9tSlNPTicgaW4gUHVibGljS2V5Q3JlZGVudGlhbCAmJlxuICAgICAgICB0eXBlb2YgUHVibGljS2V5Q3JlZGVudGlhbFxuICAgICAgICAgICAgLnBhcnNlUmVxdWVzdE9wdGlvbnNGcm9tSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBVc2UgdGhlIG5hdGl2ZSBXZWJBdXRobiBMZXZlbCAzIG1ldGhvZFxuICAgICAgICByZXR1cm4gUHVibGljS2V5Q3JlZGVudGlhbC5wYXJzZVJlcXVlc3RPcHRpb25zRnJvbUpTT04ob3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrIHRvIG1hbnVhbCBwYXJzaW5nIGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdGhlIG5hdGl2ZSBtZXRob2RcbiAgICAvLyBEZXN0cnVjdHVyZSB0byBzZXBhcmF0ZSBmaWVsZHMgdGhhdCBuZWVkIHRyYW5zZm9ybWF0aW9uXG4gICAgY29uc3QgeyBjaGFsbGVuZ2U6IGNoYWxsZW5nZVN0ciwgYWxsb3dDcmVkZW50aWFscyB9ID0gb3B0aW9ucywgcmVzdE9wdGlvbnMgPSBfX3Jlc3Qob3B0aW9uc1xuICAgIC8vIENvbnZlcnQgY2hhbGxlbmdlIGZyb20gYmFzZTY0dXJsIHRvIEFycmF5QnVmZmVyXG4gICAgLCBbXCJjaGFsbGVuZ2VcIiwgXCJhbGxvd0NyZWRlbnRpYWxzXCJdKTtcbiAgICAvLyBDb252ZXJ0IGNoYWxsZW5nZSBmcm9tIGJhc2U2NHVybCB0byBBcnJheUJ1ZmZlclxuICAgIGNvbnN0IGNoYWxsZW5nZSA9IGJhc2U2NFVybFRvVWludDhBcnJheShjaGFsbGVuZ2VTdHIpLmJ1ZmZlcjtcbiAgICAvLyBCdWlsZCB0aGUgcmVzdWx0IG9iamVjdFxuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdE9wdGlvbnMpLCB7IGNoYWxsZW5nZSB9KTtcbiAgICAvLyBPbmx5IGFkZCBhbGxvd0NyZWRlbnRpYWxzIGlmIGl0IGV4aXN0c1xuICAgIGlmIChhbGxvd0NyZWRlbnRpYWxzICYmIGFsbG93Q3JlZGVudGlhbHMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXN1bHQuYWxsb3dDcmVkZW50aWFscyA9IG5ldyBBcnJheShhbGxvd0NyZWRlbnRpYWxzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsb3dDcmVkZW50aWFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY3JlZCA9IGFsbG93Q3JlZGVudGlhbHNbaV07XG4gICAgICAgICAgICByZXN1bHQuYWxsb3dDcmVkZW50aWFsc1tpXSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY3JlZCksIHsgaWQ6IGJhc2U2NFVybFRvVWludDhBcnJheShjcmVkLmlkKS5idWZmZXIsIHR5cGU6IGNyZWQudHlwZSB8fCAncHVibGljLWtleScsIFxuICAgICAgICAgICAgICAgIC8vIENhc3QgdHJhbnNwb3J0cyB0byBoYW5kbGUgZnV0dXJlIHRyYW5zcG9ydCB0eXBlcyBsaWtlIFwiY2FibGVcIlxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydHM6IGNyZWQudHJhbnNwb3J0cyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgcmVnaXN0cmF0aW9uL2Vucm9sbG1lbnQgY3JlZGVudGlhbCByZXNwb25zZSB0byBzZXJ2ZXIgZm9ybWF0LlxuICogU2VyaWFsaXplcyBiaW5hcnkgZmllbGRzIHRvIGJhc2U2NHVybCBmb3IgSlNPTiB0cmFuc21pc3Npb24uXG4gKiBTdXBwb3J0cyBib3RoIG5hdGl2ZSBXZWJBdXRobiBMZXZlbCAzIHRvSlNPTiBhbmQgbWFudWFsIGZhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7UmVnaXN0cmF0aW9uQ3JlZGVudGlhbH0gY3JlZGVudGlhbCAtIENyZWRlbnRpYWwgZnJvbSBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuY3JlYXRlKClcbiAqIEByZXR1cm5zIHtSZWdpc3RyYXRpb25SZXNwb25zZUpTT059IEpTT04tc2VyaWFsaXphYmxlIGNyZWRlbnRpYWwgZm9yIHNlcnZlclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNkb20tcHVibGlja2V5Y3JlZGVudGlhbC10b2pzb24gVzNDIFdlYkF1dGhuIFNwZWMgLSB0b0pTT059XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVDcmVkZW50aWFsQ3JlYXRpb25SZXNwb25zZShjcmVkZW50aWFsKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIENoZWNrIGlmIHRoZSBjcmVkZW50aWFsIGluc3RhbmNlIGhhcyB0aGUgdG9KU09OIG1ldGhvZFxuICAgIGlmICgndG9KU09OJyBpbiBjcmVkZW50aWFsICYmIHR5cGVvZiBjcmVkZW50aWFsLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBVc2UgdGhlIG5hdGl2ZSBXZWJBdXRobiBMZXZlbCAzIG1ldGhvZFxuICAgICAgICByZXR1cm4gY3JlZGVudGlhbC50b0pTT04oKTtcbiAgICB9XG4gICAgY29uc3QgY3JlZGVudGlhbFdpdGhBdHRhY2htZW50ID0gY3JlZGVudGlhbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogY3JlZGVudGlhbC5pZCxcbiAgICAgICAgcmF3SWQ6IGNyZWRlbnRpYWwuaWQsXG4gICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICBhdHRlc3RhdGlvbk9iamVjdDogYnl0ZXNUb0Jhc2U2NFVSTChuZXcgVWludDhBcnJheShjcmVkZW50aWFsLnJlc3BvbnNlLmF0dGVzdGF0aW9uT2JqZWN0KSksXG4gICAgICAgICAgICBjbGllbnREYXRhSlNPTjogYnl0ZXNUb0Jhc2U2NFVSTChuZXcgVWludDhBcnJheShjcmVkZW50aWFsLnJlc3BvbnNlLmNsaWVudERhdGFKU09OKSksXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6ICdwdWJsaWMta2V5JyxcbiAgICAgICAgY2xpZW50RXh0ZW5zaW9uUmVzdWx0czogY3JlZGVudGlhbC5nZXRDbGllbnRFeHRlbnNpb25SZXN1bHRzKCksXG4gICAgICAgIC8vIENvbnZlcnQgbnVsbCB0byB1bmRlZmluZWQgYW5kIGNhc3QgdG8gQXV0aGVudGljYXRvckF0dGFjaG1lbnQgdHlwZVxuICAgICAgICBhdXRoZW50aWNhdG9yQXR0YWNobWVudDogKChfYSA9IGNyZWRlbnRpYWxXaXRoQXR0YWNobWVudC5hdXRoZW50aWNhdG9yQXR0YWNobWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkKSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0IGFuIGF1dGhlbnRpY2F0aW9uL3ZlcmlmaWNhdGlvbiBjcmVkZW50aWFsIHJlc3BvbnNlIHRvIHNlcnZlciBmb3JtYXQuXG4gKiBTZXJpYWxpemVzIGJpbmFyeSBmaWVsZHMgdG8gYmFzZTY0dXJsIGZvciBKU09OIHRyYW5zbWlzc2lvbi5cbiAqIFN1cHBvcnRzIGJvdGggbmF0aXZlIFdlYkF1dGhuIExldmVsIDMgdG9KU09OIGFuZCBtYW51YWwgZmFsbGJhY2suXG4gKlxuICogQHBhcmFtIHtBdXRoZW50aWNhdGlvbkNyZWRlbnRpYWx9IGNyZWRlbnRpYWwgLSBDcmVkZW50aWFsIGZyb20gbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmdldCgpXG4gKiBAcmV0dXJucyB7QXV0aGVudGljYXRpb25SZXNwb25zZUpTT059IEpTT04tc2VyaWFsaXphYmxlIGNyZWRlbnRpYWwgZm9yIHNlcnZlclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNkb20tcHVibGlja2V5Y3JlZGVudGlhbC10b2pzb24gVzNDIFdlYkF1dGhuIFNwZWMgLSB0b0pTT059XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVDcmVkZW50aWFsUmVxdWVzdFJlc3BvbnNlKGNyZWRlbnRpYWwpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGNyZWRlbnRpYWwgaW5zdGFuY2UgaGFzIHRoZSB0b0pTT04gbWV0aG9kXG4gICAgaWYgKCd0b0pTT04nIGluIGNyZWRlbnRpYWwgJiYgdHlwZW9mIGNyZWRlbnRpYWwudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgbmF0aXZlIFdlYkF1dGhuIExldmVsIDMgbWV0aG9kXG4gICAgICAgIHJldHVybiBjcmVkZW50aWFsLnRvSlNPTigpO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayB0byBtYW51YWwgY29udmVyc2lvbiBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHRvSlNPTlxuICAgIC8vIEFjY2VzcyBhdXRoZW50aWNhdG9yQXR0YWNobWVudCB2aWEgdHlwZSBhc3NlcnRpb24gdG8gaGFuZGxlIFR5cGVTY3JpcHQgdmVyc2lvbiBkaWZmZXJlbmNlc1xuICAgIC8vIEBzaW1wbGV3ZWJhdXRobi90eXBlcyBpbmNsdWRlcyB0aGlzIHByb3BlcnR5IGJ1dCBiYXNlIFR5cGVTY3JpcHQgNC43LjQgZG9lc24ndFxuICAgIGNvbnN0IGNyZWRlbnRpYWxXaXRoQXR0YWNobWVudCA9IGNyZWRlbnRpYWw7XG4gICAgY29uc3QgY2xpZW50RXh0ZW5zaW9uUmVzdWx0cyA9IGNyZWRlbnRpYWwuZ2V0Q2xpZW50RXh0ZW5zaW9uUmVzdWx0cygpO1xuICAgIGNvbnN0IGFzc2VydGlvblJlc3BvbnNlID0gY3JlZGVudGlhbC5yZXNwb25zZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogY3JlZGVudGlhbC5pZCxcbiAgICAgICAgcmF3SWQ6IGNyZWRlbnRpYWwuaWQsIC8vIFczQyBzcGVjIGV4cGVjdHMgcmF3SWQgdG8gbWF0Y2ggaWQgZm9yIEpTT04gZm9ybWF0XG4gICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICBhdXRoZW50aWNhdG9yRGF0YTogYnl0ZXNUb0Jhc2U2NFVSTChuZXcgVWludDhBcnJheShhc3NlcnRpb25SZXNwb25zZS5hdXRoZW50aWNhdG9yRGF0YSkpLFxuICAgICAgICAgICAgY2xpZW50RGF0YUpTT046IGJ5dGVzVG9CYXNlNjRVUkwobmV3IFVpbnQ4QXJyYXkoYXNzZXJ0aW9uUmVzcG9uc2UuY2xpZW50RGF0YUpTT04pKSxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogYnl0ZXNUb0Jhc2U2NFVSTChuZXcgVWludDhBcnJheShhc3NlcnRpb25SZXNwb25zZS5zaWduYXR1cmUpKSxcbiAgICAgICAgICAgIHVzZXJIYW5kbGU6IGFzc2VydGlvblJlc3BvbnNlLnVzZXJIYW5kbGVcbiAgICAgICAgICAgICAgICA/IGJ5dGVzVG9CYXNlNjRVUkwobmV3IFVpbnQ4QXJyYXkoYXNzZXJ0aW9uUmVzcG9uc2UudXNlckhhbmRsZSkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6ICdwdWJsaWMta2V5JyxcbiAgICAgICAgY2xpZW50RXh0ZW5zaW9uUmVzdWx0cyxcbiAgICAgICAgLy8gQ29udmVydCBudWxsIHRvIHVuZGVmaW5lZCBhbmQgY2FzdCB0byBBdXRoZW50aWNhdG9yQXR0YWNobWVudCB0eXBlXG4gICAgICAgIGF1dGhlbnRpY2F0b3JBdHRhY2htZW50OiAoKF9hID0gY3JlZGVudGlhbFdpdGhBdHRhY2htZW50LmF1dGhlbnRpY2F0b3JBdHRhY2htZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQpLFxuICAgIH07XG59XG4vKipcbiAqIEEgc2ltcGxlIHRlc3QgdG8gZGV0ZXJtaW5lIGlmIGEgaG9zdG5hbWUgaXMgYSBwcm9wZXJseS1mb3JtYXR0ZWQgZG9tYWluIG5hbWUuXG4gKiBDb25zaWRlcnMgbG9jYWxob3N0IHZhbGlkIGZvciBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gKlxuICogQSBcInZhbGlkIGRvbWFpblwiIGlzIGRlZmluZWQgaGVyZTogaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN2YWxpZC1kb21haW5cbiAqXG4gKiBSZWdleCBzb3VyY2VkIGZyb20gaGVyZTpcbiAqIGh0dHBzOi8vd3d3Lm9yZWlsbHkuY29tL2xpYnJhcnkvdmlldy9yZWd1bGFyLWV4cHJlc3Npb25zLWNvb2tib29rLzk3ODE0NDkzMjc0NTMvY2gwOHMxNS5odG1sXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGhvc3RuYW1lIC0gVGhlIGhvc3RuYW1lIHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWxpZCBkb21haW4gb3IgbG9jYWxob3N0XG4gKiBAc2VlIHtAbGluayBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3ZhbGlkLWRvbWFpbiBXSEFUV0cgVVJMIFNwZWMgLSBWYWxpZCBEb21haW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkRG9tYWluKGhvc3RuYW1lKSB7XG4gICAgcmV0dXJuIChcbiAgICAvLyBDb25zaWRlciBsb2NhbGhvc3QgdmFsaWQgYXMgd2VsbCBzaW5jZSBpdCdzIG9rYXkgd3J0IFNlY3VyZSBDb250ZXh0c1xuICAgIGhvc3RuYW1lID09PSAnbG9jYWxob3N0JyB8fCAvXihbYS16MC05XSsoLVthLXowLTldKykqXFwuKStbYS16XXsyLH0kL2kudGVzdChob3N0bmFtZSkpO1xufVxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIGJyb3dzZXIgaXMgY2FwYWJsZSBvZiBXZWJBdXRobi5cbiAqIENoZWNrcyBmb3IgbmVjZXNzYXJ5IFdlYiBBUElzOiBQdWJsaWNLZXlDcmVkZW50aWFsIGFuZCBDcmVkZW50aWFsIE1hbmFnZW1lbnQuXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYnJvd3NlciBzdXBwb3J0cyBXZWJBdXRoblxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1B1YmxpY0tleUNyZWRlbnRpYWwjYnJvd3Nlcl9jb21wYXRpYmlsaXR5IE1ETiAtIFB1YmxpY0tleUNyZWRlbnRpYWwgQnJvd3NlciBDb21wYXRpYmlsaXR5fVxuICovXG5mdW5jdGlvbiBicm93c2VyU3VwcG9ydHNXZWJBdXRobigpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAhIShpc0Jyb3dzZXIoKSAmJlxuICAgICAgICAnUHVibGljS2V5Q3JlZGVudGlhbCcgaW4gd2luZG93ICYmXG4gICAgICAgIHdpbmRvdy5QdWJsaWNLZXlDcmVkZW50aWFsICYmXG4gICAgICAgICdjcmVkZW50aWFscycgaW4gbmF2aWdhdG9yICYmXG4gICAgICAgIHR5cGVvZiAoKF9hID0gbmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLmNyZWRlbnRpYWxzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3JlYXRlKSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICB0eXBlb2YgKChfYiA9IG5hdmlnYXRvciA9PT0gbnVsbCB8fCBuYXZpZ2F0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hdmlnYXRvci5jcmVkZW50aWFscykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldCkgPT09ICdmdW5jdGlvbicpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBXZWJBdXRobiBjcmVkZW50aWFsIHVzaW5nIHRoZSBicm93c2VyJ3MgY3JlZGVudGlhbHMgQVBJLlxuICogV3JhcHMgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZSgpIHdpdGggZXJyb3IgaGFuZGxpbmcuXG4gKlxuICogQHBhcmFtIHtDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zfSBvcHRpb25zIC0gT3B0aW9ucyBpbmNsdWRpbmcgcHVibGljS2V5IHBhcmFtZXRlcnNcbiAqIEByZXR1cm5zIHtQcm9taXNlPFJlcXVlc3RSZXN1bHQ8UmVnaXN0cmF0aW9uQ3JlZGVudGlhbCwgV2ViQXV0aG5FcnJvcj4+fSBDcmVhdGVkIGNyZWRlbnRpYWwgb3IgZXJyb3JcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1jcmVhdGVDcmVkZW50aWFsIFczQyBXZWJBdXRobiBTcGVjIC0gQ3JlYXRlIENyZWRlbnRpYWx9XG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3JlZGVudGlhbHNDb250YWluZXIvY3JlYXRlIE1ETiAtIGNyZWRlbnRpYWxzLmNyZWF0ZX1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNyZWRlbnRpYWwob3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZShcbiAgICAgICAgLyoqIHdlIGFzc2VydCB0aGUgdHlwZSBoZXJlIHVudGlsIHR5cGVzY3JpcHQgdHlwZXMgYXJlIHVwZGF0ZWQgKi9cbiAgICAgICAgb3B0aW9ucyk7XG4gICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IFdlYkF1dGhuVW5rbm93bkVycm9yKCdFbXB0eSBjcmVkZW50aWFsIHJlc3BvbnNlJywgcmVzcG9uc2UpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShyZXNwb25zZSBpbnN0YW5jZW9mIFB1YmxpY0tleUNyZWRlbnRpYWwpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBXZWJBdXRoblVua25vd25FcnJvcignQnJvd3NlciByZXR1cm5lZCB1bmV4cGVjdGVkIGNyZWRlbnRpYWwgdHlwZScsIHJlc3BvbnNlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGF0YTogcmVzcG9uc2UsIGVycm9yOiBudWxsIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICBlcnJvcjogaWRlbnRpZnlSZWdpc3RyYXRpb25FcnJvcih7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiBHZXQgYSBXZWJBdXRobiBjcmVkZW50aWFsIHVzaW5nIHRoZSBicm93c2VyJ3MgY3JlZGVudGlhbHMgQVBJLlxuICogV3JhcHMgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmdldCgpIHdpdGggZXJyb3IgaGFuZGxpbmcuXG4gKlxuICogQHBhcmFtIHtDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnN9IG9wdGlvbnMgLSBPcHRpb25zIGluY2x1ZGluZyBwdWJsaWNLZXkgcGFyYW1ldGVyc1xuICogQHJldHVybnMge1Byb21pc2U8UmVxdWVzdFJlc3VsdDxBdXRoZW50aWNhdGlvbkNyZWRlbnRpYWwsIFdlYkF1dGhuRXJyb3I+Pn0gUmV0cmlldmVkIGNyZWRlbnRpYWwgb3IgZXJyb3JcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1nZXRBc3NlcnRpb24gVzNDIFdlYkF1dGhuIFNwZWMgLSBHZXQgQXNzZXJ0aW9ufVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NyZWRlbnRpYWxzQ29udGFpbmVyL2dldCBNRE4gLSBjcmVkZW50aWFscy5nZXR9XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDcmVkZW50aWFsKG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXQoXG4gICAgICAgIC8qKiB3ZSBhc3NlcnQgdGhlIHR5cGUgaGVyZSB1bnRpbCB0eXBlc2NyaXB0IHR5cGVzIGFyZSB1cGRhdGVkICovXG4gICAgICAgIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBXZWJBdXRoblVua25vd25FcnJvcignRW1wdHkgY3JlZGVudGlhbCByZXNwb25zZScsIHJlc3BvbnNlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEocmVzcG9uc2UgaW5zdGFuY2VvZiBQdWJsaWNLZXlDcmVkZW50aWFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgV2ViQXV0aG5Vbmtub3duRXJyb3IoJ0Jyb3dzZXIgcmV0dXJuZWQgdW5leHBlY3RlZCBjcmVkZW50aWFsIHR5cGUnLCByZXNwb25zZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHJlc3BvbnNlLCBlcnJvcjogbnVsbCB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgZXJyb3I6IGlkZW50aWZ5QXV0aGVudGljYXRpb25FcnJvcih7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IERFRkFVTFRfQ1JFQVRJT05fT1BUSU9OUyA9IHtcbiAgICBoaW50czogWydzZWN1cml0eS1rZXknXSxcbiAgICBhdXRoZW50aWNhdG9yU2VsZWN0aW9uOiB7XG4gICAgICAgIGF1dGhlbnRpY2F0b3JBdHRhY2htZW50OiAnY3Jvc3MtcGxhdGZvcm0nLFxuICAgICAgICByZXF1aXJlUmVzaWRlbnRLZXk6IGZhbHNlLFxuICAgICAgICAvKiogc2V0IHRvIHByZWZlcnJlZCBiZWNhdXNlIG9sZGVyIHl1YmlrZXlzIGRvbid0IGhhdmUgUElOL0Jpb21ldHJpYyAqL1xuICAgICAgICB1c2VyVmVyaWZpY2F0aW9uOiAncHJlZmVycmVkJyxcbiAgICAgICAgcmVzaWRlbnRLZXk6ICdkaXNjb3VyYWdlZCcsXG4gICAgfSxcbiAgICBhdHRlc3RhdGlvbjogJ2RpcmVjdCcsXG59O1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfUkVRVUVTVF9PUFRJT05TID0ge1xuICAgIC8qKiBzZXQgdG8gcHJlZmVycmVkIGJlY2F1c2Ugb2xkZXIgeXViaWtleXMgZG9uJ3QgaGF2ZSBQSU4vQmlvbWV0cmljICovXG4gICAgdXNlclZlcmlmaWNhdGlvbjogJ3ByZWZlcnJlZCcsXG4gICAgaGludHM6IFsnc2VjdXJpdHkta2V5J10sXG4gICAgYXR0ZXN0YXRpb246ICdkaXJlY3QnLFxufTtcbmZ1bmN0aW9uIGRlZXBNZXJnZSguLi5zb3VyY2VzKSB7XG4gICAgY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsKTtcbiAgICBjb25zdCBpc0FycmF5QnVmZmVyTGlrZSA9ICh2YWwpID0+IHZhbCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgaWYgKCFzb3VyY2UpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBwcmVzZXJ2ZSBhcnJheSByZWZlcmVuY2UsIGluY2x1ZGluZyB1bmlvbnMgbGlrZSBBdXRoZW50aWNhdG9yVHJhbnNwb3J0W11cbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNBcnJheUJ1ZmZlckxpa2UodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gcmVzdWx0W2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGV4aXN0aW5nKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGRlZXBNZXJnZShleGlzdGluZywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBkZWVwTWVyZ2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogTWVyZ2VzIFdlYkF1dGhuIGNyZWRlbnRpYWwgY3JlYXRpb24gb3B0aW9ucyB3aXRoIG92ZXJyaWRlcy5cbiAqIFNldHMgc2Vuc2libGUgZGVmYXVsdHMgZm9yIGF1dGhlbnRpY2F0b3Igc2VsZWN0aW9uIGFuZCBleHRlbnNpb25zLlxuICpcbiAqIEBwYXJhbSB7UHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc0Z1dHVyZX0gYmFzZU9wdGlvbnMgLSBUaGUgYmFzZSBvcHRpb25zIGZyb20gdGhlIHNlcnZlclxuICogQHBhcmFtIHtQdWJsaWNLZXlDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zRnV0dXJlfSBvdmVycmlkZXMgLSBPcHRpb25hbCBvdmVycmlkZXMgdG8gYXBwbHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBmcmllbmRseU5hbWUgLSBPcHRpb25hbCBmcmllbmRseSBuYW1lIGZvciB0aGUgY3JlZGVudGlhbFxuICogQHJldHVybnMge1B1YmxpY0tleUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnNGdXR1cmV9IE1lcmdlZCBjcmVkZW50aWFsIGNyZWF0aW9uIG9wdGlvbnNcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jZGljdGRlZi1hdXRoZW50aWNhdG9yc2VsZWN0aW9uY3JpdGVyaWEgVzNDIFdlYkF1dGhuIFNwZWMgLSBBdXRoZW50aWNhdG9yU2VsZWN0aW9uQ3JpdGVyaWF9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMoYmFzZU9wdGlvbnMsIG92ZXJyaWRlcykge1xuICAgIHJldHVybiBkZWVwTWVyZ2UoREVGQVVMVF9DUkVBVElPTl9PUFRJT05TLCBiYXNlT3B0aW9ucywgb3ZlcnJpZGVzIHx8IHt9KTtcbn1cbi8qKlxuICogTWVyZ2VzIFdlYkF1dGhuIGNyZWRlbnRpYWwgcmVxdWVzdCBvcHRpb25zIHdpdGggb3ZlcnJpZGVzLlxuICogU2V0cyBzZW5zaWJsZSBkZWZhdWx0cyBmb3IgdXNlciB2ZXJpZmljYXRpb24gYW5kIGhpbnRzLlxuICpcbiAqIEBwYXJhbSB7UHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zRnV0dXJlfSBiYXNlT3B0aW9ucyAtIFRoZSBiYXNlIG9wdGlvbnMgZnJvbSB0aGUgc2VydmVyXG4gKiBAcGFyYW0ge1B1YmxpY0tleUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc0Z1dHVyZX0gb3ZlcnJpZGVzIC0gT3B0aW9uYWwgb3ZlcnJpZGVzIHRvIGFwcGx5XG4gKiBAcmV0dXJucyB7UHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zRnV0dXJlfSBNZXJnZWQgY3JlZGVudGlhbCByZXF1ZXN0IG9wdGlvbnNcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jZGljdGRlZi1wdWJsaWNrZXljcmVkZW50aWFscmVxdWVzdG9wdGlvbnMgVzNDIFdlYkF1dGhuIFNwZWMgLSBQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9ucyhiYXNlT3B0aW9ucywgb3ZlcnJpZGVzKSB7XG4gICAgcmV0dXJuIGRlZXBNZXJnZShERUZBVUxUX1JFUVVFU1RfT1BUSU9OUywgYmFzZU9wdGlvbnMsIG92ZXJyaWRlcyB8fCB7fSk7XG59XG4vKipcbiAqIFdlYkF1dGhuIEFQSSB3cmFwcGVyIGZvciBTdXBhYmFzZSBBdXRoLlxuICogUHJvdmlkZXMgbWV0aG9kcyBmb3IgZW5yb2xsaW5nLCBjaGFsbGVuZ2luZywgdmVyaWZ5aW5nLCBhdXRoZW50aWNhdGluZywgYW5kIHJlZ2lzdGVyaW5nIFdlYkF1dGhuIGNyZWRlbnRpYWxzLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSByZWxlYXNlc1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyBXM0MgV2ViQXV0aG4gU3BlY2lmaWNhdGlvbn1cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJfQXV0aGVudGljYXRpb25fQVBJIE1ETiAtIFdlYiBBdXRoZW50aWNhdGlvbiBBUEl9XG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJBdXRobkFwaSB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgICAgICAvLyBCaW5kIGFsbCBtZXRob2RzIHNvIHRoZXkgY2FuIGJlIGRlc3RydWN0dXJlZFxuICAgICAgICB0aGlzLmVucm9sbCA9IHRoaXMuX2Vucm9sbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNoYWxsZW5nZSA9IHRoaXMuX2NoYWxsZW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnZlcmlmeSA9IHRoaXMuX3ZlcmlmeS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmF1dGhlbnRpY2F0ZSA9IHRoaXMuX2F1dGhlbnRpY2F0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyID0gdGhpcy5fcmVnaXN0ZXIuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5yb2xsIGEgbmV3IFdlYkF1dGhuIGZhY3Rvci5cbiAgICAgKiBDcmVhdGVzIGFuIHVudmVyaWZpZWQgV2ViQXV0aG4gZmFjdG9yIHRoYXQgbXVzdCBiZSB2ZXJpZmllZCB3aXRoIGEgY3JlZGVudGlhbC5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgVGhpcyBtZXRob2QgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSByZWxlYXNlc1xuICAgICAqIEBwYXJhbSB7T21pdDxNRkFFbnJvbGxXZWJhdXRoblBhcmFtcywgJ2ZhY3RvclR5cGUnPn0gcGFyYW1zIC0gRW5yb2xsbWVudCBwYXJhbWV0ZXJzIChmcmllbmRseU5hbWUgcmVxdWlyZWQpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXV0aE1GQUVucm9sbFdlYmF1dGhuUmVzcG9uc2U+fSBFbnJvbGxlZCBmYWN0b3IgZGV0YWlscyBvciBlcnJvclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1yZWdpc3RlcmluZy1hLW5ldy1jcmVkZW50aWFsIFczQyBXZWJBdXRobiBTcGVjIC0gUmVnaXN0ZXJpbmcgYSBOZXcgQ3JlZGVudGlhbH1cbiAgICAgKi9cbiAgICBhc3luYyBfZW5yb2xsKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQubWZhLmVucm9sbChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHsgZmFjdG9yVHlwZTogJ3dlYmF1dGhuJyB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYWxsZW5nZSBmb3IgV2ViQXV0aG4gY3JlZGVudGlhbCBjcmVhdGlvbiBvciBhdXRoZW50aWNhdGlvbi5cbiAgICAgKiBDb21iaW5lcyBzZXJ2ZXIgY2hhbGxlbmdlIHdpdGggYnJvd3NlciBjcmVkZW50aWFsIG9wZXJhdGlvbnMuXG4gICAgICogSGFuZGxlcyBib3RoIHJlZ2lzdHJhdGlvbiAoY3JlYXRlKSBhbmQgYXV0aGVudGljYXRpb24gKHJlcXVlc3QpIGZsb3dzLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBUaGlzIG1ldGhvZCBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UgaW4gZnV0dXJlIHJlbGVhc2VzXG4gICAgICogQHBhcmFtIHtNRkFDaGFsbGVuZ2VXZWJhdXRoblBhcmFtcyAmIHsgZnJpZW5kbHlOYW1lPzogc3RyaW5nOyBzaWduYWw/OiBBYm9ydFNpZ25hbCB9fSBwYXJhbXMgLSBDaGFsbGVuZ2UgcGFyYW1ldGVycyBpbmNsdWRpbmcgZmFjdG9ySWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3ZlcnJpZGVzIC0gQWxsb3dzIHlvdSB0byBvdmVycmlkZSB0aGUgcGFyYW1ldGVycyBwYXNzZWQgdG8gbmF2aWdhdG9yLmNyZWRlbnRpYWxzXG4gICAgICogQHBhcmFtIHtQdWJsaWNLZXlDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zRnV0dXJlfSBvdmVycmlkZXMuY3JlYXRlIC0gT3ZlcnJpZGUgb3B0aW9ucyBmb3IgY3JlZGVudGlhbCBjcmVhdGlvblxuICAgICAqIEBwYXJhbSB7UHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zRnV0dXJlfSBvdmVycmlkZXMucmVxdWVzdCAtIE92ZXJyaWRlIG9wdGlvbnMgZm9yIGNyZWRlbnRpYWwgcmVxdWVzdFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJlcXVlc3RSZXN1bHQ+fSBDaGFsbGVuZ2UgcmVzcG9uc2Ugd2l0aCBjcmVkZW50aWFsIG9yIGVycm9yXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLWNyZWRlbnRpYWwtY3JlYXRpb24gVzNDIFdlYkF1dGhuIFNwZWMgLSBDcmVkZW50aWFsIENyZWF0aW9ufVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi12ZXJpZnlpbmctYXNzZXJ0aW9uIFczQyBXZWJBdXRobiBTcGVjIC0gVmVyaWZ5aW5nIEFzc2VydGlvbn1cbiAgICAgKi9cbiAgICBhc3luYyBfY2hhbGxlbmdlKHsgZmFjdG9ySWQsIHdlYmF1dGhuLCBmcmllbmRseU5hbWUsIHNpZ25hbCwgfSwgb3ZlcnJpZGVzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEdldCBjaGFsbGVuZ2UgZnJvbSBzZXJ2ZXIgdXNpbmcgdGhlIGNsaWVudCdzIE1GQSBtZXRob2RzXG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IGNoYWxsZW5nZVJlc3BvbnNlLCBlcnJvcjogY2hhbGxlbmdlRXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50Lm1mYS5jaGFsbGVuZ2Uoe1xuICAgICAgICAgICAgICAgIGZhY3RvcklkLFxuICAgICAgICAgICAgICAgIHdlYmF1dGhuLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWNoYWxsZW5nZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IGNoYWxsZW5nZUVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhYm9ydFNpZ25hbCA9IHNpZ25hbCAhPT0gbnVsbCAmJiBzaWduYWwgIT09IHZvaWQgMCA/IHNpZ25hbCA6IHdlYkF1dGhuQWJvcnRTZXJ2aWNlLmNyZWF0ZU5ld0Fib3J0U2lnbmFsKCk7XG4gICAgICAgICAgICAvKiogd2ViYXV0aG4gd2lsbCBmYWlsIGlmIGVpdGhlciBvZiB0aGUgbmFtZS9kaXNwbGF5bmFtZSBhcmUgYmxhbmsgKi9cbiAgICAgICAgICAgIGlmIChjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi50eXBlID09PSAnY3JlYXRlJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdXNlciB9ID0gY2hhbGxlbmdlUmVzcG9uc2Uud2ViYXV0aG4uY3JlZGVudGlhbF9vcHRpb25zLnB1YmxpY0tleTtcbiAgICAgICAgICAgICAgICBpZiAoIXVzZXIubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmVzZXJ2ZSBvcmlnaW5hbCBmb3JtYXQ6IHVzZSBmcmllbmRseU5hbWUgaWYgcHJvdmlkZWQsIG90aGVyd2lzZSBmZXRjaCBmYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG1haW50YWlucyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggdGhlICR7dXNlci5pZH06JHtuYW1lfSBmb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZVRvVXNlID0gZnJpZW5kbHlOYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5hbWVUb1VzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBmZXRjaCB1c2VyIGRhdGEgaWYgZnJpZW5kbHlOYW1lIGlzIG5vdCBwcm92aWRlZCAoYnVnIGZpeCBmb3IgbnVsbCBmcmllbmRseU5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VXNlciA9IGF3YWl0IHRoaXMuY2xpZW50LmdldFVzZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJEYXRhID0gY3VycmVudFVzZXIuZGF0YS51c2VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmFsbGJhY2tOYW1lID0gKChfYSA9IHVzZXJEYXRhID09PSBudWxsIHx8IHVzZXJEYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyRGF0YS51c2VyX21ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgfHwgKHVzZXJEYXRhID09PSBudWxsIHx8IHVzZXJEYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyRGF0YS5lbWFpbCkgfHwgKHVzZXJEYXRhID09PSBudWxsIHx8IHVzZXJEYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyRGF0YS5pZCkgfHwgJ1VzZXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlci5uYW1lID0gYCR7dXNlci5pZH06JHtmYWxsYmFja05hbWV9YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXIubmFtZSA9IGAke3VzZXIuaWR9OiR7bmFtZVRvVXNlfWA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF1c2VyLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXIuZGlzcGxheU5hbWUgPSB1c2VyLm5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY3JlYXRlJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gbWVyZ2VDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zKGNoYWxsZW5nZVJlc3BvbnNlLndlYmF1dGhuLmNyZWRlbnRpYWxfb3B0aW9ucy5wdWJsaWNLZXksIG92ZXJyaWRlcyA9PT0gbnVsbCB8fCBvdmVycmlkZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG92ZXJyaWRlcy5jcmVhdGUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBjcmVhdGVDcmVkZW50aWFsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1YmxpY0tleTogb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFsbGVuZ2VJZDogY2hhbGxlbmdlUmVzcG9uc2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlYmF1dGhuOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbF9yZXNwb25zZTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdyZXF1ZXN0Jzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gbWVyZ2VDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnMoY2hhbGxlbmdlUmVzcG9uc2Uud2ViYXV0aG4uY3JlZGVudGlhbF9vcHRpb25zLnB1YmxpY0tleSwgb3ZlcnJpZGVzID09PSBudWxsIHx8IG92ZXJyaWRlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3ZlcnJpZGVzLnJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBnZXRDcmVkZW50aWFsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2hhbGxlbmdlUmVzcG9uc2Uud2ViYXV0aG4uY3JlZGVudGlhbF9vcHRpb25zKSwgeyBwdWJsaWNLZXk6IG9wdGlvbnMsIHNpZ25hbDogYWJvcnRTaWduYWwgfSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFsbGVuZ2VJZDogY2hhbGxlbmdlUmVzcG9uc2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlYmF1dGhuOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbF9yZXNwb25zZTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgQXV0aFVua25vd25FcnJvcignVW5leHBlY3RlZCBlcnJvciBpbiBjaGFsbGVuZ2UnLCBlcnJvciksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmeSBhIFdlYkF1dGhuIGNyZWRlbnRpYWwgd2l0aCB0aGUgc2VydmVyLlxuICAgICAqIENvbXBsZXRlcyB0aGUgV2ViQXV0aG4gY2VyZW1vbnkgYnkgc2VuZGluZyB0aGUgY3JlZGVudGlhbCB0byB0aGUgc2VydmVyIGZvciB2ZXJpZmljYXRpb24uXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIFRoaXMgbWV0aG9kIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSBpbiBmdXR1cmUgcmVsZWFzZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVmVyaWZpY2F0aW9uIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmNoYWxsZW5nZUlkIC0gSUQgb2YgdGhlIGNoYWxsZW5nZSBiZWluZyB2ZXJpZmllZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuZmFjdG9ySWQgLSBJRCBvZiB0aGUgV2ViQXV0aG4gZmFjdG9yXG4gICAgICogQHBhcmFtIHtNRkFWZXJpZnlXZWJhdXRoblBhcmFtczxUPlsnd2ViYXV0aG4nXX0gcGFyYW1zLndlYmF1dGhuIC0gV2ViQXV0aG4gY3JlZGVudGlhbCByZXNwb25zZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEF1dGhNRkFWZXJpZnlSZXNwb25zZT59IFZlcmlmaWNhdGlvbiByZXN1bHQgd2l0aCBzZXNzaW9uIG9yIGVycm9yXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLXZlcmlmeWluZy1hc3NlcnRpb24gVzNDIFdlYkF1dGhuIFNwZWMgLSBWZXJpZnlpbmcgYW4gQXV0aGVudGljYXRpb24gQXNzZXJ0aW9ufVxuICAgICAqICovXG4gICAgYXN5bmMgX3ZlcmlmeSh7IGNoYWxsZW5nZUlkLCBmYWN0b3JJZCwgd2ViYXV0aG4sIH0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50Lm1mYS52ZXJpZnkoe1xuICAgICAgICAgICAgZmFjdG9ySWQsXG4gICAgICAgICAgICBjaGFsbGVuZ2VJZCxcbiAgICAgICAgICAgIHdlYmF1dGhuOiB3ZWJhdXRobixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBsZXRlIFdlYkF1dGhuIGF1dGhlbnRpY2F0aW9uIGZsb3cuXG4gICAgICogUGVyZm9ybXMgY2hhbGxlbmdlIGFuZCB2ZXJpZmljYXRpb24gaW4gYSBzaW5nbGUgb3BlcmF0aW9uIGZvciBleGlzdGluZyBjcmVkZW50aWFscy5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgVGhpcyBtZXRob2QgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSByZWxlYXNlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBBdXRoZW50aWNhdGlvbiBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5mYWN0b3JJZCAtIElEIG9mIHRoZSBXZWJBdXRobiBmYWN0b3IgdG8gYXV0aGVudGljYXRlIHdpdGhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zLndlYmF1dGhuIC0gV2ViQXV0aG4gY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMud2ViYXV0aG4ucnBJZCAtIFJlbHlpbmcgUGFydHkgSUQgKGRlZmF1bHRzIHRvIGN1cnJlbnQgaG9zdG5hbWUpXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zLndlYmF1dGhuLnJwT3JpZ2lucyAtIEFsbG93ZWQgb3JpZ2lucyAoZGVmYXVsdHMgdG8gY3VycmVudCBvcmlnaW4pXG4gICAgICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gcGFyYW1zLndlYmF1dGhuLnNpZ25hbCAtIE9wdGlvbmFsIGFib3J0IHNpZ25hbFxuICAgICAqIEBwYXJhbSB7UHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zRnV0dXJlfSBvdmVycmlkZXMgLSBPdmVycmlkZSBvcHRpb25zIGZvciBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuZ2V0XG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmVxdWVzdFJlc3VsdDxBdXRoTUZBVmVyaWZ5UmVzcG9uc2VEYXRhLCBXZWJBdXRobkVycm9yIHwgQXV0aEVycm9yPj59IEF1dGhlbnRpY2F0aW9uIHJlc3VsdFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1hdXRoZW50aWNhdGlvbiBXM0MgV2ViQXV0aG4gU3BlYyAtIEF1dGhlbnRpY2F0aW9uIENlcmVtb255fVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9QdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnMgTUROIC0gUHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zfVxuICAgICAqL1xuICAgIGFzeW5jIF9hdXRoZW50aWNhdGUoeyBmYWN0b3JJZCwgd2ViYXV0aG46IHsgcnBJZCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lIDogdW5kZWZpbmVkLCBycE9yaWdpbnMgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IFt3aW5kb3cubG9jYXRpb24ub3JpZ2luXSA6IHVuZGVmaW5lZCwgc2lnbmFsLCB9ID0ge30sIH0sIG92ZXJyaWRlcykge1xuICAgICAgICBpZiAoIXJwSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEF1dGhFcnJvcigncnBJZCBpcyByZXF1aXJlZCBmb3IgV2ViQXV0aG4gYXV0aGVudGljYXRpb24nKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghYnJvd3NlclN1cHBvcnRzV2ViQXV0aG4oKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgQXV0aFVua25vd25FcnJvcignQnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFdlYkF1dGhuJywgbnVsbCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCBjaGFsbGVuZ2UgYW5kIGNyZWRlbnRpYWxcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogY2hhbGxlbmdlUmVzcG9uc2UsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9ID0gYXdhaXQgdGhpcy5jaGFsbGVuZ2Uoe1xuICAgICAgICAgICAgICAgIGZhY3RvcklkLFxuICAgICAgICAgICAgICAgIHdlYmF1dGhuOiB7IHJwSWQsIHJwT3JpZ2lucyB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgICAgIH0sIHsgcmVxdWVzdDogb3ZlcnJpZGVzIH0pO1xuICAgICAgICAgICAgaWYgKCFjaGFsbGVuZ2VSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB3ZWJhdXRobiB9ID0gY2hhbGxlbmdlUmVzcG9uc2U7XG4gICAgICAgICAgICAvLyBWZXJpZnkgY3JlZGVudGlhbFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcmlmeSh7XG4gICAgICAgICAgICAgICAgZmFjdG9ySWQsXG4gICAgICAgICAgICAgICAgY2hhbGxlbmdlSWQ6IGNoYWxsZW5nZVJlc3BvbnNlLmNoYWxsZW5nZUlkLFxuICAgICAgICAgICAgICAgIHdlYmF1dGhuOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHdlYmF1dGhuLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHJwSWQsXG4gICAgICAgICAgICAgICAgICAgIHJwT3JpZ2lucyxcbiAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbF9yZXNwb25zZTogd2ViYXV0aG4uY3JlZGVudGlhbF9yZXNwb25zZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEF1dGhVbmtub3duRXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3IgaW4gYXV0aGVudGljYXRlJywgZXJyb3IpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wbGV0ZSBXZWJBdXRobiByZWdpc3RyYXRpb24gZmxvdy5cbiAgICAgKiBQZXJmb3JtcyBlbnJvbGxtZW50LCBjaGFsbGVuZ2UsIGFuZCB2ZXJpZmljYXRpb24gaW4gYSBzaW5nbGUgb3BlcmF0aW9uIGZvciBuZXcgY3JlZGVudGlhbHMuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIFRoaXMgbWV0aG9kIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSBpbiBmdXR1cmUgcmVsZWFzZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gUmVnaXN0cmF0aW9uIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmZyaWVuZGx5TmFtZSAtIFVzZXItZnJpZW5kbHkgbmFtZSBmb3IgdGhlIGNyZWRlbnRpYWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnJwSWQgLSBSZWx5aW5nIFBhcnR5IElEIChkZWZhdWx0cyB0byBjdXJyZW50IGhvc3RuYW1lKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcy5ycE9yaWdpbnMgLSBBbGxvd2VkIG9yaWdpbnMgKGRlZmF1bHRzIHRvIGN1cnJlbnQgb3JpZ2luKVxuICAgICAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IHBhcmFtcy5zaWduYWwgLSBPcHRpb25hbCBhYm9ydCBzaWduYWxcbiAgICAgKiBAcGFyYW0ge1B1YmxpY0tleUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnNGdXR1cmV9IG92ZXJyaWRlcyAtIE92ZXJyaWRlIG9wdGlvbnMgZm9yIG5hdmlnYXRvci5jcmVkZW50aWFscy5jcmVhdGVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXF1ZXN0UmVzdWx0PEF1dGhNRkFWZXJpZnlSZXNwb25zZURhdGEsIFdlYkF1dGhuRXJyb3IgfCBBdXRoRXJyb3I+Pn0gUmVnaXN0cmF0aW9uIHJlc3VsdFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1yZWdpc3RlcmluZy1hLW5ldy1jcmVkZW50aWFsIFczQyBXZWJBdXRobiBTcGVjIC0gUmVnaXN0cmF0aW9uIENlcmVtb255fVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9QdWJsaWNLZXlDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zIE1ETiAtIFB1YmxpY0tleUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnN9XG4gICAgICovXG4gICAgYXN5bmMgX3JlZ2lzdGVyKHsgZnJpZW5kbHlOYW1lLCB3ZWJhdXRobjogeyBycElkID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgOiB1bmRlZmluZWQsIHJwT3JpZ2lucyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gW3dpbmRvdy5sb2NhdGlvbi5vcmlnaW5dIDogdW5kZWZpbmVkLCBzaWduYWwsIH0gPSB7fSwgfSwgb3ZlcnJpZGVzKSB7XG4gICAgICAgIGlmICghcnBJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgQXV0aEVycm9yKCdycElkIGlzIHJlcXVpcmVkIGZvciBXZWJBdXRobiByZWdpc3RyYXRpb24nKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghYnJvd3NlclN1cHBvcnRzV2ViQXV0aG4oKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgQXV0aFVua25vd25FcnJvcignQnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFdlYkF1dGhuJywgbnVsbCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVucm9sbCBmYWN0b3JcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogZmFjdG9yLCBlcnJvcjogZW5yb2xsRXJyb3IgfSA9IGF3YWl0IHRoaXMuX2Vucm9sbCh7XG4gICAgICAgICAgICAgICAgZnJpZW5kbHlOYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWZhY3Rvcikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY2xpZW50Lm1mYVxuICAgICAgICAgICAgICAgICAgICAubGlzdEZhY3RvcnMoKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoZmFjdG9ycykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoX2EgPSBmYWN0b3JzLmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hbGwuZmluZCgodikgPT4gdi5mYWN0b3JfdHlwZSA9PT0gJ3dlYmF1dGhuJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdi5mcmllbmRseV9uYW1lID09PSBmcmllbmRseU5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHYuc3RhdHVzICE9PSAndW52ZXJpZmllZCcpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChmYWN0b3IpID0+IChmYWN0b3IgPyB0aGlzLmNsaWVudC5tZmEudW5lbnJvbGwoeyBmYWN0b3JJZDogZmFjdG9yID09PSBudWxsIHx8IGZhY3RvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmFjdG9yLmlkIH0pIDogdm9pZCAwKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IGVucm9sbEVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgY2hhbGxlbmdlIGFuZCBjcmVhdGUgY3JlZGVudGlhbFxuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBjaGFsbGVuZ2VSZXNwb25zZSwgZXJyb3I6IGNoYWxsZW5nZUVycm9yIH0gPSBhd2FpdCB0aGlzLl9jaGFsbGVuZ2Uoe1xuICAgICAgICAgICAgICAgIGZhY3RvcklkOiBmYWN0b3IuaWQsXG4gICAgICAgICAgICAgICAgZnJpZW5kbHlOYW1lOiBmYWN0b3IuZnJpZW5kbHlfbmFtZSxcbiAgICAgICAgICAgICAgICB3ZWJhdXRobjogeyBycElkLCBycE9yaWdpbnMgfSxcbiAgICAgICAgICAgICAgICBzaWduYWwsXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgY3JlYXRlOiBvdmVycmlkZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghY2hhbGxlbmdlUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogY2hhbGxlbmdlRXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92ZXJpZnkoe1xuICAgICAgICAgICAgICAgIGZhY3RvcklkOiBmYWN0b3IuaWQsXG4gICAgICAgICAgICAgICAgY2hhbGxlbmdlSWQ6IGNoYWxsZW5nZVJlc3BvbnNlLmNoYWxsZW5nZUlkLFxuICAgICAgICAgICAgICAgIHdlYmF1dGhuOiB7XG4gICAgICAgICAgICAgICAgICAgIHJwSWQsXG4gICAgICAgICAgICAgICAgICAgIHJwT3JpZ2lucyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogY2hhbGxlbmdlUmVzcG9uc2Uud2ViYXV0aG4udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbF9yZXNwb25zZTogY2hhbGxlbmdlUmVzcG9uc2Uud2ViYXV0aG4uY3JlZGVudGlhbF9yZXNwb25zZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEF1dGhVbmtub3duRXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3IgaW4gcmVnaXN0ZXInLCBlcnJvciksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViYXV0aG4uanMubWFwIl0sIm5hbWVzIjpbIl9fcmVzdCIsImJhc2U2NFVybFRvVWludDhBcnJheSIsImJ5dGVzVG9CYXNlNjRVUkwiLCJBdXRoRXJyb3IiLCJBdXRoVW5rbm93bkVycm9yIiwiaXNBdXRoRXJyb3IiLCJpc0Jyb3dzZXIiLCJpZGVudGlmeUF1dGhlbnRpY2F0aW9uRXJyb3IiLCJpZGVudGlmeVJlZ2lzdHJhdGlvbkVycm9yIiwiaXNXZWJBdXRobkVycm9yIiwiV2ViQXV0aG5FcnJvciIsIldlYkF1dGhuVW5rbm93bkVycm9yIiwiV2ViQXV0aG5BYm9ydFNlcnZpY2UiLCJjcmVhdGVOZXdBYm9ydFNpZ25hbCIsImNvbnRyb2xsZXIiLCJhYm9ydEVycm9yIiwiRXJyb3IiLCJuYW1lIiwiYWJvcnQiLCJuZXdDb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwic2lnbmFsIiwiY2FuY2VsQ2VyZW1vbnkiLCJ1bmRlZmluZWQiLCJ3ZWJBdXRobkFib3J0U2VydmljZSIsImRlc2VyaWFsaXplQ3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucyIsIm9wdGlvbnMiLCJQdWJsaWNLZXlDcmVkZW50aWFsIiwicGFyc2VDcmVhdGlvbk9wdGlvbnNGcm9tSlNPTiIsImNoYWxsZW5nZSIsImNoYWxsZW5nZVN0ciIsInVzZXIiLCJ1c2VyT3B0cyIsImV4Y2x1ZGVDcmVkZW50aWFscyIsInJlc3RPcHRpb25zIiwiYnVmZmVyIiwiT2JqZWN0IiwiYXNzaWduIiwiaWQiLCJyZXN1bHQiLCJsZW5ndGgiLCJBcnJheSIsImkiLCJjcmVkIiwidHlwZSIsInRyYW5zcG9ydHMiLCJkZXNlcmlhbGl6ZUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9ucyIsInBhcnNlUmVxdWVzdE9wdGlvbnNGcm9tSlNPTiIsImFsbG93Q3JlZGVudGlhbHMiLCJzZXJpYWxpemVDcmVkZW50aWFsQ3JlYXRpb25SZXNwb25zZSIsImNyZWRlbnRpYWwiLCJfYSIsInRvSlNPTiIsImNyZWRlbnRpYWxXaXRoQXR0YWNobWVudCIsInJhd0lkIiwicmVzcG9uc2UiLCJhdHRlc3RhdGlvbk9iamVjdCIsIlVpbnQ4QXJyYXkiLCJjbGllbnREYXRhSlNPTiIsImNsaWVudEV4dGVuc2lvblJlc3VsdHMiLCJnZXRDbGllbnRFeHRlbnNpb25SZXN1bHRzIiwiYXV0aGVudGljYXRvckF0dGFjaG1lbnQiLCJzZXJpYWxpemVDcmVkZW50aWFsUmVxdWVzdFJlc3BvbnNlIiwiYXNzZXJ0aW9uUmVzcG9uc2UiLCJhdXRoZW50aWNhdG9yRGF0YSIsInNpZ25hdHVyZSIsInVzZXJIYW5kbGUiLCJpc1ZhbGlkRG9tYWluIiwiaG9zdG5hbWUiLCJ0ZXN0IiwiYnJvd3NlclN1cHBvcnRzV2ViQXV0aG4iLCJfYiIsIndpbmRvdyIsIm5hdmlnYXRvciIsImNyZWRlbnRpYWxzIiwiY3JlYXRlIiwiZ2V0IiwiY3JlYXRlQ3JlZGVudGlhbCIsImRhdGEiLCJlcnJvciIsImVyciIsImdldENyZWRlbnRpYWwiLCJERUZBVUxUX0NSRUFUSU9OX09QVElPTlMiLCJoaW50cyIsImF1dGhlbnRpY2F0b3JTZWxlY3Rpb24iLCJyZXF1aXJlUmVzaWRlbnRLZXkiLCJ1c2VyVmVyaWZpY2F0aW9uIiwicmVzaWRlbnRLZXkiLCJhdHRlc3RhdGlvbiIsIkRFRkFVTFRfUkVRVUVTVF9PUFRJT05TIiwiZGVlcE1lcmdlIiwic291cmNlcyIsImlzT2JqZWN0IiwidmFsIiwiaXNBcnJheSIsImlzQXJyYXlCdWZmZXJMaWtlIiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJzb3VyY2UiLCJrZXkiLCJ2YWx1ZSIsImV4aXN0aW5nIiwibWVyZ2VDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zIiwiYmFzZU9wdGlvbnMiLCJvdmVycmlkZXMiLCJtZXJnZUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9ucyIsIldlYkF1dGhuQXBpIiwiY29uc3RydWN0b3IiLCJjbGllbnQiLCJlbnJvbGwiLCJfZW5yb2xsIiwiYmluZCIsIl9jaGFsbGVuZ2UiLCJ2ZXJpZnkiLCJfdmVyaWZ5IiwiYXV0aGVudGljYXRlIiwiX2F1dGhlbnRpY2F0ZSIsInJlZ2lzdGVyIiwiX3JlZ2lzdGVyIiwicGFyYW1zIiwibWZhIiwiZmFjdG9yVHlwZSIsImZhY3RvcklkIiwid2ViYXV0aG4iLCJmcmllbmRseU5hbWUiLCJjaGFsbGVuZ2VSZXNwb25zZSIsImNoYWxsZW5nZUVycm9yIiwiYWJvcnRTaWduYWwiLCJjcmVkZW50aWFsX29wdGlvbnMiLCJwdWJsaWNLZXkiLCJuYW1lVG9Vc2UiLCJjdXJyZW50VXNlciIsImdldFVzZXIiLCJ1c2VyRGF0YSIsImZhbGxiYWNrTmFtZSIsInVzZXJfbWV0YWRhdGEiLCJlbWFpbCIsImRpc3BsYXlOYW1lIiwiY2hhbGxlbmdlSWQiLCJjcmVkZW50aWFsX3Jlc3BvbnNlIiwicmVxdWVzdCIsInJwSWQiLCJsb2NhdGlvbiIsInJwT3JpZ2lucyIsIm9yaWdpbiIsImZhY3RvciIsImVucm9sbEVycm9yIiwibGlzdEZhY3RvcnMiLCJ0aGVuIiwiZmFjdG9ycyIsImFsbCIsImZpbmQiLCJ2IiwiZmFjdG9yX3R5cGUiLCJmcmllbmRseV9uYW1lIiwic3RhdHVzIiwidW5lbnJvbGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FunctionsClient: () => (/* binding */ FunctionsClient)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper */ \"(ssr)/./node_modules/@supabase/functions-js/dist/module/helper.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@supabase/functions-js/dist/module/types.js\");\n\n\n\n/**\n * Client for invoking Supabase Edge Functions.\n */ class FunctionsClient {\n    /**\n     * Creates a new Functions client bound to an Edge Functions URL.\n     *\n     * @example\n     * ```ts\n     * import { FunctionsClient, FunctionRegion } from '@supabase/functions-js'\n     *\n     * const functions = new FunctionsClient('https://xyzcompany.supabase.co/functions/v1', {\n     *   headers: { apikey: 'public-anon-key' },\n     *   region: FunctionRegion.UsEast1,\n     * })\n     * ```\n     */ constructor(url, { headers = {}, customFetch, region = _types__WEBPACK_IMPORTED_MODULE_0__.FunctionRegion.Any } = {}){\n        this.url = url;\n        this.headers = headers;\n        this.region = region;\n        this.fetch = (0,_helper__WEBPACK_IMPORTED_MODULE_1__.resolveFetch)(customFetch);\n    }\n    /**\n     * Updates the authorization header\n     * @param token - the new jwt token sent in the authorisation header\n     * @example\n     * ```ts\n     * functions.setAuth(session.access_token)\n     * ```\n     */ setAuth(token) {\n        this.headers.Authorization = `Bearer ${token}`;\n    }\n    /**\n     * Invokes a function\n     * @param functionName - The name of the Function to invoke.\n     * @param options - Options for invoking the Function.\n     * @example\n     * ```ts\n     * const { data, error } = await functions.invoke('hello-world', {\n     *   body: { name: 'Ada' },\n     * })\n     * ```\n     */ invoke(functionName_1) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, arguments, void 0, function*(functionName, options = {}) {\n            var _a;\n            let timeoutId;\n            let timeoutController;\n            try {\n                const { headers, method, body: functionArgs, signal, timeout } = options;\n                let _headers = {};\n                let { region } = options;\n                if (!region) {\n                    region = this.region;\n                }\n                // Add region as query parameter using URL API\n                const url = new URL(`${this.url}/${functionName}`);\n                if (region && region !== \"any\") {\n                    _headers[\"x-region\"] = region;\n                    url.searchParams.set(\"forceFunctionRegion\", region);\n                }\n                let body;\n                if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, \"Content-Type\") || !headers)) {\n                    if (typeof Blob !== \"undefined\" && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {\n                        // will work for File as File inherits Blob\n                        // also works for ArrayBuffer as it is the same underlying structure as a Blob\n                        _headers[\"Content-Type\"] = \"application/octet-stream\";\n                        body = functionArgs;\n                    } else if (typeof functionArgs === \"string\") {\n                        // plain string\n                        _headers[\"Content-Type\"] = \"text/plain\";\n                        body = functionArgs;\n                    } else if (typeof FormData !== \"undefined\" && functionArgs instanceof FormData) {\n                        // don't set content-type headers\n                        // Request will automatically add the right boundary value\n                        body = functionArgs;\n                    } else {\n                        // default, assume this is JSON\n                        _headers[\"Content-Type\"] = \"application/json\";\n                        body = JSON.stringify(functionArgs);\n                    }\n                } else {\n                    if (functionArgs && typeof functionArgs !== \"string\" && !(typeof Blob !== \"undefined\" && functionArgs instanceof Blob) && !(functionArgs instanceof ArrayBuffer) && !(typeof FormData !== \"undefined\" && functionArgs instanceof FormData)) {\n                        body = JSON.stringify(functionArgs);\n                    } else {\n                        body = functionArgs;\n                    }\n                }\n                // Handle timeout by creating an AbortController\n                let effectiveSignal = signal;\n                if (timeout) {\n                    timeoutController = new AbortController();\n                    timeoutId = setTimeout(()=>timeoutController.abort(), timeout);\n                    // If user provided their own signal, we need to respect both\n                    if (signal) {\n                        effectiveSignal = timeoutController.signal;\n                        // If the user's signal is aborted, abort our timeout controller too\n                        signal.addEventListener(\"abort\", ()=>timeoutController.abort());\n                    } else {\n                        effectiveSignal = timeoutController.signal;\n                    }\n                }\n                const response = yield this.fetch(url.toString(), {\n                    method: method || \"POST\",\n                    // headers priority is (high to low):\n                    // 1. invoke-level headers\n                    // 2. client-level headers\n                    // 3. default Content-Type header\n                    headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),\n                    body,\n                    signal: effectiveSignal\n                }).catch((fetchError)=>{\n                    throw new _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsFetchError(fetchError);\n                });\n                const isRelayError = response.headers.get(\"x-relay-error\");\n                if (isRelayError && isRelayError === \"true\") {\n                    throw new _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsRelayError(response);\n                }\n                if (!response.ok) {\n                    throw new _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsHttpError(response);\n                }\n                let responseType = ((_a = response.headers.get(\"Content-Type\")) !== null && _a !== void 0 ? _a : \"text/plain\").split(\";\")[0].trim();\n                let data;\n                if (responseType === \"application/json\") {\n                    data = yield response.json();\n                } else if (responseType === \"application/octet-stream\" || responseType === \"application/pdf\") {\n                    data = yield response.blob();\n                } else if (responseType === \"text/event-stream\") {\n                    data = response;\n                } else if (responseType === \"multipart/form-data\") {\n                    data = yield response.formData();\n                } else {\n                    // default to text\n                    data = yield response.text();\n                }\n                return {\n                    data,\n                    error: null,\n                    response\n                };\n            } catch (error) {\n                return {\n                    data: null,\n                    error,\n                    response: error instanceof _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsHttpError || error instanceof _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsRelayError ? error.context : undefined\n                };\n            } finally{\n                // Clear the timeout if it was set\n                if (timeoutId) {\n                    clearTimeout(timeoutId);\n                }\n            }\n        });\n    }\n} //# sourceMappingURL=FunctionsClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcy9kaXN0L21vZHVsZS9GdW5jdGlvbnNDbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFrQztBQUNNO0FBQ2dFO0FBQ3hHOztDQUVDLEdBQ00sTUFBTU07SUFDVDs7Ozs7Ozs7Ozs7O0tBWUMsR0FDREMsWUFBWUMsR0FBRyxFQUFFLEVBQUVDLFVBQVUsQ0FBQyxDQUFDLEVBQUVDLFdBQVcsRUFBRUMsU0FBU1Qsa0RBQWNBLENBQUNVLEdBQUcsRUFBRyxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQy9FLElBQUksQ0FBQ0osR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0UsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0UsS0FBSyxHQUFHWixxREFBWUEsQ0FBQ1M7SUFDOUI7SUFDQTs7Ozs7OztLQU9DLEdBQ0RJLFFBQVFDLEtBQUssRUFBRTtRQUNYLElBQUksQ0FBQ04sT0FBTyxDQUFDTyxhQUFhLEdBQUcsQ0FBQyxPQUFPLEVBQUVELE1BQU0sQ0FBQztJQUNsRDtJQUNBOzs7Ozs7Ozs7O0tBVUMsR0FDREUsT0FBT0MsY0FBYyxFQUFFO1FBQ25CLE9BQU9sQixnREFBU0EsQ0FBQyxJQUFJLEVBQUVtQixXQUFXLEtBQUssR0FBRyxVQUFXQyxZQUFZLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO1lBQzNFLElBQUlDO1lBQ0osSUFBSUM7WUFDSixJQUFJQztZQUNKLElBQUk7Z0JBQ0EsTUFBTSxFQUFFZixPQUFPLEVBQUVnQixNQUFNLEVBQUVDLE1BQU1DLFlBQVksRUFBRUMsTUFBTSxFQUFFQyxPQUFPLEVBQUUsR0FBR1I7Z0JBQ2pFLElBQUlTLFdBQVcsQ0FBQztnQkFDaEIsSUFBSSxFQUFFbkIsTUFBTSxFQUFFLEdBQUdVO2dCQUNqQixJQUFJLENBQUNWLFFBQVE7b0JBQ1RBLFNBQVMsSUFBSSxDQUFDQSxNQUFNO2dCQUN4QjtnQkFDQSw4Q0FB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MEIsU0FBU3ZDLE9BQU8sQ0FBQzZDLEdBQUcsQ0FBQyxlQUFjLE1BQU8sUUFBUWhDLE9BQU8sS0FBSyxJQUFJQSxLQUFLLFlBQVcsRUFBR21DLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDQyxJQUFJO2dCQUNqSSxJQUFJQztnQkFDSixJQUFJSCxpQkFBaUIsb0JBQW9CO29CQUNyQ0csT0FBTyxNQUFNWCxTQUFTWSxJQUFJO2dCQUM5QixPQUNLLElBQUlKLGlCQUFpQiw4QkFDdEJBLGlCQUFpQixtQkFBbUI7b0JBQ3BDRyxPQUFPLE1BQU1YLFNBQVNhLElBQUk7Z0JBQzlCLE9BQ0ssSUFBSUwsaUJBQWlCLHFCQUFxQjtvQkFDM0NHLE9BQU9YO2dCQUNYLE9BQ0ssSUFBSVEsaUJBQWlCLHVCQUF1QjtvQkFDN0NHLE9BQU8sTUFBTVgsU0FBU2MsUUFBUTtnQkFDbEMsT0FDSztvQkFDRCxrQkFBa0I7b0JBQ2xCSCxPQUFPLE1BQU1YLFNBQVNlLElBQUk7Z0JBQzlCO2dCQUNBLE9BQU87b0JBQUVKO29CQUFNSyxPQUFPO29CQUFNaEI7Z0JBQVM7WUFDekMsRUFDQSxPQUFPZ0IsT0FBTztnQkFDVixPQUFPO29CQUNITCxNQUFNO29CQUNOSztvQkFDQWhCLFVBQVVnQixpQkFBaUI1RCxzREFBa0JBLElBQUk0RCxpQkFBaUIzRCx1REFBbUJBLEdBQy9FMkQsTUFBTUMsT0FBTyxHQUNiQztnQkFDVjtZQUNKLFNBQ1E7Z0JBQ0osa0NBQWtDO2dCQUNsQyxJQUFJM0MsV0FBVztvQkFDWDRDLGFBQWE1QztnQkFDakI7WUFDSjtRQUNKO0lBQ0o7QUFDSixFQUNBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FuY2hvci13b3JrZmxvd3MvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcy9kaXN0L21vZHVsZS9GdW5jdGlvbnNDbGllbnQuanM/NWMzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2F3YWl0ZXIgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IHJlc29sdmVGZXRjaCB9IGZyb20gJy4vaGVscGVyJztcbmltcG9ydCB7IEZ1bmN0aW9uUmVnaW9uLCBGdW5jdGlvbnNGZXRjaEVycm9yLCBGdW5jdGlvbnNIdHRwRXJyb3IsIEZ1bmN0aW9uc1JlbGF5RXJyb3IsIH0gZnJvbSAnLi90eXBlcyc7XG4vKipcbiAqIENsaWVudCBmb3IgaW52b2tpbmcgU3VwYWJhc2UgRWRnZSBGdW5jdGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbnNDbGllbnQge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRnVuY3Rpb25zIGNsaWVudCBib3VuZCB0byBhbiBFZGdlIEZ1bmN0aW9ucyBVUkwuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogaW1wb3J0IHsgRnVuY3Rpb25zQ2xpZW50LCBGdW5jdGlvblJlZ2lvbiB9IGZyb20gJ0BzdXBhYmFzZS9mdW5jdGlvbnMtanMnXG4gICAgICpcbiAgICAgKiBjb25zdCBmdW5jdGlvbnMgPSBuZXcgRnVuY3Rpb25zQ2xpZW50KCdodHRwczovL3h5emNvbXBhbnkuc3VwYWJhc2UuY28vZnVuY3Rpb25zL3YxJywge1xuICAgICAqICAgaGVhZGVyczogeyBhcGlrZXk6ICdwdWJsaWMtYW5vbi1rZXknIH0sXG4gICAgICogICByZWdpb246IEZ1bmN0aW9uUmVnaW9uLlVzRWFzdDEsXG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmwsIHsgaGVhZGVycyA9IHt9LCBjdXN0b21GZXRjaCwgcmVnaW9uID0gRnVuY3Rpb25SZWdpb24uQW55LCB9ID0ge30pIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIHRoaXMucmVnaW9uID0gcmVnaW9uO1xuICAgICAgICB0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKGN1c3RvbUZldGNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgYXV0aG9yaXphdGlvbiBoZWFkZXJcbiAgICAgKiBAcGFyYW0gdG9rZW4gLSB0aGUgbmV3IGp3dCB0b2tlbiBzZW50IGluIHRoZSBhdXRob3Jpc2F0aW9uIGhlYWRlclxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBmdW5jdGlvbnMuc2V0QXV0aChzZXNzaW9uLmFjY2Vzc190b2tlbilcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzZXRBdXRoKHRva2VuKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke3Rva2VufWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZXMgYSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSBmdW5jdGlvbk5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgRnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgaW52b2tpbmcgdGhlIEZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBmdW5jdGlvbnMuaW52b2tlKCdoZWxsby13b3JsZCcsIHtcbiAgICAgKiAgIGJvZHk6IHsgbmFtZTogJ0FkYScgfSxcbiAgICAgKiB9KVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGludm9rZShmdW5jdGlvbk5hbWVfMSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiogKGZ1bmN0aW9uTmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBsZXQgdGltZW91dElkO1xuICAgICAgICAgICAgbGV0IHRpbWVvdXRDb250cm9sbGVyO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGhlYWRlcnMsIG1ldGhvZCwgYm9keTogZnVuY3Rpb25BcmdzLCBzaWduYWwsIHRpbWVvdXQgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgbGV0IF9oZWFkZXJzID0ge307XG4gICAgICAgICAgICAgICAgbGV0IHsgcmVnaW9uIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgICAgIGlmICghcmVnaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lvbiA9IHRoaXMucmVnaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBZGQgcmVnaW9uIGFzIHF1ZXJ5IHBhcmFtZXRlciB1c2luZyBVUkwgQVBJXG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHt0aGlzLnVybH0vJHtmdW5jdGlvbk5hbWV9YCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZ2lvbiAmJiByZWdpb24gIT09ICdhbnknKSB7XG4gICAgICAgICAgICAgICAgICAgIF9oZWFkZXJzWyd4LXJlZ2lvbiddID0gcmVnaW9uO1xuICAgICAgICAgICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnZm9yY2VGdW5jdGlvblJlZ2lvbicsIHJlZ2lvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBib2R5O1xuICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbkFyZ3MgJiZcbiAgICAgICAgICAgICAgICAgICAgKChoZWFkZXJzICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaGVhZGVycywgJ0NvbnRlbnQtVHlwZScpKSB8fCAhaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgZnVuY3Rpb25BcmdzIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uQXJncyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIHdvcmsgZm9yIEZpbGUgYXMgRmlsZSBpbmhlcml0cyBCbG9iXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIHdvcmtzIGZvciBBcnJheUJ1ZmZlciBhcyBpdCBpcyB0aGUgc2FtZSB1bmRlcmx5aW5nIHN0cnVjdHVyZSBhcyBhIEJsb2JcbiAgICAgICAgICAgICAgICAgICAgICAgIF9oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IGZ1bmN0aW9uQXJncztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZnVuY3Rpb25BcmdzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGxhaW4gc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBfaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAndGV4dC9wbGFpbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gZnVuY3Rpb25BcmdzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgZnVuY3Rpb25BcmdzIGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IHNldCBjb250ZW50LXR5cGUgaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVxdWVzdCB3aWxsIGF1dG9tYXRpY2FsbHkgYWRkIHRoZSByaWdodCBib3VuZGFyeSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IGZ1bmN0aW9uQXJncztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQsIGFzc3VtZSB0aGlzIGlzIEpTT05cbiAgICAgICAgICAgICAgICAgICAgICAgIF9oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShmdW5jdGlvbkFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25BcmdzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZnVuY3Rpb25BcmdzICE9PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgISh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgZnVuY3Rpb25BcmdzIGluc3RhbmNlb2YgQmxvYikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICEoZnVuY3Rpb25BcmdzIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgZnVuY3Rpb25BcmdzIGluc3RhbmNlb2YgRm9ybURhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkoZnVuY3Rpb25BcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBmdW5jdGlvbkFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIHRpbWVvdXQgYnkgY3JlYXRpbmcgYW4gQWJvcnRDb250cm9sbGVyXG4gICAgICAgICAgICAgICAgbGV0IGVmZmVjdGl2ZVNpZ25hbCA9IHNpZ25hbDtcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB0aW1lb3V0Q29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdXNlciBwcm92aWRlZCB0aGVpciBvd24gc2lnbmFsLCB3ZSBuZWVkIHRvIHJlc3BlY3QgYm90aFxuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZmZlY3RpdmVTaWduYWwgPSB0aW1lb3V0Q29udHJvbGxlci5zaWduYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdXNlcidzIHNpZ25hbCBpcyBhYm9ydGVkLCBhYm9ydCBvdXIgdGltZW91dCBjb250cm9sbGVyIHRvb1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4gdGltZW91dENvbnRyb2xsZXIuYWJvcnQoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZmZlY3RpdmVTaWduYWwgPSB0aW1lb3V0Q29udHJvbGxlci5zaWduYWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmZldGNoKHVybC50b1N0cmluZygpLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kIHx8ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgLy8gaGVhZGVycyBwcmlvcml0eSBpcyAoaGlnaCB0byBsb3cpOlxuICAgICAgICAgICAgICAgICAgICAvLyAxLiBpbnZva2UtbGV2ZWwgaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgICAvLyAyLiBjbGllbnQtbGV2ZWwgaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgICAvLyAzLiBkZWZhdWx0IENvbnRlbnQtVHlwZSBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIF9oZWFkZXJzKSwgdGhpcy5oZWFkZXJzKSwgaGVhZGVycyksXG4gICAgICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hbDogZWZmZWN0aXZlU2lnbmFsLFxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKChmZXRjaEVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGdW5jdGlvbnNGZXRjaEVycm9yKGZldGNoRXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVsYXlFcnJvciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LXJlbGF5LWVycm9yJyk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVsYXlFcnJvciAmJiBpc1JlbGF5RXJyb3IgPT09ICd0cnVlJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRnVuY3Rpb25zUmVsYXlFcnJvcihyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZ1bmN0aW9uc0h0dHBFcnJvcihyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZVR5cGUgPSAoKF9hID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAndGV4dC9wbGFpbicpLnNwbGl0KCc7JylbMF0udHJpbSgpO1xuICAgICAgICAgICAgICAgIGxldCBkYXRhO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVR5cGUgPT09ICdhcHBsaWNhdGlvbi9qc29uJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0geWllbGQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZVR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nIHx8XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlVHlwZSA9PT0gJ2FwcGxpY2F0aW9uL3BkZicpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHlpZWxkIHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzcG9uc2VUeXBlID09PSAndGV4dC9ldmVudC1zdHJlYW0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzcG9uc2VUeXBlID09PSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHlpZWxkIHJlc3BvbnNlLmZvcm1EYXRhKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHRvIHRleHRcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHlpZWxkIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwsIHJlc3BvbnNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IGVycm9yIGluc3RhbmNlb2YgRnVuY3Rpb25zSHR0cEVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRnVuY3Rpb25zUmVsYXlFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBlcnJvci5jb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIHRpbWVvdXQgaWYgaXQgd2FzIHNldFxuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GdW5jdGlvbnNDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInJlc29sdmVGZXRjaCIsIkZ1bmN0aW9uUmVnaW9uIiwiRnVuY3Rpb25zRmV0Y2hFcnJvciIsIkZ1bmN0aW9uc0h0dHBFcnJvciIsIkZ1bmN0aW9uc1JlbGF5RXJyb3IiLCJGdW5jdGlvbnNDbGllbnQiLCJjb25zdHJ1Y3RvciIsInVybCIsImhlYWRlcnMiLCJjdXN0b21GZXRjaCIsInJlZ2lvbiIsIkFueSIsImZldGNoIiwic2V0QXV0aCIsInRva2VuIiwiQXV0aG9yaXphdGlvbiIsImludm9rZSIsImZ1bmN0aW9uTmFtZV8xIiwiYXJndW1lbnRzIiwiZnVuY3Rpb25OYW1lIiwib3B0aW9ucyIsIl9hIiwidGltZW91dElkIiwidGltZW91dENvbnRyb2xsZXIiLCJtZXRob2QiLCJib2R5IiwiZnVuY3Rpb25BcmdzIiwic2lnbmFsIiwidGltZW91dCIsIl9oZWFkZXJzIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwic2V0IiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiQmxvYiIsIkFycmF5QnVmZmVyIiwiRm9ybURhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwiZWZmZWN0aXZlU2lnbmFsIiwiQWJvcnRDb250cm9sbGVyIiwic2V0VGltZW91dCIsImFib3J0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlc3BvbnNlIiwidG9TdHJpbmciLCJhc3NpZ24iLCJjYXRjaCIsImZldGNoRXJyb3IiLCJpc1JlbGF5RXJyb3IiLCJnZXQiLCJvayIsInJlc3BvbnNlVHlwZSIsInNwbGl0IiwidHJpbSIsImRhdGEiLCJqc29uIiwiYmxvYiIsImZvcm1EYXRhIiwidGV4dCIsImVycm9yIiwiY29udGV4dCIsInVuZGVmaW5lZCIsImNsZWFyVGltZW91dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/functions-js/dist/module/helper.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/functions-js/dist/module/helper.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch)\n/* harmony export */ });\nconst resolveFetch = (customFetch)=>{\n    if (customFetch) {\n        return (...args)=>customFetch(...args);\n    }\n    return (...args)=>fetch(...args);\n}; //# sourceMappingURL=helper.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcy9kaXN0L21vZHVsZS9oZWxwZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLGVBQWUsQ0FBQ0M7SUFDekIsSUFBSUEsYUFBYTtRQUNiLE9BQU8sQ0FBQyxHQUFHQyxPQUFTRCxlQUFlQztJQUN2QztJQUNBLE9BQU8sQ0FBQyxHQUFHQSxPQUFTQyxTQUFTRDtBQUNqQyxFQUFFLENBQ0Ysa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5jaG9yLXdvcmtmbG93cy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL2Rpc3QvbW9kdWxlL2hlbHBlci5qcz9iNjk1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2gpID0+IHtcbiAgICBpZiAoY3VzdG9tRmV0Y2gpIHtcbiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiBjdXN0b21GZXRjaCguLi5hcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiBmZXRjaCguLi5hcmdzKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXIuanMubWFwIl0sIm5hbWVzIjpbInJlc29sdmVGZXRjaCIsImN1c3RvbUZldGNoIiwiYXJncyIsImZldGNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/functions-js/dist/module/helper.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/functions-js/dist/module/types.js":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/functions-js/dist/module/types.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FunctionRegion: () => (/* binding */ FunctionRegion),\n/* harmony export */   FunctionsError: () => (/* binding */ FunctionsError),\n/* harmony export */   FunctionsFetchError: () => (/* binding */ FunctionsFetchError),\n/* harmony export */   FunctionsHttpError: () => (/* binding */ FunctionsHttpError),\n/* harmony export */   FunctionsRelayError: () => (/* binding */ FunctionsRelayError)\n/* harmony export */ });\n/**\n * Base error for Supabase Edge Function invocations.\n *\n * @example\n * ```ts\n * import { FunctionsError } from '@supabase/functions-js'\n *\n * throw new FunctionsError('Unexpected error invoking function', 'FunctionsError', {\n *   requestId: 'abc123',\n * })\n * ```\n */ class FunctionsError extends Error {\n    constructor(message, name = \"FunctionsError\", context){\n        super(message);\n        this.name = name;\n        this.context = context;\n    }\n}\n/**\n * Error thrown when the network request to an Edge Function fails.\n *\n * @example\n * ```ts\n * import { FunctionsFetchError } from '@supabase/functions-js'\n *\n * throw new FunctionsFetchError({ requestId: 'abc123' })\n * ```\n */ class FunctionsFetchError extends FunctionsError {\n    constructor(context){\n        super(\"Failed to send a request to the Edge Function\", \"FunctionsFetchError\", context);\n    }\n}\n/**\n * Error thrown when the Supabase relay cannot reach the Edge Function.\n *\n * @example\n * ```ts\n * import { FunctionsRelayError } from '@supabase/functions-js'\n *\n * throw new FunctionsRelayError({ region: 'us-east-1' })\n * ```\n */ class FunctionsRelayError extends FunctionsError {\n    constructor(context){\n        super(\"Relay Error invoking the Edge Function\", \"FunctionsRelayError\", context);\n    }\n}\n/**\n * Error thrown when the Edge Function returns a non-2xx status code.\n *\n * @example\n * ```ts\n * import { FunctionsHttpError } from '@supabase/functions-js'\n *\n * throw new FunctionsHttpError({ status: 500 })\n * ```\n */ class FunctionsHttpError extends FunctionsError {\n    constructor(context){\n        super(\"Edge Function returned a non-2xx status code\", \"FunctionsHttpError\", context);\n    }\n}\n// Define the enum for the 'region' property\nvar FunctionRegion;\n(function(FunctionRegion) {\n    FunctionRegion[\"Any\"] = \"any\";\n    FunctionRegion[\"ApNortheast1\"] = \"ap-northeast-1\";\n    FunctionRegion[\"ApNortheast2\"] = \"ap-northeast-2\";\n    FunctionRegion[\"ApSouth1\"] = \"ap-south-1\";\n    FunctionRegion[\"ApSoutheast1\"] = \"ap-southeast-1\";\n    FunctionRegion[\"ApSoutheast2\"] = \"ap-southeast-2\";\n    FunctionRegion[\"CaCentral1\"] = \"ca-central-1\";\n    FunctionRegion[\"EuCentral1\"] = \"eu-central-1\";\n    FunctionRegion[\"EuWest1\"] = \"eu-west-1\";\n    FunctionRegion[\"EuWest2\"] = \"eu-west-2\";\n    FunctionRegion[\"EuWest3\"] = \"eu-west-3\";\n    FunctionRegion[\"SaEast1\"] = \"sa-east-1\";\n    FunctionRegion[\"UsEast1\"] = \"us-east-1\";\n    FunctionRegion[\"UsWest1\"] = \"us-west-1\";\n    FunctionRegion[\"UsWest2\"] = \"us-west-2\";\n})(FunctionRegion || (FunctionRegion = {})); //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcy9kaXN0L21vZHVsZS90eXBlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7Ozs7Ozs7OztDQVdDLEdBQ00sTUFBTUEsdUJBQXVCQztJQUNoQ0MsWUFBWUMsT0FBTyxFQUFFQyxPQUFPLGdCQUFnQixFQUFFQyxPQUFPLENBQUU7UUFDbkQsS0FBSyxDQUFDRjtRQUNOLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtJQUNuQjtBQUNKO0FBQ0E7Ozs7Ozs7OztDQVNDLEdBQ00sTUFBTUMsNEJBQTRCTjtJQUNyQ0UsWUFBWUcsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQyxpREFBaUQsdUJBQXVCQTtJQUNsRjtBQUNKO0FBQ0E7Ozs7Ozs7OztDQVNDLEdBQ00sTUFBTUUsNEJBQTRCUDtJQUNyQ0UsWUFBWUcsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQywwQ0FBMEMsdUJBQXVCQTtJQUMzRTtBQUNKO0FBQ0E7Ozs7Ozs7OztDQVNDLEdBQ00sTUFBTUcsMkJBQTJCUjtJQUNwQ0UsWUFBWUcsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQyxnREFBZ0Qsc0JBQXNCQTtJQUNoRjtBQUNKO0FBQ0EsNENBQTRDO0FBQ3JDLElBQUlJLGVBQWU7QUFDekIsVUFBVUEsY0FBYztJQUNyQkEsY0FBYyxDQUFDLE1BQU0sR0FBRztJQUN4QkEsY0FBYyxDQUFDLGVBQWUsR0FBRztJQUNqQ0EsY0FBYyxDQUFDLGVBQWUsR0FBRztJQUNqQ0EsY0FBYyxDQUFDLFdBQVcsR0FBRztJQUM3QkEsY0FBYyxDQUFDLGVBQWUsR0FBRztJQUNqQ0EsY0FBYyxDQUFDLGVBQWUsR0FBRztJQUNqQ0EsY0FBYyxDQUFDLGFBQWEsR0FBRztJQUMvQkEsY0FBYyxDQUFDLGFBQWEsR0FBRztJQUMvQkEsY0FBYyxDQUFDLFVBQVUsR0FBRztJQUM1QkEsY0FBYyxDQUFDLFVBQVUsR0FBRztJQUM1QkEsY0FBYyxDQUFDLFVBQVUsR0FBRztJQUM1QkEsY0FBYyxDQUFDLFVBQVUsR0FBRztJQUM1QkEsY0FBYyxDQUFDLFVBQVUsR0FBRztJQUM1QkEsY0FBYyxDQUFDLFVBQVUsR0FBRztJQUM1QkEsY0FBYyxDQUFDLFVBQVUsR0FBRztBQUNoQyxHQUFHQSxrQkFBbUJBLENBQUFBLGlCQUFpQixDQUFDLEtBQ3hDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FuY2hvci13b3JrZmxvd3MvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcy9kaXN0L21vZHVsZS90eXBlcy5qcz82ODhlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQmFzZSBlcnJvciBmb3IgU3VwYWJhc2UgRWRnZSBGdW5jdGlvbiBpbnZvY2F0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEZ1bmN0aW9uc0Vycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcydcbiAqXG4gKiB0aHJvdyBuZXcgRnVuY3Rpb25zRXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3IgaW52b2tpbmcgZnVuY3Rpb24nLCAnRnVuY3Rpb25zRXJyb3InLCB7XG4gKiAgIHJlcXVlc3RJZDogJ2FiYzEyMycsXG4gKiB9KVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbnNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBuYW1lID0gJ0Z1bmN0aW9uc0Vycm9yJywgY29udGV4dCkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG59XG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIHRoZSBuZXR3b3JrIHJlcXVlc3QgdG8gYW4gRWRnZSBGdW5jdGlvbiBmYWlscy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEZ1bmN0aW9uc0ZldGNoRXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvZnVuY3Rpb25zLWpzJ1xuICpcbiAqIHRocm93IG5ldyBGdW5jdGlvbnNGZXRjaEVycm9yKHsgcmVxdWVzdElkOiAnYWJjMTIzJyB9KVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbnNGZXRjaEVycm9yIGV4dGVuZHMgRnVuY3Rpb25zRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoJ0ZhaWxlZCB0byBzZW5kIGEgcmVxdWVzdCB0byB0aGUgRWRnZSBGdW5jdGlvbicsICdGdW5jdGlvbnNGZXRjaEVycm9yJywgY29udGV4dCk7XG4gICAgfVxufVxuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiB0aGUgU3VwYWJhc2UgcmVsYXkgY2Fubm90IHJlYWNoIHRoZSBFZGdlIEZ1bmN0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgRnVuY3Rpb25zUmVsYXlFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9mdW5jdGlvbnMtanMnXG4gKlxuICogdGhyb3cgbmV3IEZ1bmN0aW9uc1JlbGF5RXJyb3IoeyByZWdpb246ICd1cy1lYXN0LTEnIH0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uc1JlbGF5RXJyb3IgZXh0ZW5kcyBGdW5jdGlvbnNFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICBzdXBlcignUmVsYXkgRXJyb3IgaW52b2tpbmcgdGhlIEVkZ2UgRnVuY3Rpb24nLCAnRnVuY3Rpb25zUmVsYXlFcnJvcicsIGNvbnRleHQpO1xuICAgIH1cbn1cbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlIEVkZ2UgRnVuY3Rpb24gcmV0dXJucyBhIG5vbi0yeHggc3RhdHVzIGNvZGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBGdW5jdGlvbnNIdHRwRXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvZnVuY3Rpb25zLWpzJ1xuICpcbiAqIHRocm93IG5ldyBGdW5jdGlvbnNIdHRwRXJyb3IoeyBzdGF0dXM6IDUwMCB9KVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbnNIdHRwRXJyb3IgZXh0ZW5kcyBGdW5jdGlvbnNFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICBzdXBlcignRWRnZSBGdW5jdGlvbiByZXR1cm5lZCBhIG5vbi0yeHggc3RhdHVzIGNvZGUnLCAnRnVuY3Rpb25zSHR0cEVycm9yJywgY29udGV4dCk7XG4gICAgfVxufVxuLy8gRGVmaW5lIHRoZSBlbnVtIGZvciB0aGUgJ3JlZ2lvbicgcHJvcGVydHlcbmV4cG9ydCB2YXIgRnVuY3Rpb25SZWdpb247XG4oZnVuY3Rpb24gKEZ1bmN0aW9uUmVnaW9uKSB7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJBbnlcIl0gPSBcImFueVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiQXBOb3J0aGVhc3QxXCJdID0gXCJhcC1ub3J0aGVhc3QtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiQXBOb3J0aGVhc3QyXCJdID0gXCJhcC1ub3J0aGVhc3QtMlwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiQXBTb3V0aDFcIl0gPSBcImFwLXNvdXRoLTFcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkFwU291dGhlYXN0MVwiXSA9IFwiYXAtc291dGhlYXN0LTFcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkFwU291dGhlYXN0MlwiXSA9IFwiYXAtc291dGhlYXN0LTJcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkNhQ2VudHJhbDFcIl0gPSBcImNhLWNlbnRyYWwtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiRXVDZW50cmFsMVwiXSA9IFwiZXUtY2VudHJhbC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJFdVdlc3QxXCJdID0gXCJldS13ZXN0LTFcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkV1V2VzdDJcIl0gPSBcImV1LXdlc3QtMlwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiRXVXZXN0M1wiXSA9IFwiZXUtd2VzdC0zXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJTYUVhc3QxXCJdID0gXCJzYS1lYXN0LTFcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIlVzRWFzdDFcIl0gPSBcInVzLWVhc3QtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiVXNXZXN0MVwiXSA9IFwidXMtd2VzdC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJVc1dlc3QyXCJdID0gXCJ1cy13ZXN0LTJcIjtcbn0pKEZ1bmN0aW9uUmVnaW9uIHx8IChGdW5jdGlvblJlZ2lvbiA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOlsiRnVuY3Rpb25zRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsIm5hbWUiLCJjb250ZXh0IiwiRnVuY3Rpb25zRmV0Y2hFcnJvciIsIkZ1bmN0aW9uc1JlbGF5RXJyb3IiLCJGdW5jdGlvbnNIdHRwRXJyb3IiLCJGdW5jdGlvblJlZ2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/functions-js/dist/module/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   REALTIME_CHANNEL_STATES: () => (/* binding */ REALTIME_CHANNEL_STATES),\n/* harmony export */   REALTIME_LISTEN_TYPES: () => (/* binding */ REALTIME_LISTEN_TYPES),\n/* harmony export */   REALTIME_POSTGRES_CHANGES_LISTEN_EVENT: () => (/* binding */ REALTIME_POSTGRES_CHANGES_LISTEN_EVENT),\n/* harmony export */   REALTIME_SUBSCRIBE_STATES: () => (/* binding */ REALTIME_SUBSCRIBE_STATES),\n/* harmony export */   \"default\": () => (/* binding */ RealtimeChannel)\n/* harmony export */ });\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/constants */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_push__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/push */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/push.js\");\n/* harmony import */ var _lib_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/timer */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js\");\n/* harmony import */ var _RealtimePresence__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RealtimePresence */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js\");\n/* harmony import */ var _lib_transformers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/transformers */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js\");\n\n\n\n\n\n\nvar REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n(function(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\nvar REALTIME_LISTEN_TYPES;\n(function(REALTIME_LISTEN_TYPES) {\n    REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\n    REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\n    REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n    REALTIME_LISTEN_TYPES[\"SYSTEM\"] = \"system\";\n})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));\nvar REALTIME_SUBSCRIBE_STATES;\n(function(REALTIME_SUBSCRIBE_STATES) {\n    REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n    REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\n    REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\n    REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));\nconst REALTIME_CHANNEL_STATES = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES;\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n */ class RealtimeChannel {\n    /**\n     * Creates a channel that can broadcast messages, sync presence, and listen to Postgres changes.\n     *\n     * The topic determines which realtime stream you are subscribing to. Config options let you\n     * enable acknowledgement for broadcasts, presence tracking, or private channels.\n     *\n     * @example\n     * ```ts\n     * import RealtimeClient from '@supabase/realtime-js'\n     *\n     * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {\n     *   params: { apikey: 'public-anon-key' },\n     * })\n     * const channel = new RealtimeChannel('realtime:public:messages', { config: {} }, client)\n     * ```\n     */ constructor(/** Topic name can be any string. */ topic, params = {\n        config: {}\n    }, socket){\n        var _a, _b;\n        this.topic = topic;\n        this.params = params;\n        this.socket = socket;\n        this.bindings = {};\n        this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;\n        this.joinedOnce = false;\n        this.pushBuffer = [];\n        this.subTopic = topic.replace(/^realtime:/i, \"\");\n        this.params.config = Object.assign({\n            broadcast: {\n                ack: false,\n                self: false\n            },\n            presence: {\n                key: \"\",\n                enabled: false\n            },\n            private: false\n        }, params.config);\n        this.timeout = this.socket.timeout;\n        this.joinPush = new _lib_push__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.join, this.params, this.timeout);\n        this.rejoinTimer = new _lib_timer__WEBPACK_IMPORTED_MODULE_2__[\"default\"](()=>this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\n        this.joinPush.receive(\"ok\", ()=>{\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joined;\n            this.rejoinTimer.reset();\n            this.pushBuffer.forEach((pushEvent)=>pushEvent.send());\n            this.pushBuffer = [];\n        });\n        this._onClose(()=>{\n            this.rejoinTimer.reset();\n            this.socket.log(\"channel\", `close ${this.topic} ${this._joinRef()}`);\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;\n            this.socket._remove(this);\n        });\n        this._onError((reason)=>{\n            if (this._isLeaving() || this._isClosed()) {\n                return;\n            }\n            this.socket.log(\"channel\", `error ${this.topic}`, reason);\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive(\"timeout\", ()=>{\n            if (!this._isJoining()) {\n                return;\n            }\n            this.socket.log(\"channel\", `timeout ${this.topic}`, this.joinPush.timeout);\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive(\"error\", (reason)=>{\n            if (this._isLeaving() || this._isClosed()) {\n                return;\n            }\n            this.socket.log(\"channel\", `error ${this.topic}`, reason);\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this._on(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.reply, {}, (payload, ref)=>{\n            this._trigger(this._replyEventName(ref), payload);\n        });\n        this.presence = new _RealtimePresence__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this);\n        this.broadcastEndpointURL = (0,_lib_transformers__WEBPACK_IMPORTED_MODULE_4__.httpEndpointURL)(this.socket.endPoint);\n        this.private = this.params.config.private || false;\n        if (!this.private && ((_b = (_a = this.params.config) === null || _a === void 0 ? void 0 : _a.broadcast) === null || _b === void 0 ? void 0 : _b.replay)) {\n            throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`;\n        }\n    }\n    /** Subscribe registers your client with the server */ subscribe(callback, timeout = this.timeout) {\n        var _a, _b, _c;\n        if (!this.socket.isConnected()) {\n            this.socket.connect();\n        }\n        if (this.state == _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed) {\n            const { config: { broadcast, presence, private: isPrivate } } = this.params;\n            const postgres_changes = (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map((r)=>r.filter)) !== null && _b !== void 0 ? _b : [];\n            const presence_enabled = !!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE] && this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length > 0 || ((_c = this.params.config.presence) === null || _c === void 0 ? void 0 : _c.enabled) === true;\n            const accessTokenPayload = {};\n            const config = {\n                broadcast,\n                presence: Object.assign(Object.assign({}, presence), {\n                    enabled: presence_enabled\n                }),\n                postgres_changes,\n                private: isPrivate\n            };\n            if (this.socket.accessTokenValue) {\n                accessTokenPayload.access_token = this.socket.accessTokenValue;\n            }\n            this._onError((e)=>callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));\n            this._onClose(()=>callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));\n            this.updateJoinPayload(Object.assign({\n                config\n            }, accessTokenPayload));\n            this.joinedOnce = true;\n            this._rejoin(timeout);\n            this.joinPush.receive(\"ok\", async ({ postgres_changes })=>{\n                var _a;\n                // Only refresh auth if using callback-based tokens\n                if (!this.socket._isManualToken()) {\n                    this.socket.setAuth();\n                }\n                if (postgres_changes === undefined) {\n                    callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n                    return;\n                } else {\n                    const clientPostgresBindings = this.bindings.postgres_changes;\n                    const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\n                    const newPostgresBindings = [];\n                    for(let i = 0; i < bindingsLen; i++){\n                        const clientPostgresBinding = clientPostgresBindings[i];\n                        const { filter: { event, schema, table, filter } } = clientPostgresBinding;\n                        const serverPostgresFilter = postgres_changes && postgres_changes[i];\n                        if (serverPostgresFilter && serverPostgresFilter.event === event && RealtimeChannel.isFilterValueEqual(serverPostgresFilter.schema, schema) && RealtimeChannel.isFilterValueEqual(serverPostgresFilter.table, table) && RealtimeChannel.isFilterValueEqual(serverPostgresFilter.filter, filter)) {\n                            newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), {\n                                id: serverPostgresFilter.id\n                            }));\n                        } else {\n                            this.unsubscribe();\n                            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n                            callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(\"mismatch between server and client bindings for postgres changes\"));\n                            return;\n                        }\n                    }\n                    this.bindings.postgres_changes = newPostgresBindings;\n                    callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n                    return;\n                }\n            }).receive(\"error\", (error)=>{\n                this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(\", \") || \"error\")));\n                return;\n            }).receive(\"timeout\", ()=>{\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);\n                return;\n            });\n        }\n        return this;\n    }\n    /**\n     * Returns the current presence state for this channel.\n     *\n     * The shape is a map keyed by presence key (for example a user id) where each entry contains the\n     * tracked metadata for that user.\n     */ presenceState() {\n        return this.presence.state;\n    }\n    /**\n     * Sends the supplied payload to the presence tracker so other subscribers can see that this\n     * client is online. Use `untrack` to stop broadcasting presence for the same key.\n     */ async track(payload, opts = {}) {\n        return await this.send({\n            type: \"presence\",\n            event: \"track\",\n            payload\n        }, opts.timeout || this.timeout);\n    }\n    /**\n     * Removes the current presence state for this client.\n     */ async untrack(opts = {}) {\n        return await this.send({\n            type: \"presence\",\n            event: \"untrack\"\n        }, opts);\n    }\n    on(type, filter, callback) {\n        if (this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joined && type === REALTIME_LISTEN_TYPES.PRESENCE) {\n            this.socket.log(\"channel\", `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`);\n            this.unsubscribe().then(async ()=>await this.subscribe());\n        }\n        return this._on(type, filter, callback);\n    }\n    /**\n     * Sends a broadcast message explicitly via REST API.\n     *\n     * This method always uses the REST API endpoint regardless of WebSocket connection state.\n     * Useful when you want to guarantee REST delivery or when gradually migrating from implicit REST fallback.\n     *\n     * @param event The name of the broadcast event\n     * @param payload Payload to be sent (required)\n     * @param opts Options including timeout\n     * @returns Promise resolving to object with success status, and error details if failed\n     */ async httpSend(event, payload, opts = {}) {\n        var _a;\n        if (payload === undefined || payload === null) {\n            return Promise.reject(\"Payload is required for httpSend()\");\n        }\n        const headers = {\n            apikey: this.socket.apiKey ? this.socket.apiKey : \"\",\n            \"Content-Type\": \"application/json\"\n        };\n        if (this.socket.accessTokenValue) {\n            headers[\"Authorization\"] = `Bearer ${this.socket.accessTokenValue}`;\n        }\n        const options = {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify({\n                messages: [\n                    {\n                        topic: this.subTopic,\n                        event,\n                        payload: payload,\n                        private: this.private\n                    }\n                ]\n            })\n        };\n        const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\n        if (response.status === 202) {\n            return {\n                success: true\n            };\n        }\n        let errorMessage = response.statusText;\n        try {\n            const errorBody = await response.json();\n            errorMessage = errorBody.error || errorBody.message || errorMessage;\n        } catch (_b) {}\n        return Promise.reject(new Error(errorMessage));\n    }\n    /**\n     * Sends a message into the channel.\n     *\n     * @param args Arguments to send to channel\n     * @param args.type The type of event to send\n     * @param args.event The name of the event being sent\n     * @param args.payload Payload to be sent\n     * @param opts Options to be used during the send process\n     */ async send(args, opts = {}) {\n        var _a, _b;\n        if (!this._canPush() && args.type === \"broadcast\") {\n            console.warn(\"Realtime send() is automatically falling back to REST API. \" + \"This behavior will be deprecated in the future. \" + \"Please use httpSend() explicitly for REST delivery.\");\n            const { event, payload: endpoint_payload } = args;\n            const headers = {\n                apikey: this.socket.apiKey ? this.socket.apiKey : \"\",\n                \"Content-Type\": \"application/json\"\n            };\n            if (this.socket.accessTokenValue) {\n                headers[\"Authorization\"] = `Bearer ${this.socket.accessTokenValue}`;\n            }\n            const options = {\n                method: \"POST\",\n                headers,\n                body: JSON.stringify({\n                    messages: [\n                        {\n                            topic: this.subTopic,\n                            event,\n                            payload: endpoint_payload,\n                            private: this.private\n                        }\n                    ]\n                })\n            };\n            try {\n                const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\n                await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());\n                return response.ok ? \"ok\" : \"error\";\n            } catch (error) {\n                if (error.name === \"AbortError\") {\n                    return \"timed out\";\n                } else {\n                    return \"error\";\n                }\n            }\n        } else {\n            return new Promise((resolve)=>{\n                var _a, _b, _c;\n                const push = this._push(args.type, args, opts.timeout || this.timeout);\n                if (args.type === \"broadcast\" && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n                    resolve(\"ok\");\n                }\n                push.receive(\"ok\", ()=>resolve(\"ok\"));\n                push.receive(\"error\", ()=>resolve(\"error\"));\n                push.receive(\"timeout\", ()=>resolve(\"timed out\"));\n            });\n        }\n    }\n    /**\n     * Updates the payload that will be sent the next time the channel joins (reconnects).\n     * Useful for rotating access tokens or updating config without re-creating the channel.\n     */ updateJoinPayload(payload) {\n        this.joinPush.updatePayload(payload);\n    }\n    /**\n     * Leaves the channel.\n     *\n     * Unsubscribes from server events, and instructs channel to terminate on server.\n     * Triggers onClose() hooks.\n     *\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n     */ unsubscribe(timeout = this.timeout) {\n        this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.leaving;\n        const onClose = ()=>{\n            this.socket.log(\"channel\", `leave ${this.topic}`);\n            this._trigger(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.close, \"leave\", this._joinRef());\n        };\n        this.joinPush.destroy();\n        let leavePush = null;\n        return new Promise((resolve)=>{\n            leavePush = new _lib_push__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.leave, {}, timeout);\n            leavePush.receive(\"ok\", ()=>{\n                onClose();\n                resolve(\"ok\");\n            }).receive(\"timeout\", ()=>{\n                onClose();\n                resolve(\"timed out\");\n            }).receive(\"error\", ()=>{\n                resolve(\"error\");\n            });\n            leavePush.send();\n            if (!this._canPush()) {\n                leavePush.trigger(\"ok\", {});\n            }\n        }).finally(()=>{\n            leavePush === null || leavePush === void 0 ? void 0 : leavePush.destroy();\n        });\n    }\n    /**\n     * Teardown the channel.\n     *\n     * Destroys and stops related timers.\n     */ teardown() {\n        this.pushBuffer.forEach((push)=>push.destroy());\n        this.pushBuffer = [];\n        this.rejoinTimer.reset();\n        this.joinPush.destroy();\n        this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;\n        this.bindings = {};\n    }\n    /** @internal */ async _fetchWithTimeout(url, options, timeout) {\n        const controller = new AbortController();\n        const id = setTimeout(()=>controller.abort(), timeout);\n        const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), {\n            signal: controller.signal\n        }));\n        clearTimeout(id);\n        return response;\n    }\n    /** @internal */ _push(event, payload, timeout = this.timeout) {\n        if (!this.joinedOnce) {\n            throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n        }\n        let pushEvent = new _lib_push__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, event, payload, timeout);\n        if (this._canPush()) {\n            pushEvent.send();\n        } else {\n            this._addToPushBuffer(pushEvent);\n        }\n        return pushEvent;\n    }\n    /** @internal */ _addToPushBuffer(pushEvent) {\n        pushEvent.startTimeout();\n        this.pushBuffer.push(pushEvent);\n        // Enforce buffer size limit\n        if (this.pushBuffer.length > _lib_constants__WEBPACK_IMPORTED_MODULE_0__.MAX_PUSH_BUFFER_SIZE) {\n            const removedPush = this.pushBuffer.shift();\n            if (removedPush) {\n                removedPush.destroy();\n                this.socket.log(\"channel\", `discarded push due to buffer overflow: ${removedPush.event}`, removedPush.payload);\n            }\n        }\n    }\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\n     * Must return the payload, modified or unmodified.\n     *\n     * @internal\n     */ _onMessage(_event, payload, _ref) {\n        return payload;\n    }\n    /** @internal */ _isMember(topic) {\n        return this.topic === topic;\n    }\n    /** @internal */ _joinRef() {\n        return this.joinPush.ref;\n    }\n    /** @internal */ _trigger(type, payload, ref) {\n        var _a, _b;\n        const typeLower = type.toLocaleLowerCase();\n        const { close, error, leave, join } = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS;\n        const events = [\n            close,\n            error,\n            leave,\n            join\n        ];\n        if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n            return;\n        }\n        let handledPayload = this._onMessage(typeLower, payload, ref);\n        if (payload && !handledPayload) {\n            throw \"channel onMessage callbacks must return the payload, modified or unmodified\";\n        }\n        if ([\n            \"insert\",\n            \"update\",\n            \"delete\"\n        ].includes(typeLower)) {\n            (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter((bind)=>{\n                var _a, _b, _c;\n                return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === \"*\" || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;\n            }).map((bind)=>bind.callback(handledPayload, ref));\n        } else {\n            (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind)=>{\n                var _a, _b, _c, _d, _e, _f;\n                if ([\n                    \"broadcast\",\n                    \"presence\",\n                    \"postgres_changes\"\n                ].includes(typeLower)) {\n                    if (\"id\" in bind) {\n                        const bindId = bind.id;\n                        const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\n                        return bindId && ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) && (bindEvent === \"*\" || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));\n                    } else {\n                        const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\n                        return bindEvent === \"*\" || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());\n                    }\n                } else {\n                    return bind.type.toLocaleLowerCase() === typeLower;\n                }\n            }).map((bind)=>{\n                if (typeof handledPayload === \"object\" && \"ids\" in handledPayload) {\n                    const postgresChanges = handledPayload.data;\n                    const { schema, table, commit_timestamp, type, errors } = postgresChanges;\n                    const enrichedPayload = {\n                        schema: schema,\n                        table: table,\n                        commit_timestamp: commit_timestamp,\n                        eventType: type,\n                        new: {},\n                        old: {},\n                        errors: errors\n                    };\n                    handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\n                }\n                bind.callback(handledPayload, ref);\n            });\n        }\n    }\n    /** @internal */ _isClosed() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;\n    }\n    /** @internal */ _isJoined() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joined;\n    }\n    /** @internal */ _isJoining() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joining;\n    }\n    /** @internal */ _isLeaving() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.leaving;\n    }\n    /** @internal */ _replyEventName(ref) {\n        return `chan_reply_${ref}`;\n    }\n    /** @internal */ _on(type, filter, callback) {\n        const typeLower = type.toLocaleLowerCase();\n        const binding = {\n            type: typeLower,\n            filter: filter,\n            callback: callback\n        };\n        if (this.bindings[typeLower]) {\n            this.bindings[typeLower].push(binding);\n        } else {\n            this.bindings[typeLower] = [\n                binding\n            ];\n        }\n        return this;\n    }\n    /** @internal */ _off(type, filter) {\n        const typeLower = type.toLocaleLowerCase();\n        if (this.bindings[typeLower]) {\n            this.bindings[typeLower] = this.bindings[typeLower].filter((bind)=>{\n                var _a;\n                return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));\n            });\n        }\n        return this;\n    }\n    /** @internal */ static isEqual(obj1, obj2) {\n        if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n            return false;\n        }\n        for(const k in obj1){\n            if (obj1[k] !== obj2[k]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Compares two optional filter values for equality.\n     * Treats undefined, null, and empty string as equivalent empty values.\n     * @internal\n     */ static isFilterValueEqual(serverValue, clientValue) {\n        const normalizedServer = serverValue !== null && serverValue !== void 0 ? serverValue : undefined;\n        const normalizedClient = clientValue !== null && clientValue !== void 0 ? clientValue : undefined;\n        return normalizedServer === normalizedClient;\n    }\n    /** @internal */ _rejoinUntilConnected() {\n        this.rejoinTimer.scheduleTimeout();\n        if (this.socket.isConnected()) {\n            this._rejoin();\n        }\n    }\n    /**\n     * Registers a callback that will be executed when the channel closes.\n     *\n     * @internal\n     */ _onClose(callback) {\n        this._on(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.close, {}, callback);\n    }\n    /**\n     * Registers a callback that will be executed when the channel encounteres an error.\n     *\n     * @internal\n     */ _onError(callback) {\n        this._on(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.error, {}, (reason)=>callback(reason));\n    }\n    /**\n     * Returns `true` if the socket is connected and the channel has been joined.\n     *\n     * @internal\n     */ _canPush() {\n        return this.socket.isConnected() && this._isJoined();\n    }\n    /** @internal */ _rejoin(timeout = this.timeout) {\n        if (this._isLeaving()) {\n            return;\n        }\n        this.socket._leaveOpenTopic(this.topic);\n        this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joining;\n        this.joinPush.resend(timeout);\n    }\n    /** @internal */ _getPayloadRecords(payload) {\n        const records = {\n            new: {},\n            old: {}\n        };\n        if (payload.type === \"INSERT\" || payload.type === \"UPDATE\") {\n            records.new = _lib_transformers__WEBPACK_IMPORTED_MODULE_4__.convertChangeData(payload.columns, payload.record);\n        }\n        if (payload.type === \"UPDATE\" || payload.type === \"DELETE\") {\n            records.old = _lib_transformers__WEBPACK_IMPORTED_MODULE_4__.convertChangeData(payload.columns, payload.old_record);\n        }\n        return records;\n    }\n} //# sourceMappingURL=RealtimeChannel.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL1JlYWx0aW1lQ2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXVGO0FBQ3pEO0FBQ0U7QUFDa0I7QUFDQztBQUNFO0FBQzlDLElBQUlRLHVDQUF1QztBQUNqRCxVQUFVQSxzQ0FBc0M7SUFDN0NBLHNDQUFzQyxDQUFDLE1BQU0sR0FBRztJQUNoREEsc0NBQXNDLENBQUMsU0FBUyxHQUFHO0lBQ25EQSxzQ0FBc0MsQ0FBQyxTQUFTLEdBQUc7SUFDbkRBLHNDQUFzQyxDQUFDLFNBQVMsR0FBRztBQUN2RCxHQUFHQSwwQ0FBMkNBLENBQUFBLHlDQUF5QyxDQUFDO0FBQ2pGLElBQUlDLHNCQUFzQjtBQUNoQyxVQUFVQSxxQkFBcUI7SUFDNUJBLHFCQUFxQixDQUFDLFlBQVksR0FBRztJQUNyQ0EscUJBQXFCLENBQUMsV0FBVyxHQUFHO0lBQ3BDQSxxQkFBcUIsQ0FBQyxtQkFBbUIsR0FBRztJQUM1Q0EscUJBQXFCLENBQUMsU0FBUyxHQUFHO0FBQ3RDLEdBQUdBLHlCQUEwQkEsQ0FBQUEsd0JBQXdCLENBQUM7QUFDL0MsSUFBSUMsMEJBQTBCO0FBQ3BDLFVBQVVBLHlCQUF5QjtJQUNoQ0EseUJBQXlCLENBQUMsYUFBYSxHQUFHO0lBQzFDQSx5QkFBeUIsQ0FBQyxZQUFZLEdBQUc7SUFDekNBLHlCQUF5QixDQUFDLFNBQVMsR0FBRztJQUN0Q0EseUJBQXlCLENBQUMsZ0JBQWdCLEdBQUc7QUFDakQsR0FBR0EsNkJBQThCQSxDQUFBQSw0QkFBNEIsQ0FBQztBQUN2RCxNQUFNQywwQkFBMEJWLDBEQUFjQSxDQUFDO0FBQ3REOzs7O0NBSUMsR0FDYyxNQUFNVztJQUNqQjs7Ozs7Ozs7Ozs7Ozs7O0tBZUMsR0FDREMsWUFDQSxrQ0FBa0MsR0FDbENDLEtBQUssRUFBRUMsU0FBUztRQUFFQyxRQUFRLENBQUM7SUFBRSxDQUFDLEVBQUVDLE1BQU0sQ0FBRTtRQUNwQyxJQUFJQyxJQUFJQztRQUNSLElBQUksQ0FBQ0wsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0UsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0csUUFBUSxHQUFHLENBQUM7UUFDakIsSUFBSSxDQUFDQyxLQUFLLEdBQUdwQiwwREFBY0EsQ0FBQ3FCLE1BQU07UUFDbEMsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDQyxVQUFVLEdBQUcsRUFBRTtRQUNwQixJQUFJLENBQUNDLFFBQVEsR0FBR1gsTUFBTVksT0FBTyxDQUFDLGVBQWU7UUFDN0MsSUFBSSxDQUFDWCxNQUFNLENBQUNDLE1BQU0sR0FBR1csT0FBT0MsTUFBTSxDQUFDO1lBQy9CQyxXQUFXO2dCQUFFQyxLQUFLO2dCQUFPQyxNQUFNO1lBQU07WUFDckNDLFVBQVU7Z0JBQUVDLEtBQUs7Z0JBQUlDLFNBQVM7WUFBTTtZQUNwQ0MsU0FBUztRQUNiLEdBQUdwQixPQUFPQyxNQUFNO1FBQ2hCLElBQUksQ0FBQ29CLE9BQU8sR0FBRyxJQUFJLENBQUNuQixNQUFNLENBQUNtQixPQUFPO1FBQ2xDLElBQUksQ0FBQ0MsUUFBUSxHQUFHLElBQUlsQyxpREFBSUEsQ0FBQyxJQUFJLEVBQUVILDBEQUFjQSxDQUFDc0MsSUFBSSxFQUFFLElBQUksQ0FBQ3ZCLE1BQU0sRUFBRSxJQUFJLENBQUNxQixPQUFPO1FBQzdFLElBQUksQ0FBQ0csV0FBVyxHQUFHLElBQUluQyxrREFBS0EsQ0FBQyxJQUFNLElBQUksQ0FBQ29DLHFCQUFxQixJQUFJLElBQUksQ0FBQ3ZCLE1BQU0sQ0FBQ3dCLGdCQUFnQjtRQUM3RixJQUFJLENBQUNKLFFBQVEsQ0FBQ0ssT0FBTyxDQUFDLE1BQU07WUFDeEIsSUFBSSxDQUFDckIsS0FBSyxHQUFHcEIsMERBQWNBLENBQUMwQyxNQUFNO1lBQ2xDLElBQUksQ0FBQ0osV0FBVyxDQUFDSyxLQUFLO1lBQ3RCLElBQUksQ0FBQ3BCLFVBQVUsQ0FBQ3FCLE9BQU8sQ0FBQyxDQUFDQyxZQUFjQSxVQUFVQyxJQUFJO1lBQ3JELElBQUksQ0FBQ3ZCLFVBQVUsR0FBRyxFQUFFO1FBQ3hCO1FBQ0EsSUFBSSxDQUFDd0IsUUFBUSxDQUFDO1lBQ1YsSUFBSSxDQUFDVCxXQUFXLENBQUNLLEtBQUs7WUFDdEIsSUFBSSxDQUFDM0IsTUFBTSxDQUFDZ0MsR0FBRyxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDbkMsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUNvQyxRQUFRLEdBQUcsQ0FBQztZQUNuRSxJQUFJLENBQUM3QixLQUFLLEdBQUdwQiwwREFBY0EsQ0FBQ3FCLE1BQU07WUFDbEMsSUFBSSxDQUFDTCxNQUFNLENBQUNrQyxPQUFPLENBQUMsSUFBSTtRQUM1QjtRQUNBLElBQUksQ0FBQ0MsUUFBUSxDQUFDLENBQUNDO1lBQ1gsSUFBSSxJQUFJLENBQUNDLFVBQVUsTUFBTSxJQUFJLENBQUNDLFNBQVMsSUFBSTtnQkFDdkM7WUFDSjtZQUNBLElBQUksQ0FBQ3RDLE1BQU0sQ0FBQ2dDLEdBQUcsQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQ25DLEtBQUssQ0FBQyxDQUFDLEVBQUV1QztZQUNsRCxJQUFJLENBQUNoQyxLQUFLLEdBQUdwQiwwREFBY0EsQ0FBQ3VELE9BQU87WUFDbkMsSUFBSSxDQUFDakIsV0FBVyxDQUFDa0IsZUFBZTtRQUNwQztRQUNBLElBQUksQ0FBQ3BCLFFBQVEsQ0FBQ0ssT0FBTyxDQUFDLFdBQVc7WUFDN0IsSUFBSSxDQUFDLElBQUksQ0FBQ2dCLFVBQVUsSUFBSTtnQkFDcEI7WUFDSjtZQUNBLElBQUksQ0FBQ3pDLE1BQU0sQ0FBQ2dDLEdBQUcsQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQ25DLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDdUIsUUFBUSxDQUFDRCxPQUFPO1lBQ3pFLElBQUksQ0FBQ2YsS0FBSyxHQUFHcEIsMERBQWNBLENBQUN1RCxPQUFPO1lBQ25DLElBQUksQ0FBQ2pCLFdBQVcsQ0FBQ2tCLGVBQWU7UUFDcEM7UUFDQSxJQUFJLENBQUNwQixRQUFRLENBQUNLLE9BQU8sQ0FBQyxTQUFTLENBQUNXO1lBQzVCLElBQUksSUFBSSxDQUFDQyxVQUFVLE1BQU0sSUFBSSxDQUFDQyxTQUFTLElBQUk7Z0JBQ3ZDO1lBQ0o7WUFDQSxJQUFJLENBQUN0QyxNQUFNLENBQUNnQyxHQUFHLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUNuQyxLQUFLLENBQUMsQ0FBQyxFQUFFdUM7WUFDbEQsSUFBSSxDQUFDaEMsS0FBSyxHQUFHcEIsMERBQWNBLENBQUN1RCxPQUFPO1lBQ25DLElBQUksQ0FBQ2pCLFdBQVcsQ0FBQ2tCLGVBQWU7UUFDcEM7UUFDQSxJQUFJLENBQUNFLEdBQUcsQ0FBQzNELDBEQUFjQSxDQUFDNEQsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDQyxTQUFTQztZQUN6QyxJQUFJLENBQUNDLFFBQVEsQ0FBQyxJQUFJLENBQUNDLGVBQWUsQ0FBQ0YsTUFBTUQ7UUFDN0M7UUFDQSxJQUFJLENBQUM3QixRQUFRLEdBQUcsSUFBSTNCLHlEQUFnQkEsQ0FBQyxJQUFJO1FBQ3pDLElBQUksQ0FBQzRELG9CQUFvQixHQUFHMUQsa0VBQWVBLENBQUMsSUFBSSxDQUFDVSxNQUFNLENBQUNpRCxRQUFRO1FBQ2hFLElBQUksQ0FBQy9CLE9BQU8sR0FBRyxJQUFJLENBQUNwQixNQUFNLENBQUNDLE1BQU0sQ0FBQ21CLE9BQU8sSUFBSTtRQUM3QyxJQUFJLENBQUMsSUFBSSxDQUFDQSxPQUFPLElBQUssRUFBQ2hCLEtBQUssQ0FBQ0QsS0FBSyxJQUFJLENBQUNILE1BQU0sQ0FBQ0MsTUFBTSxNQUFNLFFBQVFFLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR1csU0FBUyxNQUFNLFFBQVFWLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2dELE1BQU0sR0FBRztZQUN0SixNQUFNLENBQUMsdUNBQXVDLEVBQUUsSUFBSSxDQUFDckQsS0FBSyxDQUFDLGdDQUFnQyxDQUFDO1FBQ2hHO0lBQ0o7SUFDQSxvREFBb0QsR0FDcERzRCxVQUFVQyxRQUFRLEVBQUVqQyxVQUFVLElBQUksQ0FBQ0EsT0FBTyxFQUFFO1FBQ3hDLElBQUlsQixJQUFJQyxJQUFJbUQ7UUFDWixJQUFJLENBQUMsSUFBSSxDQUFDckQsTUFBTSxDQUFDc0QsV0FBVyxJQUFJO1lBQzVCLElBQUksQ0FBQ3RELE1BQU0sQ0FBQ3VELE9BQU87UUFDdkI7UUFDQSxJQUFJLElBQUksQ0FBQ25ELEtBQUssSUFBSXBCLDBEQUFjQSxDQUFDcUIsTUFBTSxFQUFFO1lBQ3JDLE1BQU0sRUFBRU4sUUFBUSxFQUFFYSxTQUFTLEVBQUVHLFFBQVEsRUFBRUcsU0FBU3NDLFNBQVMsRUFBRSxFQUFHLEdBQUcsSUFBSSxDQUFDMUQsTUFBTTtZQUM1RSxNQUFNMkQsbUJBQW1CLENBQUN2RCxLQUFLLENBQUNELEtBQUssSUFBSSxDQUFDRSxRQUFRLENBQUNzRCxnQkFBZ0IsTUFBTSxRQUFReEQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHeUQsR0FBRyxDQUFDLENBQUNDLElBQU1BLEVBQUVDLE1BQU0sT0FBTyxRQUFRMUQsT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBRTtZQUN0SyxNQUFNMkQsbUJBQW1CLENBQUUsQ0FBQyxJQUFJLENBQUMxRCxRQUFRLENBQUNYLHNCQUFzQnNFLFFBQVEsQ0FBQyxJQUNyRSxJQUFJLENBQUMzRCxRQUFRLENBQUNYLHNCQUFzQnNFLFFBQVEsQ0FBQyxDQUFDQyxNQUFNLEdBQUcsS0FDdkQsQ0FBQyxDQUFDVixLQUFLLElBQUksQ0FBQ3ZELE1BQU0sQ0FBQ0MsTUFBTSxDQUFDZ0IsUUFBUSxNQUFNLFFBQVFzQyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdwQyxPQUFPLE1BQU07WUFDN0YsTUFBTStDLHFCQUFxQixDQUFDO1lBQzVCLE1BQU1qRSxTQUFTO2dCQUNYYTtnQkFDQUcsVUFBVUwsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHSSxXQUFXO29CQUFFRSxTQUFTNEM7Z0JBQWlCO2dCQUNqRko7Z0JBQ0F2QyxTQUFTc0M7WUFDYjtZQUNBLElBQUksSUFBSSxDQUFDeEQsTUFBTSxDQUFDaUUsZ0JBQWdCLEVBQUU7Z0JBQzlCRCxtQkFBbUJFLFlBQVksR0FBRyxJQUFJLENBQUNsRSxNQUFNLENBQUNpRSxnQkFBZ0I7WUFDbEU7WUFDQSxJQUFJLENBQUM5QixRQUFRLENBQUMsQ0FBQ2dDLElBQU1mLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTM0QsMEJBQTBCMkUsYUFBYSxFQUFFRDtZQUMzSCxJQUFJLENBQUNwQyxRQUFRLENBQUMsSUFBTXFCLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTM0QsMEJBQTBCNEUsTUFBTTtZQUNqSCxJQUFJLENBQUNDLGlCQUFpQixDQUFDNUQsT0FBT0MsTUFBTSxDQUFDO2dCQUFFWjtZQUFPLEdBQUdpRTtZQUNqRCxJQUFJLENBQUMxRCxVQUFVLEdBQUc7WUFDbEIsSUFBSSxDQUFDaUUsT0FBTyxDQUFDcEQ7WUFDYixJQUFJLENBQUNDLFFBQVEsQ0FDUkssT0FBTyxDQUFDLE1BQU0sT0FBTyxFQUFFZ0MsZ0JBQWdCLEVBQUU7Z0JBQzFDLElBQUl4RDtnQkFDSixtREFBbUQ7Z0JBQ25ELElBQUksQ0FBQyxJQUFJLENBQUNELE1BQU0sQ0FBQ3dFLGNBQWMsSUFBSTtvQkFDL0IsSUFBSSxDQUFDeEUsTUFBTSxDQUFDeUUsT0FBTztnQkFDdkI7Z0JBQ0EsSUFBSWhCLHFCQUFxQmlCLFdBQVc7b0JBQ2hDdEIsYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVMzRCwwQkFBMEJrRixVQUFVO29CQUNqRztnQkFDSixPQUNLO29CQUNELE1BQU1DLHlCQUF5QixJQUFJLENBQUN6RSxRQUFRLENBQUNzRCxnQkFBZ0I7b0JBQzdELE1BQU1vQixjQUFjLENBQUM1RSxLQUFLMkUsMkJBQTJCLFFBQVFBLDJCQUEyQixLQUFLLElBQUksS0FBSyxJQUFJQSx1QkFBdUJiLE1BQU0sTUFBTSxRQUFROUQsT0FBTyxLQUFLLElBQUlBLEtBQUs7b0JBQzFLLE1BQU02RSxzQkFBc0IsRUFBRTtvQkFDOUIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLGFBQWFFLElBQUs7d0JBQ2xDLE1BQU1DLHdCQUF3Qkosc0JBQXNCLENBQUNHLEVBQUU7d0JBQ3ZELE1BQU0sRUFBRW5CLFFBQVEsRUFBRXFCLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxLQUFLLEVBQUV2QixNQUFNLEVBQUUsRUFBRyxHQUFHb0I7d0JBQ3RELE1BQU1JLHVCQUF1QjNCLG9CQUFvQkEsZ0JBQWdCLENBQUNzQixFQUFFO3dCQUNwRSxJQUFJSyx3QkFDQUEscUJBQXFCSCxLQUFLLEtBQUtBLFNBQy9CdEYsZ0JBQWdCMEYsa0JBQWtCLENBQUNELHFCQUFxQkYsTUFBTSxFQUFFQSxXQUNoRXZGLGdCQUFnQjBGLGtCQUFrQixDQUFDRCxxQkFBcUJELEtBQUssRUFBRUEsVUFDL0R4RixnQkFBZ0IwRixrQkFBa0IsQ0FBQ0QscUJBQXFCeEIsTUFBTSxFQUFFQSxTQUFTOzRCQUN6RWtCLG9CQUFvQlEsSUFBSSxDQUFDNUUsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHcUUsd0JBQXdCO2dDQUFFTyxJQUFJSCxxQkFBcUJHLEVBQUU7NEJBQUM7d0JBQ25ILE9BQ0s7NEJBQ0QsSUFBSSxDQUFDQyxXQUFXOzRCQUNoQixJQUFJLENBQUNwRixLQUFLLEdBQUdwQiwwREFBY0EsQ0FBQ3VELE9BQU87NEJBQ25DYSxhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBUzNELDBCQUEwQjJFLGFBQWEsRUFBRSxJQUFJcUIsTUFBTTs0QkFDaEg7d0JBQ0o7b0JBQ0o7b0JBQ0EsSUFBSSxDQUFDdEYsUUFBUSxDQUFDc0QsZ0JBQWdCLEdBQUdxQjtvQkFDakMxQixZQUFZQSxTQUFTM0QsMEJBQTBCa0YsVUFBVTtvQkFDekQ7Z0JBQ0o7WUFDSixHQUNLbEQsT0FBTyxDQUFDLFNBQVMsQ0FBQ2lFO2dCQUNuQixJQUFJLENBQUN0RixLQUFLLEdBQUdwQiwwREFBY0EsQ0FBQ3VELE9BQU87Z0JBQ25DYSxhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBUzNELDBCQUEwQjJFLGFBQWEsRUFBRSxJQUFJcUIsTUFBTUUsS0FBS0MsU0FBUyxDQUFDbEYsT0FBT21GLE1BQU0sQ0FBQ0gsT0FBT3JFLElBQUksQ0FBQyxTQUFTO2dCQUNsSztZQUNKLEdBQ0tJLE9BQU8sQ0FBQyxXQUFXO2dCQUNwQjJCLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTM0QsMEJBQTBCcUcsU0FBUztnQkFDaEc7WUFDSjtRQUNKO1FBQ0EsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7Ozs7S0FLQyxHQUNEQyxnQkFBZ0I7UUFDWixPQUFPLElBQUksQ0FBQ2hGLFFBQVEsQ0FBQ1gsS0FBSztJQUM5QjtJQUNBOzs7S0FHQyxHQUNELE1BQU00RixNQUFNcEQsT0FBTyxFQUFFcUQsT0FBTyxDQUFDLENBQUMsRUFBRTtRQUM1QixPQUFPLE1BQU0sSUFBSSxDQUFDbkUsSUFBSSxDQUFDO1lBQ25Cb0UsTUFBTTtZQUNOakIsT0FBTztZQUNQckM7UUFDSixHQUFHcUQsS0FBSzlFLE9BQU8sSUFBSSxJQUFJLENBQUNBLE9BQU87SUFDbkM7SUFDQTs7S0FFQyxHQUNELE1BQU1nRixRQUFRRixPQUFPLENBQUMsQ0FBQyxFQUFFO1FBQ3JCLE9BQU8sTUFBTSxJQUFJLENBQUNuRSxJQUFJLENBQUM7WUFDbkJvRSxNQUFNO1lBQ05qQixPQUFPO1FBQ1gsR0FBR2dCO0lBQ1A7SUFDQUcsR0FBR0YsSUFBSSxFQUFFdEMsTUFBTSxFQUFFUixRQUFRLEVBQUU7UUFDdkIsSUFBSSxJQUFJLENBQUNoRCxLQUFLLEtBQUtwQiwwREFBY0EsQ0FBQzBDLE1BQU0sSUFBSXdFLFNBQVMxRyxzQkFBc0JzRSxRQUFRLEVBQUU7WUFDakYsSUFBSSxDQUFDOUQsTUFBTSxDQUFDZ0MsR0FBRyxDQUFDLFdBQVcsQ0FBQyxlQUFlLEVBQUUsSUFBSSxDQUFDbkMsS0FBSyxDQUFDLHNEQUFzRCxDQUFDO1lBQy9HLElBQUksQ0FBQzJGLFdBQVcsR0FBR2EsSUFBSSxDQUFDLFVBQVksTUFBTSxJQUFJLENBQUNsRCxTQUFTO1FBQzVEO1FBQ0EsT0FBTyxJQUFJLENBQUNULEdBQUcsQ0FBQ3dELE1BQU10QyxRQUFRUjtJQUNsQztJQUNBOzs7Ozs7Ozs7O0tBVUMsR0FDRCxNQUFNa0QsU0FBU3JCLEtBQUssRUFBRXJDLE9BQU8sRUFBRXFELE9BQU8sQ0FBQyxDQUFDLEVBQUU7UUFDdEMsSUFBSWhHO1FBQ0osSUFBSTJDLFlBQVk4QixhQUFhOUIsWUFBWSxNQUFNO1lBQzNDLE9BQU8yRCxRQUFRQyxNQUFNLENBQUM7UUFDMUI7UUFDQSxNQUFNQyxVQUFVO1lBQ1pDLFFBQVEsSUFBSSxDQUFDMUcsTUFBTSxDQUFDMkcsTUFBTSxHQUFHLElBQUksQ0FBQzNHLE1BQU0sQ0FBQzJHLE1BQU0sR0FBRztZQUNsRCxnQkFBZ0I7UUFDcEI7UUFDQSxJQUFJLElBQUksQ0FBQzNHLE1BQU0sQ0FBQ2lFLGdCQUFnQixFQUFFO1lBQzlCd0MsT0FBTyxDQUFDLGdCQUFnQixHQUFHLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQ3pHLE1BQU0sQ0FBQ2lFLGdCQUFnQixDQUFDLENBQUM7UUFDdkU7UUFDQSxNQUFNMkMsVUFBVTtZQUNaQyxRQUFRO1lBQ1JKO1lBQ0FLLE1BQU1uQixLQUFLQyxTQUFTLENBQUM7Z0JBQ2pCbUIsVUFBVTtvQkFDTjt3QkFDSWxILE9BQU8sSUFBSSxDQUFDVyxRQUFRO3dCQUNwQnlFO3dCQUNBckMsU0FBU0E7d0JBQ1QxQixTQUFTLElBQUksQ0FBQ0EsT0FBTztvQkFDekI7aUJBQ0g7WUFDTDtRQUNKO1FBQ0EsTUFBTThGLFdBQVcsTUFBTSxJQUFJLENBQUNDLGlCQUFpQixDQUFDLElBQUksQ0FBQ2pFLG9CQUFvQixFQUFFNEQsU0FBUyxDQUFDM0csS0FBS2dHLEtBQUs5RSxPQUFPLE1BQU0sUUFBUWxCLE9BQU8sS0FBSyxJQUFJQSxLQUFLLElBQUksQ0FBQ2tCLE9BQU87UUFDbkosSUFBSTZGLFNBQVNFLE1BQU0sS0FBSyxLQUFLO1lBQ3pCLE9BQU87Z0JBQUVDLFNBQVM7WUFBSztRQUMzQjtRQUNBLElBQUlDLGVBQWVKLFNBQVNLLFVBQVU7UUFDdEMsSUFBSTtZQUNBLE1BQU1DLFlBQVksTUFBTU4sU0FBU08sSUFBSTtZQUNyQ0gsZUFBZUUsVUFBVTVCLEtBQUssSUFBSTRCLFVBQVVFLE9BQU8sSUFBSUo7UUFDM0QsRUFDQSxPQUFPbEgsSUFBSSxDQUFFO1FBQ2IsT0FBT3FHLFFBQVFDLE1BQU0sQ0FBQyxJQUFJZixNQUFNMkI7SUFDcEM7SUFDQTs7Ozs7Ozs7S0FRQyxHQUNELE1BQU10RixLQUFLMkYsSUFBSSxFQUFFeEIsT0FBTyxDQUFDLENBQUMsRUFBRTtRQUN4QixJQUFJaEcsSUFBSUM7UUFDUixJQUFJLENBQUMsSUFBSSxDQUFDd0gsUUFBUSxNQUFNRCxLQUFLdkIsSUFBSSxLQUFLLGFBQWE7WUFDL0N5QixRQUFRQyxJQUFJLENBQUMsZ0VBQ1QscURBQ0E7WUFDSixNQUFNLEVBQUUzQyxLQUFLLEVBQUVyQyxTQUFTaUYsZ0JBQWdCLEVBQUUsR0FBR0o7WUFDN0MsTUFBTWhCLFVBQVU7Z0JBQ1pDLFFBQVEsSUFBSSxDQUFDMUcsTUFBTSxDQUFDMkcsTUFBTSxHQUFHLElBQUksQ0FBQzNHLE1BQU0sQ0FBQzJHLE1BQU0sR0FBRztnQkFDbEQsZ0JBQWdCO1lBQ3BCO1lBQ0EsSUFBSSxJQUFJLENBQUMzRyxNQUFNLENBQUNpRSxnQkFBZ0IsRUFBRTtnQkFDOUJ3QyxPQUFPLENBQUMsZ0JBQWdCLEdBQUcsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDekcsTUFBTSxDQUFDaUUsZ0JBQWdCLENBQUMsQ0FBQztZQUN2RTtZQUNBLE1BQU0yQyxVQUFVO2dCQUNaQyxRQUFRO2dCQUNSSjtnQkFDQUssTUFBTW5CLEtBQUtDLFNBQVMsQ0FBQztvQkFDakJtQixVQUFVO3dCQUNOOzRCQUNJbEgsT0FBTyxJQUFJLENBQUNXLFFBQVE7NEJBQ3BCeUU7NEJBQ0FyQyxTQUFTaUY7NEJBQ1QzRyxTQUFTLElBQUksQ0FBQ0EsT0FBTzt3QkFDekI7cUJBQ0g7Z0JBQ0w7WUFDSjtZQUNBLElBQUk7Z0JBQ0EsTUFBTThGLFdBQVcsTUFBTSxJQUFJLENBQUNDLGlCQUFpQixDQUFDLElBQUksQ0FBQ2pFLG9CQUFvQixFQUFFNEQsU0FBUyxDQUFDM0csS0FBS2dHLEtBQUs5RSxPQUFPLE1BQU0sUUFBUWxCLE9BQU8sS0FBSyxJQUFJQSxLQUFLLElBQUksQ0FBQ2tCLE9BQU87Z0JBQ25KLE1BQU8sRUFBQ2pCLEtBQUs4RyxTQUFTRixJQUFJLE1BQU0sUUFBUTVHLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzRILE1BQU0sRUFBQztnQkFDM0UsT0FBT2QsU0FBU2UsRUFBRSxHQUFHLE9BQU87WUFDaEMsRUFDQSxPQUFPckMsT0FBTztnQkFDVixJQUFJQSxNQUFNc0MsSUFBSSxLQUFLLGNBQWM7b0JBQzdCLE9BQU87Z0JBQ1gsT0FDSztvQkFDRCxPQUFPO2dCQUNYO1lBQ0o7UUFDSixPQUNLO1lBQ0QsT0FBTyxJQUFJekIsUUFBUSxDQUFDMEI7Z0JBQ2hCLElBQUloSSxJQUFJQyxJQUFJbUQ7Z0JBQ1osTUFBTWlDLE9BQU8sSUFBSSxDQUFDNEMsS0FBSyxDQUFDVCxLQUFLdkIsSUFBSSxFQUFFdUIsTUFBTXhCLEtBQUs5RSxPQUFPLElBQUksSUFBSSxDQUFDQSxPQUFPO2dCQUNyRSxJQUFJc0csS0FBS3ZCLElBQUksS0FBSyxlQUFlLENBQUUsRUFBQzdDLEtBQUssQ0FBQ25ELEtBQUssQ0FBQ0QsS0FBSyxJQUFJLENBQUNILE1BQU0sTUFBTSxRQUFRRyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdGLE1BQU0sTUFBTSxRQUFRRyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdVLFNBQVMsTUFBTSxRQUFReUMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHeEMsR0FBRyxHQUFHO29CQUMvTW9ILFFBQVE7Z0JBQ1o7Z0JBQ0EzQyxLQUFLN0QsT0FBTyxDQUFDLE1BQU0sSUFBTXdHLFFBQVE7Z0JBQ2pDM0MsS0FBSzdELE9BQU8sQ0FBQyxTQUFTLElBQU13RyxRQUFRO2dCQUNwQzNDLEtBQUs3RCxPQUFPLENBQUMsV0FBVyxJQUFNd0csUUFBUTtZQUMxQztRQUNKO0lBQ0o7SUFDQTs7O0tBR0MsR0FDRDNELGtCQUFrQjFCLE9BQU8sRUFBRTtRQUN2QixJQUFJLENBQUN4QixRQUFRLENBQUMrRyxhQUFhLENBQUN2RjtJQUNoQztJQUNBOzs7Ozs7OztLQVFDLEdBQ0Q0QyxZQUFZckUsVUFBVSxJQUFJLENBQUNBLE9BQU8sRUFBRTtRQUNoQyxJQUFJLENBQUNmLEtBQUssR0FBR3BCLDBEQUFjQSxDQUFDb0osT0FBTztRQUNuQyxNQUFNQyxVQUFVO1lBQ1osSUFBSSxDQUFDckksTUFBTSxDQUFDZ0MsR0FBRyxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDbkMsS0FBSyxDQUFDLENBQUM7WUFDaEQsSUFBSSxDQUFDaUQsUUFBUSxDQUFDL0QsMERBQWNBLENBQUN1SixLQUFLLEVBQUUsU0FBUyxJQUFJLENBQUNyRyxRQUFRO1FBQzlEO1FBQ0EsSUFBSSxDQUFDYixRQUFRLENBQUNtSCxPQUFPO1FBQ3JCLElBQUlDLFlBQVk7UUFDaEIsT0FBTyxJQUFJakMsUUFBUSxDQUFDMEI7WUFDaEJPLFlBQVksSUFBSXRKLGlEQUFJQSxDQUFDLElBQUksRUFBRUgsMERBQWNBLENBQUMwSixLQUFLLEVBQUUsQ0FBQyxHQUFHdEg7WUFDckRxSCxVQUNLL0csT0FBTyxDQUFDLE1BQU07Z0JBQ2Y0RztnQkFDQUosUUFBUTtZQUNaLEdBQ0t4RyxPQUFPLENBQUMsV0FBVztnQkFDcEI0RztnQkFDQUosUUFBUTtZQUNaLEdBQ0t4RyxPQUFPLENBQUMsU0FBUztnQkFDbEJ3RyxRQUFRO1lBQ1o7WUFDQU8sVUFBVTFHLElBQUk7WUFDZCxJQUFJLENBQUMsSUFBSSxDQUFDNEYsUUFBUSxJQUFJO2dCQUNsQmMsVUFBVUUsT0FBTyxDQUFDLE1BQU0sQ0FBQztZQUM3QjtRQUNKLEdBQUdDLE9BQU8sQ0FBQztZQUNQSCxjQUFjLFFBQVFBLGNBQWMsS0FBSyxJQUFJLEtBQUssSUFBSUEsVUFBVUQsT0FBTztRQUMzRTtJQUNKO0lBQ0E7Ozs7S0FJQyxHQUNESyxXQUFXO1FBQ1AsSUFBSSxDQUFDckksVUFBVSxDQUFDcUIsT0FBTyxDQUFDLENBQUMwRCxPQUFTQSxLQUFLaUQsT0FBTztRQUM5QyxJQUFJLENBQUNoSSxVQUFVLEdBQUcsRUFBRTtRQUNwQixJQUFJLENBQUNlLFdBQVcsQ0FBQ0ssS0FBSztRQUN0QixJQUFJLENBQUNQLFFBQVEsQ0FBQ21ILE9BQU87UUFDckIsSUFBSSxDQUFDbkksS0FBSyxHQUFHcEIsMERBQWNBLENBQUNxQixNQUFNO1FBQ2xDLElBQUksQ0FBQ0YsUUFBUSxHQUFHLENBQUM7SUFDckI7SUFDQSxjQUFjLEdBQ2QsTUFBTThHLGtCQUFrQjRCLEdBQUcsRUFBRWpDLE9BQU8sRUFBRXpGLE9BQU8sRUFBRTtRQUMzQyxNQUFNMkgsYUFBYSxJQUFJQztRQUN2QixNQUFNeEQsS0FBS3lELFdBQVcsSUFBTUYsV0FBV0csS0FBSyxJQUFJOUg7UUFDaEQsTUFBTTZGLFdBQVcsTUFBTSxJQUFJLENBQUNoSCxNQUFNLENBQUNrSixLQUFLLENBQUNMLEtBQUtuSSxPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdpRyxVQUFVO1lBQUV1QyxRQUFRTCxXQUFXSyxNQUFNO1FBQUM7UUFDcEhDLGFBQWE3RDtRQUNiLE9BQU95QjtJQUNYO0lBQ0EsY0FBYyxHQUNka0IsTUFBTWpELEtBQUssRUFBRXJDLE9BQU8sRUFBRXpCLFVBQVUsSUFBSSxDQUFDQSxPQUFPLEVBQUU7UUFDMUMsSUFBSSxDQUFDLElBQUksQ0FBQ2IsVUFBVSxFQUFFO1lBQ2xCLE1BQU0sQ0FBQyxlQUFlLEVBQUUyRSxNQUFNLE1BQU0sRUFBRSxJQUFJLENBQUNwRixLQUFLLENBQUMsK0RBQStELENBQUM7UUFDckg7UUFDQSxJQUFJZ0MsWUFBWSxJQUFJM0MsaURBQUlBLENBQUMsSUFBSSxFQUFFK0YsT0FBT3JDLFNBQVN6QjtRQUMvQyxJQUFJLElBQUksQ0FBQ3VHLFFBQVEsSUFBSTtZQUNqQjdGLFVBQVVDLElBQUk7UUFDbEIsT0FDSztZQUNELElBQUksQ0FBQ3VILGdCQUFnQixDQUFDeEg7UUFDMUI7UUFDQSxPQUFPQTtJQUNYO0lBQ0EsY0FBYyxHQUNkd0gsaUJBQWlCeEgsU0FBUyxFQUFFO1FBQ3hCQSxVQUFVeUgsWUFBWTtRQUN0QixJQUFJLENBQUMvSSxVQUFVLENBQUMrRSxJQUFJLENBQUN6RDtRQUNyQiw0QkFBNEI7UUFDNUIsSUFBSSxJQUFJLENBQUN0QixVQUFVLENBQUN3RCxNQUFNLEdBQUc5RSxnRUFBb0JBLEVBQUU7WUFDL0MsTUFBTXNLLGNBQWMsSUFBSSxDQUFDaEosVUFBVSxDQUFDaUosS0FBSztZQUN6QyxJQUFJRCxhQUFhO2dCQUNiQSxZQUFZaEIsT0FBTztnQkFDbkIsSUFBSSxDQUFDdkksTUFBTSxDQUFDZ0MsR0FBRyxDQUFDLFdBQVcsQ0FBQyx1Q0FBdUMsRUFBRXVILFlBQVl0RSxLQUFLLENBQUMsQ0FBQyxFQUFFc0UsWUFBWTNHLE9BQU87WUFDakg7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7S0FPQyxHQUNENkcsV0FBV0MsTUFBTSxFQUFFOUcsT0FBTyxFQUFFK0csSUFBSSxFQUFFO1FBQzlCLE9BQU8vRztJQUNYO0lBQ0EsY0FBYyxHQUNkZ0gsVUFBVS9KLEtBQUssRUFBRTtRQUNiLE9BQU8sSUFBSSxDQUFDQSxLQUFLLEtBQUtBO0lBQzFCO0lBQ0EsY0FBYyxHQUNkb0MsV0FBVztRQUNQLE9BQU8sSUFBSSxDQUFDYixRQUFRLENBQUN5QixHQUFHO0lBQzVCO0lBQ0EsY0FBYyxHQUNkQyxTQUFTb0QsSUFBSSxFQUFFdEQsT0FBTyxFQUFFQyxHQUFHLEVBQUU7UUFDekIsSUFBSTVDLElBQUlDO1FBQ1IsTUFBTTJKLFlBQVkzRCxLQUFLNEQsaUJBQWlCO1FBQ3hDLE1BQU0sRUFBRXhCLEtBQUssRUFBRTVDLEtBQUssRUFBRStDLEtBQUssRUFBRXBILElBQUksRUFBRSxHQUFHdEMsMERBQWNBO1FBQ3BELE1BQU1nTCxTQUFTO1lBQUN6QjtZQUFPNUM7WUFBTytDO1lBQU9wSDtTQUFLO1FBQzFDLElBQUl3QixPQUFPa0gsT0FBT0MsT0FBTyxDQUFDSCxjQUFjLEtBQUtoSCxRQUFRLElBQUksQ0FBQ1osUUFBUSxJQUFJO1lBQ2xFO1FBQ0o7UUFDQSxJQUFJZ0ksaUJBQWlCLElBQUksQ0FBQ1IsVUFBVSxDQUFDSSxXQUFXakgsU0FBU0M7UUFDekQsSUFBSUQsV0FBVyxDQUFDcUgsZ0JBQWdCO1lBQzVCLE1BQU07UUFDVjtRQUNBLElBQUk7WUFBQztZQUFVO1lBQVU7U0FBUyxDQUFDQyxRQUFRLENBQUNMLFlBQVk7WUFDbkQ1SixDQUFBQSxLQUFLLElBQUksQ0FBQ0UsUUFBUSxDQUFDc0QsZ0JBQWdCLE1BQU0sUUFBUXhELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzJELE1BQU0sQ0FBQyxDQUFDdUc7Z0JBQ2xGLElBQUlsSyxJQUFJQyxJQUFJbUQ7Z0JBQ1osT0FBTyxDQUFDLENBQUNwRCxLQUFLa0ssS0FBS3ZHLE1BQU0sTUFBTSxRQUFRM0QsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHZ0YsS0FBSyxNQUFNLE9BQU8sQ0FBQyxDQUFDNUIsS0FBSyxDQUFDbkQsS0FBS2lLLEtBQUt2RyxNQUFNLE1BQU0sUUFBUTFELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRytFLEtBQUssTUFBTSxRQUFRNUIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHeUcsaUJBQWlCLEVBQUMsTUFBT0Q7WUFDbk8sR0FBR25HLEdBQUcsQ0FBQyxDQUFDeUcsT0FBU0EsS0FBSy9HLFFBQVEsQ0FBQzZHLGdCQUFnQnBIO1FBQ25ELE9BQ0s7WUFDQTNDLENBQUFBLEtBQUssSUFBSSxDQUFDQyxRQUFRLENBQUMwSixVQUFVLE1BQU0sUUFBUTNKLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzBELE1BQU0sQ0FBQyxDQUFDdUc7Z0JBQzVFLElBQUlsSyxJQUFJQyxJQUFJbUQsSUFBSStHLElBQUlDLElBQUlDO2dCQUN4QixJQUFJO29CQUFDO29CQUFhO29CQUFZO2lCQUFtQixDQUFDSixRQUFRLENBQUNMLFlBQVk7b0JBQ25FLElBQUksUUFBUU0sTUFBTTt3QkFDZCxNQUFNSSxTQUFTSixLQUFLNUUsRUFBRTt3QkFDdEIsTUFBTWlGLFlBQVksQ0FBQ3ZLLEtBQUtrSyxLQUFLdkcsTUFBTSxNQUFNLFFBQVEzRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdnRixLQUFLO3dCQUNsRixPQUFRc0YsVUFDSCxFQUFDckssS0FBSzBDLFFBQVE2SCxHQUFHLE1BQU0sUUFBUXZLLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2dLLFFBQVEsQ0FBQ0ssT0FBTSxLQUMxRUMsQ0FBQUEsY0FBYyxPQUNYLENBQUNBLGNBQWMsUUFBUUEsY0FBYyxLQUFLLElBQUksS0FBSyxJQUFJQSxVQUFVVixpQkFBaUIsRUFBQyxNQUFRLEVBQUN6RyxLQUFLVCxRQUFROEgsSUFBSSxNQUFNLFFBQVFySCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc2QyxJQUFJLENBQUM0RCxpQkFBaUIsRUFBQyxDQUFDO29CQUMzTCxPQUNLO3dCQUNELE1BQU1VLFlBQVksQ0FBQ0gsS0FBSyxDQUFDRCxLQUFLRCxTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFBSUEsS0FBS3ZHLE1BQU0sTUFBTSxRQUFRd0csT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHbkYsS0FBSyxNQUFNLFFBQVFvRixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdQLGlCQUFpQjt3QkFDL0wsT0FBT1UsY0FBYyxPQUFPQSxjQUFlLEVBQUNGLEtBQUsxSCxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUXFDLEtBQUssTUFBTSxRQUFRcUYsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHUixpQkFBaUIsRUFBQztvQkFDaEw7Z0JBQ0osT0FDSztvQkFDRCxPQUFPSyxLQUFLakUsSUFBSSxDQUFDNEQsaUJBQWlCLE9BQU9EO2dCQUM3QztZQUNKLEdBQUduRyxHQUFHLENBQUMsQ0FBQ3lHO2dCQUNKLElBQUksT0FBT0YsbUJBQW1CLFlBQVksU0FBU0EsZ0JBQWdCO29CQUMvRCxNQUFNVSxrQkFBa0JWLGVBQWVTLElBQUk7b0JBQzNDLE1BQU0sRUFBRXhGLE1BQU0sRUFBRUMsS0FBSyxFQUFFeUYsZ0JBQWdCLEVBQUUxRSxJQUFJLEVBQUUyRSxNQUFNLEVBQUUsR0FBR0Y7b0JBQzFELE1BQU1HLGtCQUFrQjt3QkFDcEI1RixRQUFRQTt3QkFDUkMsT0FBT0E7d0JBQ1B5RixrQkFBa0JBO3dCQUNsQkcsV0FBVzdFO3dCQUNYOEUsS0FBSyxDQUFDO3dCQUNOQyxLQUFLLENBQUM7d0JBQ05KLFFBQVFBO29CQUNaO29CQUNBWixpQkFBaUJ2SixPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdtSyxrQkFBa0IsSUFBSSxDQUFDSSxrQkFBa0IsQ0FBQ1A7Z0JBQy9GO2dCQUNBUixLQUFLL0csUUFBUSxDQUFDNkcsZ0JBQWdCcEg7WUFDbEM7UUFDSjtJQUNKO0lBQ0EsY0FBYyxHQUNkUCxZQUFZO1FBQ1IsT0FBTyxJQUFJLENBQUNsQyxLQUFLLEtBQUtwQiwwREFBY0EsQ0FBQ3FCLE1BQU07SUFDL0M7SUFDQSxjQUFjLEdBQ2Q4SyxZQUFZO1FBQ1IsT0FBTyxJQUFJLENBQUMvSyxLQUFLLEtBQUtwQiwwREFBY0EsQ0FBQzBDLE1BQU07SUFDL0M7SUFDQSxjQUFjLEdBQ2RlLGFBQWE7UUFDVCxPQUFPLElBQUksQ0FBQ3JDLEtBQUssS0FBS3BCLDBEQUFjQSxDQUFDb00sT0FBTztJQUNoRDtJQUNBLGNBQWMsR0FDZC9JLGFBQWE7UUFDVCxPQUFPLElBQUksQ0FBQ2pDLEtBQUssS0FBS3BCLDBEQUFjQSxDQUFDb0osT0FBTztJQUNoRDtJQUNBLGNBQWMsR0FDZHJGLGdCQUFnQkYsR0FBRyxFQUFFO1FBQ2pCLE9BQU8sQ0FBQyxXQUFXLEVBQUVBLElBQUksQ0FBQztJQUM5QjtJQUNBLGNBQWMsR0FDZEgsSUFBSXdELElBQUksRUFBRXRDLE1BQU0sRUFBRVIsUUFBUSxFQUFFO1FBQ3hCLE1BQU15RyxZQUFZM0QsS0FBSzRELGlCQUFpQjtRQUN4QyxNQUFNdUIsVUFBVTtZQUNabkYsTUFBTTJEO1lBQ05qRyxRQUFRQTtZQUNSUixVQUFVQTtRQUNkO1FBQ0EsSUFBSSxJQUFJLENBQUNqRCxRQUFRLENBQUMwSixVQUFVLEVBQUU7WUFDMUIsSUFBSSxDQUFDMUosUUFBUSxDQUFDMEosVUFBVSxDQUFDdkUsSUFBSSxDQUFDK0Y7UUFDbEMsT0FDSztZQUNELElBQUksQ0FBQ2xMLFFBQVEsQ0FBQzBKLFVBQVUsR0FBRztnQkFBQ3dCO2FBQVE7UUFDeEM7UUFDQSxPQUFPLElBQUk7SUFDZjtJQUNBLGNBQWMsR0FDZEMsS0FBS3BGLElBQUksRUFBRXRDLE1BQU0sRUFBRTtRQUNmLE1BQU1pRyxZQUFZM0QsS0FBSzRELGlCQUFpQjtRQUN4QyxJQUFJLElBQUksQ0FBQzNKLFFBQVEsQ0FBQzBKLFVBQVUsRUFBRTtZQUMxQixJQUFJLENBQUMxSixRQUFRLENBQUMwSixVQUFVLEdBQUcsSUFBSSxDQUFDMUosUUFBUSxDQUFDMEosVUFBVSxDQUFDakcsTUFBTSxDQUFDLENBQUN1RztnQkFDeEQsSUFBSWxLO2dCQUNKLE9BQU8sQ0FBRSxFQUFDLENBQUNBLEtBQUtrSyxLQUFLakUsSUFBSSxNQUFNLFFBQVFqRyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc2SixpQkFBaUIsRUFBQyxNQUFPRCxhQUN4RmxLLGdCQUFnQjRMLE9BQU8sQ0FBQ3BCLEtBQUt2RyxNQUFNLEVBQUVBLE9BQU07WUFDbkQ7UUFDSjtRQUNBLE9BQU8sSUFBSTtJQUNmO0lBQ0EsY0FBYyxHQUNkLE9BQU8ySCxRQUFRQyxJQUFJLEVBQUVDLElBQUksRUFBRTtRQUN2QixJQUFJL0ssT0FBT2dMLElBQUksQ0FBQ0YsTUFBTXpILE1BQU0sS0FBS3JELE9BQU9nTCxJQUFJLENBQUNELE1BQU0xSCxNQUFNLEVBQUU7WUFDdkQsT0FBTztRQUNYO1FBQ0EsSUFBSyxNQUFNNEgsS0FBS0gsS0FBTTtZQUNsQixJQUFJQSxJQUFJLENBQUNHLEVBQUUsS0FBS0YsSUFBSSxDQUFDRSxFQUFFLEVBQUU7Z0JBQ3JCLE9BQU87WUFDWDtRQUNKO1FBQ0EsT0FBTztJQUNYO0lBQ0E7Ozs7S0FJQyxHQUNELE9BQU90RyxtQkFBbUJ1RyxXQUFXLEVBQUVDLFdBQVcsRUFBRTtRQUNoRCxNQUFNQyxtQkFBbUJGLGdCQUFnQixRQUFRQSxnQkFBZ0IsS0FBSyxJQUFJQSxjQUFjbEg7UUFDeEYsTUFBTXFILG1CQUFtQkYsZ0JBQWdCLFFBQVFBLGdCQUFnQixLQUFLLElBQUlBLGNBQWNuSDtRQUN4RixPQUFPb0gscUJBQXFCQztJQUNoQztJQUNBLGNBQWMsR0FDZHhLLHdCQUF3QjtRQUNwQixJQUFJLENBQUNELFdBQVcsQ0FBQ2tCLGVBQWU7UUFDaEMsSUFBSSxJQUFJLENBQUN4QyxNQUFNLENBQUNzRCxXQUFXLElBQUk7WUFDM0IsSUFBSSxDQUFDaUIsT0FBTztRQUNoQjtJQUNKO0lBQ0E7Ozs7S0FJQyxHQUNEeEMsU0FBU3FCLFFBQVEsRUFBRTtRQUNmLElBQUksQ0FBQ1YsR0FBRyxDQUFDM0QsMERBQWNBLENBQUN1SixLQUFLLEVBQUUsQ0FBQyxHQUFHbEY7SUFDdkM7SUFDQTs7OztLQUlDLEdBQ0RqQixTQUFTaUIsUUFBUSxFQUFFO1FBQ2YsSUFBSSxDQUFDVixHQUFHLENBQUMzRCwwREFBY0EsQ0FBQzJHLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQ3RELFNBQVdnQixTQUFTaEI7SUFDNUQ7SUFDQTs7OztLQUlDLEdBQ0RzRixXQUFXO1FBQ1AsT0FBTyxJQUFJLENBQUMxSCxNQUFNLENBQUNzRCxXQUFXLE1BQU0sSUFBSSxDQUFDNkgsU0FBUztJQUN0RDtJQUNBLGNBQWMsR0FDZDVHLFFBQVFwRCxVQUFVLElBQUksQ0FBQ0EsT0FBTyxFQUFFO1FBQzVCLElBQUksSUFBSSxDQUFDa0IsVUFBVSxJQUFJO1lBQ25CO1FBQ0o7UUFDQSxJQUFJLENBQUNyQyxNQUFNLENBQUNnTSxlQUFlLENBQUMsSUFBSSxDQUFDbk0sS0FBSztRQUN0QyxJQUFJLENBQUNPLEtBQUssR0FBR3BCLDBEQUFjQSxDQUFDb00sT0FBTztRQUNuQyxJQUFJLENBQUNoSyxRQUFRLENBQUM2SyxNQUFNLENBQUM5SztJQUN6QjtJQUNBLGNBQWMsR0FDZCtKLG1CQUFtQnRJLE9BQU8sRUFBRTtRQUN4QixNQUFNc0osVUFBVTtZQUNabEIsS0FBSyxDQUFDO1lBQ05DLEtBQUssQ0FBQztRQUNWO1FBQ0EsSUFBSXJJLFFBQVFzRCxJQUFJLEtBQUssWUFBWXRELFFBQVFzRCxJQUFJLEtBQUssVUFBVTtZQUN4RGdHLFFBQVFsQixHQUFHLEdBQUczTCxnRUFBOEIsQ0FBQ3VELFFBQVF3SixPQUFPLEVBQUV4SixRQUFReUosTUFBTTtRQUNoRjtRQUNBLElBQUl6SixRQUFRc0QsSUFBSSxLQUFLLFlBQVl0RCxRQUFRc0QsSUFBSSxLQUFLLFVBQVU7WUFDeERnRyxRQUFRakIsR0FBRyxHQUFHNUwsZ0VBQThCLENBQUN1RCxRQUFRd0osT0FBTyxFQUFFeEosUUFBUTBKLFVBQVU7UUFDcEY7UUFDQSxPQUFPSjtJQUNYO0FBQ0osRUFDQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmNob3Itd29ya2Zsb3dzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21vZHVsZS9SZWFsdGltZUNoYW5uZWwuanM/ZWM0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDSEFOTkVMX0VWRU5UUywgQ0hBTk5FTF9TVEFURVMsIE1BWF9QVVNIX0JVRkZFUl9TSVpFIH0gZnJvbSAnLi9saWIvY29uc3RhbnRzJztcbmltcG9ydCBQdXNoIGZyb20gJy4vbGliL3B1c2gnO1xuaW1wb3J0IFRpbWVyIGZyb20gJy4vbGliL3RpbWVyJztcbmltcG9ydCBSZWFsdGltZVByZXNlbmNlIGZyb20gJy4vUmVhbHRpbWVQcmVzZW5jZSc7XG5pbXBvcnQgKiBhcyBUcmFuc2Zvcm1lcnMgZnJvbSAnLi9saWIvdHJhbnNmb3JtZXJzJztcbmltcG9ydCB7IGh0dHBFbmRwb2ludFVSTCB9IGZyb20gJy4vbGliL3RyYW5zZm9ybWVycyc7XG5leHBvcnQgdmFyIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UO1xuKGZ1bmN0aW9uIChSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCkge1xuICAgIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UW1wiQUxMXCJdID0gXCIqXCI7XG4gICAgUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlRbXCJJTlNFUlRcIl0gPSBcIklOU0VSVFwiO1xuICAgIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UW1wiVVBEQVRFXCJdID0gXCJVUERBVEVcIjtcbiAgICBSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVFtcIkRFTEVURVwiXSA9IFwiREVMRVRFXCI7XG59KShSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCB8fCAoUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQgPSB7fSkpO1xuZXhwb3J0IHZhciBSRUFMVElNRV9MSVNURU5fVFlQRVM7XG4oZnVuY3Rpb24gKFJFQUxUSU1FX0xJU1RFTl9UWVBFUykge1xuICAgIFJFQUxUSU1FX0xJU1RFTl9UWVBFU1tcIkJST0FEQ0FTVFwiXSA9IFwiYnJvYWRjYXN0XCI7XG4gICAgUkVBTFRJTUVfTElTVEVOX1RZUEVTW1wiUFJFU0VOQ0VcIl0gPSBcInByZXNlbmNlXCI7XG4gICAgUkVBTFRJTUVfTElTVEVOX1RZUEVTW1wiUE9TVEdSRVNfQ0hBTkdFU1wiXSA9IFwicG9zdGdyZXNfY2hhbmdlc1wiO1xuICAgIFJFQUxUSU1FX0xJU1RFTl9UWVBFU1tcIlNZU1RFTVwiXSA9IFwic3lzdGVtXCI7XG59KShSRUFMVElNRV9MSVNURU5fVFlQRVMgfHwgKFJFQUxUSU1FX0xJU1RFTl9UWVBFUyA9IHt9KSk7XG5leHBvcnQgdmFyIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVM7XG4oZnVuY3Rpb24gKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMpIHtcbiAgICBSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTW1wiU1VCU0NSSUJFRFwiXSA9IFwiU1VCU0NSSUJFRFwiO1xuICAgIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVNbXCJUSU1FRF9PVVRcIl0gPSBcIlRJTUVEX09VVFwiO1xuICAgIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVNbXCJDTE9TRURcIl0gPSBcIkNMT1NFRFwiO1xuICAgIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVNbXCJDSEFOTkVMX0VSUk9SXCJdID0gXCJDSEFOTkVMX0VSUk9SXCI7XG59KShSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTIHx8IChSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTID0ge30pKTtcbmV4cG9ydCBjb25zdCBSRUFMVElNRV9DSEFOTkVMX1NUQVRFUyA9IENIQU5ORUxfU1RBVEVTO1xuLyoqIEEgY2hhbm5lbCBpcyB0aGUgYmFzaWMgYnVpbGRpbmcgYmxvY2sgb2YgUmVhbHRpbWVcbiAqIGFuZCBuYXJyb3dzIHRoZSBzY29wZSBvZiBkYXRhIGZsb3cgdG8gc3Vic2NyaWJlZCBjbGllbnRzLlxuICogWW91IGNhbiB0aGluayBvZiBhIGNoYW5uZWwgYXMgYSBjaGF0cm9vbSB3aGVyZSBwYXJ0aWNpcGFudHMgYXJlIGFibGUgdG8gc2VlIHdobydzIG9ubGluZVxuICogYW5kIHNlbmQgYW5kIHJlY2VpdmUgbWVzc2FnZXMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlYWx0aW1lQ2hhbm5lbCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNoYW5uZWwgdGhhdCBjYW4gYnJvYWRjYXN0IG1lc3NhZ2VzLCBzeW5jIHByZXNlbmNlLCBhbmQgbGlzdGVuIHRvIFBvc3RncmVzIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBUaGUgdG9waWMgZGV0ZXJtaW5lcyB3aGljaCByZWFsdGltZSBzdHJlYW0geW91IGFyZSBzdWJzY3JpYmluZyB0by4gQ29uZmlnIG9wdGlvbnMgbGV0IHlvdVxuICAgICAqIGVuYWJsZSBhY2tub3dsZWRnZW1lbnQgZm9yIGJyb2FkY2FzdHMsIHByZXNlbmNlIHRyYWNraW5nLCBvciBwcml2YXRlIGNoYW5uZWxzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGltcG9ydCBSZWFsdGltZUNsaWVudCBmcm9tICdAc3VwYWJhc2UvcmVhbHRpbWUtanMnXG4gICAgICpcbiAgICAgKiBjb25zdCBjbGllbnQgPSBuZXcgUmVhbHRpbWVDbGllbnQoJ2h0dHBzOi8veHl6Y29tcGFueS5zdXBhYmFzZS5jby9yZWFsdGltZS92MScsIHtcbiAgICAgKiAgIHBhcmFtczogeyBhcGlrZXk6ICdwdWJsaWMtYW5vbi1rZXknIH0sXG4gICAgICogfSlcbiAgICAgKiBjb25zdCBjaGFubmVsID0gbmV3IFJlYWx0aW1lQ2hhbm5lbCgncmVhbHRpbWU6cHVibGljOm1lc3NhZ2VzJywgeyBjb25maWc6IHt9IH0sIGNsaWVudClcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKiogVG9waWMgbmFtZSBjYW4gYmUgYW55IHN0cmluZy4gKi9cbiAgICB0b3BpYywgcGFyYW1zID0geyBjb25maWc6IHt9IH0sIHNvY2tldCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLnRvcGljID0gdG9waWM7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkO1xuICAgICAgICB0aGlzLmpvaW5lZE9uY2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wdXNoQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuc3ViVG9waWMgPSB0b3BpYy5yZXBsYWNlKC9ecmVhbHRpbWU6L2ksICcnKTtcbiAgICAgICAgdGhpcy5wYXJhbXMuY29uZmlnID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBicm9hZGNhc3Q6IHsgYWNrOiBmYWxzZSwgc2VsZjogZmFsc2UgfSxcbiAgICAgICAgICAgIHByZXNlbmNlOiB7IGtleTogJycsIGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICBwcml2YXRlOiBmYWxzZSxcbiAgICAgICAgfSwgcGFyYW1zLmNvbmZpZyk7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHRoaXMuc29ja2V0LnRpbWVvdXQ7XG4gICAgICAgIHRoaXMuam9pblB1c2ggPSBuZXcgUHVzaCh0aGlzLCBDSEFOTkVMX0VWRU5UUy5qb2luLCB0aGlzLnBhcmFtcywgdGhpcy50aW1lb3V0KTtcbiAgICAgICAgdGhpcy5yZWpvaW5UaW1lciA9IG5ldyBUaW1lcigoKSA9PiB0aGlzLl9yZWpvaW5VbnRpbENvbm5lY3RlZCgpLCB0aGlzLnNvY2tldC5yZWNvbm5lY3RBZnRlck1zKTtcbiAgICAgICAgdGhpcy5qb2luUHVzaC5yZWNlaXZlKCdvaycsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5qb2luZWQ7XG4gICAgICAgICAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLnB1c2hCdWZmZXIuZm9yRWFjaCgocHVzaEV2ZW50KSA9PiBwdXNoRXZlbnQuc2VuZCgpKTtcbiAgICAgICAgICAgIHRoaXMucHVzaEJ1ZmZlciA9IFtdO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fb25DbG9zZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgY2xvc2UgJHt0aGlzLnRvcGljfSAke3RoaXMuX2pvaW5SZWYoKX1gKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5jbG9zZWQ7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5fcmVtb3ZlKHRoaXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fb25FcnJvcigocmVhc29uKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNMZWF2aW5nKCkgfHwgdGhpcy5faXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmxvZygnY2hhbm5lbCcsIGBlcnJvciAke3RoaXMudG9waWN9YCwgcmVhc29uKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkO1xuICAgICAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZSgndGltZW91dCcsICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNKb2luaW5nKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgdGltZW91dCAke3RoaXMudG9waWN9YCwgdGhpcy5qb2luUHVzaC50aW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkO1xuICAgICAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZSgnZXJyb3InLCAocmVhc29uKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNMZWF2aW5nKCkgfHwgdGhpcy5faXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmxvZygnY2hhbm5lbCcsIGBlcnJvciAke3RoaXMudG9waWN9YCwgcmVhc29uKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkO1xuICAgICAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX29uKENIQU5ORUxfRVZFTlRTLnJlcGx5LCB7fSwgKHBheWxvYWQsIHJlZikgPT4ge1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcih0aGlzLl9yZXBseUV2ZW50TmFtZShyZWYpLCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJlc2VuY2UgPSBuZXcgUmVhbHRpbWVQcmVzZW5jZSh0aGlzKTtcbiAgICAgICAgdGhpcy5icm9hZGNhc3RFbmRwb2ludFVSTCA9IGh0dHBFbmRwb2ludFVSTCh0aGlzLnNvY2tldC5lbmRQb2ludCk7XG4gICAgICAgIHRoaXMucHJpdmF0ZSA9IHRoaXMucGFyYW1zLmNvbmZpZy5wcml2YXRlIHx8IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMucHJpdmF0ZSAmJiAoKF9iID0gKF9hID0gdGhpcy5wYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYnJvYWRjYXN0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVwbGF5KSkge1xuICAgICAgICAgICAgdGhyb3cgYHRyaWVkIHRvIHVzZSByZXBsYXkgb24gcHVibGljIGNoYW5uZWwgJyR7dGhpcy50b3BpY30nLiBJdCBtdXN0IGJlIGEgcHJpdmF0ZSBjaGFubmVsLmA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFN1YnNjcmliZSByZWdpc3RlcnMgeW91ciBjbGllbnQgd2l0aCB0aGUgc2VydmVyICovXG4gICAgc3Vic2NyaWJlKGNhbGxiYWNrLCB0aW1lb3V0ID0gdGhpcy50aW1lb3V0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBpZiAoIXRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PSBDSEFOTkVMX1NUQVRFUy5jbG9zZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY29uZmlnOiB7IGJyb2FkY2FzdCwgcHJlc2VuY2UsIHByaXZhdGU6IGlzUHJpdmF0ZSB9LCB9ID0gdGhpcy5wYXJhbXM7XG4gICAgICAgICAgICBjb25zdCBwb3N0Z3Jlc19jaGFuZ2VzID0gKF9iID0gKF9hID0gdGhpcy5iaW5kaW5ncy5wb3N0Z3Jlc19jaGFuZ2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChyKSA9PiByLmZpbHRlcikpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xuICAgICAgICAgICAgY29uc3QgcHJlc2VuY2VfZW5hYmxlZCA9ICghIXRoaXMuYmluZGluZ3NbUkVBTFRJTUVfTElTVEVOX1RZUEVTLlBSRVNFTkNFXSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbUkVBTFRJTUVfTElTVEVOX1RZUEVTLlBSRVNFTkNFXS5sZW5ndGggPiAwKSB8fFxuICAgICAgICAgICAgICAgICgoX2MgPSB0aGlzLnBhcmFtcy5jb25maWcucHJlc2VuY2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5lbmFibGVkKSA9PT0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuUGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgIGJyb2FkY2FzdCxcbiAgICAgICAgICAgICAgICBwcmVzZW5jZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcmVzZW5jZSksIHsgZW5hYmxlZDogcHJlc2VuY2VfZW5hYmxlZCB9KSxcbiAgICAgICAgICAgICAgICBwb3N0Z3Jlc19jaGFuZ2VzLFxuICAgICAgICAgICAgICAgIHByaXZhdGU6IGlzUHJpdmF0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5zb2NrZXQuYWNjZXNzVG9rZW5WYWx1ZSkge1xuICAgICAgICAgICAgICAgIGFjY2Vzc1Rva2VuUGF5bG9hZC5hY2Nlc3NfdG9rZW4gPSB0aGlzLnNvY2tldC5hY2Nlc3NUb2tlblZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb25FcnJvcigoZSkgPT4gY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuQ0hBTk5FTF9FUlJPUiwgZSkpO1xuICAgICAgICAgICAgdGhpcy5fb25DbG9zZSgoKSA9PiBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5DTE9TRUQpKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSm9pblBheWxvYWQoT2JqZWN0LmFzc2lnbih7IGNvbmZpZyB9LCBhY2Nlc3NUb2tlblBheWxvYWQpKTtcbiAgICAgICAgICAgIHRoaXMuam9pbmVkT25jZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9yZWpvaW4odGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLmpvaW5QdXNoXG4gICAgICAgICAgICAgICAgLnJlY2VpdmUoJ29rJywgYXN5bmMgKHsgcG9zdGdyZXNfY2hhbmdlcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgcmVmcmVzaCBhdXRoIGlmIHVzaW5nIGNhbGxiYWNrLWJhc2VkIHRva2Vuc1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zb2NrZXQuX2lzTWFudWFsVG9rZW4oKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5zZXRBdXRoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3N0Z3Jlc19jaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuU1VCU0NSSUJFRCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudFBvc3RncmVzQmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzLnBvc3RncmVzX2NoYW5nZXM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpbmRpbmdzTGVuID0gKF9hID0gY2xpZW50UG9zdGdyZXNCaW5kaW5ncyA9PT0gbnVsbCB8fCBjbGllbnRQb3N0Z3Jlc0JpbmRpbmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbGllbnRQb3N0Z3Jlc0JpbmRpbmdzLmxlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UG9zdGdyZXNCaW5kaW5ncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmRpbmdzTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudFBvc3RncmVzQmluZGluZyA9IGNsaWVudFBvc3RncmVzQmluZGluZ3NbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGZpbHRlcjogeyBldmVudCwgc2NoZW1hLCB0YWJsZSwgZmlsdGVyIH0sIH0gPSBjbGllbnRQb3N0Z3Jlc0JpbmRpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlciA9IHBvc3RncmVzX2NoYW5nZXMgJiYgcG9zdGdyZXNfY2hhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlclBvc3RncmVzRmlsdGVyLmV2ZW50ID09PSBldmVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWx0aW1lQ2hhbm5lbC5pc0ZpbHRlclZhbHVlRXF1YWwoc2VydmVyUG9zdGdyZXNGaWx0ZXIuc2NoZW1hLCBzY2hlbWEpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhbHRpbWVDaGFubmVsLmlzRmlsdGVyVmFsdWVFcXVhbChzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci50YWJsZSwgdGFibGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhbHRpbWVDaGFubmVsLmlzRmlsdGVyVmFsdWVFcXVhbChzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci5maWx0ZXIsIGZpbHRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdQb3N0Z3Jlc0JpbmRpbmdzLnB1c2goT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjbGllbnRQb3N0Z3Jlc0JpbmRpbmcpLCB7IGlkOiBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci5pZCB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuQ0hBTk5FTF9FUlJPUiwgbmV3IEVycm9yKCdtaXNtYXRjaCBiZXR3ZWVuIHNlcnZlciBhbmQgY2xpZW50IGJpbmRpbmdzIGZvciBwb3N0Z3JlcyBjaGFuZ2VzJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdzLnBvc3RncmVzX2NoYW5nZXMgPSBuZXdQb3N0Z3Jlc0JpbmRpbmdzO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLlNVQlNDUklCRUQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVjZWl2ZSgnZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5DSEFOTkVMX0VSUk9SLCBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoT2JqZWN0LnZhbHVlcyhlcnJvcikuam9pbignLCAnKSB8fCAnZXJyb3InKSkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnJlY2VpdmUoJ3RpbWVvdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuVElNRURfT1VUKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBwcmVzZW5jZSBzdGF0ZSBmb3IgdGhpcyBjaGFubmVsLlxuICAgICAqXG4gICAgICogVGhlIHNoYXBlIGlzIGEgbWFwIGtleWVkIGJ5IHByZXNlbmNlIGtleSAoZm9yIGV4YW1wbGUgYSB1c2VyIGlkKSB3aGVyZSBlYWNoIGVudHJ5IGNvbnRhaW5zIHRoZVxuICAgICAqIHRyYWNrZWQgbWV0YWRhdGEgZm9yIHRoYXQgdXNlci5cbiAgICAgKi9cbiAgICBwcmVzZW5jZVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmVzZW5jZS5zdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgdGhlIHN1cHBsaWVkIHBheWxvYWQgdG8gdGhlIHByZXNlbmNlIHRyYWNrZXIgc28gb3RoZXIgc3Vic2NyaWJlcnMgY2FuIHNlZSB0aGF0IHRoaXNcbiAgICAgKiBjbGllbnQgaXMgb25saW5lLiBVc2UgYHVudHJhY2tgIHRvIHN0b3AgYnJvYWRjYXN0aW5nIHByZXNlbmNlIGZvciB0aGUgc2FtZSBrZXkuXG4gICAgICovXG4gICAgYXN5bmMgdHJhY2socGF5bG9hZCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogJ3ByZXNlbmNlJyxcbiAgICAgICAgICAgIGV2ZW50OiAndHJhY2snLFxuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgfSwgb3B0cy50aW1lb3V0IHx8IHRoaXMudGltZW91dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGN1cnJlbnQgcHJlc2VuY2Ugc3RhdGUgZm9yIHRoaXMgY2xpZW50LlxuICAgICAqL1xuICAgIGFzeW5jIHVudHJhY2sob3B0cyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogJ3ByZXNlbmNlJyxcbiAgICAgICAgICAgIGV2ZW50OiAndW50cmFjaycsXG4gICAgICAgIH0sIG9wdHMpO1xuICAgIH1cbiAgICBvbih0eXBlLCBmaWx0ZXIsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5qb2luZWQgJiYgdHlwZSA9PT0gUkVBTFRJTUVfTElTVEVOX1RZUEVTLlBSRVNFTkNFKSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgcmVzdWJzY3JpYmUgdG8gJHt0aGlzLnRvcGljfSBkdWUgdG8gY2hhbmdlIGluIHByZXNlbmNlIGNhbGxiYWNrcyBvbiBqb2luZWQgY2hhbm5lbGApO1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpLnRoZW4oYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5zdWJzY3JpYmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX29uKHR5cGUsIGZpbHRlciwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIGJyb2FkY2FzdCBtZXNzYWdlIGV4cGxpY2l0bHkgdmlhIFJFU1QgQVBJLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYWx3YXlzIHVzZXMgdGhlIFJFU1QgQVBJIGVuZHBvaW50IHJlZ2FyZGxlc3Mgb2YgV2ViU29ja2V0IGNvbm5lY3Rpb24gc3RhdGUuXG4gICAgICogVXNlZnVsIHdoZW4geW91IHdhbnQgdG8gZ3VhcmFudGVlIFJFU1QgZGVsaXZlcnkgb3Igd2hlbiBncmFkdWFsbHkgbWlncmF0aW5nIGZyb20gaW1wbGljaXQgUkVTVCBmYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgbmFtZSBvZiB0aGUgYnJvYWRjYXN0IGV2ZW50XG4gICAgICogQHBhcmFtIHBheWxvYWQgUGF5bG9hZCB0byBiZSBzZW50IChyZXF1aXJlZClcbiAgICAgKiBAcGFyYW0gb3B0cyBPcHRpb25zIGluY2x1ZGluZyB0aW1lb3V0XG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gb2JqZWN0IHdpdGggc3VjY2VzcyBzdGF0dXMsIGFuZCBlcnJvciBkZXRhaWxzIGlmIGZhaWxlZFxuICAgICAqL1xuICAgIGFzeW5jIGh0dHBTZW5kKGV2ZW50LCBwYXlsb2FkLCBvcHRzID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAocGF5bG9hZCA9PT0gdW5kZWZpbmVkIHx8IHBheWxvYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnUGF5bG9hZCBpcyByZXF1aXJlZCBmb3IgaHR0cFNlbmQoKScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICBhcGlrZXk6IHRoaXMuc29ja2V0LmFwaUtleSA/IHRoaXMuc29ja2V0LmFwaUtleSA6ICcnLFxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0LmFjY2Vzc1Rva2VuVmFsdWUpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IGBCZWFyZXIgJHt0aGlzLnNvY2tldC5hY2Nlc3NUb2tlblZhbHVlfWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BpYzogdGhpcy5zdWJUb3BpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaXZhdGU6IHRoaXMucHJpdmF0ZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZmV0Y2hXaXRoVGltZW91dCh0aGlzLmJyb2FkY2FzdEVuZHBvaW50VVJMLCBvcHRpb25zLCAoX2EgPSBvcHRzLnRpbWVvdXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMudGltZW91dCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMikge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSByZXNwb25zZS5zdGF0dXNUZXh0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3JCb2R5LmVycm9yIHx8IGVycm9yQm9keS5tZXNzYWdlIHx8IGVycm9yTWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2IpIHsgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGVycm9yTWVzc2FnZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG1lc3NhZ2UgaW50byB0aGUgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIEFyZ3VtZW50cyB0byBzZW5kIHRvIGNoYW5uZWxcbiAgICAgKiBAcGFyYW0gYXJncy50eXBlIFRoZSB0eXBlIG9mIGV2ZW50IHRvIHNlbmRcbiAgICAgKiBAcGFyYW0gYXJncy5ldmVudCBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgYmVpbmcgc2VudFxuICAgICAqIEBwYXJhbSBhcmdzLnBheWxvYWQgUGF5bG9hZCB0byBiZSBzZW50XG4gICAgICogQHBhcmFtIG9wdHMgT3B0aW9ucyB0byBiZSB1c2VkIGR1cmluZyB0aGUgc2VuZCBwcm9jZXNzXG4gICAgICovXG4gICAgYXN5bmMgc2VuZChhcmdzLCBvcHRzID0ge30pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCF0aGlzLl9jYW5QdXNoKCkgJiYgYXJncy50eXBlID09PSAnYnJvYWRjYXN0Jykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdSZWFsdGltZSBzZW5kKCkgaXMgYXV0b21hdGljYWxseSBmYWxsaW5nIGJhY2sgdG8gUkVTVCBBUEkuICcgK1xuICAgICAgICAgICAgICAgICdUaGlzIGJlaGF2aW9yIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB0aGUgZnV0dXJlLiAnICtcbiAgICAgICAgICAgICAgICAnUGxlYXNlIHVzZSBodHRwU2VuZCgpIGV4cGxpY2l0bHkgZm9yIFJFU1QgZGVsaXZlcnkuJyk7XG4gICAgICAgICAgICBjb25zdCB7IGV2ZW50LCBwYXlsb2FkOiBlbmRwb2ludF9wYXlsb2FkIH0gPSBhcmdzO1xuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICBhcGlrZXk6IHRoaXMuc29ja2V0LmFwaUtleSA/IHRoaXMuc29ja2V0LmFwaUtleSA6ICcnLFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuc29ja2V0LmFjY2Vzc1Rva2VuVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7dGhpcy5zb2NrZXQuYWNjZXNzVG9rZW5WYWx1ZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3BpYzogdGhpcy5zdWJUb3BpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBlbmRwb2ludF9wYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaXZhdGU6IHRoaXMucHJpdmF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2ZldGNoV2l0aFRpbWVvdXQodGhpcy5icm9hZGNhc3RFbmRwb2ludFVSTCwgb3B0aW9ucywgKF9hID0gb3B0cy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGF3YWl0ICgoX2IgPSByZXNwb25zZS5ib2R5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FuY2VsKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5vayA/ICdvaycgOiAnZXJyb3InO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RpbWVkIG91dCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2Vycm9yJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICBjb25zdCBwdXNoID0gdGhpcy5fcHVzaChhcmdzLnR5cGUsIGFyZ3MsIG9wdHMudGltZW91dCB8fCB0aGlzLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLnR5cGUgPT09ICdicm9hZGNhc3QnICYmICEoKF9jID0gKF9iID0gKF9hID0gdGhpcy5wYXJhbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5icm9hZGNhc3QpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hY2spKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoJ29rJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHB1c2gucmVjZWl2ZSgnb2snLCAoKSA9PiByZXNvbHZlKCdvaycpKTtcbiAgICAgICAgICAgICAgICBwdXNoLnJlY2VpdmUoJ2Vycm9yJywgKCkgPT4gcmVzb2x2ZSgnZXJyb3InKSk7XG4gICAgICAgICAgICAgICAgcHVzaC5yZWNlaXZlKCd0aW1lb3V0JywgKCkgPT4gcmVzb2x2ZSgndGltZWQgb3V0JykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcGF5bG9hZCB0aGF0IHdpbGwgYmUgc2VudCB0aGUgbmV4dCB0aW1lIHRoZSBjaGFubmVsIGpvaW5zIChyZWNvbm5lY3RzKS5cbiAgICAgKiBVc2VmdWwgZm9yIHJvdGF0aW5nIGFjY2VzcyB0b2tlbnMgb3IgdXBkYXRpbmcgY29uZmlnIHdpdGhvdXQgcmUtY3JlYXRpbmcgdGhlIGNoYW5uZWwuXG4gICAgICovXG4gICAgdXBkYXRlSm9pblBheWxvYWQocGF5bG9hZCkge1xuICAgICAgICB0aGlzLmpvaW5QdXNoLnVwZGF0ZVBheWxvYWQocGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlYXZlcyB0aGUgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIFVuc3Vic2NyaWJlcyBmcm9tIHNlcnZlciBldmVudHMsIGFuZCBpbnN0cnVjdHMgY2hhbm5lbCB0byB0ZXJtaW5hdGUgb24gc2VydmVyLlxuICAgICAqIFRyaWdnZXJzIG9uQ2xvc2UoKSBob29rcy5cbiAgICAgKlxuICAgICAqIFRvIHJlY2VpdmUgbGVhdmUgYWNrbm93bGVkZ2VtZW50cywgdXNlIHRoZSBhIGByZWNlaXZlYCBob29rIHRvIGJpbmQgdG8gdGhlIHNlcnZlciBhY2ssIGllOlxuICAgICAqIGNoYW5uZWwudW5zdWJzY3JpYmUoKS5yZWNlaXZlKFwib2tcIiwgKCkgPT4gYWxlcnQoXCJsZWZ0IVwiKSApXG4gICAgICovXG4gICAgdW5zdWJzY3JpYmUodGltZW91dCA9IHRoaXMudGltZW91dCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMubGVhdmluZztcbiAgICAgICAgY29uc3Qgb25DbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmxvZygnY2hhbm5lbCcsIGBsZWF2ZSAke3RoaXMudG9waWN9YCk7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyKENIQU5ORUxfRVZFTlRTLmNsb3NlLCAnbGVhdmUnLCB0aGlzLl9qb2luUmVmKCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmpvaW5QdXNoLmRlc3Ryb3koKTtcbiAgICAgICAgbGV0IGxlYXZlUHVzaCA9IG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgbGVhdmVQdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMubGVhdmUsIHt9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgIGxlYXZlUHVzaFxuICAgICAgICAgICAgICAgIC5yZWNlaXZlKCdvaycsICgpID0+IHtcbiAgICAgICAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgnb2snKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnJlY2VpdmUoJ3RpbWVvdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgb25DbG9zZSgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoJ3RpbWVkIG91dCcpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVjZWl2ZSgnZXJyb3InLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgnZXJyb3InKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGVhdmVQdXNoLnNlbmQoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2FuUHVzaCgpKSB7XG4gICAgICAgICAgICAgICAgbGVhdmVQdXNoLnRyaWdnZXIoJ29rJywge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgIGxlYXZlUHVzaCA9PT0gbnVsbCB8fCBsZWF2ZVB1c2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxlYXZlUHVzaC5kZXN0cm95KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZWFyZG93biB0aGUgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIERlc3Ryb3lzIGFuZCBzdG9wcyByZWxhdGVkIHRpbWVycy5cbiAgICAgKi9cbiAgICB0ZWFyZG93bigpIHtcbiAgICAgICAgdGhpcy5wdXNoQnVmZmVyLmZvckVhY2goKHB1c2gpID0+IHB1c2guZGVzdHJveSgpKTtcbiAgICAgICAgdGhpcy5wdXNoQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKTtcbiAgICAgICAgdGhpcy5qb2luUHVzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5jbG9zZWQ7XG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSB7fTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGFzeW5jIF9mZXRjaFdpdGhUaW1lb3V0KHVybCwgb3B0aW9ucywgdGltZW91dCkge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBjb25zdCBpZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNvY2tldC5mZXRjaCh1cmwsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCB9KSk7XG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9wdXNoKGV2ZW50LCBwYXlsb2FkLCB0aW1lb3V0ID0gdGhpcy50aW1lb3V0KSB7XG4gICAgICAgIGlmICghdGhpcy5qb2luZWRPbmNlKSB7XG4gICAgICAgICAgICB0aHJvdyBgdHJpZWQgdG8gcHVzaCAnJHtldmVudH0nIHRvICcke3RoaXMudG9waWN9JyBiZWZvcmUgam9pbmluZy4gVXNlIGNoYW5uZWwuc3Vic2NyaWJlKCkgYmVmb3JlIHB1c2hpbmcgZXZlbnRzYDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHVzaEV2ZW50ID0gbmV3IFB1c2godGhpcywgZXZlbnQsIHBheWxvYWQsIHRpbWVvdXQpO1xuICAgICAgICBpZiAodGhpcy5fY2FuUHVzaCgpKSB7XG4gICAgICAgICAgICBwdXNoRXZlbnQuc2VuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYWRkVG9QdXNoQnVmZmVyKHB1c2hFdmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHB1c2hFdmVudDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9hZGRUb1B1c2hCdWZmZXIocHVzaEV2ZW50KSB7XG4gICAgICAgIHB1c2hFdmVudC5zdGFydFRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5wdXNoQnVmZmVyLnB1c2gocHVzaEV2ZW50KTtcbiAgICAgICAgLy8gRW5mb3JjZSBidWZmZXIgc2l6ZSBsaW1pdFxuICAgICAgICBpZiAodGhpcy5wdXNoQnVmZmVyLmxlbmd0aCA+IE1BWF9QVVNIX0JVRkZFUl9TSVpFKSB7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVkUHVzaCA9IHRoaXMucHVzaEJ1ZmZlci5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKHJlbW92ZWRQdXNoKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZFB1c2guZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LmxvZygnY2hhbm5lbCcsIGBkaXNjYXJkZWQgcHVzaCBkdWUgdG8gYnVmZmVyIG92ZXJmbG93OiAke3JlbW92ZWRQdXNoLmV2ZW50fWAsIHJlbW92ZWRQdXNoLnBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRhYmxlIG1lc3NhZ2UgaG9va1xuICAgICAqXG4gICAgICogUmVjZWl2ZXMgYWxsIGV2ZW50cyBmb3Igc3BlY2lhbGl6ZWQgbWVzc2FnZSBoYW5kbGluZyBiZWZvcmUgZGlzcGF0Y2hpbmcgdG8gdGhlIGNoYW5uZWwgY2FsbGJhY2tzLlxuICAgICAqIE11c3QgcmV0dXJuIHRoZSBwYXlsb2FkLCBtb2RpZmllZCBvciB1bm1vZGlmaWVkLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX29uTWVzc2FnZShfZXZlbnQsIHBheWxvYWQsIF9yZWYpIHtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfaXNNZW1iZXIodG9waWMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9waWMgPT09IHRvcGljO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2pvaW5SZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpvaW5QdXNoLnJlZjtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF90cmlnZ2VyKHR5cGUsIHBheWxvYWQsIHJlZikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB0eXBlTG93ZXIgPSB0eXBlLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHsgY2xvc2UsIGVycm9yLCBsZWF2ZSwgam9pbiB9ID0gQ0hBTk5FTF9FVkVOVFM7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IFtjbG9zZSwgZXJyb3IsIGxlYXZlLCBqb2luXTtcbiAgICAgICAgaWYgKHJlZiAmJiBldmVudHMuaW5kZXhPZih0eXBlTG93ZXIpID49IDAgJiYgcmVmICE9PSB0aGlzLl9qb2luUmVmKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaGFuZGxlZFBheWxvYWQgPSB0aGlzLl9vbk1lc3NhZ2UodHlwZUxvd2VyLCBwYXlsb2FkLCByZWYpO1xuICAgICAgICBpZiAocGF5bG9hZCAmJiAhaGFuZGxlZFBheWxvYWQpIHtcbiAgICAgICAgICAgIHRocm93ICdjaGFubmVsIG9uTWVzc2FnZSBjYWxsYmFja3MgbXVzdCByZXR1cm4gdGhlIHBheWxvYWQsIG1vZGlmaWVkIG9yIHVubW9kaWZpZWQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChbJ2luc2VydCcsICd1cGRhdGUnLCAnZGVsZXRlJ10uaW5jbHVkZXModHlwZUxvd2VyKSkge1xuICAgICAgICAgICAgKF9hID0gdGhpcy5iaW5kaW5ncy5wb3N0Z3Jlc19jaGFuZ2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlsdGVyKChiaW5kKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoX2EgPSBiaW5kLmZpbHRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV2ZW50KSA9PT0gJyonIHx8ICgoX2MgPSAoX2IgPSBiaW5kLmZpbHRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmV2ZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9Mb2NhbGVMb3dlckNhc2UoKSkgPT09IHR5cGVMb3dlcjtcbiAgICAgICAgICAgIH0pLm1hcCgoYmluZCkgPT4gYmluZC5jYWxsYmFjayhoYW5kbGVkUGF5bG9hZCwgcmVmKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoX2IgPSB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5maWx0ZXIoKGJpbmQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgICAgICAgICBpZiAoWydicm9hZGNhc3QnLCAncHJlc2VuY2UnLCAncG9zdGdyZXNfY2hhbmdlcyddLmluY2x1ZGVzKHR5cGVMb3dlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCdpZCcgaW4gYmluZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmluZElkID0gYmluZC5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpbmRFdmVudCA9IChfYSA9IGJpbmQuZmlsdGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGJpbmRJZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoX2IgPSBwYXlsb2FkLmlkcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKGJpbmRJZCkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJpbmRFdmVudCA9PT0gJyonIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChiaW5kRXZlbnQgPT09IG51bGwgfHwgYmluZEV2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiaW5kRXZlbnQudG9Mb2NhbGVMb3dlckNhc2UoKSkgPT09ICgoX2MgPSBwYXlsb2FkLmRhdGEpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50eXBlLnRvTG9jYWxlTG93ZXJDYXNlKCkpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiaW5kRXZlbnQgPSAoX2UgPSAoX2QgPSBiaW5kID09PSBudWxsIHx8IGJpbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJpbmQuZmlsdGVyKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZXZlbnQpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpbmRFdmVudCA9PT0gJyonIHx8IGJpbmRFdmVudCA9PT0gKChfZiA9IHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC5ldmVudCkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnRvTG9jYWxlTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmluZC50eXBlLnRvTG9jYWxlTG93ZXJDYXNlKCkgPT09IHR5cGVMb3dlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5tYXAoKGJpbmQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZWRQYXlsb2FkID09PSAnb2JqZWN0JyAmJiAnaWRzJyBpbiBoYW5kbGVkUGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3N0Z3Jlc0NoYW5nZXMgPSBoYW5kbGVkUGF5bG9hZC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNjaGVtYSwgdGFibGUsIGNvbW1pdF90aW1lc3RhbXAsIHR5cGUsIGVycm9ycyB9ID0gcG9zdGdyZXNDaGFuZ2VzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnJpY2hlZFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWE6IHNjaGVtYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlOiB0YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1pdF90aW1lc3RhbXA6IGNvbW1pdF90aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXc6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yczogZXJyb3JzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVkUGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZW5yaWNoZWRQYXlsb2FkKSwgdGhpcy5fZ2V0UGF5bG9hZFJlY29yZHMocG9zdGdyZXNDaGFuZ2VzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJpbmQuY2FsbGJhY2soaGFuZGxlZFBheWxvYWQsIHJlZik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2lzQ2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2lzSm9pbmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuam9pbmVkO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2lzSm9pbmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmpvaW5pbmc7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfaXNMZWF2aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMubGVhdmluZztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9yZXBseUV2ZW50TmFtZShyZWYpIHtcbiAgICAgICAgcmV0dXJuIGBjaGFuX3JlcGx5XyR7cmVmfWA7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfb24odHlwZSwgZmlsdGVyLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCB0eXBlTG93ZXIgPSB0eXBlLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGJpbmRpbmcgPSB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlTG93ZXIsXG4gICAgICAgICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXSkge1xuICAgICAgICAgICAgdGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdLnB1c2goYmluZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0gPSBbYmluZGluZ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfb2ZmKHR5cGUsIGZpbHRlcikge1xuICAgICAgICBjb25zdCB0eXBlTG93ZXIgPSB0eXBlLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICh0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0pIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXSA9IHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXS5maWx0ZXIoKGJpbmQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEoKChfYSA9IGJpbmQudHlwZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvTG9jYWxlTG93ZXJDYXNlKCkpID09PSB0eXBlTG93ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgUmVhbHRpbWVDaGFubmVsLmlzRXF1YWwoYmluZC5maWx0ZXIsIGZpbHRlcikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgaXNFcXVhbChvYmoxLCBvYmoyKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhvYmoxKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKG9iajIpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgayBpbiBvYmoxKSB7XG4gICAgICAgICAgICBpZiAob2JqMVtrXSAhPT0gb2JqMltrXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdHdvIG9wdGlvbmFsIGZpbHRlciB2YWx1ZXMgZm9yIGVxdWFsaXR5LlxuICAgICAqIFRyZWF0cyB1bmRlZmluZWQsIG51bGwsIGFuZCBlbXB0eSBzdHJpbmcgYXMgZXF1aXZhbGVudCBlbXB0eSB2YWx1ZXMuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIGlzRmlsdGVyVmFsdWVFcXVhbChzZXJ2ZXJWYWx1ZSwgY2xpZW50VmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFNlcnZlciA9IHNlcnZlclZhbHVlICE9PSBudWxsICYmIHNlcnZlclZhbHVlICE9PSB2b2lkIDAgPyBzZXJ2ZXJWYWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZENsaWVudCA9IGNsaWVudFZhbHVlICE9PSBudWxsICYmIGNsaWVudFZhbHVlICE9PSB2b2lkIDAgPyBjbGllbnRWYWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRTZXJ2ZXIgPT09IG5vcm1hbGl6ZWRDbGllbnQ7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfcmVqb2luVW50aWxDb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWpvaW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2hhbm5lbCBjbG9zZXMuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfb25DbG9zZShjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vbihDSEFOTkVMX0VWRU5UUy5jbG9zZSwge30sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNoYW5uZWwgZW5jb3VudGVyZXMgYW4gZXJyb3IuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfb25FcnJvcihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vbihDSEFOTkVMX0VWRU5UUy5lcnJvciwge30sIChyZWFzb24pID0+IGNhbGxiYWNrKHJlYXNvbikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc29ja2V0IGlzIGNvbm5lY3RlZCBhbmQgdGhlIGNoYW5uZWwgaGFzIGJlZW4gam9pbmVkLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2NhblB1c2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpICYmIHRoaXMuX2lzSm9pbmVkKCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfcmVqb2luKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzTGVhdmluZygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb2NrZXQuX2xlYXZlT3BlblRvcGljKHRoaXMudG9waWMpO1xuICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuam9pbmluZztcbiAgICAgICAgdGhpcy5qb2luUHVzaC5yZXNlbmQodGltZW91dCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZ2V0UGF5bG9hZFJlY29yZHMocGF5bG9hZCkge1xuICAgICAgICBjb25zdCByZWNvcmRzID0ge1xuICAgICAgICAgICAgbmV3OiB7fSxcbiAgICAgICAgICAgIG9sZDoge30sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwYXlsb2FkLnR5cGUgPT09ICdJTlNFUlQnIHx8IHBheWxvYWQudHlwZSA9PT0gJ1VQREFURScpIHtcbiAgICAgICAgICAgIHJlY29yZHMubmV3ID0gVHJhbnNmb3JtZXJzLmNvbnZlcnRDaGFuZ2VEYXRhKHBheWxvYWQuY29sdW1ucywgcGF5bG9hZC5yZWNvcmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXlsb2FkLnR5cGUgPT09ICdVUERBVEUnIHx8IHBheWxvYWQudHlwZSA9PT0gJ0RFTEVURScpIHtcbiAgICAgICAgICAgIHJlY29yZHMub2xkID0gVHJhbnNmb3JtZXJzLmNvbnZlcnRDaGFuZ2VEYXRhKHBheWxvYWQuY29sdW1ucywgcGF5bG9hZC5vbGRfcmVjb3JkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjb3JkcztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWFsdGltZUNoYW5uZWwuanMubWFwIl0sIm5hbWVzIjpbIkNIQU5ORUxfRVZFTlRTIiwiQ0hBTk5FTF9TVEFURVMiLCJNQVhfUFVTSF9CVUZGRVJfU0laRSIsIlB1c2giLCJUaW1lciIsIlJlYWx0aW1lUHJlc2VuY2UiLCJUcmFuc2Zvcm1lcnMiLCJodHRwRW5kcG9pbnRVUkwiLCJSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCIsIlJFQUxUSU1FX0xJU1RFTl9UWVBFUyIsIlJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMiLCJSRUFMVElNRV9DSEFOTkVMX1NUQVRFUyIsIlJlYWx0aW1lQ2hhbm5lbCIsImNvbnN0cnVjdG9yIiwidG9waWMiLCJwYXJhbXMiLCJjb25maWciLCJzb2NrZXQiLCJfYSIsIl9iIiwiYmluZGluZ3MiLCJzdGF0ZSIsImNsb3NlZCIsImpvaW5lZE9uY2UiLCJwdXNoQnVmZmVyIiwic3ViVG9waWMiLCJyZXBsYWNlIiwiT2JqZWN0IiwiYXNzaWduIiwiYnJvYWRjYXN0IiwiYWNrIiwic2VsZiIsInByZXNlbmNlIiwia2V5IiwiZW5hYmxlZCIsInByaXZhdGUiLCJ0aW1lb3V0Iiwiam9pblB1c2giLCJqb2luIiwicmVqb2luVGltZXIiLCJfcmVqb2luVW50aWxDb25uZWN0ZWQiLCJyZWNvbm5lY3RBZnRlck1zIiwicmVjZWl2ZSIsImpvaW5lZCIsInJlc2V0IiwiZm9yRWFjaCIsInB1c2hFdmVudCIsInNlbmQiLCJfb25DbG9zZSIsImxvZyIsIl9qb2luUmVmIiwiX3JlbW92ZSIsIl9vbkVycm9yIiwicmVhc29uIiwiX2lzTGVhdmluZyIsIl9pc0Nsb3NlZCIsImVycm9yZWQiLCJzY2hlZHVsZVRpbWVvdXQiLCJfaXNKb2luaW5nIiwiX29uIiwicmVwbHkiLCJwYXlsb2FkIiwicmVmIiwiX3RyaWdnZXIiLCJfcmVwbHlFdmVudE5hbWUiLCJicm9hZGNhc3RFbmRwb2ludFVSTCIsImVuZFBvaW50IiwicmVwbGF5Iiwic3Vic2NyaWJlIiwiY2FsbGJhY2siLCJfYyIsImlzQ29ubmVjdGVkIiwiY29ubmVjdCIsImlzUHJpdmF0ZSIsInBvc3RncmVzX2NoYW5nZXMiLCJtYXAiLCJyIiwiZmlsdGVyIiwicHJlc2VuY2VfZW5hYmxlZCIsIlBSRVNFTkNFIiwibGVuZ3RoIiwiYWNjZXNzVG9rZW5QYXlsb2FkIiwiYWNjZXNzVG9rZW5WYWx1ZSIsImFjY2Vzc190b2tlbiIsImUiLCJDSEFOTkVMX0VSUk9SIiwiQ0xPU0VEIiwidXBkYXRlSm9pblBheWxvYWQiLCJfcmVqb2luIiwiX2lzTWFudWFsVG9rZW4iLCJzZXRBdXRoIiwidW5kZWZpbmVkIiwiU1VCU0NSSUJFRCIsImNsaWVudFBvc3RncmVzQmluZGluZ3MiLCJiaW5kaW5nc0xlbiIsIm5ld1Bvc3RncmVzQmluZGluZ3MiLCJpIiwiY2xpZW50UG9zdGdyZXNCaW5kaW5nIiwiZXZlbnQiLCJzY2hlbWEiLCJ0YWJsZSIsInNlcnZlclBvc3RncmVzRmlsdGVyIiwiaXNGaWx0ZXJWYWx1ZUVxdWFsIiwicHVzaCIsImlkIiwidW5zdWJzY3JpYmUiLCJFcnJvciIsImVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsInZhbHVlcyIsIlRJTUVEX09VVCIsInByZXNlbmNlU3RhdGUiLCJ0cmFjayIsIm9wdHMiLCJ0eXBlIiwidW50cmFjayIsIm9uIiwidGhlbiIsImh0dHBTZW5kIiwiUHJvbWlzZSIsInJlamVjdCIsImhlYWRlcnMiLCJhcGlrZXkiLCJhcGlLZXkiLCJvcHRpb25zIiwibWV0aG9kIiwiYm9keSIsIm1lc3NhZ2VzIiwicmVzcG9uc2UiLCJfZmV0Y2hXaXRoVGltZW91dCIsInN0YXR1cyIsInN1Y2Nlc3MiLCJlcnJvck1lc3NhZ2UiLCJzdGF0dXNUZXh0IiwiZXJyb3JCb2R5IiwianNvbiIsIm1lc3NhZ2UiLCJhcmdzIiwiX2NhblB1c2giLCJjb25zb2xlIiwid2FybiIsImVuZHBvaW50X3BheWxvYWQiLCJjYW5jZWwiLCJvayIsIm5hbWUiLCJyZXNvbHZlIiwiX3B1c2giLCJ1cGRhdGVQYXlsb2FkIiwibGVhdmluZyIsIm9uQ2xvc2UiLCJjbG9zZSIsImRlc3Ryb3kiLCJsZWF2ZVB1c2giLCJsZWF2ZSIsInRyaWdnZXIiLCJmaW5hbGx5IiwidGVhcmRvd24iLCJ1cmwiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwic2V0VGltZW91dCIsImFib3J0IiwiZmV0Y2giLCJzaWduYWwiLCJjbGVhclRpbWVvdXQiLCJfYWRkVG9QdXNoQnVmZmVyIiwic3RhcnRUaW1lb3V0IiwicmVtb3ZlZFB1c2giLCJzaGlmdCIsIl9vbk1lc3NhZ2UiLCJfZXZlbnQiLCJfcmVmIiwiX2lzTWVtYmVyIiwidHlwZUxvd2VyIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJldmVudHMiLCJpbmRleE9mIiwiaGFuZGxlZFBheWxvYWQiLCJpbmNsdWRlcyIsImJpbmQiLCJfZCIsIl9lIiwiX2YiLCJiaW5kSWQiLCJiaW5kRXZlbnQiLCJpZHMiLCJkYXRhIiwicG9zdGdyZXNDaGFuZ2VzIiwiY29tbWl0X3RpbWVzdGFtcCIsImVycm9ycyIsImVucmljaGVkUGF5bG9hZCIsImV2ZW50VHlwZSIsIm5ldyIsIm9sZCIsIl9nZXRQYXlsb2FkUmVjb3JkcyIsIl9pc0pvaW5lZCIsImpvaW5pbmciLCJiaW5kaW5nIiwiX29mZiIsImlzRXF1YWwiLCJvYmoxIiwib2JqMiIsImtleXMiLCJrIiwic2VydmVyVmFsdWUiLCJjbGllbnRWYWx1ZSIsIm5vcm1hbGl6ZWRTZXJ2ZXIiLCJub3JtYWxpemVkQ2xpZW50IiwiX2xlYXZlT3BlblRvcGljIiwicmVzZW5kIiwicmVjb3JkcyIsImNvbnZlcnRDaGFuZ2VEYXRhIiwiY29sdW1ucyIsInJlY29yZCIsIm9sZF9yZWNvcmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RealtimeClient)\n/* harmony export */ });\n/* harmony import */ var _lib_websocket_factory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/websocket-factory */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js\");\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/constants */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_serializer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/serializer */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js\");\n/* harmony import */ var _lib_timer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/timer */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js\");\n/* harmony import */ var _lib_transformers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/transformers */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js\");\n/* harmony import */ var _RealtimeChannel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./RealtimeChannel */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js\");\n\n\n\n\n\n\nconst noop = ()=>{};\n// Connection-related constants\nconst CONNECTION_TIMEOUTS = {\n    HEARTBEAT_INTERVAL: 25000,\n    RECONNECT_DELAY: 10,\n    HEARTBEAT_TIMEOUT_FALLBACK: 100\n};\nconst RECONNECT_INTERVALS = [\n    1000,\n    2000,\n    5000,\n    10000\n];\nconst DEFAULT_RECONNECT_FALLBACK = 10000;\nconst WORKER_SCRIPT = `\n  addEventListener(\"message\", (e) => {\n    if (e.data.event === \"start\") {\n      setInterval(() => postMessage({ event: \"keepAlive\" }), e.data.interval);\n    }\n  });`;\nclass RealtimeClient {\n    /**\n     * Initializes the Socket.\n     *\n     * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n     * @param httpEndpoint The string HTTP endpoint, ie, \"https://example.com\", \"/\" (inherited host & protocol)\n     * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation\n     * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n     * @param options.params The optional params to pass when connecting.\n     * @param options.headers Deprecated: headers cannot be set on websocket connections and this option will be removed in the future.\n     * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n     * @param options.heartbeatCallback The optional function to handle heartbeat status and latency.\n     * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n     * @param options.logLevel Sets the log level for Realtime\n     * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n     * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n     * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n     * @param options.worker Use Web Worker to set a side flow. Defaults to false.\n     * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.\n     * @param options.vsn The protocol version to use when connecting. Supported versions are \"1.0.0\" and \"2.0.0\". Defaults to \"2.0.0\".\n     * @example\n     * ```ts\n     * import RealtimeClient from '@supabase/realtime-js'\n     *\n     * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {\n     *   params: { apikey: 'public-anon-key' },\n     * })\n     * client.connect()\n     * ```\n     */ constructor(endPoint, options){\n        var _a;\n        this.accessTokenValue = null;\n        this.apiKey = null;\n        this._manuallySetToken = false;\n        this.channels = new Array();\n        this.endPoint = \"\";\n        this.httpEndpoint = \"\";\n        /** @deprecated headers cannot be set on websocket connections */ this.headers = {};\n        this.params = {};\n        this.timeout = _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_TIMEOUT;\n        this.transport = null;\n        this.heartbeatIntervalMs = CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;\n        this.heartbeatTimer = undefined;\n        this.pendingHeartbeatRef = null;\n        this.heartbeatCallback = noop;\n        this.ref = 0;\n        this.reconnectTimer = null;\n        this.vsn = _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_VSN;\n        this.logger = noop;\n        this.conn = null;\n        this.sendBuffer = [];\n        this.serializer = new _lib_serializer__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n        this.stateChangeCallbacks = {\n            open: [],\n            close: [],\n            error: [],\n            message: []\n        };\n        this.accessToken = null;\n        this._connectionState = \"disconnected\";\n        this._wasManualDisconnect = false;\n        this._authPromise = null;\n        this._heartbeatSentAt = null;\n        /**\n         * Use either custom fetch, if provided, or default fetch to make HTTP requests\n         *\n         * @internal\n         */ this._resolveFetch = (customFetch)=>{\n            if (customFetch) {\n                return (...args)=>customFetch(...args);\n            }\n            return (...args)=>fetch(...args);\n        };\n        // Validate required parameters\n        if (!((_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey)) {\n            throw new Error(\"API key is required to connect to Realtime\");\n        }\n        this.apiKey = options.params.apikey;\n        // Initialize endpoint URLs\n        this.endPoint = `${endPoint}/${_lib_constants__WEBPACK_IMPORTED_MODULE_1__.TRANSPORTS.websocket}`;\n        this.httpEndpoint = (0,_lib_transformers__WEBPACK_IMPORTED_MODULE_4__.httpEndpointURL)(endPoint);\n        this._initializeOptions(options);\n        this._setupReconnectionTimer();\n        this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);\n    }\n    /**\n     * Connects the socket, unless already connected.\n     */ connect() {\n        // Skip if already connecting, disconnecting, or connected\n        if (this.isConnecting() || this.isDisconnecting() || this.conn !== null && this.isConnected()) {\n            return;\n        }\n        this._setConnectionState(\"connecting\");\n        // Trigger auth if needed and not already in progress\n        // This ensures auth is called for standalone RealtimeClient usage\n        // while avoiding race conditions with SupabaseClient's immediate setAuth call\n        if (this.accessToken && !this._authPromise) {\n            this._setAuthSafely(\"connect\");\n        }\n        // Establish WebSocket connection\n        if (this.transport) {\n            // Use custom transport if provided\n            this.conn = new this.transport(this.endpointURL());\n        } else {\n            // Try to use native WebSocket\n            try {\n                this.conn = _lib_websocket_factory__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createWebSocket(this.endpointURL());\n            } catch (error) {\n                this._setConnectionState(\"disconnected\");\n                const errorMessage = error.message;\n                // Provide helpful error message based on environment\n                if (errorMessage.includes(\"Node.js\")) {\n                    throw new Error(`${errorMessage}\\n\\n` + \"To use Realtime in Node.js, you need to provide a WebSocket implementation:\\n\\n\" + \"Option 1: Use Node.js 22+ which has native WebSocket support\\n\" + 'Option 2: Install and provide the \"ws\" package:\\n\\n' + \"  npm install ws\\n\\n\" + '  import ws from \"ws\"\\n' + \"  const client = new RealtimeClient(url, {\\n\" + \"    ...options,\\n\" + \"    transport: ws\\n\" + \"  })\");\n                }\n                throw new Error(`WebSocket not available: ${errorMessage}`);\n            }\n        }\n        this._setupConnectionHandlers();\n    }\n    /**\n     * Returns the URL of the websocket.\n     * @returns string The URL of the websocket.\n     */ endpointURL() {\n        return this._appendParams(this.endPoint, Object.assign({}, this.params, {\n            vsn: this.vsn\n        }));\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */ disconnect(code, reason) {\n        if (this.isDisconnecting()) {\n            return;\n        }\n        this._setConnectionState(\"disconnecting\", true);\n        if (this.conn) {\n            // Setup fallback timer to prevent hanging in disconnecting state\n            const fallbackTimer = setTimeout(()=>{\n                this._setConnectionState(\"disconnected\");\n            }, 100);\n            this.conn.onclose = ()=>{\n                clearTimeout(fallbackTimer);\n                this._setConnectionState(\"disconnected\");\n            };\n            // Close the WebSocket connection if close method exists\n            if (typeof this.conn.close === \"function\") {\n                if (code) {\n                    this.conn.close(code, reason !== null && reason !== void 0 ? reason : \"\");\n                } else {\n                    this.conn.close();\n                }\n            }\n            this._teardownConnection();\n        } else {\n            this._setConnectionState(\"disconnected\");\n        }\n    }\n    /**\n     * Returns all created channels\n     */ getChannels() {\n        return this.channels;\n    }\n    /**\n     * Unsubscribes and removes a single channel\n     * @param channel A RealtimeChannel instance\n     */ async removeChannel(channel) {\n        const status = await channel.unsubscribe();\n        if (this.channels.length === 0) {\n            this.disconnect();\n        }\n        return status;\n    }\n    /**\n     * Unsubscribes and removes all channels\n     */ async removeAllChannels() {\n        const values_1 = await Promise.all(this.channels.map((channel)=>channel.unsubscribe()));\n        this.channels = [];\n        this.disconnect();\n        return values_1;\n    }\n    /**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overridden.\n     */ log(kind, msg, data) {\n        this.logger(kind, msg, data);\n    }\n    /**\n     * Returns the current state of the socket.\n     */ connectionState() {\n        switch(this.conn && this.conn.readyState){\n            case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_STATES.connecting:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_STATE.Connecting;\n            case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_STATES.open:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_STATE.Open;\n            case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_STATES.closing:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_STATE.Closing;\n            default:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_STATE.Closed;\n        }\n    }\n    /**\n     * Returns `true` is the connection is open.\n     */ isConnected() {\n        return this.connectionState() === _lib_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_STATE.Open;\n    }\n    /**\n     * Returns `true` if the connection is currently connecting.\n     */ isConnecting() {\n        return this._connectionState === \"connecting\";\n    }\n    /**\n     * Returns `true` if the connection is currently disconnecting.\n     */ isDisconnecting() {\n        return this._connectionState === \"disconnecting\";\n    }\n    /**\n     * Creates (or reuses) a {@link RealtimeChannel} for the provided topic.\n     *\n     * Topics are automatically prefixed with `realtime:` to match the Realtime service.\n     * If a channel with the same topic already exists it will be returned instead of creating\n     * a duplicate connection.\n     */ channel(topic, params = {\n        config: {}\n    }) {\n        const realtimeTopic = `realtime:${topic}`;\n        const exists = this.getChannels().find((c)=>c.topic === realtimeTopic);\n        if (!exists) {\n            const chan = new _RealtimeChannel__WEBPACK_IMPORTED_MODULE_5__[\"default\"](`realtime:${topic}`, params, this);\n            this.channels.push(chan);\n            return chan;\n        } else {\n            return exists;\n        }\n    }\n    /**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */ push(data) {\n        const { topic, event, payload, ref } = data;\n        const callback = ()=>{\n            this.encode(data, (result)=>{\n                var _a;\n                (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n            });\n        };\n        this.log(\"push\", `${topic} ${event} (${ref})`, payload);\n        if (this.isConnected()) {\n            callback();\n        } else {\n            this.sendBuffer.push(callback);\n        }\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * If param is null it will use the `accessToken` callback function or the token set on the client.\n     *\n     * On callback used, it will set the value of the token internal to the client.\n     *\n     * When a token is explicitly provided, it will be preserved across channel operations\n     * (including removeChannel and resubscribe). The `accessToken` callback will not be\n     * invoked until `setAuth()` is called without arguments.\n     *\n     * @param token A JWT string to override the token set on the client.\n     *\n     * @example\n     * // Use a manual token (preserved across resubscribes, ignores accessToken callback)\n     * client.realtime.setAuth('my-custom-jwt')\n     *\n     * // Switch back to using the accessToken callback\n     * client.realtime.setAuth()\n     */ async setAuth(token = null) {\n        this._authPromise = this._performAuth(token);\n        try {\n            await this._authPromise;\n        } finally{\n            this._authPromise = null;\n        }\n    }\n    /**\n     * Returns true if the current access token was explicitly set via setAuth(token),\n     * false if it was obtained via the accessToken callback.\n     * @internal\n     */ _isManualToken() {\n        return this._manuallySetToken;\n    }\n    /**\n     * Sends a heartbeat message if the socket is connected.\n     */ async sendHeartbeat() {\n        var _a;\n        if (!this.isConnected()) {\n            try {\n                this.heartbeatCallback(\"disconnected\");\n            } catch (e) {\n                this.log(\"error\", \"error in heartbeat callback\", e);\n            }\n            return;\n        }\n        // Handle heartbeat timeout and force reconnection if needed\n        if (this.pendingHeartbeatRef) {\n            this.pendingHeartbeatRef = null;\n            this._heartbeatSentAt = null;\n            this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\");\n            try {\n                this.heartbeatCallback(\"timeout\");\n            } catch (e) {\n                this.log(\"error\", \"error in heartbeat callback\", e);\n            }\n            // Force reconnection after heartbeat timeout\n            this._wasManualDisconnect = false;\n            (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(_lib_constants__WEBPACK_IMPORTED_MODULE_1__.WS_CLOSE_NORMAL, \"heartbeat timeout\");\n            setTimeout(()=>{\n                var _a;\n                if (!this.isConnected()) {\n                    (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();\n                }\n            }, CONNECTION_TIMEOUTS.HEARTBEAT_TIMEOUT_FALLBACK);\n            return;\n        }\n        // Send heartbeat message to server\n        this._heartbeatSentAt = Date.now();\n        this.pendingHeartbeatRef = this._makeRef();\n        this.push({\n            topic: \"phoenix\",\n            event: \"heartbeat\",\n            payload: {},\n            ref: this.pendingHeartbeatRef\n        });\n        try {\n            this.heartbeatCallback(\"sent\");\n        } catch (e) {\n            this.log(\"error\", \"error in heartbeat callback\", e);\n        }\n        this._setAuthSafely(\"heartbeat\");\n    }\n    /**\n     * Sets a callback that receives lifecycle events for internal heartbeat messages.\n     * Useful for instrumenting connection health (e.g. sent/ok/timeout/disconnected).\n     */ onHeartbeat(callback) {\n        this.heartbeatCallback = callback;\n    }\n    /**\n     * Flushes send buffer\n     */ flushSendBuffer() {\n        if (this.isConnected() && this.sendBuffer.length > 0) {\n            this.sendBuffer.forEach((callback)=>callback());\n            this.sendBuffer = [];\n        }\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     *\n     * @internal\n     */ _makeRef() {\n        let newRef = this.ref + 1;\n        if (newRef === this.ref) {\n            this.ref = 0;\n        } else {\n            this.ref = newRef;\n        }\n        return this.ref.toString();\n    }\n    /**\n     * Unsubscribe from channels with the specified topic.\n     *\n     * @internal\n     */ _leaveOpenTopic(topic) {\n        let dupChannel = this.channels.find((c)=>c.topic === topic && (c._isJoined() || c._isJoining()));\n        if (dupChannel) {\n            this.log(\"transport\", `leaving duplicate topic \"${topic}\"`);\n            dupChannel.unsubscribe();\n        }\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     *\n     * @internal\n     */ _remove(channel) {\n        this.channels = this.channels.filter((c)=>c.topic !== channel.topic);\n    }\n    /** @internal */ _onConnMessage(rawMessage) {\n        this.decode(rawMessage.data, (msg)=>{\n            // Handle heartbeat responses\n            if (msg.topic === \"phoenix\" && msg.event === \"phx_reply\" && msg.ref && msg.ref === this.pendingHeartbeatRef) {\n                const latency = this._heartbeatSentAt ? Date.now() - this._heartbeatSentAt : undefined;\n                try {\n                    this.heartbeatCallback(msg.payload.status === \"ok\" ? \"ok\" : \"error\", latency);\n                } catch (e) {\n                    this.log(\"error\", \"error in heartbeat callback\", e);\n                }\n                this._heartbeatSentAt = null;\n                this.pendingHeartbeatRef = null;\n            }\n            // Log incoming message\n            const { topic, event, payload, ref } = msg;\n            const refString = ref ? `(${ref})` : \"\";\n            const status = payload.status || \"\";\n            this.log(\"receive\", `${status} ${topic} ${event} ${refString}`.trim(), payload);\n            // Route message to appropriate channels\n            this.channels.filter((channel)=>channel._isMember(topic)).forEach((channel)=>channel._trigger(event, payload, ref));\n            this._triggerStateCallbacks(\"message\", msg);\n        });\n    }\n    /**\n     * Clear specific timer\n     * @internal\n     */ _clearTimer(timer) {\n        var _a;\n        if (timer === \"heartbeat\" && this.heartbeatTimer) {\n            clearInterval(this.heartbeatTimer);\n            this.heartbeatTimer = undefined;\n        } else if (timer === \"reconnect\") {\n            (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.reset();\n        }\n    }\n    /**\n     * Clear all timers\n     * @internal\n     */ _clearAllTimers() {\n        this._clearTimer(\"heartbeat\");\n        this._clearTimer(\"reconnect\");\n    }\n    /**\n     * Setup connection handlers for WebSocket events\n     * @internal\n     */ _setupConnectionHandlers() {\n        if (!this.conn) return;\n        // Set binary type if supported (browsers and most WebSocket implementations)\n        if (\"binaryType\" in this.conn) {\n            ;\n            this.conn.binaryType = \"arraybuffer\";\n        }\n        this.conn.onopen = ()=>this._onConnOpen();\n        this.conn.onerror = (error)=>this._onConnError(error);\n        this.conn.onmessage = (event)=>this._onConnMessage(event);\n        this.conn.onclose = (event)=>this._onConnClose(event);\n        if (this.conn.readyState === _lib_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_STATES.open) {\n            this._onConnOpen();\n        }\n    }\n    /**\n     * Teardown connection and cleanup resources\n     * @internal\n     */ _teardownConnection() {\n        if (this.conn) {\n            if (this.conn.readyState === _lib_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_STATES.open || this.conn.readyState === _lib_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_STATES.connecting) {\n                try {\n                    this.conn.close();\n                } catch (e) {\n                    this.log(\"error\", \"Error closing connection\", e);\n                }\n            }\n            this.conn.onopen = null;\n            this.conn.onerror = null;\n            this.conn.onmessage = null;\n            this.conn.onclose = null;\n            this.conn = null;\n        }\n        this._clearAllTimers();\n        this._terminateWorker();\n        this.channels.forEach((channel)=>channel.teardown());\n    }\n    /** @internal */ _onConnOpen() {\n        this._setConnectionState(\"connected\");\n        this.log(\"transport\", `connected to ${this.endpointURL()}`);\n        // Wait for any pending auth operations before flushing send buffer\n        // This ensures channel join messages include the correct access token\n        const authPromise = this._authPromise || (this.accessToken && !this.accessTokenValue ? this.setAuth() : Promise.resolve());\n        authPromise.then(()=>{\n            this.flushSendBuffer();\n        }).catch((e)=>{\n            this.log(\"error\", \"error waiting for auth on connect\", e);\n            // Proceed anyway to avoid hanging connections\n            this.flushSendBuffer();\n        });\n        this._clearTimer(\"reconnect\");\n        if (!this.worker) {\n            this._startHeartbeat();\n        } else {\n            if (!this.workerRef) {\n                this._startWorkerHeartbeat();\n            }\n        }\n        this._triggerStateCallbacks(\"open\");\n    }\n    /** @internal */ _startHeartbeat() {\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.heartbeatTimer = setInterval(()=>this.sendHeartbeat(), this.heartbeatIntervalMs);\n    }\n    /** @internal */ _startWorkerHeartbeat() {\n        if (this.workerUrl) {\n            this.log(\"worker\", `starting worker for from ${this.workerUrl}`);\n        } else {\n            this.log(\"worker\", `starting default worker`);\n        }\n        const objectUrl = this._workerObjectUrl(this.workerUrl);\n        this.workerRef = new Worker(objectUrl);\n        this.workerRef.onerror = (error)=>{\n            this.log(\"worker\", \"worker error\", error.message);\n            this._terminateWorker();\n        };\n        this.workerRef.onmessage = (event)=>{\n            if (event.data.event === \"keepAlive\") {\n                this.sendHeartbeat();\n            }\n        };\n        this.workerRef.postMessage({\n            event: \"start\",\n            interval: this.heartbeatIntervalMs\n        });\n    }\n    /**\n     * Terminate the Web Worker and clear the reference\n     * @internal\n     */ _terminateWorker() {\n        if (this.workerRef) {\n            this.log(\"worker\", \"terminating worker\");\n            this.workerRef.terminate();\n            this.workerRef = undefined;\n        }\n    }\n    /** @internal */ _onConnClose(event) {\n        var _a;\n        this._setConnectionState(\"disconnected\");\n        this.log(\"transport\", \"close\", event);\n        this._triggerChanError();\n        this._clearTimer(\"heartbeat\");\n        // Only schedule reconnection if it wasn't a manual disconnect\n        if (!this._wasManualDisconnect) {\n            (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();\n        }\n        this._triggerStateCallbacks(\"close\", event);\n    }\n    /** @internal */ _onConnError(error) {\n        this._setConnectionState(\"disconnected\");\n        this.log(\"transport\", `${error}`);\n        this._triggerChanError();\n        this._triggerStateCallbacks(\"error\", error);\n        try {\n            this.heartbeatCallback(\"error\");\n        } catch (e) {\n            this.log(\"error\", \"error in heartbeat callback\", e);\n        }\n    }\n    /** @internal */ _triggerChanError() {\n        this.channels.forEach((channel)=>channel._trigger(_lib_constants__WEBPACK_IMPORTED_MODULE_1__.CHANNEL_EVENTS.error));\n    }\n    /** @internal */ _appendParams(url, params) {\n        if (Object.keys(params).length === 0) {\n            return url;\n        }\n        const prefix = url.match(/\\?/) ? \"&\" : \"?\";\n        const query = new URLSearchParams(params);\n        return `${url}${prefix}${query}`;\n    }\n    _workerObjectUrl(url) {\n        let result_url;\n        if (url) {\n            result_url = url;\n        } else {\n            const blob = new Blob([\n                WORKER_SCRIPT\n            ], {\n                type: \"application/javascript\"\n            });\n            result_url = URL.createObjectURL(blob);\n        }\n        return result_url;\n    }\n    /**\n     * Set connection state with proper state management\n     * @internal\n     */ _setConnectionState(state, manual = false) {\n        this._connectionState = state;\n        if (state === \"connecting\") {\n            this._wasManualDisconnect = false;\n        } else if (state === \"disconnecting\") {\n            this._wasManualDisconnect = manual;\n        }\n    }\n    /**\n     * Perform the actual auth operation\n     * @internal\n     */ async _performAuth(token = null) {\n        let tokenToSend;\n        let isManualToken = false;\n        if (token) {\n            tokenToSend = token;\n            // Track if this is a manually-provided token\n            isManualToken = true;\n        } else if (this.accessToken) {\n            // Call the accessToken callback to get fresh token\n            try {\n                tokenToSend = await this.accessToken();\n            } catch (e) {\n                this.log(\"error\", \"Error fetching access token from callback\", e);\n                // Fall back to cached value if callback fails\n                tokenToSend = this.accessTokenValue;\n            }\n        } else {\n            tokenToSend = this.accessTokenValue;\n        }\n        // Track whether this token was manually set or fetched via callback\n        if (isManualToken) {\n            this._manuallySetToken = true;\n        } else if (this.accessToken) {\n            // If we used the callback, clear the manual flag\n            this._manuallySetToken = false;\n        }\n        if (this.accessTokenValue != tokenToSend) {\n            this.accessTokenValue = tokenToSend;\n            this.channels.forEach((channel)=>{\n                const payload = {\n                    access_token: tokenToSend,\n                    version: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_VERSION\n                };\n                tokenToSend && channel.updateJoinPayload(payload);\n                if (channel.joinedOnce && channel._isJoined()) {\n                    channel._push(_lib_constants__WEBPACK_IMPORTED_MODULE_1__.CHANNEL_EVENTS.access_token, {\n                        access_token: tokenToSend\n                    });\n                }\n            });\n        }\n    }\n    /**\n     * Wait for any in-flight auth operations to complete\n     * @internal\n     */ async _waitForAuthIfNeeded() {\n        if (this._authPromise) {\n            await this._authPromise;\n        }\n    }\n    /**\n     * Safely call setAuth with standardized error handling\n     * @internal\n     */ _setAuthSafely(context = \"general\") {\n        // Only refresh auth if using callback-based tokens\n        if (!this._isManualToken()) {\n            this.setAuth().catch((e)=>{\n                this.log(\"error\", `Error setting auth in ${context}`, e);\n            });\n        }\n    }\n    /**\n     * Trigger state change callbacks with proper error handling\n     * @internal\n     */ _triggerStateCallbacks(event, data) {\n        try {\n            this.stateChangeCallbacks[event].forEach((callback)=>{\n                try {\n                    callback(data);\n                } catch (e) {\n                    this.log(\"error\", `error in ${event} callback`, e);\n                }\n            });\n        } catch (e) {\n            this.log(\"error\", `error triggering ${event} callbacks`, e);\n        }\n    }\n    /**\n     * Setup reconnection timer with proper configuration\n     * @internal\n     */ _setupReconnectionTimer() {\n        this.reconnectTimer = new _lib_timer__WEBPACK_IMPORTED_MODULE_3__[\"default\"](async ()=>{\n            setTimeout(async ()=>{\n                await this._waitForAuthIfNeeded();\n                if (!this.isConnected()) {\n                    this.connect();\n                }\n            }, CONNECTION_TIMEOUTS.RECONNECT_DELAY);\n        }, this.reconnectAfterMs);\n    }\n    /**\n     * Initialize client options with defaults\n     * @internal\n     */ _initializeOptions(options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n        // Set defaults\n        this.transport = (_a = options === null || options === void 0 ? void 0 : options.transport) !== null && _a !== void 0 ? _a : null;\n        this.timeout = (_b = options === null || options === void 0 ? void 0 : options.timeout) !== null && _b !== void 0 ? _b : _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_TIMEOUT;\n        this.heartbeatIntervalMs = (_c = options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) !== null && _c !== void 0 ? _c : CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;\n        this.worker = (_d = options === null || options === void 0 ? void 0 : options.worker) !== null && _d !== void 0 ? _d : false;\n        this.accessToken = (_e = options === null || options === void 0 ? void 0 : options.accessToken) !== null && _e !== void 0 ? _e : null;\n        this.heartbeatCallback = (_f = options === null || options === void 0 ? void 0 : options.heartbeatCallback) !== null && _f !== void 0 ? _f : noop;\n        this.vsn = (_g = options === null || options === void 0 ? void 0 : options.vsn) !== null && _g !== void 0 ? _g : _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_VSN;\n        // Handle special cases\n        if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;\n        if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;\n        if ((options === null || options === void 0 ? void 0 : options.logLevel) || (options === null || options === void 0 ? void 0 : options.log_level)) {\n            this.logLevel = options.logLevel || options.log_level;\n            this.params = Object.assign(Object.assign({}, this.params), {\n                log_level: this.logLevel\n            });\n        }\n        // Set up functions with defaults\n        this.reconnectAfterMs = (_h = options === null || options === void 0 ? void 0 : options.reconnectAfterMs) !== null && _h !== void 0 ? _h : (tries)=>{\n            return RECONNECT_INTERVALS[tries - 1] || DEFAULT_RECONNECT_FALLBACK;\n        };\n        switch(this.vsn){\n            case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.VSN_1_0_0:\n                this.encode = (_j = options === null || options === void 0 ? void 0 : options.encode) !== null && _j !== void 0 ? _j : (payload, callback)=>{\n                    return callback(JSON.stringify(payload));\n                };\n                this.decode = (_k = options === null || options === void 0 ? void 0 : options.decode) !== null && _k !== void 0 ? _k : (payload, callback)=>{\n                    return callback(JSON.parse(payload));\n                };\n                break;\n            case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.VSN_2_0_0:\n                this.encode = (_l = options === null || options === void 0 ? void 0 : options.encode) !== null && _l !== void 0 ? _l : this.serializer.encode.bind(this.serializer);\n                this.decode = (_m = options === null || options === void 0 ? void 0 : options.decode) !== null && _m !== void 0 ? _m : this.serializer.decode.bind(this.serializer);\n                break;\n            default:\n                throw new Error(`Unsupported serializer version: ${this.vsn}`);\n        }\n        // Handle worker setup\n        if (this.worker) {\n            if (false) {}\n            this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;\n        }\n    }\n} //# sourceMappingURL=RealtimeClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL1JlYWx0aW1lQ2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBdUQ7QUFDOEg7QUFDM0k7QUFDVjtBQUNxQjtBQUNMO0FBQ2hELE1BQU1lLE9BQU8sS0FBUTtBQUNyQiwrQkFBK0I7QUFDL0IsTUFBTUMsc0JBQXNCO0lBQ3hCQyxvQkFBb0I7SUFDcEJDLGlCQUFpQjtJQUNqQkMsNEJBQTRCO0FBQ2hDO0FBQ0EsTUFBTUMsc0JBQXNCO0lBQUM7SUFBTTtJQUFNO0lBQU07Q0FBTTtBQUNyRCxNQUFNQyw2QkFBNkI7QUFDbkMsTUFBTUMsZ0JBQWdCLENBQUM7Ozs7O0tBS2xCLENBQUM7QUFDUyxNQUFNQztJQUNqQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQTRCQyxHQUNEQyxZQUFZQyxRQUFRLEVBQUVDLE9BQU8sQ0FBRTtRQUMzQixJQUFJQztRQUNKLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNDLGlCQUFpQixHQUFHO1FBQ3pCLElBQUksQ0FBQ0MsUUFBUSxHQUFHLElBQUlDO1FBQ3BCLElBQUksQ0FBQ1AsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ1EsWUFBWSxHQUFHO1FBQ3BCLCtEQUErRCxHQUMvRCxJQUFJLENBQUNDLE9BQU8sR0FBRyxDQUFDO1FBQ2hCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLENBQUM7UUFDZixJQUFJLENBQUNDLE9BQU8sR0FBR2hDLDJEQUFlQTtRQUM5QixJQUFJLENBQUNpQyxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxtQkFBbUIsR0FBR3RCLG9CQUFvQkMsa0JBQWtCO1FBQ2pFLElBQUksQ0FBQ3NCLGNBQWMsR0FBR0M7UUFDdEIsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRztRQUMzQixJQUFJLENBQUNDLGlCQUFpQixHQUFHM0I7UUFDekIs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Q0FBQyxDQUFDO1FBQ3JFO1FBQ0Esc0JBQXNCO1FBQ3RCLElBQUksSUFBSSxDQUFDbUksTUFBTSxFQUFFO1lBQ2IsSUFBSSxLQUErQyxFQUFFLEVBRXBEO1lBQ0QsSUFBSSxDQUFDSyxTQUFTLEdBQUczSixZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUTJKLFNBQVM7UUFDeEY7SUFDSjtBQUNKLEVBQ0EsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5jaG9yLXdvcmtmbG93cy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvUmVhbHRpbWVDbGllbnQuanM/NmI2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgV2ViU29ja2V0RmFjdG9yeSBmcm9tICcuL2xpYi93ZWJzb2NrZXQtZmFjdG9yeSc7XG5pbXBvcnQgeyBDSEFOTkVMX0VWRU5UUywgQ09OTkVDVElPTl9TVEFURSwgREVGQVVMVF9WRVJTSU9OLCBERUZBVUxUX1RJTUVPVVQsIFNPQ0tFVF9TVEFURVMsIFRSQU5TUE9SVFMsIERFRkFVTFRfVlNOLCBWU05fMV8wXzAsIFZTTl8yXzBfMCwgV1NfQ0xPU0VfTk9STUFMLCB9IGZyb20gJy4vbGliL2NvbnN0YW50cyc7XG5pbXBvcnQgU2VyaWFsaXplciBmcm9tICcuL2xpYi9zZXJpYWxpemVyJztcbmltcG9ydCBUaW1lciBmcm9tICcuL2xpYi90aW1lcic7XG5pbXBvcnQgeyBodHRwRW5kcG9pbnRVUkwgfSBmcm9tICcuL2xpYi90cmFuc2Zvcm1lcnMnO1xuaW1wb3J0IFJlYWx0aW1lQ2hhbm5lbCBmcm9tICcuL1JlYWx0aW1lQ2hhbm5lbCc7XG5jb25zdCBub29wID0gKCkgPT4geyB9O1xuLy8gQ29ubmVjdGlvbi1yZWxhdGVkIGNvbnN0YW50c1xuY29uc3QgQ09OTkVDVElPTl9USU1FT1VUUyA9IHtcbiAgICBIRUFSVEJFQVRfSU5URVJWQUw6IDI1MDAwLFxuICAgIFJFQ09OTkVDVF9ERUxBWTogMTAsXG4gICAgSEVBUlRCRUFUX1RJTUVPVVRfRkFMTEJBQ0s6IDEwMCxcbn07XG5jb25zdCBSRUNPTk5FQ1RfSU5URVJWQUxTID0gWzEwMDAsIDIwMDAsIDUwMDAsIDEwMDAwXTtcbmNvbnN0IERFRkFVTFRfUkVDT05ORUNUX0ZBTExCQUNLID0gMTAwMDA7XG5jb25zdCBXT1JLRVJfU0NSSVBUID0gYFxuICBhZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZSkgPT4ge1xuICAgIGlmIChlLmRhdGEuZXZlbnQgPT09IFwic3RhcnRcIikge1xuICAgICAgc2V0SW50ZXJ2YWwoKCkgPT4gcG9zdE1lc3NhZ2UoeyBldmVudDogXCJrZWVwQWxpdmVcIiB9KSwgZS5kYXRhLmludGVydmFsKTtcbiAgICB9XG4gIH0pO2A7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWFsdGltZUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIFNvY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbmRQb2ludCBUaGUgc3RyaW5nIFdlYlNvY2tldCBlbmRwb2ludCwgaWUsIFwid3M6Ly9leGFtcGxlLmNvbS9zb2NrZXRcIiwgXCJ3c3M6Ly9leGFtcGxlLmNvbVwiLCBcIi9zb2NrZXRcIiAoaW5oZXJpdGVkIGhvc3QgJiBwcm90b2NvbClcbiAgICAgKiBAcGFyYW0gaHR0cEVuZHBvaW50IFRoZSBzdHJpbmcgSFRUUCBlbmRwb2ludCwgaWUsIFwiaHR0cHM6Ly9leGFtcGxlLmNvbVwiLCBcIi9cIiAoaW5oZXJpdGVkIGhvc3QgJiBwcm90b2NvbClcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50cmFuc3BvcnQgVGhlIFdlYnNvY2tldCBUcmFuc3BvcnQsIGZvciBleGFtcGxlIFdlYlNvY2tldC4gVGhpcyBjYW4gYmUgYSBjdXN0b20gaW1wbGVtZW50YXRpb25cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50aW1lb3V0IFRoZSBkZWZhdWx0IHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIHRyaWdnZXIgcHVzaCB0aW1lb3V0cy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wYXJhbXMgVGhlIG9wdGlvbmFsIHBhcmFtcyB0byBwYXNzIHdoZW4gY29ubmVjdGluZy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFkZXJzIERlcHJlY2F0ZWQ6IGhlYWRlcnMgY2Fubm90IGJlIHNldCBvbiB3ZWJzb2NrZXQgY29ubmVjdGlvbnMgYW5kIHRoaXMgb3B0aW9uIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmhlYXJ0YmVhdEludGVydmFsTXMgVGhlIG1pbGxpc2VjIGludGVydmFsIHRvIHNlbmQgYSBoZWFydGJlYXQgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFydGJlYXRDYWxsYmFjayBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gdG8gaGFuZGxlIGhlYXJ0YmVhdCBzdGF0dXMgYW5kIGxhdGVuY3kuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubG9nZ2VyIFRoZSBvcHRpb25hbCBmdW5jdGlvbiBmb3Igc3BlY2lhbGl6ZWQgbG9nZ2luZywgaWU6IGxvZ2dlcjogKGtpbmQsIG1zZywgZGF0YSkgPT4geyBjb25zb2xlLmxvZyhgJHtraW5kfTogJHttc2d9YCwgZGF0YSkgfVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmxvZ0xldmVsIFNldHMgdGhlIGxvZyBsZXZlbCBmb3IgUmVhbHRpbWVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5lbmNvZGUgVGhlIGZ1bmN0aW9uIHRvIGVuY29kZSBvdXRnb2luZyBtZXNzYWdlcy4gRGVmYXVsdHMgdG8gSlNPTjogKHBheWxvYWQsIGNhbGxiYWNrKSA9PiBjYWxsYmFjayhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSlcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kZWNvZGUgVGhlIGZ1bmN0aW9uIHRvIGRlY29kZSBpbmNvbWluZyBtZXNzYWdlcy4gRGVmYXVsdHMgdG8gU2VyaWFsaXplcidzIGRlY29kZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZWNvbm5lY3RBZnRlck1zIGhlIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbWlsbHNlYyByZWNvbm5lY3QgaW50ZXJ2YWwuIERlZmF1bHRzIHRvIHN0ZXBwZWQgYmFja29mZiBvZmYuXG4gICAgICogQHBhcmFtIG9wdGlvbnMud29ya2VyIFVzZSBXZWIgV29ya2VyIHRvIHNldCBhIHNpZGUgZmxvdy4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMud29ya2VyVXJsIFRoZSBVUkwgb2YgdGhlIHdvcmtlciBzY3JpcHQuIERlZmF1bHRzIHRvIGh0dHBzOi8vcmVhbHRpbWUuc3VwYWJhc2UuY29tL3dvcmtlci5qcyB0aGF0IGluY2x1ZGVzIGEgaGVhcnRiZWF0IGV2ZW50IGNhbGwgdG8ga2VlcCB0aGUgY29ubmVjdGlvbiBhbGl2ZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy52c24gVGhlIHByb3RvY29sIHZlcnNpb24gdG8gdXNlIHdoZW4gY29ubmVjdGluZy4gU3VwcG9ydGVkIHZlcnNpb25zIGFyZSBcIjEuMC4wXCIgYW5kIFwiMi4wLjBcIi4gRGVmYXVsdHMgdG8gXCIyLjAuMFwiLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBpbXBvcnQgUmVhbHRpbWVDbGllbnQgZnJvbSAnQHN1cGFiYXNlL3JlYWx0aW1lLWpzJ1xuICAgICAqXG4gICAgICogY29uc3QgY2xpZW50ID0gbmV3IFJlYWx0aW1lQ2xpZW50KCdodHRwczovL3h5emNvbXBhbnkuc3VwYWJhc2UuY28vcmVhbHRpbWUvdjEnLCB7XG4gICAgICogICBwYXJhbXM6IHsgYXBpa2V5OiAncHVibGljLWFub24ta2V5JyB9LFxuICAgICAqIH0pXG4gICAgICogY2xpZW50LmNvbm5lY3QoKVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVuZFBvaW50LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlblZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBudWxsO1xuICAgICAgICB0aGlzLl9tYW51YWxseVNldFRva2VuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5lbmRQb2ludCA9ICcnO1xuICAgICAgICB0aGlzLmh0dHBFbmRwb2ludCA9ICcnO1xuICAgICAgICAvKiogQGRlcHJlY2F0ZWQgaGVhZGVycyBjYW5ub3QgYmUgc2V0IG9uIHdlYnNvY2tldCBjb25uZWN0aW9ucyAqL1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSB7fTtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gREVGQVVMVF9USU1FT1VUO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyA9IENPTk5FQ1RJT05fVElNRU9VVFMuSEVBUlRCRUFUX0lOVEVSVkFMO1xuICAgICAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsO1xuICAgICAgICB0aGlzLmhlYXJ0YmVhdENhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgdGhpcy5yZWYgPSAwO1xuICAgICAgICB0aGlzLnJlY29ubmVjdFRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy52c24gPSBERUZBVUxUX1ZTTjtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBub29wO1xuICAgICAgICB0aGlzLmNvbm4gPSBudWxsO1xuICAgICAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gbmV3IFNlcmlhbGl6ZXIoKTtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIG9wZW46IFtdLFxuICAgICAgICAgICAgY2xvc2U6IFtdLFxuICAgICAgICAgICAgZXJyb3I6IFtdLFxuICAgICAgICAgICAgbWVzc2FnZTogW10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBudWxsO1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdGUgPSAnZGlzY29ubmVjdGVkJztcbiAgICAgICAgdGhpcy5fd2FzTWFudWFsRGlzY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9hdXRoUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2hlYXJ0YmVhdFNlbnRBdCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2UgZWl0aGVyIGN1c3RvbSBmZXRjaCwgaWYgcHJvdmlkZWQsIG9yIGRlZmF1bHQgZmV0Y2ggdG8gbWFrZSBIVFRQIHJlcXVlc3RzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcmVzb2x2ZUZldGNoID0gKGN1c3RvbUZldGNoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY3VzdG9tRmV0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IGN1c3RvbUZldGNoKC4uLmFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiBmZXRjaCguLi5hcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVmFsaWRhdGUgcmVxdWlyZWQgcGFyYW1ldGVyc1xuICAgICAgICBpZiAoISgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXBpa2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBUEkga2V5IGlzIHJlcXVpcmVkIHRvIGNvbm5lY3QgdG8gUmVhbHRpbWUnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwaUtleSA9IG9wdGlvbnMucGFyYW1zLmFwaWtleTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBlbmRwb2ludCBVUkxzXG4gICAgICAgIHRoaXMuZW5kUG9pbnQgPSBgJHtlbmRQb2ludH0vJHtUUkFOU1BPUlRTLndlYnNvY2tldH1gO1xuICAgICAgICB0aGlzLmh0dHBFbmRwb2ludCA9IGh0dHBFbmRwb2ludFVSTChlbmRQb2ludCk7XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9zZXR1cFJlY29ubmVjdGlvblRpbWVyKCk7XG4gICAgICAgIHRoaXMuZmV0Y2ggPSB0aGlzLl9yZXNvbHZlRmV0Y2gob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZldGNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdHMgdGhlIHNvY2tldCwgdW5sZXNzIGFscmVhZHkgY29ubmVjdGVkLlxuICAgICAqL1xuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIC8vIFNraXAgaWYgYWxyZWFkeSBjb25uZWN0aW5nLCBkaXNjb25uZWN0aW5nLCBvciBjb25uZWN0ZWRcbiAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0aW5nKCkgfHxcbiAgICAgICAgICAgIHRoaXMuaXNEaXNjb25uZWN0aW5nKCkgfHxcbiAgICAgICAgICAgICh0aGlzLmNvbm4gIT09IG51bGwgJiYgdGhpcy5pc0Nvbm5lY3RlZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldENvbm5lY3Rpb25TdGF0ZSgnY29ubmVjdGluZycpO1xuICAgICAgICAvLyBUcmlnZ2VyIGF1dGggaWYgbmVlZGVkIGFuZCBub3QgYWxyZWFkeSBpbiBwcm9ncmVzc1xuICAgICAgICAvLyBUaGlzIGVuc3VyZXMgYXV0aCBpcyBjYWxsZWQgZm9yIHN0YW5kYWxvbmUgUmVhbHRpbWVDbGllbnQgdXNhZ2VcbiAgICAgICAgLy8gd2hpbGUgYXZvaWRpbmcgcmFjZSBjb25kaXRpb25zIHdpdGggU3VwYWJhc2VDbGllbnQncyBpbW1lZGlhdGUgc2V0QXV0aCBjYWxsXG4gICAgICAgIGlmICh0aGlzLmFjY2Vzc1Rva2VuICYmICF0aGlzLl9hdXRoUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0QXV0aFNhZmVseSgnY29ubmVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVzdGFibGlzaCBXZWJTb2NrZXQgY29ubmVjdGlvblxuICAgICAgICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIC8vIFVzZSBjdXN0b20gdHJhbnNwb3J0IGlmIHByb3ZpZGVkXG4gICAgICAgICAgICB0aGlzLmNvbm4gPSBuZXcgdGhpcy50cmFuc3BvcnQodGhpcy5lbmRwb2ludFVSTCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRyeSB0byB1c2UgbmF0aXZlIFdlYlNvY2tldFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm4gPSBXZWJTb2NrZXRGYWN0b3J5LmNyZWF0ZVdlYlNvY2tldCh0aGlzLmVuZHBvaW50VVJMKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0Q29ubmVjdGlvblN0YXRlKCdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIC8vIFByb3ZpZGUgaGVscGZ1bCBlcnJvciBtZXNzYWdlIGJhc2VkIG9uIGVudmlyb25tZW50XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yTWVzc2FnZS5pbmNsdWRlcygnTm9kZS5qcycpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtlcnJvck1lc3NhZ2V9XFxuXFxuYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnVG8gdXNlIFJlYWx0aW1lIGluIE5vZGUuanMsIHlvdSBuZWVkIHRvIHByb3ZpZGUgYSBXZWJTb2NrZXQgaW1wbGVtZW50YXRpb246XFxuXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnT3B0aW9uIDE6IFVzZSBOb2RlLmpzIDIyKyB3aGljaCBoYXMgbmF0aXZlIFdlYlNvY2tldCBzdXBwb3J0XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnT3B0aW9uIDI6IEluc3RhbGwgYW5kIHByb3ZpZGUgdGhlIFwid3NcIiBwYWNrYWdlOlxcblxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyAgbnBtIGluc3RhbGwgd3NcXG5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgIGltcG9ydCB3cyBmcm9tIFwid3NcIlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyAgY29uc3QgY2xpZW50ID0gbmV3IFJlYWx0aW1lQ2xpZW50KHVybCwge1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyAgICAuLi5vcHRpb25zLFxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyAgICB0cmFuc3BvcnQ6IHdzXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnICB9KScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdlYlNvY2tldCBub3QgYXZhaWxhYmxlOiAke2Vycm9yTWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXR1cENvbm5lY3Rpb25IYW5kbGVycygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBVUkwgb2YgdGhlIHdlYnNvY2tldC5cbiAgICAgKiBAcmV0dXJucyBzdHJpbmcgVGhlIFVSTCBvZiB0aGUgd2Vic29ja2V0LlxuICAgICAqL1xuICAgIGVuZHBvaW50VVJMKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwZW5kUGFyYW1zKHRoaXMuZW5kUG9pbnQsIE9iamVjdC5hc3NpZ24oe30sIHRoaXMucGFyYW1zLCB7IHZzbjogdGhpcy52c24gfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0cyB0aGUgc29ja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvZGUgQSBudW1lcmljIHN0YXR1cyBjb2RlIHRvIHNlbmQgb24gZGlzY29ubmVjdC5cbiAgICAgKiBAcGFyYW0gcmVhc29uIEEgY3VzdG9tIHJlYXNvbiBmb3IgdGhlIGRpc2Nvbm5lY3QuXG4gICAgICovXG4gICAgZGlzY29ubmVjdChjb2RlLCByZWFzb24pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXNjb25uZWN0aW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RpbmcnLCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMuY29ubikge1xuICAgICAgICAgICAgLy8gU2V0dXAgZmFsbGJhY2sgdGltZXIgdG8gcHJldmVudCBoYW5naW5nIGluIGRpc2Nvbm5lY3Rpbmcgc3RhdGVcbiAgICAgICAgICAgIGNvbnN0IGZhbGxiYWNrVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgIHRoaXMuY29ubi5vbmNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChmYWxsYmFja1RpbWVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIENsb3NlIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpZiBjbG9zZSBtZXRob2QgZXhpc3RzXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29ubi5jbG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubi5jbG9zZShjb2RlLCByZWFzb24gIT09IG51bGwgJiYgcmVhc29uICE9PSB2b2lkIDAgPyByZWFzb24gOiAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm4uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90ZWFyZG93bkNvbm5lY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldENvbm5lY3Rpb25TdGF0ZSgnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgY3JlYXRlZCBjaGFubmVsc1xuICAgICAqL1xuICAgIGdldENoYW5uZWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVscztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIGFuZCByZW1vdmVzIGEgc2luZ2xlIGNoYW5uZWxcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBBIFJlYWx0aW1lQ2hhbm5lbCBpbnN0YW5jZVxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZUNoYW5uZWwoY2hhbm5lbCkge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBhd2FpdCBjaGFubmVsLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIGFuZCByZW1vdmVzIGFsbCBjaGFubmVsc1xuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZUFsbENoYW5uZWxzKCkge1xuICAgICAgICBjb25zdCB2YWx1ZXNfMSA9IGF3YWl0IFByb21pc2UuYWxsKHRoaXMuY2hhbm5lbHMubWFwKChjaGFubmVsKSA9PiBjaGFubmVsLnVuc3Vic2NyaWJlKCkpKTtcbiAgICAgICAgdGhpcy5jaGFubmVscyA9IFtdO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlc18xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIHRoZSBtZXNzYWdlLlxuICAgICAqXG4gICAgICogRm9yIGN1c3RvbWl6ZWQgbG9nZ2luZywgYHRoaXMubG9nZ2VyYCBjYW4gYmUgb3ZlcnJpZGRlbi5cbiAgICAgKi9cbiAgICBsb2coa2luZCwgbXNnLCBkYXRhKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyKGtpbmQsIG1zZywgZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHNvY2tldC5cbiAgICAgKi9cbiAgICBjb25uZWN0aW9uU3RhdGUoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5jb25uICYmIHRoaXMuY29ubi5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZzpcbiAgICAgICAgICAgICAgICByZXR1cm4gQ09OTkVDVElPTl9TVEFURS5Db25uZWN0aW5nO1xuICAgICAgICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLm9wZW46XG4gICAgICAgICAgICAgICAgcmV0dXJuIENPTk5FQ1RJT05fU1RBVEUuT3BlbjtcbiAgICAgICAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5jbG9zaW5nOlxuICAgICAgICAgICAgICAgIHJldHVybiBDT05ORUNUSU9OX1NUQVRFLkNsb3Npbmc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBDT05ORUNUSU9OX1NUQVRFLkNsb3NlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpcyB0aGUgY29ubmVjdGlvbiBpcyBvcGVuLlxuICAgICAqL1xuICAgIGlzQ29ubmVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uU3RhdGUoKSA9PT0gQ09OTkVDVElPTl9TVEFURS5PcGVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgY29ubmVjdGlvbiBpcyBjdXJyZW50bHkgY29ubmVjdGluZy5cbiAgICAgKi9cbiAgICBpc0Nvbm5lY3RpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0aW5nJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNvbm5lY3Rpb24gaXMgY3VycmVudGx5IGRpc2Nvbm5lY3RpbmcuXG4gICAgICovXG4gICAgaXNEaXNjb25uZWN0aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblN0YXRlID09PSAnZGlzY29ubmVjdGluZyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgKG9yIHJldXNlcykgYSB7QGxpbmsgUmVhbHRpbWVDaGFubmVsfSBmb3IgdGhlIHByb3ZpZGVkIHRvcGljLlxuICAgICAqXG4gICAgICogVG9waWNzIGFyZSBhdXRvbWF0aWNhbGx5IHByZWZpeGVkIHdpdGggYHJlYWx0aW1lOmAgdG8gbWF0Y2ggdGhlIFJlYWx0aW1lIHNlcnZpY2UuXG4gICAgICogSWYgYSBjaGFubmVsIHdpdGggdGhlIHNhbWUgdG9waWMgYWxyZWFkeSBleGlzdHMgaXQgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkIG9mIGNyZWF0aW5nXG4gICAgICogYSBkdXBsaWNhdGUgY29ubmVjdGlvbi5cbiAgICAgKi9cbiAgICBjaGFubmVsKHRvcGljLCBwYXJhbXMgPSB7IGNvbmZpZzoge30gfSkge1xuICAgICAgICBjb25zdCByZWFsdGltZVRvcGljID0gYHJlYWx0aW1lOiR7dG9waWN9YDtcbiAgICAgICAgY29uc3QgZXhpc3RzID0gdGhpcy5nZXRDaGFubmVscygpLmZpbmQoKGMpID0+IGMudG9waWMgPT09IHJlYWx0aW1lVG9waWMpO1xuICAgICAgICBpZiAoIWV4aXN0cykge1xuICAgICAgICAgICAgY29uc3QgY2hhbiA9IG5ldyBSZWFsdGltZUNoYW5uZWwoYHJlYWx0aW1lOiR7dG9waWN9YCwgcGFyYW1zLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHMucHVzaChjaGFuKTtcbiAgICAgICAgICAgIHJldHVybiBjaGFuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0cztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoIG91dCBhIG1lc3NhZ2UgaWYgdGhlIHNvY2tldCBpcyBjb25uZWN0ZWQuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgc29ja2V0IGlzIG5vdCBjb25uZWN0ZWQsIHRoZSBtZXNzYWdlIGdldHMgZW5xdWV1ZWQgd2l0aGluIGEgbG9jYWwgYnVmZmVyLCBhbmQgc2VudCBvdXQgd2hlbiBhIGNvbm5lY3Rpb24gaXMgbmV4dCBlc3RhYmxpc2hlZC5cbiAgICAgKi9cbiAgICBwdXNoKGRhdGEpIHtcbiAgICAgICAgY29uc3QgeyB0b3BpYywgZXZlbnQsIHBheWxvYWQsIHJlZiB9ID0gZGF0YTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVuY29kZShkYXRhLCAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuY29ubikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlbmQocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvZygncHVzaCcsIGAke3RvcGljfSAke2V2ZW50fSAoJHtyZWZ9KWAsIHBheWxvYWQpO1xuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZW5kQnVmZmVyLnB1c2goY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIEpXVCBhY2Nlc3MgdG9rZW4gdXNlZCBmb3IgY2hhbm5lbCBzdWJzY3JpcHRpb24gYXV0aG9yaXphdGlvbiBhbmQgUmVhbHRpbWUgUkxTLlxuICAgICAqXG4gICAgICogSWYgcGFyYW0gaXMgbnVsbCBpdCB3aWxsIHVzZSB0aGUgYGFjY2Vzc1Rva2VuYCBjYWxsYmFjayBmdW5jdGlvbiBvciB0aGUgdG9rZW4gc2V0IG9uIHRoZSBjbGllbnQuXG4gICAgICpcbiAgICAgKiBPbiBjYWxsYmFjayB1c2VkLCBpdCB3aWxsIHNldCB0aGUgdmFsdWUgb2YgdGhlIHRva2VuIGludGVybmFsIHRvIHRoZSBjbGllbnQuXG4gICAgICpcbiAgICAgKiBXaGVuIGEgdG9rZW4gaXMgZXhwbGljaXRseSBwcm92aWRlZCwgaXQgd2lsbCBiZSBwcmVzZXJ2ZWQgYWNyb3NzIGNoYW5uZWwgb3BlcmF0aW9uc1xuICAgICAqIChpbmNsdWRpbmcgcmVtb3ZlQ2hhbm5lbCBhbmQgcmVzdWJzY3JpYmUpLiBUaGUgYGFjY2Vzc1Rva2VuYCBjYWxsYmFjayB3aWxsIG5vdCBiZVxuICAgICAqIGludm9rZWQgdW50aWwgYHNldEF1dGgoKWAgaXMgY2FsbGVkIHdpdGhvdXQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRva2VuIEEgSldUIHN0cmluZyB0byBvdmVycmlkZSB0aGUgdG9rZW4gc2V0IG9uIHRoZSBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFVzZSBhIG1hbnVhbCB0b2tlbiAocHJlc2VydmVkIGFjcm9zcyByZXN1YnNjcmliZXMsIGlnbm9yZXMgYWNjZXNzVG9rZW4gY2FsbGJhY2spXG4gICAgICogY2xpZW50LnJlYWx0aW1lLnNldEF1dGgoJ215LWN1c3RvbS1qd3QnKVxuICAgICAqXG4gICAgICogLy8gU3dpdGNoIGJhY2sgdG8gdXNpbmcgdGhlIGFjY2Vzc1Rva2VuIGNhbGxiYWNrXG4gICAgICogY2xpZW50LnJlYWx0aW1lLnNldEF1dGgoKVxuICAgICAqL1xuICAgIGFzeW5jIHNldEF1dGgodG9rZW4gPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2F1dGhQcm9taXNlID0gdGhpcy5fcGVyZm9ybUF1dGgodG9rZW4pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fYXV0aFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9hdXRoUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IGFjY2VzcyB0b2tlbiB3YXMgZXhwbGljaXRseSBzZXQgdmlhIHNldEF1dGgodG9rZW4pLFxuICAgICAqIGZhbHNlIGlmIGl0IHdhcyBvYnRhaW5lZCB2aWEgdGhlIGFjY2Vzc1Rva2VuIGNhbGxiYWNrLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9pc01hbnVhbFRva2VuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFudWFsbHlTZXRUb2tlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBoZWFydGJlYXQgbWVzc2FnZSBpZiB0aGUgc29ja2V0IGlzIGNvbm5lY3RlZC5cbiAgICAgKi9cbiAgICBhc3luYyBzZW5kSGVhcnRiZWF0KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhcnRiZWF0Q2FsbGJhY2soJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZygnZXJyb3InLCAnZXJyb3IgaW4gaGVhcnRiZWF0IGNhbGxiYWNrJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGhlYXJ0YmVhdCB0aW1lb3V0IGFuZCBmb3JjZSByZWNvbm5lY3Rpb24gaWYgbmVlZGVkXG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRTZW50QXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5sb2coJ3RyYW5zcG9ydCcsICdoZWFydGJlYXQgdGltZW91dC4gQXR0ZW1wdGluZyB0byByZS1lc3RhYmxpc2ggY29ubmVjdGlvbicpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYXJ0YmVhdENhbGxiYWNrKCd0aW1lb3V0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKCdlcnJvcicsICdlcnJvciBpbiBoZWFydGJlYXQgY2FsbGJhY2snLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZvcmNlIHJlY29ubmVjdGlvbiBhZnRlciBoZWFydGJlYXQgdGltZW91dFxuICAgICAgICAgICAgdGhpcy5fd2FzTWFudWFsRGlzY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5jb25uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoV1NfQ0xPU0VfTk9STUFMLCAnaGVhcnRiZWF0IHRpbWVvdXQnKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLnJlY29ubmVjdFRpbWVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgQ09OTkVDVElPTl9USU1FT1VUUy5IRUFSVEJFQVRfVElNRU9VVF9GQUxMQkFDSyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VuZCBoZWFydGJlYXQgbWVzc2FnZSB0byBzZXJ2ZXJcbiAgICAgICAgdGhpcy5faGVhcnRiZWF0U2VudEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gdGhpcy5fbWFrZVJlZigpO1xuICAgICAgICB0aGlzLnB1c2goe1xuICAgICAgICAgICAgdG9waWM6ICdwaG9lbml4JyxcbiAgICAgICAgICAgIGV2ZW50OiAnaGVhcnRiZWF0JyxcbiAgICAgICAgICAgIHBheWxvYWQ6IHt9LFxuICAgICAgICAgICAgcmVmOiB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYsXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5oZWFydGJlYXRDYWxsYmFjaygnc2VudCcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZygnZXJyb3InLCAnZXJyb3IgaW4gaGVhcnRiZWF0IGNhbGxiYWNrJywgZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0QXV0aFNhZmVseSgnaGVhcnRiZWF0Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIGxpZmVjeWNsZSBldmVudHMgZm9yIGludGVybmFsIGhlYXJ0YmVhdCBtZXNzYWdlcy5cbiAgICAgKiBVc2VmdWwgZm9yIGluc3RydW1lbnRpbmcgY29ubmVjdGlvbiBoZWFsdGggKGUuZy4gc2VudC9vay90aW1lb3V0L2Rpc2Nvbm5lY3RlZCkuXG4gICAgICovXG4gICAgb25IZWFydGJlYXQoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGbHVzaGVzIHNlbmQgYnVmZmVyXG4gICAgICovXG4gICAgZmx1c2hTZW5kQnVmZmVyKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCgpICYmIHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRCdWZmZXIuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBuZXh0IG1lc3NhZ2UgcmVmLCBhY2NvdW50aW5nIGZvciBvdmVyZmxvd3NcbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9tYWtlUmVmKCkge1xuICAgICAgICBsZXQgbmV3UmVmID0gdGhpcy5yZWYgKyAxO1xuICAgICAgICBpZiAobmV3UmVmID09PSB0aGlzLnJlZikge1xuICAgICAgICAgICAgdGhpcy5yZWYgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZWYgPSBuZXdSZWY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVmLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlIGZyb20gY2hhbm5lbHMgd2l0aCB0aGUgc3BlY2lmaWVkIHRvcGljLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2xlYXZlT3BlblRvcGljKHRvcGljKSB7XG4gICAgICAgIGxldCBkdXBDaGFubmVsID0gdGhpcy5jaGFubmVscy5maW5kKChjKSA9PiBjLnRvcGljID09PSB0b3BpYyAmJiAoYy5faXNKb2luZWQoKSB8fCBjLl9pc0pvaW5pbmcoKSkpO1xuICAgICAgICBpZiAoZHVwQ2hhbm5lbCkge1xuICAgICAgICAgICAgdGhpcy5sb2coJ3RyYW5zcG9ydCcsIGBsZWF2aW5nIGR1cGxpY2F0ZSB0b3BpYyBcIiR7dG9waWN9XCJgKTtcbiAgICAgICAgICAgIGR1cENoYW5uZWwudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgc3Vic2NyaXB0aW9uIGZyb20gdGhlIHNvY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIEFuIG9wZW4gc3Vic2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3JlbW92ZShjaGFubmVsKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMgPSB0aGlzLmNoYW5uZWxzLmZpbHRlcigoYykgPT4gYy50b3BpYyAhPT0gY2hhbm5lbC50b3BpYyk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfb25Db25uTWVzc2FnZShyYXdNZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuZGVjb2RlKHJhd01lc3NhZ2UuZGF0YSwgKG1zZykgPT4ge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGhlYXJ0YmVhdCByZXNwb25zZXNcbiAgICAgICAgICAgIGlmIChtc2cudG9waWMgPT09ICdwaG9lbml4JyAmJlxuICAgICAgICAgICAgICAgIG1zZy5ldmVudCA9PT0gJ3BoeF9yZXBseScgJiZcbiAgICAgICAgICAgICAgICBtc2cucmVmICYmXG4gICAgICAgICAgICAgICAgbXNnLnJlZiA9PT0gdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGF0ZW5jeSA9IHRoaXMuX2hlYXJ0YmVhdFNlbnRBdCA/IERhdGUubm93KCkgLSB0aGlzLl9oZWFydGJlYXRTZW50QXQgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFydGJlYXRDYWxsYmFjayhtc2cucGF5bG9hZC5zdGF0dXMgPT09ICdvaycgPyAnb2snIDogJ2Vycm9yJywgbGF0ZW5jeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKCdlcnJvcicsICdlcnJvciBpbiBoZWFydGJlYXQgY2FsbGJhY2snLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0U2VudEF0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTG9nIGluY29taW5nIG1lc3NhZ2VcbiAgICAgICAgICAgIGNvbnN0IHsgdG9waWMsIGV2ZW50LCBwYXlsb2FkLCByZWYgfSA9IG1zZztcbiAgICAgICAgICAgIGNvbnN0IHJlZlN0cmluZyA9IHJlZiA/IGAoJHtyZWZ9KWAgOiAnJztcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHBheWxvYWQuc3RhdHVzIHx8ICcnO1xuICAgICAgICAgICAgdGhpcy5sb2coJ3JlY2VpdmUnLCBgJHtzdGF0dXN9ICR7dG9waWN9ICR7ZXZlbnR9ICR7cmVmU3RyaW5nfWAudHJpbSgpLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIC8vIFJvdXRlIG1lc3NhZ2UgdG8gYXBwcm9wcmlhdGUgY2hhbm5lbHNcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChjaGFubmVsKSA9PiBjaGFubmVsLl9pc01lbWJlcih0b3BpYykpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKGNoYW5uZWwpID0+IGNoYW5uZWwuX3RyaWdnZXIoZXZlbnQsIHBheWxvYWQsIHJlZikpO1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlclN0YXRlQ2FsbGJhY2tzKCdtZXNzYWdlJywgbXNnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIHNwZWNpZmljIHRpbWVyXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2NsZWFyVGltZXIodGltZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGltZXIgPT09ICdoZWFydGJlYXQnICYmIHRoaXMuaGVhcnRiZWF0VGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5oZWFydGJlYXRUaW1lcik7XG4gICAgICAgICAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRpbWVyID09PSAncmVjb25uZWN0Jykge1xuICAgICAgICAgICAgKF9hID0gdGhpcy5yZWNvbm5lY3RUaW1lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIHRpbWVyc1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9jbGVhckFsbFRpbWVycygpIHtcbiAgICAgICAgdGhpcy5fY2xlYXJUaW1lcignaGVhcnRiZWF0Jyk7XG4gICAgICAgIHRoaXMuX2NsZWFyVGltZXIoJ3JlY29ubmVjdCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXR1cCBjb25uZWN0aW9uIGhhbmRsZXJzIGZvciBXZWJTb2NrZXQgZXZlbnRzXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3NldHVwQ29ubmVjdGlvbkhhbmRsZXJzKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29ubilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gU2V0IGJpbmFyeSB0eXBlIGlmIHN1cHBvcnRlZCAoYnJvd3NlcnMgYW5kIG1vc3QgV2ViU29ja2V0IGltcGxlbWVudGF0aW9ucylcbiAgICAgICAgaWYgKCdiaW5hcnlUeXBlJyBpbiB0aGlzLmNvbm4pIHtcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHRoaXMuY29ubi5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm4ub25vcGVuID0gKCkgPT4gdGhpcy5fb25Db25uT3BlbigpO1xuICAgICAgICB0aGlzLmNvbm4ub25lcnJvciA9IChlcnJvcikgPT4gdGhpcy5fb25Db25uRXJyb3IoZXJyb3IpO1xuICAgICAgICB0aGlzLmNvbm4ub25tZXNzYWdlID0gKGV2ZW50KSA9PiB0aGlzLl9vbkNvbm5NZXNzYWdlKGV2ZW50KTtcbiAgICAgICAgdGhpcy5jb25uLm9uY2xvc2UgPSAoZXZlbnQpID0+IHRoaXMuX29uQ29ubkNsb3NlKGV2ZW50KTtcbiAgICAgICAgaWYgKHRoaXMuY29ubi5yZWFkeVN0YXRlID09PSBTT0NLRVRfU1RBVEVTLm9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX29uQ29ubk9wZW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZWFyZG93biBjb25uZWN0aW9uIGFuZCBjbGVhbnVwIHJlc291cmNlc1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF90ZWFyZG93bkNvbm5lY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm4pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm4ucmVhZHlTdGF0ZSA9PT0gU09DS0VUX1NUQVRFUy5vcGVuIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uLnJlYWR5U3RhdGUgPT09IFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZygnZXJyb3InLCAnRXJyb3IgY2xvc2luZyBjb25uZWN0aW9uJywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb25uLm9ub3BlbiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNvbm4ub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNvbm4ub25tZXNzYWdlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY29ubi5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY29ubiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2xlYXJBbGxUaW1lcnMoKTtcbiAgICAgICAgdGhpcy5fdGVybWluYXRlV29ya2VyKCk7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMuZm9yRWFjaCgoY2hhbm5lbCkgPT4gY2hhbm5lbC50ZWFyZG93bigpKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9vbkNvbm5PcGVuKCkge1xuICAgICAgICB0aGlzLl9zZXRDb25uZWN0aW9uU3RhdGUoJ2Nvbm5lY3RlZCcpO1xuICAgICAgICB0aGlzLmxvZygndHJhbnNwb3J0JywgYGNvbm5lY3RlZCB0byAke3RoaXMuZW5kcG9pbnRVUkwoKX1gKTtcbiAgICAgICAgLy8gV2FpdCBmb3IgYW55IHBlbmRpbmcgYXV0aCBvcGVyYXRpb25zIGJlZm9yZSBmbHVzaGluZyBzZW5kIGJ1ZmZlclxuICAgICAgICAvLyBUaGlzIGVuc3VyZXMgY2hhbm5lbCBqb2luIG1lc3NhZ2VzIGluY2x1ZGUgdGhlIGNvcnJlY3QgYWNjZXNzIHRva2VuXG4gICAgICAgIGNvbnN0IGF1dGhQcm9taXNlID0gdGhpcy5fYXV0aFByb21pc2UgfHxcbiAgICAgICAgICAgICh0aGlzLmFjY2Vzc1Rva2VuICYmICF0aGlzLmFjY2Vzc1Rva2VuVmFsdWUgPyB0aGlzLnNldEF1dGgoKSA6IFByb21pc2UucmVzb2x2ZSgpKTtcbiAgICAgICAgYXV0aFByb21pc2VcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hTZW5kQnVmZmVyKCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nKCdlcnJvcicsICdlcnJvciB3YWl0aW5nIGZvciBhdXRoIG9uIGNvbm5lY3QnLCBlKTtcbiAgICAgICAgICAgIC8vIFByb2NlZWQgYW55d2F5IHRvIGF2b2lkIGhhbmdpbmcgY29ubmVjdGlvbnNcbiAgICAgICAgICAgIHRoaXMuZmx1c2hTZW5kQnVmZmVyKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9jbGVhclRpbWVyKCdyZWNvbm5lY3QnKTtcbiAgICAgICAgaWYgKCF0aGlzLndvcmtlcikge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRIZWFydGJlYXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy53b3JrZXJSZWYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFdvcmtlckhlYXJ0YmVhdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyaWdnZXJTdGF0ZUNhbGxiYWNrcygnb3BlbicpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3N0YXJ0SGVhcnRiZWF0KCkge1xuICAgICAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyICYmIGNsZWFySW50ZXJ2YWwodGhpcy5oZWFydGJlYXRUaW1lcik7XG4gICAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLnNlbmRIZWFydGJlYXQoKSwgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9zdGFydFdvcmtlckhlYXJ0YmVhdCgpIHtcbiAgICAgICAgaWYgKHRoaXMud29ya2VyVXJsKSB7XG4gICAgICAgICAgICB0aGlzLmxvZygnd29ya2VyJywgYHN0YXJ0aW5nIHdvcmtlciBmb3IgZnJvbSAke3RoaXMud29ya2VyVXJsfWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2coJ3dvcmtlcicsIGBzdGFydGluZyBkZWZhdWx0IHdvcmtlcmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9iamVjdFVybCA9IHRoaXMuX3dvcmtlck9iamVjdFVybCh0aGlzLndvcmtlclVybCk7XG4gICAgICAgIHRoaXMud29ya2VyUmVmID0gbmV3IFdvcmtlcihvYmplY3RVcmwpO1xuICAgICAgICB0aGlzLndvcmtlclJlZi5vbmVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZygnd29ya2VyJywgJ3dvcmtlciBlcnJvcicsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5fdGVybWluYXRlV29ya2VyKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud29ya2VyUmVmLm9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEuZXZlbnQgPT09ICdrZWVwQWxpdmUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kSGVhcnRiZWF0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud29ya2VyUmVmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGV2ZW50OiAnc3RhcnQnLFxuICAgICAgICAgICAgaW50ZXJ2YWw6IHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlcm1pbmF0ZSB0aGUgV2ViIFdvcmtlciBhbmQgY2xlYXIgdGhlIHJlZmVyZW5jZVxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF90ZXJtaW5hdGVXb3JrZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLndvcmtlclJlZikge1xuICAgICAgICAgICAgdGhpcy5sb2coJ3dvcmtlcicsICd0ZXJtaW5hdGluZyB3b3JrZXInKTtcbiAgICAgICAgICAgIHRoaXMud29ya2VyUmVmLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgdGhpcy53b3JrZXJSZWYgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9vbkNvbm5DbG9zZShldmVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuX3NldENvbm5lY3Rpb25TdGF0ZSgnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgIHRoaXMubG9nKCd0cmFuc3BvcnQnLCAnY2xvc2UnLCBldmVudCk7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJDaGFuRXJyb3IoKTtcbiAgICAgICAgdGhpcy5fY2xlYXJUaW1lcignaGVhcnRiZWF0Jyk7XG4gICAgICAgIC8vIE9ubHkgc2NoZWR1bGUgcmVjb25uZWN0aW9uIGlmIGl0IHdhc24ndCBhIG1hbnVhbCBkaXNjb25uZWN0XG4gICAgICAgIGlmICghdGhpcy5fd2FzTWFudWFsRGlzY29ubmVjdCkge1xuICAgICAgICAgICAgKF9hID0gdGhpcy5yZWNvbm5lY3RUaW1lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNjaGVkdWxlVGltZW91dCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyaWdnZXJTdGF0ZUNhbGxiYWNrcygnY2xvc2UnLCBldmVudCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfb25Db25uRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5fc2V0Q29ubmVjdGlvblN0YXRlKCdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgdGhpcy5sb2coJ3RyYW5zcG9ydCcsIGAke2Vycm9yfWApO1xuICAgICAgICB0aGlzLl90cmlnZ2VyQ2hhbkVycm9yKCk7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJTdGF0ZUNhbGxiYWNrcygnZXJyb3InLCBlcnJvcik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmhlYXJ0YmVhdENhbGxiYWNrKCdlcnJvcicpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZygnZXJyb3InLCAnZXJyb3IgaW4gaGVhcnRiZWF0IGNhbGxiYWNrJywgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF90cmlnZ2VyQ2hhbkVycm9yKCkge1xuICAgICAgICB0aGlzLmNoYW5uZWxzLmZvckVhY2goKGNoYW5uZWwpID0+IGNoYW5uZWwuX3RyaWdnZXIoQ0hBTk5FTF9FVkVOVFMuZXJyb3IpKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9hcHBlbmRQYXJhbXModXJsLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHVybC5tYXRjaCgvXFw/LykgPyAnJicgOiAnPyc7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbXMpO1xuICAgICAgICByZXR1cm4gYCR7dXJsfSR7cHJlZml4fSR7cXVlcnl9YDtcbiAgICB9XG4gICAgX3dvcmtlck9iamVjdFVybCh1cmwpIHtcbiAgICAgICAgbGV0IHJlc3VsdF91cmw7XG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgIHJlc3VsdF91cmwgPSB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW1dPUktFUl9TQ1JJUFRdLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyB9KTtcbiAgICAgICAgICAgIHJlc3VsdF91cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRfdXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgY29ubmVjdGlvbiBzdGF0ZSB3aXRoIHByb3BlciBzdGF0ZSBtYW5hZ2VtZW50XG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3NldENvbm5lY3Rpb25TdGF0ZShzdGF0ZSwgbWFudWFsID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRlID0gc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nvbm5lY3RpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLl93YXNNYW51YWxEaXNjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUgPT09ICdkaXNjb25uZWN0aW5nJykge1xuICAgICAgICAgICAgdGhpcy5fd2FzTWFudWFsRGlzY29ubmVjdCA9IG1hbnVhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIHRoZSBhY3R1YWwgYXV0aCBvcGVyYXRpb25cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBhc3luYyBfcGVyZm9ybUF1dGgodG9rZW4gPSBudWxsKSB7XG4gICAgICAgIGxldCB0b2tlblRvU2VuZDtcbiAgICAgICAgbGV0IGlzTWFudWFsVG9rZW4gPSBmYWxzZTtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICB0b2tlblRvU2VuZCA9IHRva2VuO1xuICAgICAgICAgICAgLy8gVHJhY2sgaWYgdGhpcyBpcyBhIG1hbnVhbGx5LXByb3ZpZGVkIHRva2VuXG4gICAgICAgICAgICBpc01hbnVhbFRva2VuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICAvLyBDYWxsIHRoZSBhY2Nlc3NUb2tlbiBjYWxsYmFjayB0byBnZXQgZnJlc2ggdG9rZW5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdG9rZW5Ub1NlbmQgPSBhd2FpdCB0aGlzLmFjY2Vzc1Rva2VuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKCdlcnJvcicsICdFcnJvciBmZXRjaGluZyBhY2Nlc3MgdG9rZW4gZnJvbSBjYWxsYmFjaycsIGUpO1xuICAgICAgICAgICAgICAgIC8vIEZhbGwgYmFjayB0byBjYWNoZWQgdmFsdWUgaWYgY2FsbGJhY2sgZmFpbHNcbiAgICAgICAgICAgICAgICB0b2tlblRvU2VuZCA9IHRoaXMuYWNjZXNzVG9rZW5WYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRva2VuVG9TZW5kID0gdGhpcy5hY2Nlc3NUb2tlblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyYWNrIHdoZXRoZXIgdGhpcyB0b2tlbiB3YXMgbWFudWFsbHkgc2V0IG9yIGZldGNoZWQgdmlhIGNhbGxiYWNrXG4gICAgICAgIGlmIChpc01hbnVhbFRva2VuKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW51YWxseVNldFRva2VuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSB1c2VkIHRoZSBjYWxsYmFjaywgY2xlYXIgdGhlIG1hbnVhbCBmbGFnXG4gICAgICAgICAgICB0aGlzLl9tYW51YWxseVNldFRva2VuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWNjZXNzVG9rZW5WYWx1ZSAhPSB0b2tlblRvU2VuZCkge1xuICAgICAgICAgICAgdGhpcy5hY2Nlc3NUb2tlblZhbHVlID0gdG9rZW5Ub1NlbmQ7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzLmZvckVhY2goKGNoYW5uZWwpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICBhY2Nlc3NfdG9rZW46IHRva2VuVG9TZW5kLFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBERUZBVUxUX1ZFUlNJT04sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0b2tlblRvU2VuZCAmJiBjaGFubmVsLnVwZGF0ZUpvaW5QYXlsb2FkKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFubmVsLmpvaW5lZE9uY2UgJiYgY2hhbm5lbC5faXNKb2luZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLl9wdXNoKENIQU5ORUxfRVZFTlRTLmFjY2Vzc190b2tlbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiB0b2tlblRvU2VuZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdCBmb3IgYW55IGluLWZsaWdodCBhdXRoIG9wZXJhdGlvbnMgdG8gY29tcGxldGVcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBhc3luYyBfd2FpdEZvckF1dGhJZk5lZWRlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2F1dGhQcm9taXNlKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9hdXRoUHJvbWlzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTYWZlbHkgY2FsbCBzZXRBdXRoIHdpdGggc3RhbmRhcmRpemVkIGVycm9yIGhhbmRsaW5nXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3NldEF1dGhTYWZlbHkoY29udGV4dCA9ICdnZW5lcmFsJykge1xuICAgICAgICAvLyBPbmx5IHJlZnJlc2ggYXV0aCBpZiB1c2luZyBjYWxsYmFjay1iYXNlZCB0b2tlbnNcbiAgICAgICAgaWYgKCF0aGlzLl9pc01hbnVhbFRva2VuKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXV0aCgpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2coJ2Vycm9yJywgYEVycm9yIHNldHRpbmcgYXV0aCBpbiAke2NvbnRleHR9YCwgZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIHN0YXRlIGNoYW5nZSBjYWxsYmFja3Mgd2l0aCBwcm9wZXIgZXJyb3IgaGFuZGxpbmdcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfdHJpZ2dlclN0YXRlQ2FsbGJhY2tzKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzW2V2ZW50XS5mb3JFYWNoKChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZygnZXJyb3InLCBgZXJyb3IgaW4gJHtldmVudH0gY2FsbGJhY2tgLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5sb2coJ2Vycm9yJywgYGVycm9yIHRyaWdnZXJpbmcgJHtldmVudH0gY2FsbGJhY2tzYCwgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0dXAgcmVjb25uZWN0aW9uIHRpbWVyIHdpdGggcHJvcGVyIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfc2V0dXBSZWNvbm5lY3Rpb25UaW1lcigpIHtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG5ldyBUaW1lcihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl93YWl0Rm9yQXV0aElmTmVlZGVkKCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgQ09OTkVDVElPTl9USU1FT1VUUy5SRUNPTk5FQ1RfREVMQVkpO1xuICAgICAgICB9LCB0aGlzLnJlY29ubmVjdEFmdGVyTXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGNsaWVudCBvcHRpb25zIHdpdGggZGVmYXVsdHNcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbTtcbiAgICAgICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYW5zcG9ydCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRpbWVvdXQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IERFRkFVTFRfVElNRU9VVDtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zID1cbiAgICAgICAgICAgIChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFydGJlYXRJbnRlcnZhbE1zKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBDT05ORUNUSU9OX1RJTUVPVVRTLkhFQVJUQkVBVF9JTlRFUlZBTDtcbiAgICAgICAgdGhpcy53b3JrZXIgPSAoX2QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMud29ya2VyKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IChfZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hY2Nlc3NUb2tlbikgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogbnVsbDtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRDYWxsYmFjayA9IChfZiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFydGJlYXRDYWxsYmFjaykgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogbm9vcDtcbiAgICAgICAgdGhpcy52c24gPSAoX2cgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudnNuKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBERUZBVUxUX1ZTTjtcbiAgICAgICAgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZXNcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYXJhbXMpXG4gICAgICAgICAgICB0aGlzLnBhcmFtcyA9IG9wdGlvbnMucGFyYW1zO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvZ2dlcilcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyID0gb3B0aW9ucy5sb2dnZXI7XG4gICAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvZ0xldmVsKSB8fCAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvZ19sZXZlbCkpIHtcbiAgICAgICAgICAgIHRoaXMubG9nTGV2ZWwgPSBvcHRpb25zLmxvZ0xldmVsIHx8IG9wdGlvbnMubG9nX2xldmVsO1xuICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMucGFyYW1zKSwgeyBsb2dfbGV2ZWw6IHRoaXMubG9nTGV2ZWwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHVwIGZ1bmN0aW9ucyB3aXRoIGRlZmF1bHRzXG4gICAgICAgIHRoaXMucmVjb25uZWN0QWZ0ZXJNcyA9XG4gICAgICAgICAgICAoX2ggPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVjb25uZWN0QWZ0ZXJNcykgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogKCh0cmllcykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBSRUNPTk5FQ1RfSU5URVJWQUxTW3RyaWVzIC0gMV0gfHwgREVGQVVMVF9SRUNPTk5FQ1RfRkFMTEJBQ0s7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnZzbikge1xuICAgICAgICAgICAgY2FzZSBWU05fMV8wXzA6XG4gICAgICAgICAgICAgICAgdGhpcy5lbmNvZGUgPVxuICAgICAgICAgICAgICAgICAgICAoX2ogPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZW5jb2RlKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiAoKHBheWxvYWQsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZSA9XG4gICAgICAgICAgICAgICAgICAgIChfayA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZWNvZGUpICE9PSBudWxsICYmIF9rICE9PSB2b2lkIDAgPyBfayA6ICgocGF5bG9hZCwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhKU09OLnBhcnNlKHBheWxvYWQpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFZTTl8yXzBfMDpcbiAgICAgICAgICAgICAgICB0aGlzLmVuY29kZSA9IChfbCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5lbmNvZGUpICE9PSBudWxsICYmIF9sICE9PSB2b2lkIDAgPyBfbCA6IHRoaXMuc2VyaWFsaXplci5lbmNvZGUuYmluZCh0aGlzLnNlcmlhbGl6ZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlID0gKF9tID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRlY29kZSkgIT09IG51bGwgJiYgX20gIT09IHZvaWQgMCA/IF9tIDogdGhpcy5zZXJpYWxpemVyLmRlY29kZS5iaW5kKHRoaXMuc2VyaWFsaXplcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgc2VyaWFsaXplciB2ZXJzaW9uOiAke3RoaXMudnNufWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSB3b3JrZXIgc2V0dXBcbiAgICAgICAgaWYgKHRoaXMud29ya2VyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXdpbmRvdy5Xb3JrZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYiBXb3JrZXIgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy53b3JrZXJVcmwgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMud29ya2VyVXJsO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVhbHRpbWVDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIldlYlNvY2tldEZhY3RvcnkiLCJDSEFOTkVMX0VWRU5UUyIsIkNPTk5FQ1RJT05fU1RBVEUiLCJERUZBVUxUX1ZFUlNJT04iLCJERUZBVUxUX1RJTUVPVVQiLCJTT0NLRVRfU1RBVEVTIiwiVFJBTlNQT1JUUyIsIkRFRkFVTFRfVlNOIiwiVlNOXzFfMF8wIiwiVlNOXzJfMF8wIiwiV1NfQ0xPU0VfTk9STUFMIiwiU2VyaWFsaXplciIsIlRpbWVyIiwiaHR0cEVuZHBvaW50VVJMIiwiUmVhbHRpbWVDaGFubmVsIiwibm9vcCIsIkNPTk5FQ1RJT05fVElNRU9VVFMiLCJIRUFSVEJFQVRfSU5URVJWQUwiLCJSRUNPTk5FQ1RfREVMQVkiLCJIRUFSVEJFQVRfVElNRU9VVF9GQUxMQkFDSyIsIlJFQ09OTkVDVF9JTlRFUlZBTFMiLCJERUZBVUxUX1JFQ09OTkVDVF9GQUxMQkFDSyIsIldPUktFUl9TQ1JJUFQiLCJSZWFsdGltZUNsaWVudCIsImNvbnN0cnVjdG9yIiwiZW5kUG9pbnQiLCJvcHRpb25zIiwiX2EiLCJhY2Nlc3NUb2tlblZhbHVlIiwiYXBpS2V5IiwiX21hbnVhbGx5U2V0VG9rZW4iLCJjaGFubmVscyIsIkFycmF5IiwiaHR0cEVuZHBvaW50IiwiaGVhZGVycyIsInBhcmFtcyIsInRpbWVvdXQiLCJ0cmFuc3BvcnQiLCJoZWFydGJlYXRJbnRlcnZhbE1zIiwiaGVhcnRiZWF0VGltZXIiLCJ1bmRlZmluZWQiLCJwZW5kaW5nSGVhcnRiZWF0UmVmIiwiaGVhcnRiZWF0Q2FsbGJhY2siLCJyZWYiLCJyZWNvbm5lY3RUaW1lciIsInZzbiIsImxvZ2dlciIsImNvbm4iLCJzZW5kQnVmZmVyIiwic2VyaWFsaXplciIsInN0YXRlQ2hhbmdlQ2FsbGJhY2tzIiwib3BlbiIsImNsb3NlIiwiZXJyb3IiLCJtZXNzYWdlIiwiYWNjZXNzVG9rZW4iLCJfY29ubmVjdGlvblN0YXRlIiwiX3dhc01hbnVhbERpc2Nvbm5lY3QiLCJfYXV0aFByb21pc2UiLCJfaGVhcnRiZWF0U2VudEF0IiwiX3Jlc29sdmVGZXRjaCIsImN1c3RvbUZldGNoIiwiYXJncyIsImZldGNoIiwiYXBpa2V5IiwiRXJyb3IiLCJ3ZWJzb2NrZXQiLCJfaW5pdGlhbGl6ZU9wdGlvbnMiLCJfc2V0dXBSZWNvbm5lY3Rpb25UaW1lciIsImNvbm5lY3QiLCJpc0Nvbm5lY3RpbmciLCJpc0Rpc2Nvbm5lY3RpbmciLCJpc0Nvbm5lY3RlZCIsIl9zZXRDb25uZWN0aW9uU3RhdGUiLCJfc2V0QXV0aFNhZmVseSIsImVuZHBvaW50VVJMIiwiY3JlYXRlV2ViU29ja2V0IiwiZXJyb3JNZXNzYWdlIiwiaW5jbHVkZXMiLCJfc2V0dXBDb25uZWN0aW9uSGFuZGxlcnMiLCJfYXBwZW5kUGFyYW1zIiwiT2JqZWN0IiwiYXNzaWduIiwiZGlzY29ubmVjdCIsImNvZGUiLCJyZWFzb24iLCJmYWxsYmFja1RpbWVyIiwic2V0VGltZW91dCIsIm9uY2xvc2UiLCJjbGVhclRpbWVvdXQiLCJfdGVhcmRvd25Db25uZWN0aW9uIiwiZ2V0Q2hhbm5lbHMiLCJyZW1vdmVDaGFubmVsIiwiY2hhbm5lbCIsInN0YXR1cyIsInVuc3Vic2NyaWJlIiwibGVuZ3RoIiwicmVtb3ZlQWxsQ2hhbm5lbHMiLCJ2YWx1ZXNfMSIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJsb2ciLCJraW5kIiwibXNnIiwiZGF0YSIsImNvbm5lY3Rpb25TdGF0ZSIsInJlYWR5U3RhdGUiLCJjb25uZWN0aW5nIiwiQ29ubmVjdGluZyIsIk9wZW4iLCJjbG9zaW5nIiwiQ2xvc2luZyIsIkNsb3NlZCIsInRvcGljIiwiY29uZmlnIiwicmVhbHRpbWVUb3BpYyIsImV4aXN0cyIsImZpbmQiLCJjIiwiY2hhbiIsInB1c2giLCJldmVudCIsInBheWxvYWQiLCJjYWxsYmFjayIsImVuY29kZSIsInJlc3VsdCIsInNlbmQiLCJzZXRBdXRoIiwidG9rZW4iLCJfcGVyZm9ybUF1dGgiLCJfaXNNYW51YWxUb2tlbiIsInNlbmRIZWFydGJlYXQiLCJlIiwic2NoZWR1bGVUaW1lb3V0IiwiRGF0ZSIsIm5vdyIsIl9tYWtlUmVmIiwib25IZWFydGJlYXQiLCJmbHVzaFNlbmRCdWZmZXIiLCJmb3JFYWNoIiwibmV3UmVmIiwidG9TdHJpbmciLCJfbGVhdmVPcGVuVG9waWMiLCJkdXBDaGFubmVsIiwiX2lzSm9pbmVkIiwiX2lzSm9pbmluZyIsIl9yZW1vdmUiLCJmaWx0ZXIiLCJfb25Db25uTWVzc2FnZSIsInJhd01lc3NhZ2UiLCJkZWNvZGUiLCJsYXRlbmN5IiwicmVmU3RyaW5nIiwidHJpbSIsIl9pc01lbWJlciIsIl90cmlnZ2VyIiwiX3RyaWdnZXJTdGF0ZUNhbGxiYWNrcyIsIl9jbGVhclRpbWVyIiwidGltZXIiLCJjbGVhckludGVydmFsIiwicmVzZXQiLCJfY2xlYXJBbGxUaW1lcnMiLCJiaW5hcnlUeXBlIiwib25vcGVuIiwiX29uQ29ubk9wZW4iLCJvbmVycm9yIiwiX29uQ29ubkVycm9yIiwib25tZXNzYWdlIiwiX29uQ29ubkNsb3NlIiwiX3Rlcm1pbmF0ZVdvcmtlciIsInRlYXJkb3duIiwiYXV0aFByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsImNhdGNoIiwid29ya2VyIiwiX3N0YXJ0SGVhcnRiZWF0Iiwid29ya2VyUmVmIiwiX3N0YXJ0V29ya2VySGVhcnRiZWF0Iiwic2V0SW50ZXJ2YWwiLCJ3b3JrZXJVcmwiLCJvYmplY3RVcmwiLCJfd29ya2VyT2JqZWN0VXJsIiwiV29ya2VyIiwicG9zdE1lc3NhZ2UiLCJpbnRlcnZhbCIsInRlcm1pbmF0ZSIsIl90cmlnZ2VyQ2hhbkVycm9yIiwidXJsIiwia2V5cyIsInByZWZpeCIsIm1hdGNoIiwicXVlcnkiLCJVUkxTZWFyY2hQYXJhbXMiLCJyZXN1bHRfdXJsIiwiYmxvYiIsIkJsb2IiLCJ0eXBlIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwic3RhdGUiLCJtYW51YWwiLCJ0b2tlblRvU2VuZCIsImlzTWFudWFsVG9rZW4iLCJhY2Nlc3NfdG9rZW4iLCJ2ZXJzaW9uIiwidXBkYXRlSm9pblBheWxvYWQiLCJqb2luZWRPbmNlIiwiX3B1c2giLCJfd2FpdEZvckF1dGhJZk5lZWRlZCIsImNvbnRleHQiLCJyZWNvbm5lY3RBZnRlck1zIiwiX2IiLCJfYyIsIl9kIiwiX2UiLCJfZiIsIl9nIiwiX2giLCJfaiIsIl9rIiwiX2wiLCJfbSIsImxvZ0xldmVsIiwibG9nX2xldmVsIiwidHJpZXMiLCJKU09OIiwic3RyaW5naWZ5IiwicGFyc2UiLCJiaW5kIiwid2luZG93Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   REALTIME_PRESENCE_LISTEN_EVENTS: () => (/* binding */ REALTIME_PRESENCE_LISTEN_EVENTS),\n/* harmony export */   \"default\": () => (/* binding */ RealtimePresence)\n/* harmony export */ });\n/*\n  This file draws heavily from https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/assets/js/phoenix/presence.js\n  License: https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/LICENSE.md\n*/ var REALTIME_PRESENCE_LISTEN_EVENTS;\n(function(REALTIME_PRESENCE_LISTEN_EVENTS) {\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"SYNC\"] = \"sync\";\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"JOIN\"] = \"join\";\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"LEAVE\"] = \"leave\";\n})(REALTIME_PRESENCE_LISTEN_EVENTS || (REALTIME_PRESENCE_LISTEN_EVENTS = {}));\nclass RealtimePresence {\n    /**\n     * Creates a Presence helper that keeps the local presence state in sync with the server.\n     *\n     * @param channel - The realtime channel to bind to.\n     * @param opts - Optional custom event names, e.g. `{ events: { state: 'state', diff: 'diff' } }`.\n     *\n     * @example\n     * ```ts\n     * const presence = new RealtimePresence(channel)\n     *\n     * channel.on('presence', ({ event, key }) => {\n     *   console.log(`Presence ${event} on ${key}`)\n     * })\n     * ```\n     */ constructor(channel, opts){\n        this.channel = channel;\n        this.state = {};\n        this.pendingDiffs = [];\n        this.joinRef = null;\n        this.enabled = false;\n        this.caller = {\n            onJoin: ()=>{},\n            onLeave: ()=>{},\n            onSync: ()=>{}\n        };\n        const events = (opts === null || opts === void 0 ? void 0 : opts.events) || {\n            state: \"presence_state\",\n            diff: \"presence_diff\"\n        };\n        this.channel._on(events.state, {}, (newState)=>{\n            const { onJoin, onLeave, onSync } = this.caller;\n            this.joinRef = this.channel._joinRef();\n            this.state = RealtimePresence.syncState(this.state, newState, onJoin, onLeave);\n            this.pendingDiffs.forEach((diff)=>{\n                this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);\n            });\n            this.pendingDiffs = [];\n            onSync();\n        });\n        this.channel._on(events.diff, {}, (diff)=>{\n            const { onJoin, onLeave, onSync } = this.caller;\n            if (this.inPendingSyncState()) {\n                this.pendingDiffs.push(diff);\n            } else {\n                this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);\n                onSync();\n            }\n        });\n        this.onJoin((key, currentPresences, newPresences)=>{\n            this.channel._trigger(\"presence\", {\n                event: \"join\",\n                key,\n                currentPresences,\n                newPresences\n            });\n        });\n        this.onLeave((key, currentPresences, leftPresences)=>{\n            this.channel._trigger(\"presence\", {\n                event: \"leave\",\n                key,\n                currentPresences,\n                leftPresences\n            });\n        });\n        this.onSync(()=>{\n            this.channel._trigger(\"presence\", {\n                event: \"sync\"\n            });\n        });\n    }\n    /**\n     * Used to sync the list of presences on the server with the\n     * client's state.\n     *\n     * An optional `onJoin` and `onLeave` callback can be provided to\n     * react to changes in the client's local presences across\n     * disconnects and reconnects with the server.\n     *\n     * @internal\n     */ static syncState(currentState, newState, onJoin, onLeave) {\n        const state = this.cloneDeep(currentState);\n        const transformedState = this.transformState(newState);\n        const joins = {};\n        const leaves = {};\n        this.map(state, (key, presences)=>{\n            if (!transformedState[key]) {\n                leaves[key] = presences;\n            }\n        });\n        this.map(transformedState, (key, newPresences)=>{\n            const currentPresences = state[key];\n            if (currentPresences) {\n                const newPresenceRefs = newPresences.map((m)=>m.presence_ref);\n                const curPresenceRefs = currentPresences.map((m)=>m.presence_ref);\n                const joinedPresences = newPresences.filter((m)=>curPresenceRefs.indexOf(m.presence_ref) < 0);\n                const leftPresences = currentPresences.filter((m)=>newPresenceRefs.indexOf(m.presence_ref) < 0);\n                if (joinedPresences.length > 0) {\n                    joins[key] = joinedPresences;\n                }\n                if (leftPresences.length > 0) {\n                    leaves[key] = leftPresences;\n                }\n            } else {\n                joins[key] = newPresences;\n            }\n        });\n        return this.syncDiff(state, {\n            joins,\n            leaves\n        }, onJoin, onLeave);\n    }\n    /**\n     * Used to sync a diff of presence join and leave events from the\n     * server, as they happen.\n     *\n     * Like `syncState`, `syncDiff` accepts optional `onJoin` and\n     * `onLeave` callbacks to react to a user joining or leaving from a\n     * device.\n     *\n     * @internal\n     */ static syncDiff(state, diff, onJoin, onLeave) {\n        const { joins, leaves } = {\n            joins: this.transformState(diff.joins),\n            leaves: this.transformState(diff.leaves)\n        };\n        if (!onJoin) {\n            onJoin = ()=>{};\n        }\n        if (!onLeave) {\n            onLeave = ()=>{};\n        }\n        this.map(joins, (key, newPresences)=>{\n            var _a;\n            const currentPresences = (_a = state[key]) !== null && _a !== void 0 ? _a : [];\n            state[key] = this.cloneDeep(newPresences);\n            if (currentPresences.length > 0) {\n                const joinedPresenceRefs = state[key].map((m)=>m.presence_ref);\n                const curPresences = currentPresences.filter((m)=>joinedPresenceRefs.indexOf(m.presence_ref) < 0);\n                state[key].unshift(...curPresences);\n            }\n            onJoin(key, currentPresences, newPresences);\n        });\n        this.map(leaves, (key, leftPresences)=>{\n            let currentPresences = state[key];\n            if (!currentPresences) return;\n            const presenceRefsToRemove = leftPresences.map((m)=>m.presence_ref);\n            currentPresences = currentPresences.filter((m)=>presenceRefsToRemove.indexOf(m.presence_ref) < 0);\n            state[key] = currentPresences;\n            onLeave(key, currentPresences, leftPresences);\n            if (currentPresences.length === 0) delete state[key];\n        });\n        return state;\n    }\n    /** @internal */ static map(obj, func) {\n        return Object.getOwnPropertyNames(obj).map((key)=>func(key, obj[key]));\n    }\n    /**\n     * Remove 'metas' key\n     * Change 'phx_ref' to 'presence_ref'\n     * Remove 'phx_ref' and 'phx_ref_prev'\n     *\n     * @example\n     * // returns {\n     *  abc123: [\n     *    { presence_ref: '2', user_id: 1 },\n     *    { presence_ref: '3', user_id: 2 }\n     *  ]\n     * }\n     * RealtimePresence.transformState({\n     *  abc123: {\n     *    metas: [\n     *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },\n     *      { phx_ref: '3', user_id: 2 }\n     *    ]\n     *  }\n     * })\n     *\n     * @internal\n     */ static transformState(state) {\n        state = this.cloneDeep(state);\n        return Object.getOwnPropertyNames(state).reduce((newState, key)=>{\n            const presences = state[key];\n            if (\"metas\" in presences) {\n                newState[key] = presences.metas.map((presence)=>{\n                    presence[\"presence_ref\"] = presence[\"phx_ref\"];\n                    delete presence[\"phx_ref\"];\n                    delete presence[\"phx_ref_prev\"];\n                    return presence;\n                });\n            } else {\n                newState[key] = presences;\n            }\n            return newState;\n        }, {});\n    }\n    /** @internal */ static cloneDeep(obj) {\n        return JSON.parse(JSON.stringify(obj));\n    }\n    /** @internal */ onJoin(callback) {\n        this.caller.onJoin = callback;\n    }\n    /** @internal */ onLeave(callback) {\n        this.caller.onLeave = callback;\n    }\n    /** @internal */ onSync(callback) {\n        this.caller.onSync = callback;\n    }\n    /** @internal */ inPendingSyncState() {\n        return !this.joinRef || this.joinRef !== this.channel._joinRef();\n    }\n} //# sourceMappingURL=RealtimePresence.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL1JlYWx0aW1lUHJlc2VuY2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7O0FBR0EsR0FDTyxJQUFJQSxnQ0FBZ0M7QUFDMUMsVUFBVUEsK0JBQStCO0lBQ3RDQSwrQkFBK0IsQ0FBQyxPQUFPLEdBQUc7SUFDMUNBLCtCQUErQixDQUFDLE9BQU8sR0FBRztJQUMxQ0EsK0JBQStCLENBQUMsUUFBUSxHQUFHO0FBQy9DLEdBQUdBLG1DQUFvQ0EsQ0FBQUEsa0NBQWtDLENBQUM7QUFDM0QsTUFBTUM7SUFDakI7Ozs7Ozs7Ozs7Ozs7O0tBY0MsR0FDREMsWUFBWUMsT0FBTyxFQUFFQyxJQUFJLENBQUU7UUFDdkIsSUFBSSxDQUFDRCxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDRSxLQUFLLEdBQUcsQ0FBQztRQUNkLElBQUksQ0FBQ0MsWUFBWSxHQUFHLEVBQUU7UUFDdEIsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNDLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1lBQ1ZDLFFBQVEsS0FBUTtZQUNoQkMsU0FBUyxLQUFRO1lBQ2pCQyxRQUFRLEtBQVE7UUFDcEI7UUFDQSxNQUFNQyxTQUFTLENBQUNULFNBQVMsUUFBUUEsU0FBUyxLQUFLLElBQUksS0FBSyxJQUFJQSxLQUFLUyxNQUFNLEtBQUs7WUFDeEVSLE9BQU87WUFDUFMsTUFBTTtRQUNWO1FBQ0EsSUFBSSxDQUFDWCxPQUFPLENBQUNZLEdBQUcsQ0FBQ0YsT0FBT1IsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDVztZQUNoQyxNQUFNLEVBQUVOLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUNILE1BQU07WUFDL0MsSUFBSSxDQUFDRixPQUFPLEdBQUcsSUFBSSxDQUFDSixPQUFPLENBQUNjLFFBQVE7WUFDcEMsSUFBSSxDQUFDWixLQUFL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QyxVQUFVO29CQUMxQixPQUFPQSxRQUFRLENBQUMsZUFBZTtvQkFDL0IsT0FBT0E7Z0JBQ1g7WUFDSixPQUNLO2dCQUNEeEMsUUFBUSxDQUFDTyxJQUFJLEdBQUdhO1lBQ3BCO1lBQ0EsT0FBT3BCO1FBQ1gsR0FBRyxDQUFDO0lBQ1I7SUFDQSxjQUFjLEdBQ2QsT0FBT2MsVUFBVW9CLEdBQUcsRUFBRTtRQUNsQixPQUFPTyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLFNBQVMsQ0FBQ1Q7SUFDckM7SUFDQSxjQUFjLEdBQ2R4QyxPQUFPa0QsUUFBUSxFQUFFO1FBQ2IsSUFBSSxDQUFDbkQsTUFBTSxDQUFDQyxNQUFNLEdBQUdrRDtJQUN6QjtJQUNBLGNBQWMsR0FDZGpELFFBQVFpRCxRQUFRLEVBQUU7UUFDZCxJQUFJLENBQUNuRCxNQUFNLENBQUNFLE9BQU8sR0FBR2lEO0lBQzFCO0lBQ0EsY0FBYyxHQUNkaEQsT0FBT2dELFFBQVEsRUFBRTtRQUNiLElBQUksQ0FBQ25ELE1BQU0sQ0FBQ0csTUFBTSxHQUFHZ0Q7SUFDekI7SUFDQSxjQUFjLEdBQ2R2QyxxQkFBcUI7UUFDakIsT0FBTyxDQUFDLElBQUksQ0FBQ2QsT0FBTyxJQUFJLElBQUksQ0FBQ0EsT0FBTyxLQUFLLElBQUksQ0FBQ0osT0FBTyxDQUFDYyxRQUFRO0lBQ2xFO0FBQ0osRUFDQSw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmNob3Itd29ya2Zsb3dzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21vZHVsZS9SZWFsdGltZVByZXNlbmNlLmpzP2NlYzMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgVGhpcyBmaWxlIGRyYXdzIGhlYXZpbHkgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcGhvZW5peGZyYW1ld29yay9waG9lbml4L2Jsb2IvZDM0NGVjMGE3MzJhYjRlZTIwNDIxNWIzMWRlNjljZjRiZTcyZTNiZi9hc3NldHMvanMvcGhvZW5peC9wcmVzZW5jZS5qc1xuICBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vcGhvZW5peGZyYW1ld29yay9waG9lbml4L2Jsb2IvZDM0NGVjMGE3MzJhYjRlZTIwNDIxNWIzMWRlNjljZjRiZTcyZTNiZi9MSUNFTlNFLm1kXG4qL1xuZXhwb3J0IHZhciBSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTO1xuKGZ1bmN0aW9uIChSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTKSB7XG4gICAgUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UU1tcIlNZTkNcIl0gPSBcInN5bmNcIjtcbiAgICBSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTW1wiSk9JTlwiXSA9IFwiam9pblwiO1xuICAgIFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFNbXCJMRUFWRVwiXSA9IFwibGVhdmVcIjtcbn0pKFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMgfHwgKFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMgPSB7fSkpO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVhbHRpbWVQcmVzZW5jZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFByZXNlbmNlIGhlbHBlciB0aGF0IGtlZXBzIHRoZSBsb2NhbCBwcmVzZW5jZSBzdGF0ZSBpbiBzeW5jIHdpdGggdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIC0gVGhlIHJlYWx0aW1lIGNoYW5uZWwgdG8gYmluZCB0by5cbiAgICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbmFsIGN1c3RvbSBldmVudCBuYW1lcywgZS5nLiBgeyBldmVudHM6IHsgc3RhdGU6ICdzdGF0ZScsIGRpZmY6ICdkaWZmJyB9IH1gLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHByZXNlbmNlID0gbmV3IFJlYWx0aW1lUHJlc2VuY2UoY2hhbm5lbClcbiAgICAgKlxuICAgICAqIGNoYW5uZWwub24oJ3ByZXNlbmNlJywgKHsgZXZlbnQsIGtleSB9KSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhgUHJlc2VuY2UgJHtldmVudH0gb24gJHtrZXl9YClcbiAgICAgKiB9KVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWwsIG9wdHMpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHt9O1xuICAgICAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdO1xuICAgICAgICB0aGlzLmpvaW5SZWYgPSBudWxsO1xuICAgICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYWxsZXIgPSB7XG4gICAgICAgICAgICBvbkpvaW46ICgpID0+IHsgfSxcbiAgICAgICAgICAgIG9uTGVhdmU6ICgpID0+IHsgfSxcbiAgICAgICAgICAgIG9uU3luYzogKCkgPT4geyB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBldmVudHMgPSAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmV2ZW50cykgfHwge1xuICAgICAgICAgICAgc3RhdGU6ICdwcmVzZW5jZV9zdGF0ZScsXG4gICAgICAgICAgICBkaWZmOiAncHJlc2VuY2VfZGlmZicsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2hhbm5lbC5fb24oZXZlbnRzLnN0YXRlLCB7fSwgKG5ld1N0YXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG9uSm9pbiwgb25MZWF2ZSwgb25TeW5jIH0gPSB0aGlzLmNhbGxlcjtcbiAgICAgICAgICAgIHRoaXMuam9pblJlZiA9IHRoaXMuY2hhbm5lbC5fam9pblJlZigpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFJlYWx0aW1lUHJlc2VuY2Uuc3luY1N0YXRlKHRoaXMuc3RhdGUsIG5ld1N0YXRlLCBvbkpvaW4sIG9uTGVhdmUpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nRGlmZnMuZm9yRWFjaCgoZGlmZikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBSZWFsdGltZVByZXNlbmNlLnN5bmNEaWZmKHRoaXMuc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW107XG4gICAgICAgICAgICBvblN5bmMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2hhbm5lbC5fb24oZXZlbnRzLmRpZmYsIHt9LCAoZGlmZikgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvbkpvaW4sIG9uTGVhdmUsIG9uU3luYyB9ID0gdGhpcy5jYWxsZXI7XG4gICAgICAgICAgICBpZiAodGhpcy5pblBlbmRpbmdTeW5jU3RhdGUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0RpZmZzLnB1c2goZGlmZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gUmVhbHRpbWVQcmVzZW5jZS5zeW5jRGlmZih0aGlzLnN0YXRlLCBkaWZmLCBvbkpvaW4sIG9uTGVhdmUpO1xuICAgICAgICAgICAgICAgIG9uU3luYygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbkpvaW4oKGtleSwgY3VycmVudFByZXNlbmNlcywgbmV3UHJlc2VuY2VzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWwuX3RyaWdnZXIoJ3ByZXNlbmNlJywge1xuICAgICAgICAgICAgICAgIGV2ZW50OiAnam9pbicsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIGN1cnJlbnRQcmVzZW5jZXMsXG4gICAgICAgICAgICAgICAgbmV3UHJlc2VuY2VzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uTGVhdmUoKGtleSwgY3VycmVudFByZXNlbmNlcywgbGVmdFByZXNlbmNlcykgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLl90cmlnZ2VyKCdwcmVzZW5jZScsIHtcbiAgICAgICAgICAgICAgICBldmVudDogJ2xlYXZlJyxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgY3VycmVudFByZXNlbmNlcyxcbiAgICAgICAgICAgICAgICBsZWZ0UHJlc2VuY2VzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uU3luYygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWwuX3RyaWdnZXIoJ3ByZXNlbmNlJywgeyBldmVudDogJ3N5bmMnIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBzeW5jIHRoZSBsaXN0IG9mIHByZXNlbmNlcyBvbiB0aGUgc2VydmVyIHdpdGggdGhlXG4gICAgICogY2xpZW50J3Mgc3RhdGUuXG4gICAgICpcbiAgICAgKiBBbiBvcHRpb25hbCBgb25Kb2luYCBhbmQgYG9uTGVhdmVgIGNhbGxiYWNrIGNhbiBiZSBwcm92aWRlZCB0b1xuICAgICAqIHJlYWN0IHRvIGNoYW5nZXMgaW4gdGhlIGNsaWVudCdzIGxvY2FsIHByZXNlbmNlcyBhY3Jvc3NcbiAgICAgKiBkaXNjb25uZWN0cyBhbmQgcmVjb25uZWN0cyB3aXRoIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgc3luY1N0YXRlKGN1cnJlbnRTdGF0ZSwgbmV3U3RhdGUsIG9uSm9pbiwgb25MZWF2ZSkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuY2xvbmVEZWVwKGN1cnJlbnRTdGF0ZSk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkU3RhdGUgPSB0aGlzLnRyYW5zZm9ybVN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgY29uc3Qgam9pbnMgPSB7fTtcbiAgICAgICAgY29uc3QgbGVhdmVzID0ge307XG4gICAgICAgIHRoaXMubWFwKHN0YXRlLCAoa2V5LCBwcmVzZW5jZXMpID0+IHtcbiAgICAgICAgICAgIGlmICghdHJhbnNmb3JtZWRTdGF0ZVtrZXldKSB7XG4gICAgICAgICAgICAgICAgbGVhdmVzW2tleV0gPSBwcmVzZW5jZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1hcCh0cmFuc2Zvcm1lZFN0YXRlLCAoa2V5LCBuZXdQcmVzZW5jZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQcmVzZW5jZXMgPSBzdGF0ZVtrZXldO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRQcmVzZW5jZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdQcmVzZW5jZVJlZnMgPSBuZXdQcmVzZW5jZXMubWFwKChtKSA9PiBtLnByZXNlbmNlX3JlZik7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyUHJlc2VuY2VSZWZzID0gY3VycmVudFByZXNlbmNlcy5tYXAoKG0pID0+IG0ucHJlc2VuY2VfcmVmKTtcbiAgICAgICAgICAgICAgICBjb25zdCBqb2luZWRQcmVzZW5jZXMgPSBuZXdQcmVzZW5jZXMuZmlsdGVyKChtKSA9PiBjdXJQcmVzZW5jZVJlZnMuaW5kZXhPZihtLnByZXNlbmNlX3JlZikgPCAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0UHJlc2VuY2VzID0gY3VycmVudFByZXNlbmNlcy5maWx0ZXIoKG0pID0+IG5ld1ByZXNlbmNlUmVmcy5pbmRleE9mKG0ucHJlc2VuY2VfcmVmKSA8IDApO1xuICAgICAgICAgICAgICAgIGlmIChqb2luZWRQcmVzZW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBqb2luc1trZXldID0gam9pbmVkUHJlc2VuY2VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGVmdFByZXNlbmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlYXZlc1trZXldID0gbGVmdFByZXNlbmNlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBqb2luc1trZXldID0gbmV3UHJlc2VuY2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3luY0RpZmYoc3RhdGUsIHsgam9pbnMsIGxlYXZlcyB9LCBvbkpvaW4sIG9uTGVhdmUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHN5bmMgYSBkaWZmIG9mIHByZXNlbmNlIGpvaW4gYW5kIGxlYXZlIGV2ZW50cyBmcm9tIHRoZVxuICAgICAqIHNlcnZlciwgYXMgdGhleSBoYXBwZW4uXG4gICAgICpcbiAgICAgKiBMaWtlIGBzeW5jU3RhdGVgLCBgc3luY0RpZmZgIGFjY2VwdHMgb3B0aW9uYWwgYG9uSm9pbmAgYW5kXG4gICAgICogYG9uTGVhdmVgIGNhbGxiYWNrcyB0byByZWFjdCB0byBhIHVzZXIgam9pbmluZyBvciBsZWF2aW5nIGZyb20gYVxuICAgICAqIGRldmljZS5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBzeW5jRGlmZihzdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKSB7XG4gICAgICAgIGNvbnN0IHsgam9pbnMsIGxlYXZlcyB9ID0ge1xuICAgICAgICAgICAgam9pbnM6IHRoaXMudHJhbnNmb3JtU3RhdGUoZGlmZi5qb2lucyksXG4gICAgICAgICAgICBsZWF2ZXM6IHRoaXMudHJhbnNmb3JtU3RhdGUoZGlmZi5sZWF2ZXMpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIW9uSm9pbikge1xuICAgICAgICAgICAgb25Kb2luID0gKCkgPT4geyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghb25MZWF2ZSkge1xuICAgICAgICAgICAgb25MZWF2ZSA9ICgpID0+IHsgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcChqb2lucywgKGtleSwgbmV3UHJlc2VuY2VzKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UHJlc2VuY2VzID0gKF9hID0gc3RhdGVba2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgICAgICBzdGF0ZVtrZXldID0gdGhpcy5jbG9uZURlZXAobmV3UHJlc2VuY2VzKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UHJlc2VuY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBqb2luZWRQcmVzZW5jZVJlZnMgPSBzdGF0ZVtrZXldLm1hcCgobSkgPT4gbS5wcmVzZW5jZV9yZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1clByZXNlbmNlcyA9IGN1cnJlbnRQcmVzZW5jZXMuZmlsdGVyKChtKSA9PiBqb2luZWRQcmVzZW5jZVJlZnMuaW5kZXhPZihtLnByZXNlbmNlX3JlZikgPCAwKTtcbiAgICAgICAgICAgICAgICBzdGF0ZVtrZXldLnVuc2hpZnQoLi4uY3VyUHJlc2VuY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uSm9pbihrZXksIGN1cnJlbnRQcmVzZW5jZXMsIG5ld1ByZXNlbmNlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1hcChsZWF2ZXMsIChrZXksIGxlZnRQcmVzZW5jZXMpID0+IHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50UHJlc2VuY2VzID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgIGlmICghY3VycmVudFByZXNlbmNlcylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBwcmVzZW5jZVJlZnNUb1JlbW92ZSA9IGxlZnRQcmVzZW5jZXMubWFwKChtKSA9PiBtLnByZXNlbmNlX3JlZik7XG4gICAgICAgICAgICBjdXJyZW50UHJlc2VuY2VzID0gY3VycmVudFByZXNlbmNlcy5maWx0ZXIoKG0pID0+IHByZXNlbmNlUmVmc1RvUmVtb3ZlLmluZGV4T2YobS5wcmVzZW5jZV9yZWYpIDwgMCk7XG4gICAgICAgICAgICBzdGF0ZVtrZXldID0gY3VycmVudFByZXNlbmNlcztcbiAgICAgICAgICAgIG9uTGVhdmUoa2V5LCBjdXJyZW50UHJlc2VuY2VzLCBsZWZ0UHJlc2VuY2VzKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UHJlc2VuY2VzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICBkZWxldGUgc3RhdGVba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBtYXAob2JqLCBmdW5jKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLm1hcCgoa2V5KSA9PiBmdW5jKGtleSwgb2JqW2tleV0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlICdtZXRhcycga2V5XG4gICAgICogQ2hhbmdlICdwaHhfcmVmJyB0byAncHJlc2VuY2VfcmVmJ1xuICAgICAqIFJlbW92ZSAncGh4X3JlZicgYW5kICdwaHhfcmVmX3ByZXYnXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHJldHVybnMge1xuICAgICAqICBhYmMxMjM6IFtcbiAgICAgKiAgICB7IHByZXNlbmNlX3JlZjogJzInLCB1c2VyX2lkOiAxIH0sXG4gICAgICogICAgeyBwcmVzZW5jZV9yZWY6ICczJywgdXNlcl9pZDogMiB9XG4gICAgICogIF1cbiAgICAgKiB9XG4gICAgICogUmVhbHRpbWVQcmVzZW5jZS50cmFuc2Zvcm1TdGF0ZSh7XG4gICAgICogIGFiYzEyMzoge1xuICAgICAqICAgIG1ldGFzOiBbXG4gICAgICogICAgICB7IHBoeF9yZWY6ICcyJywgcGh4X3JlZl9wcmV2OiAnMScgdXNlcl9pZDogMSB9LFxuICAgICAqICAgICAgeyBwaHhfcmVmOiAnMycsIHVzZXJfaWQ6IDIgfVxuICAgICAqICAgIF1cbiAgICAgKiAgfVxuICAgICAqIH0pXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgc3RhdGUgPSB0aGlzLmNsb25lRGVlcChzdGF0ZSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzdGF0ZSkucmVkdWNlKChuZXdTdGF0ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcmVzZW5jZXMgPSBzdGF0ZVtrZXldO1xuICAgICAgICAgICAgaWYgKCdtZXRhcycgaW4gcHJlc2VuY2VzKSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGVba2V5XSA9IHByZXNlbmNlcy5tZXRhcy5tYXAoKHByZXNlbmNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNlbmNlWydwcmVzZW5jZV9yZWYnXSA9IHByZXNlbmNlWydwaHhfcmVmJ107XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwcmVzZW5jZVsncGh4X3JlZiddO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcHJlc2VuY2VbJ3BoeF9yZWZfcHJldiddO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlc2VuY2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZVtrZXldID0gcHJlc2VuY2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgY2xvbmVEZWVwKG9iaikge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIG9uSm9pbihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbGxlci5vbkpvaW4gPSBjYWxsYmFjaztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIG9uTGVhdmUoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jYWxsZXIub25MZWF2ZSA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgb25TeW5jKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbGVyLm9uU3luYyA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgaW5QZW5kaW5nU3luY1N0YXRlKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuam9pblJlZiB8fCB0aGlzLmpvaW5SZWYgIT09IHRoaXMuY2hhbm5lbC5fam9pblJlZigpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlYWx0aW1lUHJlc2VuY2UuanMubWFwIl0sIm5hbWVzIjpbIlJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMiLCJSZWFsdGltZVByZXNlbmNlIiwiY29uc3RydWN0b3IiLCJjaGFubmVsIiwib3B0cyIsInN0YXRlIiwicGVuZGluZ0RpZmZzIiwiam9pblJlZiIsImVuYWJsZWQiLCJjYWxsZXIiLCJvbkpvaW4iLCJvbkxlYXZlIiwib25TeW5jIiwiZXZlbnRzIiwiZGlmZiIsIl9vbiIsIm5ld1N0YXRlIiwiX2pvaW5SZWYiLCJzeW5jU3RhdGUiLCJmb3JFYWNoIiwic3luY0RpZmYiLCJpblBlbmRpbmdTeW5jU3RhdGUiLCJwdXNoIiwia2V5IiwiY3VycmVudFByZXNlbmNlcyIsIm5ld1ByZXNlbmNlcyIsIl90cmlnZ2VyIiwiZXZlbnQiLCJsZWZ0UHJlc2VuY2VzIiwiY3VycmVudFN0YXRlIiwiY2xvbmVEZWVwIiwidHJhbnNmb3JtZWRTdGF0ZSIsInRyYW5zZm9ybVN0YXRlIiwiam9pbnMiLCJsZWF2ZXMiLCJtYXAiLCJwcmVzZW5jZXMiLCJuZXdQcmVzZW5jZVJlZnMiLCJtIiwicHJlc2VuY2VfcmVmIiwiY3VyUHJlc2VuY2VSZWZzIiwiam9pbmVkUHJlc2VuY2VzIiwiZmlsdGVyIiwiaW5kZXhPZiIsImxlbmd0aCIsIl9hIiwiam9pbmVkUHJlc2VuY2VSZWZzIiwiY3VyUHJlc2VuY2VzIiwidW5zaGlmdCIsInByZXNlbmNlUmVmc1RvUmVtb3ZlIiwib2JqIiwiZnVuYyIsIk9iamVjdCIsImdldE93blByb3BlcnR5TmFtZXMiLCJyZWR1Y2UiLCJtZXRhcyIsInByZXNlbmNlIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiY2FsbGJhY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   REALTIME_CHANNEL_STATES: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_CHANNEL_STATES),\n/* harmony export */   REALTIME_LISTEN_TYPES: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_LISTEN_TYPES),\n/* harmony export */   REALTIME_POSTGRES_CHANGES_LISTEN_EVENT: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT),\n/* harmony export */   REALTIME_PRESENCE_LISTEN_EVENTS: () => (/* reexport safe */ _RealtimePresence__WEBPACK_IMPORTED_MODULE_2__.REALTIME_PRESENCE_LISTEN_EVENTS),\n/* harmony export */   REALTIME_SUBSCRIBE_STATES: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_SUBSCRIBE_STATES),\n/* harmony export */   RealtimeChannel: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   RealtimeClient: () => (/* reexport safe */ _RealtimeClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   RealtimePresence: () => (/* reexport safe */ _RealtimePresence__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   WebSocketFactory: () => (/* reexport safe */ _lib_websocket_factory__WEBPACK_IMPORTED_MODULE_3__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _RealtimeClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RealtimeClient */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js\");\n/* harmony import */ var _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RealtimeChannel */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js\");\n/* harmony import */ var _RealtimePresence__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RealtimePresence */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js\");\n/* harmony import */ var _lib_websocket_factory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/websocket-factory */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js\");\n\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFDMEg7QUFDaEY7QUFDakM7QUFDNkssQ0FDcE8saUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5jaG9yLXdvcmtmbG93cy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvaW5kZXguanM/NTU1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhbHRpbWVDbGllbnQgZnJvbSAnLi9SZWFsdGltZUNsaWVudCc7XG5pbXBvcnQgUmVhbHRpbWVDaGFubmVsLCB7IFJFQUxUSU1FX0xJU1RFTl9UWVBFUywgUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQsIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMsIFJFQUxUSU1FX0NIQU5ORUxfU1RBVEVTLCB9IGZyb20gJy4vUmVhbHRpbWVDaGFubmVsJztcbmltcG9ydCBSZWFsdGltZVByZXNlbmNlLCB7IFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMsIH0gZnJvbSAnLi9SZWFsdGltZVByZXNlbmNlJztcbmltcG9ydCBXZWJTb2NrZXRGYWN0b3J5IGZyb20gJy4vbGliL3dlYnNvY2tldC1mYWN0b3J5JztcbmV4cG9ydCB7IFJlYWx0aW1lUHJlc2VuY2UsIFJlYWx0aW1lQ2hhbm5lbCwgUmVhbHRpbWVDbGllbnQsIFJFQUxUSU1FX0xJU1RFTl9UWVBFUywgUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQsIFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMsIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMsIFJFQUxUSU1FX0NIQU5ORUxfU1RBVEVTLCBXZWJTb2NrZXRGYWN0b3J5LCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIlJlYWx0aW1lQ2xpZW50IiwiUmVhbHRpbWVDaGFubmVsIiwiUkVBTFRJTUVfTElTVEVOX1RZUEVTIiwiUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQiLCJSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTIiwiUkVBTFRJTUVfQ0hBTk5FTF9TVEFURVMiLCJSZWFsdGltZVByZXNlbmNlIiwiUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUyIsIldlYlNvY2tldEZhY3RvcnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/constants.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CHANNEL_EVENTS: () => (/* binding */ CHANNEL_EVENTS),\n/* harmony export */   CHANNEL_STATES: () => (/* binding */ CHANNEL_STATES),\n/* harmony export */   CONNECTION_STATE: () => (/* binding */ CONNECTION_STATE),\n/* harmony export */   DEFAULT_TIMEOUT: () => (/* binding */ DEFAULT_TIMEOUT),\n/* harmony export */   DEFAULT_VERSION: () => (/* binding */ DEFAULT_VERSION),\n/* harmony export */   DEFAULT_VSN: () => (/* binding */ DEFAULT_VSN),\n/* harmony export */   MAX_PUSH_BUFFER_SIZE: () => (/* binding */ MAX_PUSH_BUFFER_SIZE),\n/* harmony export */   SOCKET_STATES: () => (/* binding */ SOCKET_STATES),\n/* harmony export */   TRANSPORTS: () => (/* binding */ TRANSPORTS),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   VSN_1_0_0: () => (/* binding */ VSN_1_0_0),\n/* harmony export */   VSN_2_0_0: () => (/* binding */ VSN_2_0_0),\n/* harmony export */   WS_CLOSE_NORMAL: () => (/* binding */ WS_CLOSE_NORMAL)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/version.js\");\n\nconst DEFAULT_VERSION = `realtime-js/${_version__WEBPACK_IMPORTED_MODULE_0__.version}`;\nconst VSN_1_0_0 = \"1.0.0\";\nconst VSN_2_0_0 = \"2.0.0\";\nconst DEFAULT_VSN = VSN_2_0_0;\nconst VERSION = _version__WEBPACK_IMPORTED_MODULE_0__.version;\nconst DEFAULT_TIMEOUT = 10000;\nconst WS_CLOSE_NORMAL = 1000;\nconst MAX_PUSH_BUFFER_SIZE = 100;\nvar SOCKET_STATES;\n(function(SOCKET_STATES) {\n    SOCKET_STATES[SOCKET_STATES[\"connecting\"] = 0] = \"connecting\";\n    SOCKET_STATES[SOCKET_STATES[\"open\"] = 1] = \"open\";\n    SOCKET_STATES[SOCKET_STATES[\"closing\"] = 2] = \"closing\";\n    SOCKET_STATES[SOCKET_STATES[\"closed\"] = 3] = \"closed\";\n})(SOCKET_STATES || (SOCKET_STATES = {}));\nvar CHANNEL_STATES;\n(function(CHANNEL_STATES) {\n    CHANNEL_STATES[\"closed\"] = \"closed\";\n    CHANNEL_STATES[\"errored\"] = \"errored\";\n    CHANNEL_STATES[\"joined\"] = \"joined\";\n    CHANNEL_STATES[\"joining\"] = \"joining\";\n    CHANNEL_STATES[\"leaving\"] = \"leaving\";\n})(CHANNEL_STATES || (CHANNEL_STATES = {}));\nvar CHANNEL_EVENTS;\n(function(CHANNEL_EVENTS) {\n    CHANNEL_EVENTS[\"close\"] = \"phx_close\";\n    CHANNEL_EVENTS[\"error\"] = \"phx_error\";\n    CHANNEL_EVENTS[\"join\"] = \"phx_join\";\n    CHANNEL_EVENTS[\"reply\"] = \"phx_reply\";\n    CHANNEL_EVENTS[\"leave\"] = \"phx_leave\";\n    CHANNEL_EVENTS[\"access_token\"] = \"access_token\";\n})(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));\nvar TRANSPORTS;\n(function(TRANSPORTS) {\n    TRANSPORTS[\"websocket\"] = \"websocket\";\n})(TRANSPORTS || (TRANSPORTS = {}));\nvar CONNECTION_STATE;\n(function(CONNECTION_STATE) {\n    CONNECTION_STATE[\"Connecting\"] = \"connecting\";\n    CONNECTION_STATE[\"Open\"] = \"open\";\n    CONNECTION_STATE[\"Closing\"] = \"closing\";\n    CONNECTION_STATE[\"Closed\"] = \"closed\";\n})(CONNECTION_STATE || (CONNECTION_STATE = {})); //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFDN0IsTUFBTUMsa0JBQWtCLENBQUMsWUFBWSxFQUFFRCw2Q0FBT0EsQ0FBQyxDQUFDLENBQUM7QUFDakQsTUFBTUUsWUFBWSxRQUFRO0FBQzFCLE1BQU1DLFlBQVksUUFBUTtBQUMxQixNQUFNQyxjQUFjRCxVQUFVO0FBQzlCLE1BQU1FLFVBQVVMLDZDQUFPQSxDQUFDO0FBQ3hCLE1BQU1NLGtCQUFrQixNQUFNO0FBQzlCLE1BQU1DLGtCQUFrQixLQUFLO0FBQzdCLE1BQU1DLHVCQUF1QixJQUFJO0FBQ2pDLElBQUlDLGNBQWM7QUFDeEIsVUFBVUEsYUFBYTtJQUNwQkEsYUFBYSxDQUFDQSxhQUFhLENBQUMsYUFBYSxHQUFHLEVBQUUsR0FBRztJQUNqREEsYUFBYSxDQUFDQSxhQUFhLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUMzQ0EsYUFBYSxDQUFDQSxhQUFhLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUM5Q0EsYUFBYSxDQUFDQSxhQUFhLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRztBQUNqRCxHQUFHQSxpQkFBa0JBLENBQUFBLGdCQUFnQixDQUFDO0FBQy9CLElBQUlDLGVBQWU7QUFDekIsVUFBVUEsY0FBYztJQUNyQkEsY0FBYyxDQUFDLFNBQVMsR0FBRztJQUMzQkEsY0FBYyxDQUFDLFVBQVUsR0FBRztJQUM1QkEsY0FBYyxDQUFDLFNBQVMsR0FBRztJQUMzQkEsY0FBYyxDQUFDLFVBQVUsR0FBRztJQUM1QkEsY0FBYyxDQUFDLFVBQVUsR0FBRztBQUNoQyxHQUFHQSxrQkFBbUJBLENBQUFBLGlCQUFpQixDQUFDO0FBQ2pDLElBQUlDLGVBQWU7QUFDekIsVUFBVUEsY0FBYztJQUNyQkEsY0FBYyxDQUFDLFFBQVEsR0FBRztJQUMxQkEsY0FBYyxDQUFDLFFBQVEsR0FBRztJQUMxQkEsY0FBYyxDQUFDLE9BQU8sR0FBRztJQUN6QkEsY0FBYyxDQUFDLFFBQVEsR0FBRztJQUMxQkEsY0FBYyxDQUFDLFFBQVEsR0FBRztJQUMxQkEsY0FBYyxDQUFDLGVBQWUsR0FBRztBQUNyQyxHQUFHQSxrQkFBbUJBLENBQUFBLGlCQUFpQixDQUFDO0FBQ2pDLElBQUlDLFdBQVc7QUFDckIsVUFBVUEsVUFBVTtJQUNqQkEsVUFBVSxDQUFDLFlBQVksR0FBRztBQUM5QixHQUFHQSxjQUFlQSxDQUFBQSxhQUFhLENBQUM7QUFDekIsSUFBSUMsaUJBQWlCO0FBQzNCLFVBQVVBLGdCQUFnQjtJQUN2QkEsZ0JBQWdCLENBQUMsYUFBYSxHQUFHO0lBQ2pDQSxnQkFBZ0IsQ0FBQyxPQUFPLEdBQUc7SUFDM0JBLGdCQUFnQixDQUFDLFVBQVUsR0FBRztJQUM5QkEsZ0JBQWdCLENBQUMsU0FBUyxHQUFHO0FBQ2pDLEdBQUdBLG9CQUFxQkEsQ0FBQUEsbUJBQW1CLENBQUMsS0FDNUMscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5jaG9yLXdvcmtmbG93cy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL2NvbnN0YW50cy5qcz9hYzEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfVkVSU0lPTiA9IGByZWFsdGltZS1qcy8ke3ZlcnNpb259YDtcbmV4cG9ydCBjb25zdCBWU05fMV8wXzAgPSAnMS4wLjAnO1xuZXhwb3J0IGNvbnN0IFZTTl8yXzBfMCA9ICcyLjAuMCc7XG5leHBvcnQgY29uc3QgREVGQVVMVF9WU04gPSBWU05fMl8wXzA7XG5leHBvcnQgY29uc3QgVkVSU0lPTiA9IHZlcnNpb247XG5leHBvcnQgY29uc3QgREVGQVVMVF9USU1FT1VUID0gMTAwMDA7XG5leHBvcnQgY29uc3QgV1NfQ0xPU0VfTk9STUFMID0gMTAwMDtcbmV4cG9ydCBjb25zdCBNQVhfUFVTSF9CVUZGRVJfU0laRSA9IDEwMDtcbmV4cG9ydCB2YXIgU09DS0VUX1NUQVRFUztcbihmdW5jdGlvbiAoU09DS0VUX1NUQVRFUykge1xuICAgIFNPQ0tFVF9TVEFURVNbU09DS0VUX1NUQVRFU1tcImNvbm5lY3RpbmdcIl0gPSAwXSA9IFwiY29ubmVjdGluZ1wiO1xuICAgIFNPQ0tFVF9TVEFURVNbU09DS0VUX1NUQVRFU1tcIm9wZW5cIl0gPSAxXSA9IFwib3BlblwiO1xuICAgIFNPQ0tFVF9TVEFURVNbU09DS0VUX1NUQVRFU1tcImNsb3NpbmdcIl0gPSAyXSA9IFwiY2xvc2luZ1wiO1xuICAgIFNPQ0tFVF9TVEFURVNbU09DS0VUX1NUQVRFU1tcImNsb3NlZFwiXSA9IDNdID0gXCJjbG9zZWRcIjtcbn0pKFNPQ0tFVF9TVEFURVMgfHwgKFNPQ0tFVF9TVEFURVMgPSB7fSkpO1xuZXhwb3J0IHZhciBDSEFOTkVMX1NUQVRFUztcbihmdW5jdGlvbiAoQ0hBTk5FTF9TVEFURVMpIHtcbiAgICBDSEFOTkVMX1NUQVRFU1tcImNsb3NlZFwiXSA9IFwiY2xvc2VkXCI7XG4gICAgQ0hBTk5FTF9TVEFURVNbXCJlcnJvcmVkXCJdID0gXCJlcnJvcmVkXCI7XG4gICAgQ0hBTk5FTF9TVEFURVNbXCJqb2luZWRcIl0gPSBcImpvaW5lZFwiO1xuICAgIENIQU5ORUxfU1RBVEVTW1wiam9pbmluZ1wiXSA9IFwiam9pbmluZ1wiO1xuICAgIENIQU5ORUxfU1RBVEVTW1wibGVhdmluZ1wiXSA9IFwibGVhdmluZ1wiO1xufSkoQ0hBTk5FTF9TVEFURVMgfHwgKENIQU5ORUxfU1RBVEVTID0ge30pKTtcbmV4cG9ydCB2YXIgQ0hBTk5FTF9FVkVOVFM7XG4oZnVuY3Rpb24gKENIQU5ORUxfRVZFTlRTKSB7XG4gICAgQ0hBTk5FTF9FVkVOVFNbXCJjbG9zZVwiXSA9IFwicGh4X2Nsb3NlXCI7XG4gICAgQ0hBTk5FTF9FVkVOVFNbXCJlcnJvclwiXSA9IFwicGh4X2Vycm9yXCI7XG4gICAgQ0hBTk5FTF9FVkVOVFNbXCJqb2luXCJdID0gXCJwaHhfam9pblwiO1xuICAgIENIQU5ORUxfRVZFTlRTW1wicmVwbHlcIl0gPSBcInBoeF9yZXBseVwiO1xuICAgIENIQU5ORUxfRVZFTlRTW1wibGVhdmVcIl0gPSBcInBoeF9sZWF2ZVwiO1xuICAgIENIQU5ORUxfRVZFTlRTW1wiYWNjZXNzX3Rva2VuXCJdID0gXCJhY2Nlc3NfdG9rZW5cIjtcbn0pKENIQU5ORUxfRVZFTlRTIHx8IChDSEFOTkVMX0VWRU5UUyA9IHt9KSk7XG5leHBvcnQgdmFyIFRSQU5TUE9SVFM7XG4oZnVuY3Rpb24gKFRSQU5TUE9SVFMpIHtcbiAgICBUUkFOU1BPUlRTW1wid2Vic29ja2V0XCJdID0gXCJ3ZWJzb2NrZXRcIjtcbn0pKFRSQU5TUE9SVFMgfHwgKFRSQU5TUE9SVFMgPSB7fSkpO1xuZXhwb3J0IHZhciBDT05ORUNUSU9OX1NUQVRFO1xuKGZ1bmN0aW9uIChDT05ORUNUSU9OX1NUQVRFKSB7XG4gICAgQ09OTkVDVElPTl9TVEFURVtcIkNvbm5lY3RpbmdcIl0gPSBcImNvbm5lY3RpbmdcIjtcbiAgICBDT05ORUNUSU9OX1NUQVRFW1wiT3BlblwiXSA9IFwib3BlblwiO1xuICAgIENPTk5FQ1RJT05fU1RBVEVbXCJDbG9zaW5nXCJdID0gXCJjbG9zaW5nXCI7XG4gICAgQ09OTkVDVElPTl9TVEFURVtcIkNsb3NlZFwiXSA9IFwiY2xvc2VkXCI7XG59KShDT05ORUNUSU9OX1NUQVRFIHx8IChDT05ORUNUSU9OX1NUQVRFID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiIsIkRFRkFVTFRfVkVSU0lPTiIsIlZTTl8xXzBfMCIsIlZTTl8yXzBfMCIsIkRFRkFVTFRfVlNOIiwiVkVSU0lPTiIsIkRFRkFVTFRfVElNRU9VVCIsIldTX0NMT1NFX05PUk1BTCIsIk1BWF9QVVNIX0JVRkZFUl9TSVpFIiwiU09DS0VUX1NUQVRFUyIsIkNIQU5ORUxfU1RBVEVTIiwiQ0hBTk5FTF9FVkVOVFMiLCJUUkFOU1BPUlRTIiwiQ09OTkVDVElPTl9TVEFURSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/push.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/push.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Push)\n/* harmony export */ });\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/constants */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\");\n\nclass Push {\n    /**\n     * Initializes the Push\n     *\n     * @param channel The Channel\n     * @param event The event, for example `\"phx_join\"`\n     * @param payload The payload, for example `{user_id: 123}`\n     * @param timeout The push timeout in milliseconds\n     */ constructor(channel, event, payload = {}, timeout = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_TIMEOUT){\n        this.channel = channel;\n        this.event = event;\n        this.payload = payload;\n        this.timeout = timeout;\n        this.sent = false;\n        this.timeoutTimer = undefined;\n        this.ref = \"\";\n        this.receivedResp = null;\n        this.recHooks = [];\n        this.refEvent = null;\n    }\n    resend(timeout) {\n        this.timeout = timeout;\n        this._cancelRefEvent();\n        this.ref = \"\";\n        this.refEvent = null;\n        this.receivedResp = null;\n        this.sent = false;\n        this.send();\n    }\n    send() {\n        if (this._hasReceived(\"timeout\")) {\n            return;\n        }\n        this.startTimeout();\n        this.sent = true;\n        this.channel.socket.push({\n            topic: this.channel.topic,\n            event: this.event,\n            payload: this.payload,\n            ref: this.ref,\n            join_ref: this.channel._joinRef()\n        });\n    }\n    updatePayload(payload) {\n        this.payload = Object.assign(Object.assign({}, this.payload), payload);\n    }\n    receive(status, callback) {\n        var _a;\n        if (this._hasReceived(status)) {\n            callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);\n        }\n        this.recHooks.push({\n            status,\n            callback\n        });\n        return this;\n    }\n    startTimeout() {\n        if (this.timeoutTimer) {\n            return;\n        }\n        this.ref = this.channel.socket._makeRef();\n        this.refEvent = this.channel._replyEventName(this.ref);\n        const callback = (payload)=>{\n            this._cancelRefEvent();\n            this._cancelTimeout();\n            this.receivedResp = payload;\n            this._matchReceive(payload);\n        };\n        this.channel._on(this.refEvent, {}, callback);\n        this.timeoutTimer = setTimeout(()=>{\n            this.trigger(\"timeout\", {});\n        }, this.timeout);\n    }\n    trigger(status, response) {\n        if (this.refEvent) this.channel._trigger(this.refEvent, {\n            status,\n            response\n        });\n    }\n    destroy() {\n        this._cancelRefEvent();\n        this._cancelTimeout();\n    }\n    _cancelRefEvent() {\n        if (!this.refEvent) {\n            return;\n        }\n        this.channel._off(this.refEvent, {});\n    }\n    _cancelTimeout() {\n        clearTimeout(this.timeoutTimer);\n        this.timeoutTimer = undefined;\n    }\n    _matchReceive({ status, response }) {\n        this.recHooks.filter((h)=>h.status === status).forEach((h)=>h.callback(response));\n    }\n    _hasReceived(status) {\n        return this.receivedResp && this.receivedResp.status === status;\n    }\n} //# sourceMappingURL=push.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi9wdXNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW1EO0FBQ3BDLE1BQU1DO0lBQ2pCOzs7Ozs7O0tBT0MsR0FDREMsWUFBWUMsT0FBTyxFQUFFQyxLQUFLLEVBQUVDLFVBQVUsQ0FBQyxDQUFDLEVBQUVDLFVBQVVOLDJEQUFlLENBQUU7UUFDakUsSUFBSSxDQUFDRyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLFlBQVksR0FBR0M7UUFDcEIsSUFBSSxDQUFDQyxHQUFHLEdBQUc7UUFDWCxJQUFJLENBQUNDLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLFFBQVEsR0FBRyxFQUFFO1FBQ2xCLElBQUksQ0FBQ0MsUUFBUSxHQUFHO0lBQ3BCO0lBQ0FDLE9BQU9SLE9BQU8sRUFBRTtRQUNaLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ1MsZUFBZTtRQUNwQixJQUFJLENBQUNMLEdBQUcsR0FBRztRQUNYLElBQUksQ0FBQ0csUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0YsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0osSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDUyxJQUFJO0lBQ2I7SUFDQUEsT0FBTztRQUNILElBQUksSUFBSSxDQUFDQyxZQUFZLENBQUMsWUFBWTtZQUM5QjtRQUNKO1FBQ0EsSUFBSSxDQUFDQyxZQUFZO1FBQ2pCLElBQUksQ0FBQ1gsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDSixPQUFPLENBQUNnQixNQUFNLENBQUNDLElBQUksQ0FBQztZQUNyQkMsT0FBTyxJQUFJLENBQUNsQixPQUFPLENBQUNrQixLQUFLO1lBQ3pCakIsT0FBTyxJQUFJLENBQUNBLEtBQUs7WUFDakJDLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCSyxLQUFLLElBQUksQ0FBQ0EsR0FBRztZQUNiWSxVQUFVLElBQUksQ0FBQ25CLE9BQU8sQ0FBQ29CLFFBQVE7UUFDbkM7SUFDSjtJQUNBQyxjQUFjbkIsT0FBTyxFQUFFO1FBQ25CLElBQUksQ0FBQ0EsT0FBTyxHQUFHb0IsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQ3JCLE9BQU8sR0FBR0E7SUFDbEU7SUFDQXNCLFFBQVFDLE1BQU0sRUFBRUMsUUFBUSxFQUFFO1FBQ3RCLElBQUlDO1FBQ0osSUFBSSxJQUFJLENBQUNiLFlBQVksQ0FBQ1csU0FBUztZQUMzQkMsU0FBUyxDQUFDQyxLQUFLLElBQUksQ0FBQ25CLFlBQVksTUFBTSxRQUFRbUIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHQyxRQUFRO1FBQ3RGO1FBQ0EsSUFBSSxDQUFDbkIsUUFBUSxDQUFDUSxJQUFJLENBQUM7WUFBRVE7WUFBUUM7UUFBUztRQUN0QyxPQUFPLElBQUk7SUFDZjtJQUNBWCxlQUFlO1FBQ1gsSUFBSSxJQUFJLENBQUNWLFlBQVksRUFBRTtZQUNuQjtRQUNKO1FBQ0EsSUFBSSxDQUFDRSxHQUFHLEdBQUcsSUFBSSxDQUFDUCxPQUFPLENBQUNnQixNQUFNLENBQUNhLFFBQVE7UUFDdkMsSUFBSSxDQUFDbkIsUUFBUSxHQUFHLElBQUksQ0FBQ1YsT0FBTyxDQUFDOEIsZUFBZSxDQUFDLElBQUksQ0FBQ3ZCLEdBQUc7UUFDckQsTUFBTW1CLFdBQVcsQ0FBQ3hCO1lBQ2QsSUFBSSxDQUFDVSxlQUFlO1lBQ3BCLElBQUksQ0FBQ21CLGNBQWM7WUFDbkIsSUFBSSxDQUFDdkIsWUFBWSxHQUFHTjtZQUNwQixJQUFJLENBQUM4QixhQUFhLENBQUM5QjtRQUN2QjtRQUNBLElBQUksQ0FBQ0YsT0FBTyxDQUFDaUMsR0FBRyxDQUFDLElBQUksQ0FBQ3ZCLFFBQVEsRUFBRSxDQUFDLEdBQUdnQjtRQUNwQyxJQUFJLENBQUNyQixZQUFZLEdBQUc2QixXQUFXO1lBQzNCLElBQUksQ0FBQ0MsT0FBTyxDQUFDLFdBQVcsQ0FBQztRQUM3QixHQUFHLElBQUksQ0FBQ2hDLE9BQU87SUFDbkI7SUFDQWdDLFFBQVFWLE1BQU0sRUFBRUcsUUFBUSxFQUFFO1FBQ3RCLElBQUksSUFBSSxDQUFDbEIsUUFBUSxFQUNiLElBQUksQ0FBQ1YsT0FBTyxDQUFDb0MsUUFBUSxDQUFDLElBQUksQ0FBQzFCLFFBQVEsRUFBRTtZQUFFZTtZQUFRRztRQUFTO0lBQ2hFO0lBQ0FTLFVBQVU7UUFDTixJQUFJLENBQUN6QixlQUFlO1FBQ3BCLElBQUksQ0FBQ21CLGNBQWM7SUFDdkI7SUFDQW5CLGtCQUFrQjtRQUNkLElBQUksQ0FBQyxJQUFJLENBQUNGLFFBQVEsRUFBRTtZQUNoQjtRQUNKO1FBQ0EsSUFBSSxDQUFDVixPQUFPLENBQUNzQyxJQUFJLENBQUMsSUFBSSxDQUFDNUIsUUFBUSxFQUFFLENBQUM7SUFDdEM7SUFDQXFCLGlCQUFpQjtRQUNiUSxhQUFhLElBQUksQ0FBQ2xDLFlBQVk7UUFDOUIsSUFBSSxDQUFDQSxZQUFZLEdBQUdDO0lBQ3hCO0lBQ0EwQixjQUFjLEVBQUVQLE1BQU0sRUFBRUcsUUFBUSxFQUFFLEVBQUU7UUFDaEMsSUFBSSxDQUFDbkIsUUFBUSxDQUFDK0IsTUFBTSxDQUFDLENBQUNDLElBQU1BLEVBQUVoQixNQUFNLEtBQUtBLFFBQVFpQixPQUFPLENBQUMsQ0FBQ0QsSUFBTUEsRUFBRWYsUUFBUSxDQUFDRTtJQUMvRTtJQUNBZCxhQUFhVyxNQUFNLEVBQUU7UUFDakIsT0FBTyxJQUFJLENBQUNqQixZQUFZLElBQUksSUFBSSxDQUFDQSxZQUFZLENBQUNpQixNQUFNLEtBQUtBO0lBQzdEO0FBQ0osRUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmNob3Itd29ya2Zsb3dzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21vZHVsZS9saWIvcHVzaC5qcz80NDhmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERFRkFVTFRfVElNRU9VVCB9IGZyb20gJy4uL2xpYi9jb25zdGFudHMnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHVzaCB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIFB1c2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBDaGFubmVsXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCwgZm9yIGV4YW1wbGUgYFwicGh4X2pvaW5cImBcbiAgICAgKiBAcGFyYW0gcGF5bG9hZCBUaGUgcGF5bG9hZCwgZm9yIGV4YW1wbGUgYHt1c2VyX2lkOiAxMjN9YFxuICAgICAqIEBwYXJhbSB0aW1lb3V0IFRoZSBwdXNoIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgZXZlbnQsIHBheWxvYWQgPSB7fSwgdGltZW91dCA9IERFRkFVTFRfVElNRU9VVCkge1xuICAgICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIHRoaXMuc2VudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRpbWVvdXRUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yZWYgPSAnJztcbiAgICAgICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsO1xuICAgICAgICB0aGlzLnJlY0hvb2tzID0gW107XG4gICAgICAgIHRoaXMucmVmRXZlbnQgPSBudWxsO1xuICAgIH1cbiAgICByZXNlbmQodGltZW91dCkge1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICB0aGlzLl9jYW5jZWxSZWZFdmVudCgpO1xuICAgICAgICB0aGlzLnJlZiA9ICcnO1xuICAgICAgICB0aGlzLnJlZkV2ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsO1xuICAgICAgICB0aGlzLnNlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZW5kKCk7XG4gICAgfVxuICAgIHNlbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNSZWNlaXZlZCgndGltZW91dCcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydFRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5zZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGFubmVsLnNvY2tldC5wdXNoKHtcbiAgICAgICAgICAgIHRvcGljOiB0aGlzLmNoYW5uZWwudG9waWMsXG4gICAgICAgICAgICBldmVudDogdGhpcy5ldmVudCxcbiAgICAgICAgICAgIHBheWxvYWQ6IHRoaXMucGF5bG9hZCxcbiAgICAgICAgICAgIHJlZjogdGhpcy5yZWYsXG4gICAgICAgICAgICBqb2luX3JlZjogdGhpcy5jaGFubmVsLl9qb2luUmVmKCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGVQYXlsb2FkKHBheWxvYWQpIHtcbiAgICAgICAgdGhpcy5wYXlsb2FkID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnBheWxvYWQpLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgcmVjZWl2ZShzdGF0dXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuX2hhc1JlY2VpdmVkKHN0YXR1cykpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKChfYSA9IHRoaXMucmVjZWl2ZWRSZXNwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVjSG9va3MucHVzaCh7IHN0YXR1cywgY2FsbGJhY2sgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdGFydFRpbWVvdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXRUaW1lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVmID0gdGhpcy5jaGFubmVsLnNvY2tldC5fbWFrZVJlZigpO1xuICAgICAgICB0aGlzLnJlZkV2ZW50ID0gdGhpcy5jaGFubmVsLl9yZXBseUV2ZW50TmFtZSh0aGlzLnJlZik7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbFJlZkV2ZW50KCk7XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxUaW1lb3V0KCk7XG4gICAgICAgICAgICB0aGlzLnJlY2VpdmVkUmVzcCA9IHBheWxvYWQ7XG4gICAgICAgICAgICB0aGlzLl9tYXRjaFJlY2VpdmUocGF5bG9hZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2hhbm5lbC5fb24odGhpcy5yZWZFdmVudCwge30sIGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy50aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcigndGltZW91dCcsIHt9KTtcbiAgICAgICAgfSwgdGhpcy50aW1lb3V0KTtcbiAgICB9XG4gICAgdHJpZ2dlcihzdGF0dXMsIHJlc3BvbnNlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZkV2ZW50KVxuICAgICAgICAgICAgdGhpcy5jaGFubmVsLl90cmlnZ2VyKHRoaXMucmVmRXZlbnQsIHsgc3RhdHVzLCByZXNwb25zZSB9KTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fY2FuY2VsUmVmRXZlbnQoKTtcbiAgICAgICAgdGhpcy5fY2FuY2VsVGltZW91dCgpO1xuICAgIH1cbiAgICBfY2FuY2VsUmVmRXZlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWZFdmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbm5lbC5fb2ZmKHRoaXMucmVmRXZlbnQsIHt9KTtcbiAgICB9XG4gICAgX2NhbmNlbFRpbWVvdXQoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRUaW1lcik7XG4gICAgICAgIHRoaXMudGltZW91dFRpbWVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBfbWF0Y2hSZWNlaXZlKHsgc3RhdHVzLCByZXNwb25zZSB9KSB7XG4gICAgICAgIHRoaXMucmVjSG9va3MuZmlsdGVyKChoKSA9PiBoLnN0YXR1cyA9PT0gc3RhdHVzKS5mb3JFYWNoKChoKSA9PiBoLmNhbGxiYWNrKHJlc3BvbnNlKSk7XG4gICAgfVxuICAgIF9oYXNSZWNlaXZlZChzdGF0dXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjZWl2ZWRSZXNwICYmIHRoaXMucmVjZWl2ZWRSZXNwLnN0YXR1cyA9PT0gc3RhdHVzO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1c2guanMubWFwIl0sIm5hbWVzIjpbIkRFRkFVTFRfVElNRU9VVCIsIlB1c2giLCJjb25zdHJ1Y3RvciIsImNoYW5uZWwiLCJldmVudCIsInBheWxvYWQiLCJ0aW1lb3V0Iiwic2VudCIsInRpbWVvdXRUaW1lciIsInVuZGVmaW5lZCIsInJlZiIsInJlY2VpdmVkUmVzcCIsInJlY0hvb2tzIiwicmVmRXZlbnQiLCJyZXNlbmQiLCJfY2FuY2VsUmVmRXZlbnQiLCJzZW5kIiwiX2hhc1JlY2VpdmVkIiwic3RhcnRUaW1lb3V0Iiwic29ja2V0IiwicHVzaCIsInRvcGljIiwiam9pbl9yZWYiLCJfam9pblJlZiIsInVwZGF0ZVBheWxvYWQiLCJPYmplY3QiLCJhc3NpZ24iLCJyZWNlaXZlIiwic3RhdHVzIiwiY2FsbGJhY2siLCJfYSIsInJlc3BvbnNlIiwiX21ha2VSZWYiLCJfcmVwbHlFdmVudE5hbWUiLCJfY2FuY2VsVGltZW91dCIsIl9tYXRjaFJlY2VpdmUiLCJfb24iLCJzZXRUaW1lb3V0IiwidHJpZ2dlciIsIl90cmlnZ2VyIiwiZGVzdHJveSIsIl9vZmYiLCJjbGVhclRpbWVvdXQiLCJmaWx0ZXIiLCJoIiwiZm9yRWFjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/push.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Serializer)\n/* harmony export */ });\nclass Serializer {\n    constructor(allowedMetadataKeys){\n        this.HEADER_LENGTH = 1;\n        this.USER_BROADCAST_PUSH_META_LENGTH = 6;\n        this.KINDS = {\n            userBroadcastPush: 3,\n            userBroadcast: 4\n        };\n        this.BINARY_ENCODING = 0;\n        this.JSON_ENCODING = 1;\n        this.BROADCAST_EVENT = \"broadcast\";\n        this.allowedMetadataKeys = [];\n        this.allowedMetadataKeys = allowedMetadataKeys !== null && allowedMetadataKeys !== void 0 ? allowedMetadataKeys : [];\n    }\n    encode(msg, callback) {\n        if (msg.event === this.BROADCAST_EVENT && !(msg.payload instanceof ArrayBuffer) && typeof msg.payload.event === \"string\") {\n            return callback(this._binaryEncodeUserBroadcastPush(msg));\n        }\n        let payload = [\n            msg.join_ref,\n            msg.ref,\n            msg.topic,\n            msg.event,\n            msg.payload\n        ];\n        return callback(JSON.stringify(payload));\n    }\n    _binaryEncodeUserBroadcastPush(message) {\n        var _a;\n        if (this._isArrayBuffer((_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload)) {\n            return this._encodeBinaryUserBroadcastPush(message);\n        } else {\n            return this._encodeJsonUserBroadcastPush(message);\n        }\n    }\n    _encodeBinaryUserBroadcastPush(message) {\n        var _a, _b;\n        const userPayload = (_b = (_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload) !== null && _b !== void 0 ? _b : new ArrayBuffer(0);\n        return this._encodeUserBroadcastPush(message, this.BINARY_ENCODING, userPayload);\n    }\n    _encodeJsonUserBroadcastPush(message) {\n        var _a, _b;\n        const userPayload = (_b = (_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload) !== null && _b !== void 0 ? _b : {};\n        const encoder = new TextEncoder();\n        const encodedUserPayload = encoder.encode(JSON.stringify(userPayload)).buffer;\n        return this._encodeUserBroadcastPush(message, this.JSON_ENCODING, encodedUserPayload);\n    }\n    _encodeUserBroadcastPush(message, encodingType, encodedPayload) {\n        var _a, _b;\n        const topic = message.topic;\n        const ref = (_a = message.ref) !== null && _a !== void 0 ? _a : \"\";\n        const joinRef = (_b = message.join_ref) !== null && _b !== void 0 ? _b : \"\";\n        const userEvent = message.payload.event;\n        // Filter metadata based on allowed keys\n        const rest = this.allowedMetadataKeys ? this._pick(message.payload, this.allowedMetadataKeys) : {};\n        const metadata = Object.keys(rest).length === 0 ? \"\" : JSON.stringify(rest);\n        // Validate lengths don't exceed uint8 max value (255)\n        if (joinRef.length > 255) {\n            throw new Error(`joinRef length ${joinRef.length} exceeds maximum of 255`);\n        }\n        if (ref.length > 255) {\n            throw new Error(`ref length ${ref.length} exceeds maximum of 255`);\n        }\n        if (topic.length > 255) {\n            throw new Error(`topic length ${topic.length} exceeds maximum of 255`);\n        }\n        if (userEvent.length > 255) {\n            throw new Error(`userEvent length ${userEvent.length} exceeds maximum of 255`);\n        }\n        if (metadata.length > 255) {\n            throw new Error(`metadata length ${metadata.length} exceeds maximum of 255`);\n        }\n        const metaLength = this.USER_BROADCAST_PUSH_META_LENGTH + joinRef.length + ref.length + topic.length + userEvent.length + metadata.length;\n        const header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);\n        let view = new DataView(header);\n        let offset = 0;\n        view.setUint8(offset++, this.KINDS.userBroadcastPush); // kind\n        view.setUint8(offset++, joinRef.length);\n        view.setUint8(offset++, ref.length);\n        view.setUint8(offset++, topic.length);\n        view.setUint8(offset++, userEvent.length);\n        view.setUint8(offset++, metadata.length);\n        view.setUint8(offset++, encodingType);\n        Array.from(joinRef, (char)=>view.setUint8(offset++, char.charCodeAt(0)));\n        Array.from(ref, (char)=>view.setUint8(offset++, char.charCodeAt(0)));\n        Array.from(topic, (char)=>view.setUint8(offset++, char.charCodeAt(0)));\n        Array.from(userEvent, (char)=>view.setUint8(offset++, char.charCodeAt(0)));\n        Array.from(metadata, (char)=>view.setUint8(offset++, char.charCodeAt(0)));\n        var combined = new Uint8Array(header.byteLength + encodedPayload.byteLength);\n        combined.set(new Uint8Array(header), 0);\n        combined.set(new Uint8Array(encodedPayload), header.byteLength);\n        return combined.buffer;\n    }\n    decode(rawPayload, callback) {\n        if (this._isArrayBuffer(rawPayload)) {\n            let result = this._binaryDecode(rawPayload);\n            return callback(result);\n        }\n        if (typeof rawPayload === \"string\") {\n            const jsonPayload = JSON.parse(rawPayload);\n            const [join_ref, ref, topic, event, payload] = jsonPayload;\n            return callback({\n                join_ref,\n                ref,\n                topic,\n                event,\n                payload\n            });\n        }\n        return callback({});\n    }\n    _binaryDecode(buffer) {\n        const view = new DataView(buffer);\n        const kind = view.getUint8(0);\n        const decoder = new TextDecoder();\n        switch(kind){\n            case this.KINDS.userBroadcast:\n                return this._decodeUserBroadcast(buffer, view, decoder);\n        }\n    }\n    _decodeUserBroadcast(buffer, view, decoder) {\n        const topicSize = view.getUint8(1);\n        const userEventSize = view.getUint8(2);\n        const metadataSize = view.getUint8(3);\n        const payloadEncoding = view.getUint8(4);\n        let offset = this.HEADER_LENGTH + 4;\n        const topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n        offset = offset + topicSize;\n        const userEvent = decoder.decode(buffer.slice(offset, offset + userEventSize));\n        offset = offset + userEventSize;\n        const metadata = decoder.decode(buffer.slice(offset, offset + metadataSize));\n        offset = offset + metadataSize;\n        const payload = buffer.slice(offset, buffer.byteLength);\n        const parsedPayload = payloadEncoding === this.JSON_ENCODING ? JSON.parse(decoder.decode(payload)) : payload;\n        const data = {\n            type: this.BROADCAST_EVENT,\n            event: userEvent,\n            payload: parsedPayload\n        };\n        // Metadata is optional and always JSON encoded\n        if (metadataSize > 0) {\n            data[\"meta\"] = JSON.parse(metadata);\n        }\n        return {\n            join_ref: null,\n            ref: null,\n            topic: topic,\n            event: this.BROADCAST_EVENT,\n            payload: data\n        };\n    }\n    _isArrayBuffer(buffer) {\n        var _a;\n        return buffer instanceof ArrayBuffer || ((_a = buffer === null || buffer === void 0 ? void 0 : buffer.constructor) === null || _a === void 0 ? void 0 : _a.name) === \"ArrayBuffer\";\n    }\n    _pick(obj, keys) {\n        if (!obj || typeof obj !== \"object\") {\n            return {};\n        }\n        return Object.fromEntries(Object.entries(obj).filter(([key])=>keys.includes(key)));\n    }\n} //# sourceMappingURL=serializer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi9zZXJpYWxpemVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZSxNQUFNQTtJQUNqQkMsWUFBWUMsbUJBQW1CLENBQUU7UUFDN0IsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDQywrQkFBK0IsR0FBRztRQUN2QyxJQUFJLENBQUNDLEtBQUssR0FBRztZQUFFQyxtQkFBbUI7WUFBR0MsZUFBZTtRQUFFO1FBQ3RELElBQUksQ0FBQ0MsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0MsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ1IsbUJBQW1CLEdBQUcsRUFBRTtRQUM3QixJQUFJLENBQUNBLG1CQUFtQixHQUFHQSx3QkFBd0IsUUFBUUEsd0JBQXdCLEtBQUssSUFBSUEsc0JBQXNCLEVBQUU7SUFDeEg7SUFDQVMsT0FBT0MsR0FBRyxFQUFFQyxRQUFRLEVBQUU7UUFDbEIsSUFBSUQsSUFBSUUsS0FBSyxLQUFLLElBQUksQ0FBQ0osZUFBZSxJQUNsQyxDQUFFRSxDQUFBQSxJQUFJRyxPQUFPLFlBQVlDLFdBQVUsS0FDbkMsT0FBT0osSUFBSUcsT0FBTyxDQUFDRCxLQUFLLEtBQUssVUFBVTtZQUN2QyxPQUFPRCxTQUFTLElBQUksQ0FBQ0ksOEJBQThCLENBQUNMO1FBQ3hEO1FBQ0EsSUFBSUcsVUFBVTtZQUFDSCxJQUFJTSxRQUFRO1lBQUVOLElBQUlPLEdBQUc7WUFBRVAsSUFBSVEsS0FBSztZQUFFUixJQUFJRSxLQUFLO1lBQUVGLElBQUlHLE9BQU87U0FBQztRQUN4RSxPQUFPRixTQUFTUSxLQUFLQyxTQUFTLENBQUNQO0lBQ25DO0lBQ0FFLCtCQUErQk0sT0FBTyxFQUFFO1FBQ3BDLElBQUlDO1FBQ0osSUFBSSxJQUFJLENBQUNDLGNBQWMsQ0FBQyxDQUFDRCxLQUFLRCxRQUFRUixPQUFPLE1B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QVcsTUFBTSxRQUFRdUIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHdUQsSUFBSSxNQUFNO0lBQ3pLO0lBQ0F2QyxNQUFNd0MsR0FBRyxFQUFFckMsSUFBSSxFQUFFO1FBQ2IsSUFBSSxDQUFDcUMsT0FBTyxPQUFPQSxRQUFRLFVBQVU7WUFDakMsT0FBTyxDQUFDO1FBQ1o7UUFDQSxPQUFPdEMsT0FBT3VDLFdBQVcsQ0FBQ3ZDLE9BQU93QyxPQUFPLENBQUNGLEtBQUtHLE1BQU0sQ0FBQyxDQUFDLENBQUNDLElBQUksR0FBS3pDLEtBQUswQyxRQUFRLENBQUNEO0lBQ2xGO0FBQ0osRUFDQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmNob3Itd29ya2Zsb3dzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21vZHVsZS9saWIvc2VyaWFsaXplci5qcz84MWRiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlcmlhbGl6ZXIge1xuICAgIGNvbnN0cnVjdG9yKGFsbG93ZWRNZXRhZGF0YUtleXMpIHtcbiAgICAgICAgdGhpcy5IRUFERVJfTEVOR1RIID0gMTtcbiAgICAgICAgdGhpcy5VU0VSX0JST0FEQ0FTVF9QVVNIX01FVEFfTEVOR1RIID0gNjtcbiAgICAgICAgdGhpcy5LSU5EUyA9IHsgdXNlckJyb2FkY2FzdFB1c2g6IDMsIHVzZXJCcm9hZGNhc3Q6IDQgfTtcbiAgICAgICAgdGhpcy5CSU5BUllfRU5DT0RJTkcgPSAwO1xuICAgICAgICB0aGlzLkpTT05fRU5DT0RJTkcgPSAxO1xuICAgICAgICB0aGlzLkJST0FEQ0FTVF9FVkVOVCA9ICdicm9hZGNhc3QnO1xuICAgICAgICB0aGlzLmFsbG93ZWRNZXRhZGF0YUtleXMgPSBbXTtcbiAgICAgICAgdGhpcy5hbGxvd2VkTWV0YWRhdGFLZXlzID0gYWxsb3dlZE1ldGFkYXRhS2V5cyAhPT0gbnVsbCAmJiBhbGxvd2VkTWV0YWRhdGFLZXlzICE9PSB2b2lkIDAgPyBhbGxvd2VkTWV0YWRhdGFLZXlzIDogW107XG4gICAgfVxuICAgIGVuY29kZShtc2csIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChtc2cuZXZlbnQgPT09IHRoaXMuQlJPQURDQVNUX0VWRU5UICYmXG4gICAgICAgICAgICAhKG1zZy5wYXlsb2FkIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpICYmXG4gICAgICAgICAgICB0eXBlb2YgbXNnLnBheWxvYWQuZXZlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fYmluYXJ5RW5jb2RlVXNlckJyb2FkY2FzdFB1c2gobXNnKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBheWxvYWQgPSBbbXNnLmpvaW5fcmVmLCBtc2cucmVmLCBtc2cudG9waWMsIG1zZy5ldmVudCwgbXNnLnBheWxvYWRdO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICAgIH1cbiAgICBfYmluYXJ5RW5jb2RlVXNlckJyb2FkY2FzdFB1c2gobWVzc2FnZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLl9pc0FycmF5QnVmZmVyKChfYSA9IG1lc3NhZ2UucGF5bG9hZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBheWxvYWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2RlQmluYXJ5VXNlckJyb2FkY2FzdFB1c2gobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2RlSnNvblVzZXJCcm9hZGNhc3RQdXNoKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9lbmNvZGVCaW5hcnlVc2VyQnJvYWRjYXN0UHVzaChtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHVzZXJQYXlsb2FkID0gKF9iID0gKF9hID0gbWVzc2FnZS5wYXlsb2FkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF5bG9hZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2RlVXNlckJyb2FkY2FzdFB1c2gobWVzc2FnZSwgdGhpcy5CSU5BUllfRU5DT0RJTkcsIHVzZXJQYXlsb2FkKTtcbiAgICB9XG4gICAgX2VuY29kZUpzb25Vc2VyQnJvYWRjYXN0UHVzaChtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHVzZXJQYXlsb2FkID0gKF9iID0gKF9hID0gbWVzc2FnZS5wYXlsb2FkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF5bG9hZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge307XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgICAgY29uc3QgZW5jb2RlZFVzZXJQYXlsb2FkID0gZW5jb2Rlci5lbmNvZGUoSlNPTi5zdHJpbmdpZnkodXNlclBheWxvYWQpKS5idWZmZXI7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGVVc2VyQnJvYWRjYXN0UHVzaChtZXNzYWdlLCB0aGlzLkpTT05fRU5DT0RJTkcsIGVuY29kZWRVc2VyUGF5bG9hZCk7XG4gICAgfVxuICAgIF9lbmNvZGVVc2VyQnJvYWRjYXN0UHVzaChtZXNzYWdlLCBlbmNvZGluZ1R5cGUsIGVuY29kZWRQYXlsb2FkKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHRvcGljID0gbWVzc2FnZS50b3BpYztcbiAgICAgICAgY29uc3QgcmVmID0gKF9hID0gbWVzc2FnZS5yZWYpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgICAgICBjb25zdCBqb2luUmVmID0gKF9iID0gbWVzc2FnZS5qb2luX3JlZikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJyc7XG4gICAgICAgIGNvbnN0IHVzZXJFdmVudCA9IG1lc3NhZ2UucGF5bG9hZC5ldmVudDtcbiAgICAgICAgLy8gRmlsdGVyIG1ldGFkYXRhIGJhc2VkIG9uIGFsbG93ZWQga2V5c1xuICAgICAgICBjb25zdCByZXN0ID0gdGhpcy5hbGxvd2VkTWV0YWRhdGFLZXlzXG4gICAgICAgICAgICA/IHRoaXMuX3BpY2sobWVzc2FnZS5wYXlsb2FkLCB0aGlzLmFsbG93ZWRNZXRhZGF0YUtleXMpXG4gICAgICAgICAgICA6IHt9O1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IE9iamVjdC5rZXlzKHJlc3QpLmxlbmd0aCA9PT0gMCA/ICcnIDogSlNPTi5zdHJpbmdpZnkocmVzdCk7XG4gICAgICAgIC8vIFZhbGlkYXRlIGxlbmd0aHMgZG9uJ3QgZXhjZWVkIHVpbnQ4IG1heCB2YWx1ZSAoMjU1KVxuICAgICAgICBpZiAoam9pblJlZi5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgam9pblJlZiBsZW5ndGggJHtqb2luUmVmLmxlbmd0aH0gZXhjZWVkcyBtYXhpbXVtIG9mIDI1NWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWYubGVuZ3RoID4gMjU1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHJlZiBsZW5ndGggJHtyZWYubGVuZ3RofSBleGNlZWRzIG1heGltdW0gb2YgMjU1YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvcGljLmxlbmd0aCA+IDI1NSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0b3BpYyBsZW5ndGggJHt0b3BpYy5sZW5ndGh9IGV4Y2VlZHMgbWF4aW11bSBvZiAyNTVgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlckV2ZW50Lmxlbmd0aCA+IDI1NSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1c2VyRXZlbnQgbGVuZ3RoICR7dXNlckV2ZW50Lmxlbmd0aH0gZXhjZWVkcyBtYXhpbXVtIG9mIDI1NWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhZGF0YS5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbWV0YWRhdGEgbGVuZ3RoICR7bWV0YWRhdGEubGVuZ3RofSBleGNlZWRzIG1heGltdW0gb2YgMjU1YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YUxlbmd0aCA9IHRoaXMuVVNFUl9CUk9BRENBU1RfUFVTSF9NRVRBX0xFTkdUSCArXG4gICAgICAgICAgICBqb2luUmVmLmxlbmd0aCArXG4gICAgICAgICAgICByZWYubGVuZ3RoICtcbiAgICAgICAgICAgIHRvcGljLmxlbmd0aCArXG4gICAgICAgICAgICB1c2VyRXZlbnQubGVuZ3RoICtcbiAgICAgICAgICAgIG1ldGFkYXRhLmxlbmd0aDtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuSEVBREVSX0xFTkdUSCArIG1ldGFMZW5ndGgpO1xuICAgICAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhoZWFkZXIpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgdGhpcy5LSU5EUy51c2VyQnJvYWRjYXN0UHVzaCk7IC8vIGtpbmRcbiAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgam9pblJlZi5sZW5ndGgpO1xuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCByZWYubGVuZ3RoKTtcbiAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgdG9waWMubGVuZ3RoKTtcbiAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgdXNlckV2ZW50Lmxlbmd0aCk7XG4gICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIG1ldGFkYXRhLmxlbmd0aCk7XG4gICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGVuY29kaW5nVHlwZSk7XG4gICAgICAgIEFycmF5LmZyb20oam9pblJlZiwgKGNoYXIpID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpO1xuICAgICAgICBBcnJheS5mcm9tKHJlZiwgKGNoYXIpID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpO1xuICAgICAgICBBcnJheS5mcm9tKHRvcGljLCAoY2hhcikgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgIEFycmF5LmZyb20odXNlckV2ZW50LCAoY2hhcikgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgIEFycmF5LmZyb20obWV0YWRhdGEsIChjaGFyKSA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgICAgdmFyIGNvbWJpbmVkID0gbmV3IFVpbnQ4QXJyYXkoaGVhZGVyLmJ5dGVMZW5ndGggKyBlbmNvZGVkUGF5bG9hZC5ieXRlTGVuZ3RoKTtcbiAgICAgICAgY29tYmluZWQuc2V0KG5ldyBVaW50OEFycmF5KGhlYWRlciksIDApO1xuICAgICAgICBjb21iaW5lZC5zZXQobmV3IFVpbnQ4QXJyYXkoZW5jb2RlZFBheWxvYWQpLCBoZWFkZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiBjb21iaW5lZC5idWZmZXI7XG4gICAgfVxuICAgIGRlY29kZShyYXdQYXlsb2FkLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5faXNBcnJheUJ1ZmZlcihyYXdQYXlsb2FkKSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuX2JpbmFyeURlY29kZShyYXdQYXlsb2FkKTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmF3UGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IGpzb25QYXlsb2FkID0gSlNPTi5wYXJzZShyYXdQYXlsb2FkKTtcbiAgICAgICAgICAgIGNvbnN0IFtqb2luX3JlZiwgcmVmLCB0b3BpYywgZXZlbnQsIHBheWxvYWRdID0ganNvblBheWxvYWQ7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soeyBqb2luX3JlZiwgcmVmLCB0b3BpYywgZXZlbnQsIHBheWxvYWQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHt9KTtcbiAgICB9XG4gICAgX2JpbmFyeURlY29kZShidWZmZXIpIHtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgICAgICBjb25zdCBraW5kID0gdmlldy5nZXRVaW50OCgwKTtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgdGhpcy5LSU5EUy51c2VyQnJvYWRjYXN0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVVc2VyQnJvYWRjYXN0KGJ1ZmZlciwgdmlldywgZGVjb2Rlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2RlY29kZVVzZXJCcm9hZGNhc3QoYnVmZmVyLCB2aWV3LCBkZWNvZGVyKSB7XG4gICAgICAgIGNvbnN0IHRvcGljU2l6ZSA9IHZpZXcuZ2V0VWludDgoMSk7XG4gICAgICAgIGNvbnN0IHVzZXJFdmVudFNpemUgPSB2aWV3LmdldFVpbnQ4KDIpO1xuICAgICAgICBjb25zdCBtZXRhZGF0YVNpemUgPSB2aWV3LmdldFVpbnQ4KDMpO1xuICAgICAgICBjb25zdCBwYXlsb2FkRW5jb2RpbmcgPSB2aWV3LmdldFVpbnQ4KDQpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgNDtcbiAgICAgICAgY29uc3QgdG9waWMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0b3BpY1NpemUpKTtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplO1xuICAgICAgICBjb25zdCB1c2VyRXZlbnQgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB1c2VyRXZlbnRTaXplKSk7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldCArIHVzZXJFdmVudFNpemU7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbWV0YWRhdGFTaXplKSk7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldCArIG1ldGFkYXRhU2l6ZTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgcGFyc2VkUGF5bG9hZCA9IHBheWxvYWRFbmNvZGluZyA9PT0gdGhpcy5KU09OX0VOQ09ESU5HID8gSlNPTi5wYXJzZShkZWNvZGVyLmRlY29kZShwYXlsb2FkKSkgOiBwYXlsb2FkO1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgdHlwZTogdGhpcy5CUk9BRENBU1RfRVZFTlQsXG4gICAgICAgICAgICBldmVudDogdXNlckV2ZW50LFxuICAgICAgICAgICAgcGF5bG9hZDogcGFyc2VkUGF5bG9hZCxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTWV0YWRhdGEgaXMgb3B0aW9uYWwgYW5kIGFsd2F5cyBKU09OIGVuY29kZWRcbiAgICAgICAgaWYgKG1ldGFkYXRhU2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGRhdGFbJ21ldGEnXSA9IEpTT04ucGFyc2UobWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGpvaW5fcmVmOiBudWxsLCByZWY6IG51bGwsIHRvcGljOiB0b3BpYywgZXZlbnQ6IHRoaXMuQlJPQURDQVNUX0VWRU5ULCBwYXlsb2FkOiBkYXRhIH07XG4gICAgfVxuICAgIF9pc0FycmF5QnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBidWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCAoKF9hID0gYnVmZmVyID09PSBudWxsIHx8IGJ1ZmZlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnVmZmVyLmNvbnN0cnVjdG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgPT09ICdBcnJheUJ1ZmZlcic7XG4gICAgfVxuICAgIF9waWNrKG9iaiwga2V5cykge1xuICAgICAgICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMob2JqKS5maWx0ZXIoKFtrZXldKSA9PiBrZXlzLmluY2x1ZGVzKGtleSkpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJpYWxpemVyLmpzLm1hcCJdLCJuYW1lcyI6WyJTZXJpYWxpemVyIiwiY29uc3RydWN0b3IiLCJhbGxvd2VkTWV0YWRhdGFLZXlzIiwiSEVBREVSX0xFTkdUSCIsIlVTRVJfQlJPQURDQVNUX1BVU0hfTUVUQV9MRU5HVEgiLCJLSU5EUyIsInVzZXJCcm9hZGNhc3RQdXNoIiwidXNlckJyb2FkY2FzdCIsIkJJTkFSWV9FTkNPRElORyIsIkpTT05fRU5DT0RJTkciLCJCUk9BRENBU1RfRVZFTlQiLCJlbmNvZGUiLCJtc2ciLCJjYWxsYmFjayIsImV2ZW50IiwicGF5bG9hZCIsIkFycmF5QnVmZmVyIiwiX2JpbmFyeUVuY29kZVVzZXJCcm9hZGNhc3RQdXNoIiwiam9pbl9yZWYiLCJyZWYiLCJ0b3BpYyIsIkpTT04iLCJzdHJpbmdpZnkiLCJtZXNzYWdlIiwiX2EiLCJfaXNBcnJheUJ1ZmZlciIsIl9lbmNvZGVCaW5hcnlVc2VyQnJvYWRjYXN0UHVzaCIsIl9lbmNvZGVKc29uVXNlckJyb2FkY2FzdFB1c2giLCJfYiIsInVzZXJQYXlsb2FkIiwiX2VuY29kZVVzZXJCcm9hZGNhc3RQdXNoIiwiZW5jb2RlciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlZFVzZXJQYXlsb2FkIiwiYnVmZmVyIiwiZW5jb2RpbmdUeXBlIiwiZW5jb2RlZFBheWxvYWQiLCJqb2luUmVmIiwidXNlckV2ZW50IiwicmVzdCIsIl9waWNrIiwibWV0YWRhdGEiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwiRXJyb3IiLCJtZXRhTGVuZ3RoIiwiaGVhZGVyIiwidmlldyIsIkRhdGFWaWV3Iiwib2Zmc2V0Iiwic2V0VWludDgiLCJBcnJheSIsImZyb20iLCJjaGFyIiwiY2hhckNvZGVBdCIsImNvbWJpbmVkIiwiVWludDhBcnJheSIsImJ5dGVMZW5ndGgiLCJzZXQiLCJkZWNvZGUiLCJyYXdQYXlsb2FkIiwicmVzdWx0IiwiX2JpbmFyeURlY29kZSIsImpzb25QYXlsb2FkIiwicGFyc2UiLCJraW5kIiwiZ2V0VWludDgiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJfZGVjb2RlVXNlckJyb2FkY2FzdCIsInRvcGljU2l6ZSIsInVzZXJFdmVudFNpemUiLCJtZXRhZGF0YVNpemUiLCJwYXlsb2FkRW5jb2RpbmciLCJzbGljZSIsInBhcnNlZFBheWxvYWQiLCJkYXRhIiwidHlwZSIsIm5hbWUiLCJvYmoiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJmaWx0ZXIiLCJrZXkiLCJpbmNsdWRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/timer.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Timer)\n/* harmony export */ });\n/**\n * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.\n *\n * @example\n *    let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *      return [1000, 5000, 10000][tries - 1] || 10000\n *    })\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n *    reconnectTimer.scheduleTimeout() // fires after 5000\n *    reconnectTimer.reset()\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n */ class Timer {\n    constructor(callback, timerCalc){\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n        this.timer = undefined;\n        this.tries = 0;\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n    }\n    reset() {\n        this.tries = 0;\n        clearTimeout(this.timer);\n        this.timer = undefined;\n    }\n    // Cancels any previous scheduleTimeout and schedules callback\n    scheduleTimeout() {\n        clearTimeout(this.timer);\n        this.timer = setTimeout(()=>{\n            this.tries = this.tries + 1;\n            this.callback();\n        }, this.timerCalc(this.tries + 1));\n    }\n} //# sourceMappingURL=timer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi90aW1lci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Ozs7Ozs7O0NBV0MsR0FDYyxNQUFNQTtJQUNqQkMsWUFBWUMsUUFBUSxFQUFFQyxTQUFTLENBQUU7UUFDN0IsSUFBSSxDQUFDRCxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0MsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNDLEtBQUssR0FBR0M7UUFDYixJQUFJLENBQUNDLEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ0osUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLFNBQVMsR0FBR0E7SUFDckI7SUFDQUksUUFBUTtRQUNKLElBQUksQ0FBQ0QsS0FBSyxHQUFHO1FBQ2JFLGFBQWEsSUFBSSxDQUFDSixLQUFLO1FBQ3ZCLElBQUksQ0FBQ0EsS0FBSyxHQUFHQztJQUNqQjtJQUNBLDhEQUE4RDtJQUM5REksa0JBQWtCO1FBQ2RELGFBQWEsSUFBSSxDQUFDSixLQUFLO1FBQ3ZCLElBQUksQ0FBQ0EsS0FBSyxHQUFHTSxXQUFXO1lBQ3BCLElBQUksQ0FBQ0osS0FBSyxHQUFHLElBQUksQ0FBQ0EsS0FBSyxHQUFHO1lBQzFCLElBQUksQ0FBQ0osUUFBUTtRQUNqQixHQUFHLElBQUksQ0FBQ0MsU0FBUyxDQUFDLElBQUksQ0FBQ0csS0FBSyxHQUFHO0lBQ25DO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmNob3Itd29ya2Zsb3dzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21vZHVsZS9saWIvdGltZXIuanM/MTE1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENyZWF0ZXMgYSB0aW1lciB0aGF0IGFjY2VwdHMgYSBgdGltZXJDYWxjYCBmdW5jdGlvbiB0byBwZXJmb3JtIGNhbGN1bGF0ZWQgdGltZW91dCByZXRyaWVzLCBzdWNoIGFzIGV4cG9uZW50aWFsIGJhY2tvZmYuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgIGxldCByZWNvbm5lY3RUaW1lciA9IG5ldyBUaW1lcigoKSA9PiB0aGlzLmNvbm5lY3QoKSwgZnVuY3Rpb24odHJpZXMpe1xuICogICAgICByZXR1cm4gWzEwMDAsIDUwMDAsIDEwMDAwXVt0cmllcyAtIDFdIHx8IDEwMDAwXG4gKiAgICB9KVxuICogICAgcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgMTAwMFxuICogICAgcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgNTAwMFxuICogICAgcmVjb25uZWN0VGltZXIucmVzZXQoKVxuICogICAgcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgMTAwMFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lciB7XG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2ssIHRpbWVyQ2FsYykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMudGltZXJDYWxjID0gdGltZXJDYWxjO1xuICAgICAgICB0aGlzLnRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnRyaWVzID0gMDtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLnRpbWVyQ2FsYyA9IHRpbWVyQ2FsYztcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMudHJpZXMgPSAwO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgIHRoaXMudGltZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIENhbmNlbHMgYW55IHByZXZpb3VzIHNjaGVkdWxlVGltZW91dCBhbmQgc2NoZWR1bGVzIGNhbGxiYWNrXG4gICAgc2NoZWR1bGVUaW1lb3V0KCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJpZXMgPSB0aGlzLnRyaWVzICsgMTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2soKTtcbiAgICAgICAgfSwgdGhpcy50aW1lckNhbGModGhpcy50cmllcyArIDEpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lci5qcy5tYXAiXSwibmFtZXMiOlsiVGltZXIiLCJjb25zdHJ1Y3RvciIsImNhbGxiYWNrIiwidGltZXJDYWxjIiwidGltZXIiLCJ1bmRlZmluZWQiLCJ0cmllcyIsInJlc2V0IiwiY2xlYXJUaW1lb3V0Iiwic2NoZWR1bGVUaW1lb3V0Iiwic2V0VGltZW91dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PostgresTypes: () => (/* binding */ PostgresTypes),\n/* harmony export */   convertCell: () => (/* binding */ convertCell),\n/* harmony export */   convertChangeData: () => (/* binding */ convertChangeData),\n/* harmony export */   convertColumn: () => (/* binding */ convertColumn),\n/* harmony export */   httpEndpointURL: () => (/* binding */ httpEndpointURL),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   toBoolean: () => (/* binding */ toBoolean),\n/* harmony export */   toJson: () => (/* binding */ toJson),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toTimestampString: () => (/* binding */ toTimestampString)\n/* harmony export */ });\n/**\n * Helpers to convert the change Payload into native JS types.\n */ // Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\nvar PostgresTypes;\n(function(PostgresTypes) {\n    PostgresTypes[\"abstime\"] = \"abstime\";\n    PostgresTypes[\"bool\"] = \"bool\";\n    PostgresTypes[\"date\"] = \"date\";\n    PostgresTypes[\"daterange\"] = \"daterange\";\n    PostgresTypes[\"float4\"] = \"float4\";\n    PostgresTypes[\"float8\"] = \"float8\";\n    PostgresTypes[\"int2\"] = \"int2\";\n    PostgresTypes[\"int4\"] = \"int4\";\n    PostgresTypes[\"int4range\"] = \"int4range\";\n    PostgresTypes[\"int8\"] = \"int8\";\n    PostgresTypes[\"int8range\"] = \"int8range\";\n    PostgresTypes[\"json\"] = \"json\";\n    PostgresTypes[\"jsonb\"] = \"jsonb\";\n    PostgresTypes[\"money\"] = \"money\";\n    PostgresTypes[\"numeric\"] = \"numeric\";\n    PostgresTypes[\"oid\"] = \"oid\";\n    PostgresTypes[\"reltime\"] = \"reltime\";\n    PostgresTypes[\"text\"] = \"text\";\n    PostgresTypes[\"time\"] = \"time\";\n    PostgresTypes[\"timestamp\"] = \"timestamp\";\n    PostgresTypes[\"timestamptz\"] = \"timestamptz\";\n    PostgresTypes[\"timetz\"] = \"timetz\";\n    PostgresTypes[\"tsrange\"] = \"tsrange\";\n    PostgresTypes[\"tstzrange\"] = \"tstzrange\";\n})(PostgresTypes || (PostgresTypes = {}));\n/**\n * Takes an array of columns and an object of string values then converts each string value\n * to its mapped type.\n *\n * @param {{name: String, type: String}[]} columns\n * @param {Object} record\n * @param {Object} options The map of various options that can be applied to the mapper\n * @param {Array} options.skipTypes The array of types that should not be converted\n *\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\n * //=>{ first_name: 'Paul', age: 33 }\n */ const convertChangeData = (columns, record, options = {})=>{\n    var _a;\n    const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];\n    if (!record) {\n        return {};\n    }\n    return Object.keys(record).reduce((acc, rec_key)=>{\n        acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);\n        return acc;\n    }, {});\n};\n/**\n * Converts the value of an individual column.\n *\n * @param {String} columnName The column that you want to convert\n * @param {{name: String, type: String}[]} columns All of the columns\n * @param {Object} record The map of string values\n * @param {Array} skipTypes An array of types that should not be converted\n * @return {object} Useless information\n *\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\n * //=> 33\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\n * //=> \"33\"\n */ const convertColumn = (columnName, columns, record, skipTypes)=>{\n    const column = columns.find((x)=>x.name === columnName);\n    const colType = column === null || column === void 0 ? void 0 : column.type;\n    const value = record[columnName];\n    if (colType && !skipTypes.includes(colType)) {\n        return convertCell(colType, value);\n    }\n    return noop(value);\n};\n/**\n * If the value of the cell is `null`, returns null.\n * Otherwise converts the string value to the correct type.\n * @param {String} type A postgres column type\n * @param {String} value The cell value\n *\n * @example convertCell('bool', 't')\n * //=> true\n * @example convertCell('int8', '10')\n * //=> 10\n * @example convertCell('_int4', '{1,2,3,4}')\n * //=> [1,2,3,4]\n */ const convertCell = (type, value)=>{\n    // if data type is an array\n    if (type.charAt(0) === \"_\") {\n        const dataType = type.slice(1, type.length);\n        return toArray(value, dataType);\n    }\n    // If not null, convert to correct type.\n    switch(type){\n        case PostgresTypes.bool:\n            return toBoolean(value);\n        case PostgresTypes.float4:\n        case PostgresTypes.float8:\n        case PostgresTypes.int2:\n        case PostgresTypes.int4:\n        case PostgresTypes.int8:\n        case PostgresTypes.numeric:\n        case PostgresTypes.oid:\n            return toNumber(value);\n        case PostgresTypes.json:\n        case PostgresTypes.jsonb:\n            return toJson(value);\n        case PostgresTypes.timestamp:\n            return toTimestampString(value); // Format to be consistent with PostgREST\n        case PostgresTypes.abstime:\n        case PostgresTypes.date:\n        case PostgresTypes.daterange:\n        case PostgresTypes.int4range:\n        case PostgresTypes.int8range:\n        case PostgresTypes.money:\n        case PostgresTypes.reltime:\n        case PostgresTypes.text:\n        case PostgresTypes.time:\n        case PostgresTypes.timestamptz:\n        case PostgresTypes.timetz:\n        case PostgresTypes.tsrange:\n        case PostgresTypes.tstzrange:\n            return noop(value);\n        default:\n            // Return the value for remaining types\n            return noop(value);\n    }\n};\nconst noop = (value)=>{\n    return value;\n};\nconst toBoolean = (value)=>{\n    switch(value){\n        case \"t\":\n            return true;\n        case \"f\":\n            return false;\n        default:\n            return value;\n    }\n};\nconst toNumber = (value)=>{\n    if (typeof value === \"string\") {\n        const parsedValue = parseFloat(value);\n        if (!Number.isNaN(parsedValue)) {\n            return parsedValue;\n        }\n    }\n    return value;\n};\nconst toJson = (value)=>{\n    if (typeof value === \"string\") {\n        try {\n            return JSON.parse(value);\n        } catch (_a) {\n            return value;\n        }\n    }\n    return value;\n};\n/**\n * Converts a Postgres Array into a native JS array\n *\n * @example toArray('{}', 'int4')\n * //=> []\n * @example toArray('{\"[2021-01-01,2021-12-31)\",\"(2021-01-01,2021-12-32]\"}', 'daterange')\n * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']\n * @example toArray([1,2,3,4], 'int4')\n * //=> [1,2,3,4]\n */ const toArray = (value, type)=>{\n    if (typeof value !== \"string\") {\n        return value;\n    }\n    const lastIdx = value.length - 1;\n    const closeBrace = value[lastIdx];\n    const openBrace = value[0];\n    // Confirm value is a Postgres array by checking curly brackets\n    if (openBrace === \"{\" && closeBrace === \"}\") {\n        let arr;\n        const valTrim = value.slice(1, lastIdx);\n        // TODO: find a better solution to separate Postgres array data\n        try {\n            arr = JSON.parse(\"[\" + valTrim + \"]\");\n        } catch (_) {\n            // WARNING: splitting on comma does not cover all edge cases\n            arr = valTrim ? valTrim.split(\",\") : [];\n        }\n        return arr.map((val)=>convertCell(type, val));\n    }\n    return value;\n};\n/**\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\n * See https://github.com/supabase/supabase/issues/18\n *\n * @example toTimestampString('2019-09-10 00:00:00')\n * //=> '2019-09-10T00:00:00'\n */ const toTimestampString = (value)=>{\n    if (typeof value === \"string\") {\n        return value.replace(\" \", \"T\");\n    }\n    return value;\n};\nconst httpEndpointURL = (socketUrl)=>{\n    const wsUrl = new URL(socketUrl);\n    wsUrl.protocol = wsUrl.protocol.replace(/^ws/i, \"http\");\n    wsUrl.pathname = wsUrl.pathname.replace(/\\/+$/, \"\") // remove all trailing slashes\n    .replace(/\\/socket\\/websocket$/i, \"\") // remove the socket/websocket path\n    .replace(/\\/socket$/i, \"\") // remove the socket path\n    .replace(/\\/websocket$/i, \"\"); // remove the websocket path\n    if (wsUrl.pathname === \"\" || wsUrl.pathname === \"/\") {\n        wsUrl.pathname = \"/api/broadcast\";\n    } else {\n        wsUrl.pathname = wsUrl.pathname + \"/api/broadcast\";\n    }\n    return wsUrl.href;\n}; //# sourceMappingURL=transformers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi90cmFuc2Zvcm1lcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBOztDQUVDLEdBQ0QsMEVBQTBFO0FBQzFFLHlGQUF5RjtBQUNsRixJQUFJQSxjQUFjO0FBQ3hCLFVBQVVBLGFBQWE7SUFDcEJBLGFBQWEsQ0FBQyxVQUFVLEdBQUc7SUFDM0JBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxZQUFZLEdBQUc7SUFDN0JBLGFBQWEsQ0FBQyxTQUFTLEdBQUc7SUFDMUJBLGFBQWEsQ0FBQyxTQUFTLEdBQUc7SUFDMUJBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxZQUFZLEdBQUc7SUFDN0JBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxZQUFZLEdBQUc7SUFDN0JBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxRQUFRLEdBQUc7SUFDekJBLGFBQWEsQ0FBQyxRQUFRLEdBQUc7SUFDekJBLGFBQWEsQ0FBQyxVQUFVLEdBQUc7SUFDM0JBLGFBQWEsQ0FBQyxNQUFNLEdBQUc7SUFDdkJBLGFBQWEsQ0FBQyxVQUFVLEdBQUc7SUFDM0JBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxZQUFZLEdBQUc7SUFDN0JBLGFBQWEsQ0FBQyxjQUFjLEdBQUc7SUFDL0JBLGFBQWEsQ0FBQyxTQUFTLEdBQUc7SUFDMUJBLGFBQWEsQ0FBQyxVQUFVLEdBQUc7SUFDM0JBLGFBQWEsQ0FBQyxZQUFZLEdBQUc7QUFDakMsR0FBR0EsaUJBQWtCQSxDQUFBQSxnQkFBZ0IsQ0FBQztBQUN0Qzs7Ozs7Ozs7Ozs7Q0FXQyxH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QUMsS0FBSztJQUM5QjtJQUNBLE9BQU9wRDtBQUNYLEVBQUU7QUFDSyxNQUFNcUQsa0JBQWtCLENBQUNDO0lBQzVCLE1BQU1DLFFBQVEsSUFBSUMsSUFBSUY7SUFDdEJDLE1BQU1FLFFBQVEsR0FBR0YsTUFBTUUsUUFBUSxDQUFDTCxPQUFPLENBQUMsUUFBUTtJQUNoREcsTUFBTUcsUUFBUSxHQUFHSCxNQUFNRyxRQUFRLENBQzFCTixPQUFPLENBQUMsUUFBUSxJQUFJLDhCQUE4QjtLQUNsREEsT0FBTyxDQUFDLHlCQUF5QixJQUFJLG1DQUFtQztLQUN4RUEsT0FBTyxDQUFDLGNBQWMsSUFBSSx5QkFBeUI7S0FDbkRBLE9BQU8sQ0FBQyxpQkFBaUIsS0FBSyw0QkFBNEI7SUFDL0QsSUFBSUcsTUFBTUcsUUFBUSxLQUFLLE1BQU1ILE1BQU1HLFFBQVEsS0FBSyxLQUFLO1FBQ2pESCxNQUFNRyxRQUFRLEdBQUc7SUFDckIsT0FDSztRQUNESCxNQUFNRyxRQUFRLEdBQUdILE1BQU1HLFFBQVEsR0FBRztJQUN0QztJQUNBLE9BQU9ILE1BQU1JLElBQUk7QUFDckIsRUFBRSxDQUNGLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2FuY2hvci13b3JrZmxvd3MvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi90cmFuc2Zvcm1lcnMuanM/M2ZjMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhlbHBlcnMgdG8gY29udmVydCB0aGUgY2hhbmdlIFBheWxvYWQgaW50byBuYXRpdmUgSlMgdHlwZXMuXG4gKi9cbi8vIEFkYXB0ZWQgZnJvbSBlcGdzcWwgKHNyYy9lcGdzcWxfYmluYXJ5LmVybCksIHRoaXMgbW9kdWxlIGxpY2Vuc2VkIHVuZGVyXG4vLyAzLWNsYXVzZSBCU0QgZm91bmQgaGVyZTogaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2VwZ3NxbC9lcGdzcWwvZGV2ZWwvTElDRU5TRVxuZXhwb3J0IHZhciBQb3N0Z3Jlc1R5cGVzO1xuKGZ1bmN0aW9uIChQb3N0Z3Jlc1R5cGVzKSB7XG4gICAgUG9zdGdyZXNUeXBlc1tcImFic3RpbWVcIl0gPSBcImFic3RpbWVcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiYm9vbFwiXSA9IFwiYm9vbFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJkYXRlXCJdID0gXCJkYXRlXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImRhdGVyYW5nZVwiXSA9IFwiZGF0ZXJhbmdlXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImZsb2F0NFwiXSA9IFwiZmxvYXQ0XCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImZsb2F0OFwiXSA9IFwiZmxvYXQ4XCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImludDJcIl0gPSBcImludDJcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiaW50NFwiXSA9IFwiaW50NFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJpbnQ0cmFuZ2VcIl0gPSBcImludDRyYW5nZVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJpbnQ4XCJdID0gXCJpbnQ4XCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImludDhyYW5nZVwiXSA9IFwiaW50OHJhbmdlXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImpzb25cIl0gPSBcImpzb25cIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wianNvbmJcIl0gPSBcImpzb25iXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcIm1vbmV5XCJdID0gXCJtb25leVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJudW1lcmljXCJdID0gXCJudW1lcmljXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcIm9pZFwiXSA9IFwib2lkXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcInJlbHRpbWVcIl0gPSBcInJlbHRpbWVcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1widGV4dFwiXSA9IFwidGV4dFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJ0aW1lXCJdID0gXCJ0aW1lXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcInRpbWVzdGFtcFwiXSA9IFwidGltZXN0YW1wXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcInRpbWVzdGFtcHR6XCJdID0gXCJ0aW1lc3RhbXB0elwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJ0aW1ldHpcIl0gPSBcInRpbWV0elwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJ0c3JhbmdlXCJdID0gXCJ0c3JhbmdlXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcInRzdHpyYW5nZVwiXSA9IFwidHN0enJhbmdlXCI7XG59KShQb3N0Z3Jlc1R5cGVzIHx8IChQb3N0Z3Jlc1R5cGVzID0ge30pKTtcbi8qKlxuICogVGFrZXMgYW4gYXJyYXkgb2YgY29sdW1ucyBhbmQgYW4gb2JqZWN0IG9mIHN0cmluZyB2YWx1ZXMgdGhlbiBjb252ZXJ0cyBlYWNoIHN0cmluZyB2YWx1ZVxuICogdG8gaXRzIG1hcHBlZCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7e25hbWU6IFN0cmluZywgdHlwZTogU3RyaW5nfVtdfSBjb2x1bW5zXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgbWFwIG9mIHZhcmlvdXMgb3B0aW9ucyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIHRoZSBtYXBwZXJcbiAqIEBwYXJhbSB7QXJyYXl9IG9wdGlvbnMuc2tpcFR5cGVzIFRoZSBhcnJheSBvZiB0eXBlcyB0aGF0IHNob3VsZCBub3QgYmUgY29udmVydGVkXG4gKlxuICogQGV4YW1wbGUgY29udmVydENoYW5nZURhdGEoW3tuYW1lOiAnZmlyc3RfbmFtZScsIHR5cGU6ICd0ZXh0J30sIHtuYW1lOiAnYWdlJywgdHlwZTogJ2ludDQnfV0sIHtmaXJzdF9uYW1lOiAnUGF1bCcsIGFnZTonMzMnfSwge30pXG4gKiAvLz0+eyBmaXJzdF9uYW1lOiAnUGF1bCcsIGFnZTogMzMgfVxuICovXG5leHBvcnQgY29uc3QgY29udmVydENoYW5nZURhdGEgPSAoY29sdW1ucywgcmVjb3JkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgc2tpcFR5cGVzID0gKF9hID0gb3B0aW9ucy5za2lwVHlwZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgIGlmICghcmVjb3JkKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHJlY29yZCkucmVkdWNlKChhY2MsIHJlY19rZXkpID0+IHtcbiAgICAgICAgYWNjW3JlY19rZXldID0gY29udmVydENvbHVtbihyZWNfa2V5LCBjb2x1bW5zLCByZWNvcmQsIHNraXBUeXBlcyk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xufTtcbi8qKlxuICogQ29udmVydHMgdGhlIHZhbHVlIG9mIGFuIGluZGl2aWR1YWwgY29sdW1uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2x1bW5OYW1lIFRoZSBjb2x1bW4gdGhhdCB5b3Ugd2FudCB0byBjb252ZXJ0XG4gKiBAcGFyYW0ge3tuYW1lOiBTdHJpbmcsIHR5cGU6IFN0cmluZ31bXX0gY29sdW1ucyBBbGwgb2YgdGhlIGNvbHVtbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmQgVGhlIG1hcCBvZiBzdHJpbmcgdmFsdWVzXG4gKiBAcGFyYW0ge0FycmF5fSBza2lwVHlwZXMgQW4gYXJyYXkgb2YgdHlwZXMgdGhhdCBzaG91bGQgbm90IGJlIGNvbnZlcnRlZFxuICogQHJldHVybiB7b2JqZWN0fSBVc2VsZXNzIGluZm9ybWF0aW9uXG4gKlxuICogQGV4YW1wbGUgY29udmVydENvbHVtbignYWdlJywgW3tuYW1lOiAnZmlyc3RfbmFtZScsIHR5cGU6ICd0ZXh0J30sIHtuYW1lOiAnYWdlJywgdHlwZTogJ2ludDQnfV0sIHtmaXJzdF9uYW1lOiAnUGF1bCcsIGFnZTogJzMzJ30sIFtdKVxuICogLy89PiAzM1xuICogQGV4YW1wbGUgY29udmVydENvbHVtbignYWdlJywgW3tuYW1lOiAnZmlyc3RfbmFtZScsIHR5cGU6ICd0ZXh0J30sIHtuYW1lOiAnYWdlJywgdHlwZTogJ2ludDQnfV0sIHtmaXJzdF9uYW1lOiAnUGF1bCcsIGFnZTogJzMzJ30sIFsnaW50NCddKVxuICogLy89PiBcIjMzXCJcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnZlcnRDb2x1bW4gPSAoY29sdW1uTmFtZSwgY29sdW1ucywgcmVjb3JkLCBza2lwVHlwZXMpID0+IHtcbiAgICBjb25zdCBjb2x1bW4gPSBjb2x1bW5zLmZpbmQoKHgpID0+IHgubmFtZSA9PT0gY29sdW1uTmFtZSk7XG4gICAgY29uc3QgY29sVHlwZSA9IGNvbHVtbiA9PT0gbnVsbCB8fCBjb2x1bW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbHVtbi50eXBlO1xuICAgIGNvbnN0IHZhbHVlID0gcmVjb3JkW2NvbHVtbk5hbWVdO1xuICAgIGlmIChjb2xUeXBlICYmICFza2lwVHlwZXMuaW5jbHVkZXMoY29sVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRDZWxsKGNvbFR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vb3AodmFsdWUpO1xufTtcbi8qKlxuICogSWYgdGhlIHZhbHVlIG9mIHRoZSBjZWxsIGlzIGBudWxsYCwgcmV0dXJucyBudWxsLlxuICogT3RoZXJ3aXNlIGNvbnZlcnRzIHRoZSBzdHJpbmcgdmFsdWUgdG8gdGhlIGNvcnJlY3QgdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgcG9zdGdyZXMgY29sdW1uIHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgY2VsbCB2YWx1ZVxuICpcbiAqIEBleGFtcGxlIGNvbnZlcnRDZWxsKCdib29sJywgJ3QnKVxuICogLy89PiB0cnVlXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q2VsbCgnaW50OCcsICcxMCcpXG4gKiAvLz0+IDEwXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q2VsbCgnX2ludDQnLCAnezEsMiwzLDR9JylcbiAqIC8vPT4gWzEsMiwzLDRdXG4gKi9cbmV4cG9ydCBjb25zdCBjb252ZXJ0Q2VsbCA9ICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgIC8vIGlmIGRhdGEgdHlwZSBpcyBhbiBhcnJheVxuICAgIGlmICh0eXBlLmNoYXJBdCgwKSA9PT0gJ18nKSB7XG4gICAgICAgIGNvbnN0IGRhdGFUeXBlID0gdHlwZS5zbGljZSgxLCB0eXBlLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiB0b0FycmF5KHZhbHVlLCBkYXRhVHlwZSk7XG4gICAgfVxuICAgIC8vIElmIG5vdCBudWxsLCBjb252ZXJ0IHRvIGNvcnJlY3QgdHlwZS5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmJvb2w6XG4gICAgICAgICAgICByZXR1cm4gdG9Cb29sZWFuKHZhbHVlKTtcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmZsb2F0NDpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmZsb2F0ODpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmludDI6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5pbnQ0OlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50ODpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLm51bWVyaWM6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5vaWQ6XG4gICAgICAgICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpO1xuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuanNvbjpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmpzb25iOlxuICAgICAgICAgICAgcmV0dXJuIHRvSnNvbih2YWx1ZSk7XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50aW1lc3RhbXA6XG4gICAgICAgICAgICByZXR1cm4gdG9UaW1lc3RhbXBTdHJpbmcodmFsdWUpOyAvLyBGb3JtYXQgdG8gYmUgY29uc2lzdGVudCB3aXRoIFBvc3RnUkVTVFxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuYWJzdGltZTogLy8gVG8gYWxsb3cgdXNlcnMgdG8gY2FzdCBpdCBiYXNlZCBvbiBUaW1lem9uZVxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuZGF0ZTogLy8gVG8gYWxsb3cgdXNlcnMgdG8gY2FzdCBpdCBiYXNlZCBvbiBUaW1lem9uZVxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuZGF0ZXJhbmdlOlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50NHJhbmdlOlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50OHJhbmdlOlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMubW9uZXk6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5yZWx0aW1lOiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50ZXh0OlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMudGltZTogLy8gVG8gYWxsb3cgdXNlcnMgdG8gY2FzdCBpdCBiYXNlZCBvbiBUaW1lem9uZVxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMudGltZXN0YW1wdHo6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRpbWV0ejogLy8gVG8gYWxsb3cgdXNlcnMgdG8gY2FzdCBpdCBiYXNlZCBvbiBUaW1lem9uZVxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMudHNyYW5nZTpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRzdHpyYW5nZTpcbiAgICAgICAgICAgIHJldHVybiBub29wKHZhbHVlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgdmFsdWUgZm9yIHJlbWFpbmluZyB0eXBlc1xuICAgICAgICAgICAgcmV0dXJuIG5vb3AodmFsdWUpO1xuICAgIH1cbn07XG5jb25zdCBub29wID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbmV4cG9ydCBjb25zdCB0b0Jvb2xlYW4gPSAodmFsdWUpID0+IHtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgdG9OdW1iZXIgPSAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICBpZiAoIU51bWJlci5pc05hTihwYXJzZWRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuZXhwb3J0IGNvbnN0IHRvSnNvbiA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbi8qKlxuICogQ29udmVydHMgYSBQb3N0Z3JlcyBBcnJheSBpbnRvIGEgbmF0aXZlIEpTIGFycmF5XG4gKlxuICogQGV4YW1wbGUgdG9BcnJheSgne30nLCAnaW50NCcpXG4gKiAvLz0+IFtdXG4gKiBAZXhhbXBsZSB0b0FycmF5KCd7XCJbMjAyMS0wMS0wMSwyMDIxLTEyLTMxKVwiLFwiKDIwMjEtMDEtMDEsMjAyMS0xMi0zMl1cIn0nLCAnZGF0ZXJhbmdlJylcbiAqIC8vPT4gWydbMjAyMS0wMS0wMSwyMDIxLTEyLTMxKScsICcoMjAyMS0wMS0wMSwyMDIxLTEyLTMyXSddXG4gKiBAZXhhbXBsZSB0b0FycmF5KFsxLDIsMyw0XSwgJ2ludDQnKVxuICogLy89PiBbMSwyLDMsNF1cbiAqL1xuZXhwb3J0IGNvbnN0IHRvQXJyYXkgPSAodmFsdWUsIHR5cGUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGxhc3RJZHggPSB2YWx1ZS5sZW5ndGggLSAxO1xuICAgIGNvbnN0IGNsb3NlQnJhY2UgPSB2YWx1ZVtsYXN0SWR4XTtcbiAgICBjb25zdCBvcGVuQnJhY2UgPSB2YWx1ZVswXTtcbiAgICAvLyBDb25maXJtIHZhbHVlIGlzIGEgUG9zdGdyZXMgYXJyYXkgYnkgY2hlY2tpbmcgY3VybHkgYnJhY2tldHNcbiAgICBpZiAob3BlbkJyYWNlID09PSAneycgJiYgY2xvc2VCcmFjZSA9PT0gJ30nKSB7XG4gICAgICAgIGxldCBhcnI7XG4gICAgICAgIGNvbnN0IHZhbFRyaW0gPSB2YWx1ZS5zbGljZSgxLCBsYXN0SWR4KTtcbiAgICAgICAgLy8gVE9ETzogZmluZCBhIGJldHRlciBzb2x1dGlvbiB0byBzZXBhcmF0ZSBQb3N0Z3JlcyBhcnJheSBkYXRhXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhcnIgPSBKU09OLnBhcnNlKCdbJyArIHZhbFRyaW0gKyAnXScpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAvLyBXQVJOSU5HOiBzcGxpdHRpbmcgb24gY29tbWEgZG9lcyBub3QgY292ZXIgYWxsIGVkZ2UgY2FzZXNcbiAgICAgICAgICAgIGFyciA9IHZhbFRyaW0gPyB2YWxUcmltLnNwbGl0KCcsJykgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyLm1hcCgodmFsKSA9PiBjb252ZXJ0Q2VsbCh0eXBlLCB2YWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbi8qKlxuICogRml4ZXMgdGltZXN0YW1wIHRvIGJlIElTTy04NjAxLiBTd2FwcyB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgZGF0ZSBhbmQgdGltZSBmb3IgYSAnVCdcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2Uvc3VwYWJhc2UvaXNzdWVzLzE4XG4gKlxuICogQGV4YW1wbGUgdG9UaW1lc3RhbXBTdHJpbmcoJzIwMTktMDktMTAgMDA6MDA6MDAnKVxuICogLy89PiAnMjAxOS0wOS0xMFQwMDowMDowMCdcbiAqL1xuZXhwb3J0IGNvbnN0IHRvVGltZXN0YW1wU3RyaW5nID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoJyAnLCAnVCcpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuZXhwb3J0IGNvbnN0IGh0dHBFbmRwb2ludFVSTCA9IChzb2NrZXRVcmwpID0+IHtcbiAgICBjb25zdCB3c1VybCA9IG5ldyBVUkwoc29ja2V0VXJsKTtcbiAgICB3c1VybC5wcm90b2NvbCA9IHdzVXJsLnByb3RvY29sLnJlcGxhY2UoL153cy9pLCAnaHR0cCcpO1xuICAgIHdzVXJsLnBhdGhuYW1lID0gd3NVcmwucGF0aG5hbWVcbiAgICAgICAgLnJlcGxhY2UoL1xcLyskLywgJycpIC8vIHJlbW92ZSBhbGwgdHJhaWxpbmcgc2xhc2hlc1xuICAgICAgICAucmVwbGFjZSgvXFwvc29ja2V0XFwvd2Vic29ja2V0JC9pLCAnJykgLy8gcmVtb3ZlIHRoZSBzb2NrZXQvd2Vic29ja2V0IHBhdGhcbiAgICAgICAgLnJlcGxhY2UoL1xcL3NvY2tldCQvaSwgJycpIC8vIHJlbW92ZSB0aGUgc29ja2V0IHBhdGhcbiAgICAgICAgLnJlcGxhY2UoL1xcL3dlYnNvY2tldCQvaSwgJycpOyAvLyByZW1vdmUgdGhlIHdlYnNvY2tldCBwYXRoXG4gICAgaWYgKHdzVXJsLnBhdGhuYW1lID09PSAnJyB8fCB3c1VybC5wYXRobmFtZSA9PT0gJy8nKSB7XG4gICAgICAgIHdzVXJsLnBhdGhuYW1lID0gJy9hcGkvYnJvYWRjYXN0JztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdzVXJsLnBhdGhuYW1lID0gd3NVcmwucGF0aG5hbWUgKyAnL2FwaS9icm9hZGNhc3QnO1xuICAgIH1cbiAgICByZXR1cm4gd3NVcmwuaHJlZjtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2Zvcm1lcnMuanMubWFwIl0sIm5hbWVzIjpbIlBvc3RncmVzVHlwZXMiLCJjb252ZXJ0Q2hhbmdlRGF0YSIsImNvbHVtbnMiLCJyZWNvcmQiLCJvcHRpb25zIiwiX2EiLCJza2lwVHlwZXMiLCJPYmplY3QiLCJrZXlzIiwicmVkdWNlIiwiYWNjIiwicmVjX2tleSIsImNvbnZlcnRDb2x1bW4iLCJjb2x1bW5OYW1lIiwiY29sdW1uIiwiZmluZCIsIngiLCJuYW1lIiwiY29sVHlwZSIsInR5cGUiLCJ2YWx1ZSIsImluY2x1ZGVzIiwiY29udmVydENlbGwiLCJub29wIiwiY2hhckF0IiwiZGF0YVR5cGUiLCJzbGljZSIsImxlbmd0aCIsInRvQXJyYXkiLCJib29sIiwidG9Cb29sZWFuIiwiZmxvYXQ0IiwiZmxvYXQ4IiwiaW50MiIsImludDQiLCJpbnQ4IiwibnVtZXJpYyIsIm9pZCIsInRvTnVtYmVyIiwianNvbiIsImpzb25iIiwidG9Kc29uIiwidGltZXN0YW1wIiwidG9UaW1lc3RhbXBTdHJpbmciLCJhYnN0aW1lIiwiZGF0ZSIsImRhdGVyYW5nZSIsImludDRyYW5nZSIsImludDhyYW5nZSIsIm1vbmV5IiwicmVsdGltZSIsInRleHQiLCJ0aW1lIiwidGltZXN0YW1wdHoiLCJ0aW1ldHoiLCJ0c3JhbmdlIiwidHN0enJhbmdlIiwicGFyc2VkVmFsdWUiLCJwYXJzZUZsb2F0IiwiTnVtYmVyIiwiaXNOYU4iLCJKU09OIiwicGFyc2UiLCJsYXN0SWR4IiwiY2xvc2VCcmFjZSIsIm9wZW5CcmFjZSIsImFyciIsInZhbFRyaW0iLCJfIiwic3BsaXQiLCJtYXAiLCJ2YWwiLCJyZXBsYWNlIiwiaHR0cEVuZHBvaW50VVJMIiwic29ja2V0VXJsIiwid3NVcmwiLCJVUkwiLCJwcm90b2NvbCIsInBhdGhuYW1lIiwiaHJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/version.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/version.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n// Generated automatically during releases by scripts/update-version-files.ts\n// This file provides runtime access to the package version for:\n// - HTTP request headers (e.g., X-Client-Info header for API requests)\n// - Debugging and support (identifying which version is running)\n// - Telemetry and logging (version reporting in errors/analytics)\n// - Ensuring build artifacts match the published package version\nconst version = \"2.97.0\"; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSw2RUFBNkU7QUFDN0UsZ0VBQWdFO0FBQ2hFLHVFQUF1RTtBQUN2RSxpRUFBaUU7QUFDakUsa0VBQWtFO0FBQ2xFLGlFQUFpRTtBQUMxRCxNQUFNQSxVQUFVLFNBQVMsQ0FDaEMsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5jaG9yLXdvcmtmbG93cy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3ZlcnNpb24uanM/MWZkNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBHZW5lcmF0ZWQgYXV0b21hdGljYWxseSBkdXJpbmcgcmVsZWFzZXMgYnkgc2NyaXB0cy91cGRhdGUtdmVyc2lvbi1maWxlcy50c1xuLy8gVGhpcyBmaWxlIHByb3ZpZGVzIHJ1bnRpbWUgYWNjZXNzIHRvIHRoZSBwYWNrYWdlIHZlcnNpb24gZm9yOlxuLy8gLSBIVFRQIHJlcXVlc3QgaGVhZGVycyAoZS5nLiwgWC1DbGllbnQtSW5mbyBoZWFkZXIgZm9yIEFQSSByZXF1ZXN0cylcbi8vIC0gRGVidWdnaW5nIGFuZCBzdXBwb3J0IChpZGVudGlmeWluZyB3aGljaCB2ZXJzaW9uIGlzIHJ1bm5pbmcpXG4vLyAtIFRlbGVtZXRyeSBhbmQgbG9nZ2luZyAodmVyc2lvbiByZXBvcnRpbmcgaW4gZXJyb3JzL2FuYWx5dGljcylcbi8vIC0gRW5zdXJpbmcgYnVpbGQgYXJ0aWZhY3RzIG1hdGNoIHRoZSBwdWJsaXNoZWQgcGFja2FnZSB2ZXJzaW9uXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9ICcyLjk3LjAnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebSocketFactory: () => (/* binding */ WebSocketFactory),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Utilities for creating WebSocket instances across runtimes.\n */ class WebSocketFactory {\n    /**\n     * Static-only utility  prevent instantiation.\n     */ constructor(){}\n    static detectEnvironment() {\n        var _a;\n        if (typeof WebSocket !== \"undefined\") {\n            return {\n                type: \"native\",\n                constructor: WebSocket\n            };\n        }\n        if (typeof globalThis !== \"undefined\" && typeof globalThis.WebSocket !== \"undefined\") {\n            return {\n                type: \"native\",\n                constructor: globalThis.WebSocket\n            };\n        }\n        if (typeof global !== \"undefined\" && typeof global.WebSocket !== \"undefined\") {\n            return {\n                type: \"native\",\n                constructor: global.WebSocket\n            };\n        }\n        if (typeof globalThis !== \"undefined\" && typeof globalThis.WebSocketPair !== \"undefined\" && typeof globalThis.WebSocket === \"undefined\") {\n            return {\n                type: \"cloudflare\",\n                error: \"Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.\",\n                workaround: \"Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime.\"\n            };\n        }\n        if (typeof globalThis !== \"undefined\" && globalThis.EdgeRuntime || typeof navigator !== \"undefined\" && ((_a = navigator.userAgent) === null || _a === void 0 ? void 0 : _a.includes(\"Vercel-Edge\"))) {\n            return {\n                type: \"unsupported\",\n                error: \"Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.\",\n                workaround: \"Use serverless functions or a different deployment target for WebSocket functionality.\"\n            };\n        }\n        // Use dynamic property access to avoid Next.js Edge Runtime static analysis warnings\n        const _process = globalThis[\"process\"];\n        if (_process) {\n            const processVersions = _process[\"versions\"];\n            if (processVersions && processVersions[\"node\"]) {\n                // Remove 'v' prefix if present and parse the major version\n                const versionString = processVersions[\"node\"];\n                const nodeVersion = parseInt(versionString.replace(/^v/, \"\").split(\".\")[0]);\n                // Node.js 22+ should have native WebSocket\n                if (nodeVersion >= 22) {\n                    // Check if native WebSocket is available (should be in Node.js 22+)\n                    if (typeof globalThis.WebSocket !== \"undefined\") {\n                        return {\n                            type: \"native\",\n                            constructor: globalThis.WebSocket\n                        };\n                    }\n                    // If not available, user needs to provide it\n                    return {\n                        type: \"unsupported\",\n                        error: `Node.js ${nodeVersion} detected but native WebSocket not found.`,\n                        workaround: \"Provide a WebSocket implementation via the transport option.\"\n                    };\n                }\n                // Node.js < 22 doesn't have native WebSocket\n                return {\n                    type: \"unsupported\",\n                    error: `Node.js ${nodeVersion} detected without native WebSocket support.`,\n                    workaround: 'For Node.js < 22, install \"ws\" package and provide it via the transport option:\\n' + 'import ws from \"ws\"\\n' + \"new RealtimeClient(url, { transport: ws })\"\n                };\n            }\n        }\n        return {\n            type: \"unsupported\",\n            error: \"Unknown JavaScript runtime without WebSocket support.\",\n            workaround: \"Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation.\"\n        };\n    }\n    /**\n     * Returns the best available WebSocket constructor for the current runtime.\n     *\n     * @example\n     * ```ts\n     * const WS = WebSocketFactory.getWebSocketConstructor()\n     * const socket = new WS('wss://realtime.supabase.co/socket')\n     * ```\n     */ static getWebSocketConstructor() {\n        const env = this.detectEnvironment();\n        if (env.constructor) {\n            return env.constructor;\n        }\n        let errorMessage = env.error || \"WebSocket not supported in this environment.\";\n        if (env.workaround) {\n            errorMessage += `\\n\\nSuggested solution: ${env.workaround}`;\n        }\n        throw new Error(errorMessage);\n    }\n    /**\n     * Creates a WebSocket using the detected constructor.\n     *\n     * @example\n     * ```ts\n     * const socket = WebSocketFactory.createWebSocket('wss://realtime.supabase.co/socket')\n     * ```\n     */ static createWebSocket(url, protocols) {\n        const WS = this.getWebSocketConstructor();\n        return new WS(url, protocols);\n    }\n    /**\n     * Detects whether the runtime can establish WebSocket connections.\n     *\n     * @example\n     * ```ts\n     * if (!WebSocketFactory.isWebSocketSupported()) {\n     *   console.warn('Falling back to long polling')\n     * }\n     * ```\n     */ static isWebSocketSupported() {\n        try {\n            const env = this.detectEnvironment();\n            return env.type === \"native\" || env.type === \"ws\";\n        } catch (_a) {\n            return false;\n        }\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WebSocketFactory); //# sourceMappingURL=websocket-factory.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi93ZWJzb2NrZXQtZmFjdG9yeS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOztDQUVDLEdBQ00sTUFBTUE7SUFDVDs7S0FFQyxHQUNEQyxhQUFjLENBQUU7SUFDaEIsT0FBT0Msb0JBQW9CO1FBQ3ZCLElBQUlDO1FBQ0osSUFBSSxPQUFPQyxjQUFjLGFBQWE7WUFDbEMsT0FBTztnQkFBRUMsTUFBTTtnQkFBVUosYUFBYUc7WUFBVTtRQUNwRDtRQUNBLElBQUksT0FBT0UsZUFBZSxlQUFlLE9BQU9BLFdBQVdGLFNBQVMsS0FBSyxhQUFhO1lBQ2xGLE9BQU87Z0JBQUVDLE1BQU07Z0JBQVVKLGFBQWFLLFdBQVdGLFNBQVM7WUFBQztRQUMvRDtRQUNBLElBQUksT0FBT0csV0FBVyxlQUFlLE9BQU9BLE9BQU9ILFNBQVMsS0FBSyxhQUFhO1lBQzFFLE9BQU87Z0JBQUVDLE1BQU07Z0JBQVVKLGFBQWFNLE9BQU9ILFNBQVM7WUFBQztRQUMzRDtRQUNBLElBQUksT0FBT0UsZUFBZSxlQUN0QixPQUFPQSxXQUFXRSxhQUFhLEtBQUssZUFDcEMsT0FBT0YsV0FBV0YsU0FBUyxLQUFLLGFBQWE7WUFDN0MsT0FBTztnQkFDSEMsTUFBTTtnQkFDTkksT0FBTztnQkFDUEMsWUFBWTtZQUNoQjtRQUNKO1FBQ0EsSUFBSSxPQUFRSixlQUFlLGVBQWVBLFdBQVdLLFdBQVcsSUFDM0QsT0FBT0MsY0FBYyxlQUFnQixFQUFDVCxLQUFLUyxVQUFVQyxTQUFTLE1BQU0sUUFBUVYsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHVyxRQUFRLENBQUMsY0FBYSxHQUFLO1lBQ3BJLE9BQU87Z0JBQ0hULE1BQU07Z0JBQ05JLE9BQU87Z0JBQ1BDLFlBQVk7WUFDaEI7UUFDSjtRQUNBLHFGQUFxRjtRQUNyRixNQUFNSyxXQUFXVCxVQUFVLENBQUMsVUFBVTtRQUN0QyxJQUFJUyxVQUFVO1lBQ1YsTUFBTUMsa0JBQWtCRCxRQUFRLENBQUMsV0FBVztZQUM1QyxJQUFJQyxtQkFBbUJBLGVBQWUsQ0FBQyxPQUFPLEVBQUU7Z0JBQzVDLDJEQUEyRDtnQkFDM0QsTUFBTUMsZ0JBQWdCRCxlQUFlLENBQUMsT0FBTztnQkFDN0MsTUFBTUUsY0FBY0MsU0FBU0YsY0FBY0csT0FBTyxDQUFDLE1BQU0sSUFBSUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUMxRSwyQ0FBMkM7Z0JBQzNDLElBQUlILGVBQWUsSUFBSTtvQkFDbkIsb0VBQW9FO29CQUNwRSxJQUFJLE9BQU9aLFdBQVdGLFNBQVMsS0FBSyxhQUFhO3dCQUM3QyxPQUFPOzRCQUFFQyxNQUFNOzRCQUFVSixhQUFhSyxXQUFXRixTQUFTO3dCQUFDO29CQUMvRDtvQkFDQSw2Q0FBNkM7b0JBQzdDLE9BQU87d0JBQ0hDLE1BQU07d0JBQ05JLE9BQU8sQ0FBQyxRQUFRLEVBQUVTLFlBQVkseUNBQXlDLENBQUM7d0JBQ3hFUixZQUFZO29CQUNoQjtnQkFDSjtnQkFDQSw2Q0FBNkM7Z0JBQzdDLE9BQU87b0JBQ0hMLE1BQU07b0JBQ05JLE9BQU8sQ0FBQyxRQUFRLEVBQUVTLFlBQVksMkNBQTJDLENBQUM7b0JBQzFFUixZQUFZLHNGQUNSLDBCQUNBO2dCQUNSO1lBQ0o7UUFDSjtRQUNBLE9BQU87WUFDSEwsTUFBTTtZQUNOSSxPQUFPO1lBQ1BDLFlBQVk7UUFDaEI7SUFDSjtJQUNBOzs7Ozs7OztLQVFDLEdBQ0QsT0FBT1ksMEJBQTBCO1FBQzdCLE1BQU1DLE1BQU0sSUFBSSxDQUFDckIsaUJBQWlCO1FBQ2xDLElBQUlxQixJQUFJdEIsV0FBVyxFQUFFO1lBQ2pCLE9BQU9zQixJQUFJdEIsV0FBVztRQUMxQjtRQUNBLElBQUl1QixlQUFlRCxJQUFJZCxLQUFLLElBQUk7UUFDaEMsSUFBSWMsSUFBSWIsVUFBVSxFQUFFO1lBQ2hCYyxnQkFBZ0IsQ0FBQyx3QkFBd0IsRUFBRUQsSUFBSWIsVUFBVSxDQUFDLENBQUM7UUFDL0Q7UUFDQSxNQUFNLElBQUllLE1BQU1EO0lBQ3BCO0lBQ0E7Ozs7Ozs7S0FPQyxHQUNELE9BQU9FLGdCQUFnQkMsR0FBRyxFQUFFQyxTQUFTLEVBQUU7UUFDbkMsTUFBTUMsS0FBSyxJQUFJLENBQUNQLHVCQUF1QjtRQUN2QyxPQUFPLElBQUlPLEdBQUdGLEtBQUtDO0lBQ3ZCO0lBQ0E7Ozs7Ozs7OztLQVNDLEdBQ0QsT0FBT0UsdUJBQXVCO1FBQzFCLElBQUk7WUFDQSxNQUFNUCxNQUFNLElBQUksQ0FBQ3JCLGlCQUFpQjtZQUNsQyxPQUFPcUIsSUFBSWxCLElBQUksS0FBSyxZQUFZa0IsSUFBSWxCLElBQUksS0FBSztRQUNqRCxFQUNBLE9BQU9GLElBQUk7WUFDUCxPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0EsaUVBQWVILGdCQUFnQkEsRUFBQyxDQUNoQyw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmNob3Itd29ya2Zsb3dzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21vZHVsZS9saWIvd2Vic29ja2V0LWZhY3RvcnkuanM/YTVhYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdGllcyBmb3IgY3JlYXRpbmcgV2ViU29ja2V0IGluc3RhbmNlcyBhY3Jvc3MgcnVudGltZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJTb2NrZXRGYWN0b3J5IHtcbiAgICAvKipcbiAgICAgKiBTdGF0aWMtb25seSB1dGlsaXR5IOKAkyBwcmV2ZW50IGluc3RhbnRpYXRpb24uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICBzdGF0aWMgZGV0ZWN0RW52aXJvbm1lbnQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHR5cGVvZiBXZWJTb2NrZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnbmF0aXZlJywgY29uc3RydWN0b3I6IFdlYlNvY2tldCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGdsb2JhbFRoaXMuV2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ25hdGl2ZScsIGNvbnN0cnVjdG9yOiBnbG9iYWxUaGlzLldlYlNvY2tldCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZ2xvYmFsLldlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICduYXRpdmUnLCBjb25zdHJ1Y3RvcjogZ2xvYmFsLldlYlNvY2tldCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiBnbG9iYWxUaGlzLldlYlNvY2tldFBhaXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICB0eXBlb2YgZ2xvYmFsVGhpcy5XZWJTb2NrZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjbG91ZGZsYXJlJyxcbiAgICAgICAgICAgICAgICBlcnJvcjogJ0Nsb3VkZmxhcmUgV29ya2VycyBkZXRlY3RlZC4gV2ViU29ja2V0IGNsaWVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gQ2xvdWRmbGFyZSBXb3JrZXJzLicsXG4gICAgICAgICAgICAgICAgd29ya2Fyb3VuZDogJ1VzZSBDbG91ZGZsYXJlIFdvcmtlcnMgV2ViU29ja2V0IEFQSSBmb3Igc2VydmVyLXNpZGUgV2ViU29ja2V0IGhhbmRsaW5nLCBvciBkZXBsb3kgdG8gYSBkaWZmZXJlbnQgcnVudGltZS4nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWxUaGlzLkVkZ2VSdW50aW1lKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmICgoX2EgPSBuYXZpZ2F0b3IudXNlckFnZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoJ1ZlcmNlbC1FZGdlJykpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndW5zdXBwb3J0ZWQnLFxuICAgICAgICAgICAgICAgIGVycm9yOiAnRWRnZSBydW50aW1lIGRldGVjdGVkIChWZXJjZWwgRWRnZS9OZXRsaWZ5IEVkZ2UpLiBXZWJTb2NrZXRzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGVkZ2UgZnVuY3Rpb25zLicsXG4gICAgICAgICAgICAgICAgd29ya2Fyb3VuZDogJ1VzZSBzZXJ2ZXJsZXNzIGZ1bmN0aW9ucyBvciBhIGRpZmZlcmVudCBkZXBsb3ltZW50IHRhcmdldCBmb3IgV2ViU29ja2V0IGZ1bmN0aW9uYWxpdHkuJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIGR5bmFtaWMgcHJvcGVydHkgYWNjZXNzIHRvIGF2b2lkIE5leHQuanMgRWRnZSBSdW50aW1lIHN0YXRpYyBhbmFseXNpcyB3YXJuaW5nc1xuICAgICAgICBjb25zdCBfcHJvY2VzcyA9IGdsb2JhbFRoaXNbJ3Byb2Nlc3MnXTtcbiAgICAgICAgaWYgKF9wcm9jZXNzKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzVmVyc2lvbnMgPSBfcHJvY2Vzc1sndmVyc2lvbnMnXTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzVmVyc2lvbnMgJiYgcHJvY2Vzc1ZlcnNpb25zWydub2RlJ10pIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgJ3YnIHByZWZpeCBpZiBwcmVzZW50IGFuZCBwYXJzZSB0aGUgbWFqb3IgdmVyc2lvblxuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb25TdHJpbmcgPSBwcm9jZXNzVmVyc2lvbnNbJ25vZGUnXTtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlVmVyc2lvbiA9IHBhcnNlSW50KHZlcnNpb25TdHJpbmcucmVwbGFjZSgvXnYvLCAnJykuc3BsaXQoJy4nKVswXSk7XG4gICAgICAgICAgICAgICAgLy8gTm9kZS5qcyAyMisgc2hvdWxkIGhhdmUgbmF0aXZlIFdlYlNvY2tldFxuICAgICAgICAgICAgICAgIGlmIChub2RlVmVyc2lvbiA+PSAyMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBuYXRpdmUgV2ViU29ja2V0IGlzIGF2YWlsYWJsZSAoc2hvdWxkIGJlIGluIE5vZGUuanMgMjIrKVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMuV2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ25hdGl2ZScsIGNvbnN0cnVjdG9yOiBnbG9iYWxUaGlzLldlYlNvY2tldCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vdCBhdmFpbGFibGUsIHVzZXIgbmVlZHMgdG8gcHJvdmlkZSBpdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Vuc3VwcG9ydGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBgTm9kZS5qcyAke25vZGVWZXJzaW9ufSBkZXRlY3RlZCBidXQgbmF0aXZlIFdlYlNvY2tldCBub3QgZm91bmQuYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmthcm91bmQ6ICdQcm92aWRlIGEgV2ViU29ja2V0IGltcGxlbWVudGF0aW9uIHZpYSB0aGUgdHJhbnNwb3J0IG9wdGlvbi4nLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBOb2RlLmpzIDwgMjIgZG9lc24ndCBoYXZlIG5hdGl2ZSBXZWJTb2NrZXRcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAndW5zdXBwb3J0ZWQnLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogYE5vZGUuanMgJHtub2RlVmVyc2lvbn0gZGV0ZWN0ZWQgd2l0aG91dCBuYXRpdmUgV2ViU29ja2V0IHN1cHBvcnQuYCxcbiAgICAgICAgICAgICAgICAgICAgd29ya2Fyb3VuZDogJ0ZvciBOb2RlLmpzIDwgMjIsIGluc3RhbGwgXCJ3c1wiIHBhY2thZ2UgYW5kIHByb3ZpZGUgaXQgdmlhIHRoZSB0cmFuc3BvcnQgb3B0aW9uOlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2ltcG9ydCB3cyBmcm9tIFwid3NcIlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ25ldyBSZWFsdGltZUNsaWVudCh1cmwsIHsgdHJhbnNwb3J0OiB3cyB9KScsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ3Vuc3VwcG9ydGVkJyxcbiAgICAgICAgICAgIGVycm9yOiAnVW5rbm93biBKYXZhU2NyaXB0IHJ1bnRpbWUgd2l0aG91dCBXZWJTb2NrZXQgc3VwcG9ydC4nLFxuICAgICAgICAgICAgd29ya2Fyb3VuZDogXCJFbnN1cmUgeW91J3JlIHJ1bm5pbmcgaW4gYSBzdXBwb3J0ZWQgZW52aXJvbm1lbnQgKGJyb3dzZXIsIE5vZGUuanMsIERlbm8pIG9yIHByb3ZpZGUgYSBjdXN0b20gV2ViU29ja2V0IGltcGxlbWVudGF0aW9uLlwiLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBiZXN0IGF2YWlsYWJsZSBXZWJTb2NrZXQgY29uc3RydWN0b3IgZm9yIHRoZSBjdXJyZW50IHJ1bnRpbWUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgV1MgPSBXZWJTb2NrZXRGYWN0b3J5LmdldFdlYlNvY2tldENvbnN0cnVjdG9yKClcbiAgICAgKiBjb25zdCBzb2NrZXQgPSBuZXcgV1MoJ3dzczovL3JlYWx0aW1lLnN1cGFiYXNlLmNvL3NvY2tldCcpXG4gICAgICogYGBgXG4gICAgICovXG4gICAgc3RhdGljIGdldFdlYlNvY2tldENvbnN0cnVjdG9yKCkge1xuICAgICAgICBjb25zdCBlbnYgPSB0aGlzLmRldGVjdEVudmlyb25tZW50KCk7XG4gICAgICAgIGlmIChlbnYuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnYuY29uc3RydWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IGVudi5lcnJvciB8fCAnV2ViU29ja2V0IG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudC4nO1xuICAgICAgICBpZiAoZW52Lndvcmthcm91bmQpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSBgXFxuXFxuU3VnZ2VzdGVkIHNvbHV0aW9uOiAke2Vudi53b3JrYXJvdW5kfWA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBXZWJTb2NrZXQgdXNpbmcgdGhlIGRldGVjdGVkIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHNvY2tldCA9IFdlYlNvY2tldEZhY3RvcnkuY3JlYXRlV2ViU29ja2V0KCd3c3M6Ly9yZWFsdGltZS5zdXBhYmFzZS5jby9zb2NrZXQnKVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVXZWJTb2NrZXQodXJsLCBwcm90b2NvbHMpIHtcbiAgICAgICAgY29uc3QgV1MgPSB0aGlzLmdldFdlYlNvY2tldENvbnN0cnVjdG9yKCk7XG4gICAgICAgIHJldHVybiBuZXcgV1ModXJsLCBwcm90b2NvbHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlY3RzIHdoZXRoZXIgdGhlIHJ1bnRpbWUgY2FuIGVzdGFibGlzaCBXZWJTb2NrZXQgY29ubmVjdGlvbnMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogaWYgKCFXZWJTb2NrZXRGYWN0b3J5LmlzV2ViU29ja2V0U3VwcG9ydGVkKCkpIHtcbiAgICAgKiAgIGNvbnNvbGUud2FybignRmFsbGluZyBiYWNrIHRvIGxvbmcgcG9sbGluZycpXG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBpc1dlYlNvY2tldFN1cHBvcnRlZCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVudiA9IHRoaXMuZGV0ZWN0RW52aXJvbm1lbnQoKTtcbiAgICAgICAgICAgIHJldHVybiBlbnYudHlwZSA9PT0gJ25hdGl2ZScgfHwgZW52LnR5cGUgPT09ICd3cyc7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBXZWJTb2NrZXRGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2Vic29ja2V0LWZhY3RvcnkuanMubWFwIl0sIm5hbWVzIjpbIldlYlNvY2tldEZhY3RvcnkiLCJjb25zdHJ1Y3RvciIsImRldGVjdEVudmlyb25tZW50IiwiX2EiLCJXZWJTb2NrZXQiLCJ0eXBlIiwiZ2xvYmFsVGhpcyIsImdsb2JhbCIsIldlYlNvY2tldFBhaXIiLCJlcnJvciIsIndvcmthcm91bmQiLCJFZGdlUnVudGltZSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImluY2x1ZGVzIiwiX3Byb2Nlc3MiLCJwcm9jZXNzVmVyc2lvbnMiLCJ2ZXJzaW9uU3RyaW5nIiwibm9kZVZlcnNpb24iLCJwYXJzZUludCIsInJlcGxhY2UiLCJzcGxpdCIsImdldFdlYlNvY2tldENvbnN0cnVjdG9yIiwiZW52IiwiZXJyb3JNZXNzYWdlIiwiRXJyb3IiLCJjcmVhdGVXZWJTb2NrZXQiLCJ1cmwiLCJwcm90b2NvbHMiLCJXUyIsImlzV2ViU29ja2V0U3VwcG9ydGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/ssr/dist/module/cookies.js":
/*!***********************************************************!*\
  !*** ./node_modules/@supabase/ssr/dist/module/cookies.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyServerStorage: () => (/* binding */ applyServerStorage),\n/* harmony export */   createStorageFromOptions: () => (/* binding */ createStorageFromOptions)\n/* harmony export */ });\n/* harmony import */ var cookie__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cookie */ \"(ssr)/./node_modules/cookie/dist/index.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@supabase/ssr/dist/module/utils/index.js\");\n\n\nconst BASE64_PREFIX = \"base64-\";\n/**\n * Creates a storage client that handles cookies correctly for browser and\n * server clients with or without properly provided cookie methods.\n *\n * @param options The options passed to createBrowserClient or createServer client.\n *\n * @param isServerClient Whether it's called from createServerClient.\n */ function createStorageFromOptions(options, isServerClient) {\n    const cookies = options.cookies ?? null;\n    const cookieEncoding = options.cookieEncoding;\n    const setItems = {};\n    const removedItems = {};\n    let getAll;\n    let setAll;\n    if (cookies) {\n        if (\"get\" in cookies) {\n            // Just get is not enough, because the client needs to see what cookies\n            // are already set and unset them if necessary. To attempt to fix this\n            // behavior for most use cases, we pass \"hints\" which is the keys of the\n            // storage items. They are then converted to their corresponding cookie\n            // chunk names and are fetched with get. Only 5 chunks are fetched, which\n            // should be enough for the majority of use cases, but does not solve\n            // those with very large sessions.\n            const getWithHints = async (keyHints)=>{\n                // optimistically find the first 5 potential chunks for the specified key\n                const chunkNames = keyHints.flatMap((keyHint)=>[\n                        keyHint,\n                        ...Array.from({\n                            length: 5\n                        }).map((_, i)=>`${keyHint}.${i}`)\n                    ]);\n                const chunks = [];\n                for(let i = 0; i < chunkNames.length; i += 1){\n                    const value = await cookies.get(chunkNames[i]);\n                    if (!value && typeof value !== \"string\") {\n                        continue;\n                    }\n                    chunks.push({\n                        name: chunkNames[i],\n                        value\n                    });\n                }\n                // TODO: detect and log stale chunks error\n                return chunks;\n            };\n            getAll = async (keyHints)=>await getWithHints(keyHints);\n            if (\"set\" in cookies && \"remove\" in cookies) {\n                setAll = async (setCookies)=>{\n                    for(let i = 0; i < setCookies.length; i += 1){\n                        const { name, value, options } = setCookies[i];\n                        if (value) {\n                            await cookies.set(name, value, options);\n                        } else {\n                            await cookies.remove(name, options);\n                        }\n                    }\n                };\n            } else if (isServerClient) {\n                setAll = async ()=>{\n                    console.warn(\"@supabase/ssr: createServerClient was configured without set and remove cookie methods, but the client needs to set cookies. This can lead to issues such as random logouts, early session termination or increased token refresh requests. If in NextJS, check your middleware.ts file, route handlers and server actions for correctness. Consider switching to the getAll and setAll cookie methods instead of get, set and remove which are deprecated and can be difficult to use correctly.\");\n                };\n            } else {\n                throw new Error(\"@supabase/ssr: createBrowserClient requires configuring a getAll and setAll cookie method (deprecated: alternatively both get, set and remove can be used)\");\n            }\n        } else if (\"getAll\" in cookies) {\n            getAll = async ()=>await cookies.getAll();\n            if (\"setAll\" in cookies) {\n                setAll = cookies.setAll;\n            } else if (isServerClient) {\n                setAll = async ()=>{\n                    console.warn(\"@supabase/ssr: createServerClient was configured without the setAll cookie method, but the client needs to set cookies. This can lead to issues such as random logouts, early session termination or increased token refresh requests. If in NextJS, check your middleware.ts file, route handlers and server actions for correctness.\");\n                };\n            } else {\n                throw new Error(\"@supabase/ssr: createBrowserClient requires configuring both getAll and setAll cookie methods (deprecated: alternatively both get, set and remove can be used)\");\n            }\n        } else {\n            // neither get nor getAll is present on cookies, only will occur if pure JavaScript is used, but cookies is an object\n            throw new Error(`@supabase/ssr: ${isServerClient ? \"createServerClient\" : \"createBrowserClient\"} requires configuring getAll and setAll cookie methods (deprecated: alternatively use get, set and remove).${(0,_utils__WEBPACK_IMPORTED_MODULE_0__.isBrowser)() ? \" As this is called in a browser runtime, consider removing the cookies option object to use the document.cookie API automatically.\" : \"\"}`);\n        }\n    } else if (!isServerClient && (0,_utils__WEBPACK_IMPORTED_MODULE_0__.isBrowser)()) {\n        // The environment is browser, so use the document.cookie API to implement getAll and setAll.\n        const noHintGetAll = ()=>{\n            const parsed = (0,cookie__WEBPACK_IMPORTED_MODULE_1__.parse)(document.cookie);\n            return Object.keys(parsed).map((name)=>({\n                    name,\n                    value: parsed[name] ?? \"\"\n                }));\n        };\n        getAll = ()=>noHintGetAll();\n        setAll = (setCookies)=>{\n            setCookies.forEach(({ name, value, options })=>{\n                document.cookie = (0,cookie__WEBPACK_IMPORTED_MODULE_1__.serialize)(name, value, options);\n            });\n        };\n    } else if (isServerClient) {\n        throw new Error(\"@supabase/ssr: createServerClient must be initialized with cookie options that specify getAll and setAll functions (deprecated, not recommended: alternatively use get, set and remove)\");\n    } else {\n        // getting cookies when there's no window but we're in browser mode can be OK, because the developer probably is not using auth functions\n        getAll = ()=>{\n            return [];\n        };\n        // this is NOT OK because the developer is using auth functions that require setting some state, so that must error out\n        setAll = ()=>{\n            throw new Error(\"@supabase/ssr: createBrowserClient in non-browser runtimes (including Next.js pre-rendering mode) was not initialized cookie options that specify getAll and setAll functions (deprecated: alternatively use get, set and remove), but they were needed\");\n        };\n    }\n    if (!isServerClient) {\n        // This is the storage client to be used in browsers. It only\n        // works on the cookies abstraction, unlike the server client\n        // which only uses cookies to read the initial state. When an\n        // item is set, cookies are both cleared and set to values so\n        // that stale chunks are not left remaining.\n        return {\n            getAll,\n            setAll,\n            setItems,\n            removedItems,\n            storage: {\n                isServer: false,\n                getItem: async (key)=>{\n                    const allCookies = await getAll([\n                        key\n                    ]);\n                    const chunkedCookie = await (0,_utils__WEBPACK_IMPORTED_MODULE_0__.combineChunks)(key, async (chunkName)=>{\n                        const cookie = allCookies?.find(({ name })=>name === chunkName) || null;\n                        if (!cookie) {\n                            return null;\n                        }\n                        return cookie.value;\n                    });\n                    if (!chunkedCookie) {\n                        return null;\n                    }\n                    let decoded = chunkedCookie;\n                    if (chunkedCookie.startsWith(BASE64_PREFIX)) {\n                        decoded = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.stringFromBase64URL)(chunkedCookie.substring(BASE64_PREFIX.length));\n                    }\n                    return decoded;\n                },\n                setItem: async (key, value)=>{\n                    const allCookies = await getAll([\n                        key\n                    ]);\n                    const cookieNames = allCookies?.map(({ name })=>name) || [];\n                    const removeCookies = new Set(cookieNames.filter((name)=>(0,_utils__WEBPACK_IMPORTED_MODULE_0__.isChunkLike)(name, key)));\n                    let encoded = value;\n                    if (cookieEncoding === \"base64url\") {\n                        encoded = BASE64_PREFIX + (0,_utils__WEBPACK_IMPORTED_MODULE_0__.stringToBase64URL)(value);\n                    }\n                    const setCookies = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.createChunks)(key, encoded);\n                    setCookies.forEach(({ name })=>{\n                        removeCookies.delete(name);\n                    });\n                    const removeCookieOptions = {\n                        ..._utils__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_COOKIE_OPTIONS,\n                        ...options?.cookieOptions,\n                        maxAge: 0\n                    };\n                    const setCookieOptions = {\n                        ..._utils__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_COOKIE_OPTIONS,\n                        ...options?.cookieOptions,\n                        maxAge: _utils__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_COOKIE_OPTIONS.maxAge\n                    };\n                    // the NextJS cookieStore API can get confused if the `name` from\n                    // options.cookieOptions leaks\n                    delete removeCookieOptions.name;\n                    delete setCookieOptions.name;\n                    const allToSet = [\n                        ...[\n                            ...removeCookies\n                        ].map((name)=>({\n                                name,\n                                value: \"\",\n                                options: removeCookieOptions\n                            })),\n                        ...setCookies.map(({ name, value })=>({\n                                name,\n                                value,\n                                options: setCookieOptions\n                            }))\n                    ];\n                    if (allToSet.length > 0) {\n                        await setAll(allToSet);\n                    }\n                },\n                removeItem: async (key)=>{\n                    const allCookies = await getAll([\n                        key\n                    ]);\n                    const cookieNames = allCookies?.map(({ name })=>name) || [];\n                    const removeCookies = cookieNames.filter((name)=>(0,_utils__WEBPACK_IMPORTED_MODULE_0__.isChunkLike)(name, key));\n                    const removeCookieOptions = {\n                        ..._utils__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_COOKIE_OPTIONS,\n                        ...options?.cookieOptions,\n                        maxAge: 0\n                    };\n                    // the NextJS cookieStore API can get confused if the `name` from\n                    // options.cookieOptions leaks\n                    delete removeCookieOptions.name;\n                    if (removeCookies.length > 0) {\n                        await setAll(removeCookies.map((name)=>({\n                                name,\n                                value: \"\",\n                                options: removeCookieOptions\n                            })));\n                    }\n                }\n            }\n        };\n    }\n    // This is the server client. It only uses getAll to read the initial\n    // state. Any subsequent changes to the items is persisted in the\n    // setItems and removedItems objects. createServerClient *must* use\n    // getAll, setAll and the values in setItems and removedItems to\n    // persist the changes *at once* when appropriate (usually only when\n    // the TOKEN_REFRESHED, USER_UPDATED or SIGNED_OUT events are fired by\n    // the Supabase Auth client).\n    return {\n        getAll,\n        setAll,\n        setItems,\n        removedItems,\n        storage: {\n            // to signal to the libraries that these cookies are\n            // coming from a server environment and their value\n            // should not be trusted\n            isServer: true,\n            getItem: async (key)=>{\n                if (typeof setItems[key] === \"string\") {\n                    return setItems[key];\n                }\n                if (removedItems[key]) {\n                    return null;\n                }\n                const allCookies = await getAll([\n                    key\n                ]);\n                const chunkedCookie = await (0,_utils__WEBPACK_IMPORTED_MODULE_0__.combineChunks)(key, async (chunkName)=>{\n                    const cookie = allCookies?.find(({ name })=>name === chunkName) || null;\n                    if (!cookie) {\n                        return null;\n                    }\n                    return cookie.value;\n                });\n                if (!chunkedCookie) {\n                    return null;\n                }\n                let decoded = chunkedCookie;\n                if (typeof chunkedCookie === \"string\" && chunkedCookie.startsWith(BASE64_PREFIX)) {\n                    decoded = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.stringFromBase64URL)(chunkedCookie.substring(BASE64_PREFIX.length));\n                }\n                return decoded;\n            },\n            setItem: async (key, value)=>{\n                // We don't have an `onAuthStateChange` event that can let us know that\n                // the PKCE code verifier is being set. Therefore, if we see it being\n                // set, we need to apply the storage (call `setAll` so the cookie is\n                // set properly).\n                if (key.endsWith(\"-code-verifier\")) {\n                    await applyServerStorage({\n                        getAll,\n                        setAll,\n                        // pretend only that the code verifier was set\n                        setItems: {\n                            [key]: value\n                        },\n                        // pretend that nothing was removed\n                        removedItems: {}\n                    }, {\n                        cookieOptions: options?.cookieOptions ?? null,\n                        cookieEncoding\n                    });\n                }\n                setItems[key] = value;\n                delete removedItems[key];\n            },\n            removeItem: async (key)=>{\n                // Intentionally not applying the storage when the key is the PKCE code\n                // verifier, as usually right after it's removed other items are set,\n                // so application of the storage will be handled by the\n                // `onAuthStateChange` callback that follows removal -- usually as part\n                // of the `exchangeCodeForSession` call.\n                delete setItems[key];\n                removedItems[key] = true;\n            }\n        }\n    };\n}\n/**\n * When createServerClient needs to apply the created storage to cookies, it\n * should call this function which handles correcly setting cookies for stored\n * and removed items in the storage.\n */ async function applyServerStorage({ getAll, setAll, setItems, removedItems }, options) {\n    const cookieEncoding = options.cookieEncoding;\n    const cookieOptions = options.cookieOptions ?? null;\n    const allCookies = await getAll([\n        ...setItems ? Object.keys(setItems) : [],\n        ...removedItems ? Object.keys(removedItems) : []\n    ]);\n    const cookieNames = allCookies?.map(({ name })=>name) || [];\n    const removeCookies = Object.keys(removedItems).flatMap((itemName)=>{\n        return cookieNames.filter((name)=>(0,_utils__WEBPACK_IMPORTED_MODULE_0__.isChunkLike)(name, itemName));\n    });\n    const setCookies = Object.keys(setItems).flatMap((itemName)=>{\n        const removeExistingCookiesForItem = new Set(cookieNames.filter((name)=>(0,_utils__WEBPACK_IMPORTED_MODULE_0__.isChunkLike)(name, itemName)));\n        let encoded = setItems[itemName];\n        if (cookieEncoding === \"base64url\") {\n            encoded = BASE64_PREFIX + (0,_utils__WEBPACK_IMPORTED_MODULE_0__.stringToBase64URL)(encoded);\n        }\n        const chunks = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.createChunks)(itemName, encoded);\n        chunks.forEach((chunk)=>{\n            removeExistingCookiesForItem.delete(chunk.name);\n        });\n        removeCookies.push(...removeExistingCookiesForItem);\n        return chunks;\n    });\n    const removeCookieOptions = {\n        ..._utils__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_COOKIE_OPTIONS,\n        ...cookieOptions,\n        maxAge: 0\n    };\n    const setCookieOptions = {\n        ..._utils__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_COOKIE_OPTIONS,\n        ...cookieOptions,\n        maxAge: _utils__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_COOKIE_OPTIONS.maxAge\n    };\n    // the NextJS cookieStore API can get confused if the `name` from\n    // options.cookieOptions leaks\n    delete removeCookieOptions.name;\n    delete setCookieOptions.name;\n    await setAll([\n        ...removeCookies.map((name)=>({\n                name,\n                value: \"\",\n                options: removeCookieOptions\n            })),\n        ...setCookies.map(({ name, value })=>({\n                name,\n                value,\n                options: setCookieOptions\n            }))\n    ]);\n} //# sourceMappingURL=cookies.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Nzci9kaXN0L21vZHVsZS9jb29raWVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMEM7QUFDcUc7QUFDL0ksTUFBTVMsZ0JBQWdCO0FBQ3RCOzs7Ozs7O0NBT0MsR0FDTSxTQUFTQyx5QkFBeUJDLE9BQU8sRUFBRUMsY0FBYztJQUM1RCxNQUFNQyxVQUFVRixRQUFRRSxPQUFPLElBQUk7SUFDbkMsTUFBTUMsaUJBQWlCSCxRQUFRRyxjQUFjO0lBQzdDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNQyxlQUFlLENBQUM7SUFDdEIsSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlMLFNBQVM7UUFDVCxJQUFJLFNBQVNBLFNBQVM7WUFDbEIsdUVBQXVFO1lBQ3ZFLHNFQUFzRTtZQUN0RSx3RUFBd0U7WUFDeEUsdUVBQXVFO1lBQ3ZFLHlFQUF5RTtZQUN6RSxxRUFBcUU7WUFDckUsa0NBQWtDO1lBQ2xDLE1BQU1NLGVBQWUsT0FBT0M7Z0JBQ3hCLHlFQUF5RTtnQkFDekUsTUFBTUMsYUFBYUQsU0FBU0UsT0FBTyxDQUFDLENBQUNDLFVBQVk7d0JBQzdDQTsyQkFDR0MsTUFBTUMsSUFBSSxDQUFDOzRCQUFFQyxRQUFRO3dCQUFFLEdBQUdDLEdBQUcsQ0FBQyxDQUFDQyxHQUFHQyxJQUFNLENBQUMsRUFBRU4sUUFBUSxDQUFDLEVBQUVNLEVBQUUsQ0FBQztxQkFDL0Q7Z0JBQ0QsTUFBTUMsU0FBUyxFQUFFO2dCQUNqQixJQUFLLElBQUlELElBQUksR0FBR0EsSUFBSVIsV0FBV0ssTUFBTSxFQUFFRyxLQUFLLEVBQUc7b0JBQzNDLE1BQU1FLFFBQVEsTUFBTWxCLFFBQVFtQixHQUFHLENBQUNYLFVBQVUsQ0FBQ1EsRUFBRTtvQkFDN0MsSUFBSSxDQUFDRSxTQUFTLE9BQU9BLFVBQVUsVUFBVTt3QkFDckM7b0JBQ0o7b0JBQ0FELE9BQU9HLElBQUksQ0FBQzt3QkFBRUMsTUFBTWIsVUFBVSxDQUFDUSxFQUFFO3dC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QixNQUFNd0M7UUFDNUYsSUFBSVYsVUFBVWpELFFBQVEsQ0FBQzJELFNBQVM7UUFDaEMsSUFBSTVELG1CQUFtQixhQUFhO1lBQ2hDa0QsVUFBVXZELGdCQUFnQkQseURBQWlCQSxDQUFDd0Q7UUFDaEQ7UUFDQSxNQUFNbEMsU0FBUzFCLG9EQUFZQSxDQUFDc0UsVUFBVVY7UUFDdENsQyxPQUFPaUIsT0FBTyxDQUFDLENBQUM2QjtZQUNaRCw2QkFBNkJWLE1BQU0sQ0FBQ1csTUFBTTFDLElBQUk7UUFDbEQ7UUFDQTJCLGNBQWM1QixJQUFJLElBQUkwQztRQUN0QixPQUFPN0M7SUFDWDtJQUNBLE1BQU1vQyxzQkFBc0I7UUFDeEIsR0FBR2hFLDBEQUFzQjtRQUN6QixHQUFHaUUsYUFBYTtRQUNoQkMsUUFBUTtJQUNaO0lBQ0EsTUFBTUMsbUJBQW1CO1FBQ3JCLEdBQUduRSwwREFBc0I7UUFDekIsR0FBR2lFLGFBQWE7UUFDaEJDLFFBQVFsRSwwREFBc0JBLENBQUNrRSxNQUFNO0lBQ3pDO0lBQ0EsaUVBQWlFO0lBQ2pFLDhCQUE4QjtJQUM5QixPQUFPRixvQkFBb0JoQyxJQUFJO0lBQy9CLE9BQU9tQyxpQkFBaUJuQyxJQUFJO0lBQzVCLE1BQU1oQixPQUFPO1dBQ04yQyxjQUFjbEMsR0FBRyxDQUFDLENBQUNPLE9BQVU7Z0JBQzVCQTtnQkFDQUgsT0FBTztnQkFDUHBCLFNBQVN1RDtZQUNiO1dBQ0cvQixXQUFXUixHQUFHLENBQUMsQ0FBQyxFQUFFTyxJQUFJLEVBQUVILEtBQUssRUFBRSxHQUFNO2dCQUNwQ0c7Z0JBQ0FIO2dCQUNBcEIsU0FBUzBEO1lBQ2I7S0FDSDtBQUNMLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5jaG9yLXdvcmtmbG93cy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3NyL2Rpc3QvbW9kdWxlL2Nvb2tpZXMuanM/MGUwNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZSwgc2VyaWFsaXplIH0gZnJvbSBcImNvb2tpZVwiO1xuaW1wb3J0IHsgREVGQVVMVF9DT09LSUVfT1BUSU9OUywgY29tYmluZUNodW5rcywgY3JlYXRlQ2h1bmtzLCBpc0Jyb3dzZXIsIGlzQ2h1bmtMaWtlLCBzdHJpbmdGcm9tQmFzZTY0VVJMLCBzdHJpbmdUb0Jhc2U2NFVSTCwgfSBmcm9tIFwiLi91dGlsc1wiO1xuY29uc3QgQkFTRTY0X1BSRUZJWCA9IFwiYmFzZTY0LVwiO1xuLyoqXG4gKiBDcmVhdGVzIGEgc3RvcmFnZSBjbGllbnQgdGhhdCBoYW5kbGVzIGNvb2tpZXMgY29ycmVjdGx5IGZvciBicm93c2VyIGFuZFxuICogc2VydmVyIGNsaWVudHMgd2l0aCBvciB3aXRob3V0IHByb3Blcmx5IHByb3ZpZGVkIGNvb2tpZSBtZXRob2RzLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIHBhc3NlZCB0byBjcmVhdGVCcm93c2VyQ2xpZW50IG9yIGNyZWF0ZVNlcnZlciBjbGllbnQuXG4gKlxuICogQHBhcmFtIGlzU2VydmVyQ2xpZW50IFdoZXRoZXIgaXQncyBjYWxsZWQgZnJvbSBjcmVhdGVTZXJ2ZXJDbGllbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdG9yYWdlRnJvbU9wdGlvbnMob3B0aW9ucywgaXNTZXJ2ZXJDbGllbnQpIHtcbiAgICBjb25zdCBjb29raWVzID0gb3B0aW9ucy5jb29raWVzID8/IG51bGw7XG4gICAgY29uc3QgY29va2llRW5jb2RpbmcgPSBvcHRpb25zLmNvb2tpZUVuY29kaW5nO1xuICAgIGNvbnN0IHNldEl0ZW1zID0ge307XG4gICAgY29uc3QgcmVtb3ZlZEl0ZW1zID0ge307XG4gICAgbGV0IGdldEFsbDtcbiAgICBsZXQgc2V0QWxsO1xuICAgIGlmIChjb29raWVzKSB7XG4gICAgICAgIGlmIChcImdldFwiIGluIGNvb2tpZXMpIHtcbiAgICAgICAgICAgIC8vIEp1c3QgZ2V0IGlzIG5vdCBlbm91Z2gsIGJlY2F1c2UgdGhlIGNsaWVudCBuZWVkcyB0byBzZWUgd2hhdCBjb29raWVzXG4gICAgICAgICAgICAvLyBhcmUgYWxyZWFkeSBzZXQgYW5kIHVuc2V0IHRoZW0gaWYgbmVjZXNzYXJ5LiBUbyBhdHRlbXB0IHRvIGZpeCB0aGlzXG4gICAgICAgICAgICAvLyBiZWhhdmlvciBmb3IgbW9zdCB1c2UgY2FzZXMsIHdlIHBhc3MgXCJoaW50c1wiIHdoaWNoIGlzIHRoZSBrZXlzIG9mIHRoZVxuICAgICAgICAgICAgLy8gc3RvcmFnZSBpdGVtcy4gVGhleSBhcmUgdGhlbiBjb252ZXJ0ZWQgdG8gdGhlaXIgY29ycmVzcG9uZGluZyBjb29raWVcbiAgICAgICAgICAgIC8vIGNodW5rIG5hbWVzIGFuZCBhcmUgZmV0Y2hlZCB3aXRoIGdldC4gT25seSA1IGNodW5rcyBhcmUgZmV0Y2hlZCwgd2hpY2hcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSBlbm91Z2ggZm9yIHRoZSBtYWpvcml0eSBvZiB1c2UgY2FzZXMsIGJ1dCBkb2VzIG5vdCBzb2x2ZVxuICAgICAgICAgICAgLy8gdGhvc2Ugd2l0aCB2ZXJ5IGxhcmdlIHNlc3Npb25zLlxuICAgICAgICAgICAgY29uc3QgZ2V0V2l0aEhpbnRzID0gYXN5bmMgKGtleUhpbnRzKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gb3B0aW1pc3RpY2FsbHkgZmluZCB0aGUgZmlyc3QgNSBwb3RlbnRpYWwgY2h1bmtzIGZvciB0aGUgc3BlY2lmaWVkIGtleVxuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rTmFtZXMgPSBrZXlIaW50cy5mbGF0TWFwKChrZXlIaW50KSA9PiBbXG4gICAgICAgICAgICAgICAgICAgIGtleUhpbnQsXG4gICAgICAgICAgICAgICAgICAgIC4uLkFycmF5LmZyb20oeyBsZW5ndGg6IDUgfSkubWFwKChfLCBpKSA9PiBgJHtrZXlIaW50fS4ke2l9YCksXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua05hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgY29va2llcy5nZXQoY2h1bmtOYW1lc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUgJiYgdHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaCh7IG5hbWU6IGNodW5rTmFtZXNbaV0sIHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBkZXRlY3QgYW5kIGxvZyBzdGFsZSBjaHVua3MgZXJyb3JcbiAgICAgICAgICAgICAgICByZXR1cm4gY2h1bmtzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdldEFsbCA9IGFzeW5jIChrZXlIaW50cykgPT4gYXdhaXQgZ2V0V2l0aEhpbnRzKGtleUhpbnRzKTtcbiAgICAgICAgICAgIGlmIChcInNldFwiIGluIGNvb2tpZXMgJiYgXCJyZW1vdmVcIiBpbiBjb29raWVzKSB7XG4gICAgICAgICAgICAgICAgc2V0QWxsID0gYXN5bmMgKHNldENvb2tpZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXRDb29raWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG5hbWUsIHZhbHVlLCBvcHRpb25zIH0gPSBzZXRDb29raWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgY29va2llcy5zZXQobmFtZSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgY29va2llcy5yZW1vdmUobmFtZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNTZXJ2ZXJDbGllbnQpIHtcbiAgICAgICAgICAgICAgICBzZXRBbGwgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkBzdXBhYmFzZS9zc3I6IGNyZWF0ZVNlcnZlckNsaWVudCB3YXMgY29uZmlndXJlZCB3aXRob3V0IHNldCBhbmQgcmVtb3ZlIGNvb2tpZSBtZXRob2RzLCBidXQgdGhlIGNsaWVudCBuZWVkcyB0byBzZXQgY29va2llcy4gVGhpcyBjYW4gbGVhZCB0byBpc3N1ZXMgc3VjaCBhcyByYW5kb20gbG9nb3V0cywgZWFybHkgc2Vzc2lvbiB0ZXJtaW5hdGlvbiBvciBpbmNyZWFzZWQgdG9rZW4gcmVmcmVzaCByZXF1ZXN0cy4gSWYgaW4gTmV4dEpTLCBjaGVjayB5b3VyIG1pZGRsZXdhcmUudHMgZmlsZSwgcm91dGUgaGFuZGxlcnMgYW5kIHNlcnZlciBhY3Rpb25zIGZvciBjb3JyZWN0bmVzcy4gQ29uc2lkZXIgc3dpdGNoaW5nIHRvIHRoZSBnZXRBbGwgYW5kIHNldEFsbCBjb29raWUgbWV0aG9kcyBpbnN0ZWFkIG9mIGdldCwgc2V0IGFuZCByZW1vdmUgd2hpY2ggYXJlIGRlcHJlY2F0ZWQgYW5kIGNhbiBiZSBkaWZmaWN1bHQgdG8gdXNlIGNvcnJlY3RseS5cIik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBzdXBhYmFzZS9zc3I6IGNyZWF0ZUJyb3dzZXJDbGllbnQgcmVxdWlyZXMgY29uZmlndXJpbmcgYSBnZXRBbGwgYW5kIHNldEFsbCBjb29raWUgbWV0aG9kIChkZXByZWNhdGVkOiBhbHRlcm5hdGl2ZWx5IGJvdGggZ2V0LCBzZXQgYW5kIHJlbW92ZSBjYW4gYmUgdXNlZClcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXCJnZXRBbGxcIiBpbiBjb29raWVzKSB7XG4gICAgICAgICAgICBnZXRBbGwgPSBhc3luYyAoKSA9PiBhd2FpdCBjb29raWVzLmdldEFsbCgpO1xuICAgICAgICAgICAgaWYgKFwic2V0QWxsXCIgaW4gY29va2llcykge1xuICAgICAgICAgICAgICAgIHNldEFsbCA9IGNvb2tpZXMuc2V0QWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNTZXJ2ZXJDbGllbnQpIHtcbiAgICAgICAgICAgICAgICBzZXRBbGwgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkBzdXBhYmFzZS9zc3I6IGNyZWF0ZVNlcnZlckNsaWVudCB3YXMgY29uZmlndXJlZCB3aXRob3V0IHRoZSBzZXRBbGwgY29va2llIG1ldGhvZCwgYnV0IHRoZSBjbGllbnQgbmVlZHMgdG8gc2V0IGNvb2tpZXMuIFRoaXMgY2FuIGxlYWQgdG8gaXNzdWVzIHN1Y2ggYXMgcmFuZG9tIGxvZ291dHMsIGVhcmx5IHNlc3Npb24gdGVybWluYXRpb24gb3IgaW5jcmVhc2VkIHRva2VuIHJlZnJlc2ggcmVxdWVzdHMuIElmIGluIE5leHRKUywgY2hlY2sgeW91ciBtaWRkbGV3YXJlLnRzIGZpbGUsIHJvdXRlIGhhbmRsZXJzIGFuZCBzZXJ2ZXIgYWN0aW9ucyBmb3IgY29ycmVjdG5lc3MuXCIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAc3VwYWJhc2Uvc3NyOiBjcmVhdGVCcm93c2VyQ2xpZW50IHJlcXVpcmVzIGNvbmZpZ3VyaW5nIGJvdGggZ2V0QWxsIGFuZCBzZXRBbGwgY29va2llIG1ldGhvZHMgKGRlcHJlY2F0ZWQ6IGFsdGVybmF0aXZlbHkgYm90aCBnZXQsIHNldCBhbmQgcmVtb3ZlIGNhbiBiZSB1c2VkKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5laXRoZXIgZ2V0IG5vciBnZXRBbGwgaXMgcHJlc2VudCBvbiBjb29raWVzLCBvbmx5IHdpbGwgb2NjdXIgaWYgcHVyZSBKYXZhU2NyaXB0IGlzIHVzZWQsIGJ1dCBjb29raWVzIGlzIGFuIG9iamVjdFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2Uvc3NyOiAke2lzU2VydmVyQ2xpZW50ID8gXCJjcmVhdGVTZXJ2ZXJDbGllbnRcIiA6IFwiY3JlYXRlQnJvd3NlckNsaWVudFwifSByZXF1aXJlcyBjb25maWd1cmluZyBnZXRBbGwgYW5kIHNldEFsbCBjb29raWUgbWV0aG9kcyAoZGVwcmVjYXRlZDogYWx0ZXJuYXRpdmVseSB1c2UgZ2V0LCBzZXQgYW5kIHJlbW92ZSkuJHtpc0Jyb3dzZXIoKSA/IFwiIEFzIHRoaXMgaXMgY2FsbGVkIGluIGEgYnJvd3NlciBydW50aW1lLCBjb25zaWRlciByZW1vdmluZyB0aGUgY29va2llcyBvcHRpb24gb2JqZWN0IHRvIHVzZSB0aGUgZG9jdW1lbnQuY29va2llIEFQSSBhdXRvbWF0aWNhbGx5LlwiIDogXCJcIn1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICghaXNTZXJ2ZXJDbGllbnQgJiYgaXNCcm93c2VyKCkpIHtcbiAgICAgICAgLy8gVGhlIGVudmlyb25tZW50IGlzIGJyb3dzZXIsIHNvIHVzZSB0aGUgZG9jdW1lbnQuY29va2llIEFQSSB0byBpbXBsZW1lbnQgZ2V0QWxsIGFuZCBzZXRBbGwuXG4gICAgICAgIGNvbnN0IG5vSGludEdldEFsbCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlKGRvY3VtZW50LmNvb2tpZSk7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocGFyc2VkKS5tYXAoKG5hbWUpID0+ICh7XG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGFyc2VkW25hbWVdID8/IFwiXCIsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIGdldEFsbCA9ICgpID0+IG5vSGludEdldEFsbCgpO1xuICAgICAgICBzZXRBbGwgPSAoc2V0Q29va2llcykgPT4ge1xuICAgICAgICAgICAgc2V0Q29va2llcy5mb3JFYWNoKCh7IG5hbWUsIHZhbHVlLCBvcHRpb25zIH0pID0+IHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBzZXJpYWxpemUobmFtZSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU2VydmVyQ2xpZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBzdXBhYmFzZS9zc3I6IGNyZWF0ZVNlcnZlckNsaWVudCBtdXN0IGJlIGluaXRpYWxpemVkIHdpdGggY29va2llIG9wdGlvbnMgdGhhdCBzcGVjaWZ5IGdldEFsbCBhbmQgc2V0QWxsIGZ1bmN0aW9ucyAoZGVwcmVjYXRlZCwgbm90IHJlY29tbWVuZGVkOiBhbHRlcm5hdGl2ZWx5IHVzZSBnZXQsIHNldCBhbmQgcmVtb3ZlKVwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGdldHRpbmcgY29va2llcyB3aGVuIHRoZXJlJ3Mgbm8gd2luZG93IGJ1dCB3ZSdyZSBpbiBicm93c2VyIG1vZGUgY2FuIGJlIE9LLCBiZWNhdXNlIHRoZSBkZXZlbG9wZXIgcHJvYmFibHkgaXMgbm90IHVzaW5nIGF1dGggZnVuY3Rpb25zXG4gICAgICAgIGdldEFsbCA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gdGhpcyBpcyBOT1QgT0sgYmVjYXVzZSB0aGUgZGV2ZWxvcGVyIGlzIHVzaW5nIGF1dGggZnVuY3Rpb25zIHRoYXQgcmVxdWlyZSBzZXR0aW5nIHNvbWUgc3RhdGUsIHNvIHRoYXQgbXVzdCBlcnJvciBvdXRcbiAgICAgICAgc2V0QWxsID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQHN1cGFiYXNlL3NzcjogY3JlYXRlQnJvd3NlckNsaWVudCBpbiBub24tYnJvd3NlciBydW50aW1lcyAoaW5jbHVkaW5nIE5leHQuanMgcHJlLXJlbmRlcmluZyBtb2RlKSB3YXMgbm90IGluaXRpYWxpemVkIGNvb2tpZSBvcHRpb25zIHRoYXQgc3BlY2lmeSBnZXRBbGwgYW5kIHNldEFsbCBmdW5jdGlvbnMgKGRlcHJlY2F0ZWQ6IGFsdGVybmF0aXZlbHkgdXNlIGdldCwgc2V0IGFuZCByZW1vdmUpLCBidXQgdGhleSB3ZXJlIG5lZWRlZFwiKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFpc1NlcnZlckNsaWVudCkge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSBzdG9yYWdlIGNsaWVudCB0byBiZSB1c2VkIGluIGJyb3dzZXJzLiBJdCBvbmx5XG4gICAgICAgIC8vIHdvcmtzIG9uIHRoZSBjb29raWVzIGFic3RyYWN0aW9uLCB1bmxpa2UgdGhlIHNlcnZlciBjbGllbnRcbiAgICAgICAgLy8gd2hpY2ggb25seSB1c2VzIGNvb2tpZXMgdG8gcmVhZCB0aGUgaW5pdGlhbCBzdGF0ZS4gV2hlbiBhblxuICAgICAgICAvLyBpdGVtIGlzIHNldCwgY29va2llcyBhcmUgYm90aCBjbGVhcmVkIGFuZCBzZXQgdG8gdmFsdWVzIHNvXG4gICAgICAgIC8vIHRoYXQgc3RhbGUgY2h1bmtzIGFyZSBub3QgbGVmdCByZW1haW5pbmcuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXRBbGwsIC8vIGZvciB0eXBlIGNvbnNpc3RlbmN5XG4gICAgICAgICAgICBzZXRBbGwsIC8vIGZvciB0eXBlIGNvbnNpc3RlbmN5XG4gICAgICAgICAgICBzZXRJdGVtcywgLy8gZm9yIHR5cGUgY29uc2lzdGVuY3lcbiAgICAgICAgICAgIHJlbW92ZWRJdGVtcywgLy8gZm9yIHR5cGUgY29uc2lzdGVuY3lcbiAgICAgICAgICAgIHN0b3JhZ2U6IHtcbiAgICAgICAgICAgICAgICBpc1NlcnZlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgZ2V0SXRlbTogYXN5bmMgKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxDb29raWVzID0gYXdhaXQgZ2V0QWxsKFtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmtlZENvb2tpZSA9IGF3YWl0IGNvbWJpbmVDaHVua3Moa2V5LCBhc3luYyAoY2h1bmtOYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb29raWUgPSBhbGxDb29raWVzPy5maW5kKCh7IG5hbWUgfSkgPT4gbmFtZSA9PT0gY2h1bmtOYW1lKSB8fCBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb29raWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb29raWUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNodW5rZWRDb29raWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBkZWNvZGVkID0gY2h1bmtlZENvb2tpZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rZWRDb29raWUuc3RhcnRzV2l0aChCQVNFNjRfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZCA9IHN0cmluZ0Zyb21CYXNlNjRVUkwoY2h1bmtlZENvb2tpZS5zdWJzdHJpbmcoQkFTRTY0X1BSRUZJWC5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlZDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldEl0ZW06IGFzeW5jIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbENvb2tpZXMgPSBhd2FpdCBnZXRBbGwoW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb29raWVOYW1lcyA9IGFsbENvb2tpZXM/Lm1hcCgoeyBuYW1lIH0pID0+IG5hbWUpIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW1vdmVDb29raWVzID0gbmV3IFNldChjb29raWVOYW1lcy5maWx0ZXIoKG5hbWUpID0+IGlzQ2h1bmtMaWtlKG5hbWUsIGtleSkpKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuY29kZWQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvb2tpZUVuY29kaW5nID09PSBcImJhc2U2NHVybFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVkID0gQkFTRTY0X1BSRUZJWCArIHN0cmluZ1RvQmFzZTY0VVJMKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXRDb29raWVzID0gY3JlYXRlQ2h1bmtzKGtleSwgZW5jb2RlZCk7XG4gICAgICAgICAgICAgICAgICAgIHNldENvb2tpZXMuZm9yRWFjaCgoeyBuYW1lIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNvb2tpZXMuZGVsZXRlKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlQ29va2llT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLkRFRkFVTFRfQ09PS0lFX09QVElPTlMsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zPy5jb29raWVPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4QWdlOiAwLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXRDb29raWVPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uREVGQVVMVF9DT09LSUVfT1BUSU9OUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnM/LmNvb2tpZU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhBZ2U6IERFRkFVTFRfQ09PS0lFX09QVElPTlMubWF4QWdlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgTmV4dEpTIGNvb2tpZVN0b3JlIEFQSSBjYW4gZ2V0IGNvbmZ1c2VkIGlmIHRoZSBgbmFtZWAgZnJvbVxuICAgICAgICAgICAgICAgICAgICAvLyBvcHRpb25zLmNvb2tpZU9wdGlvbnMgbGVha3NcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlbW92ZUNvb2tpZU9wdGlvbnMubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNldENvb2tpZU9wdGlvbnMubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsVG9TZXQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5bLi4ucmVtb3ZlQ29va2llc10ubWFwKChuYW1lKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogcmVtb3ZlQ29va2llT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnNldENvb2tpZXMubWFwKCh7IG5hbWUsIHZhbHVlIH0pID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBzZXRDb29raWVPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsVG9TZXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2V0QWxsKGFsbFRvU2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVtb3ZlSXRlbTogYXN5bmMgKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxDb29raWVzID0gYXdhaXQgZ2V0QWxsKFtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29va2llTmFtZXMgPSBhbGxDb29raWVzPy5tYXAoKHsgbmFtZSB9KSA9PiBuYW1lKSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlQ29va2llcyA9IGNvb2tpZU5hbWVzLmZpbHRlcigobmFtZSkgPT4gaXNDaHVua0xpa2UobmFtZSwga2V5KSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbW92ZUNvb2tpZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5ERUZBVUxUX0NPT0tJRV9PUFRJT05TLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ub3B0aW9ucz8uY29va2llT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEFnZTogMCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIE5leHRKUyBjb29raWVTdG9yZSBBUEkgY2FuIGdldCBjb25mdXNlZCBpZiB0aGUgYG5hbWVgIGZyb21cbiAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW9ucy5jb29raWVPcHRpb25zIGxlYWtzXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZW1vdmVDb29raWVPcHRpb25zLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdmVDb29raWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHNldEFsbChyZW1vdmVDb29raWVzLm1hcCgobmFtZSkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHJlbW92ZUNvb2tpZU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgdGhlIHNlcnZlciBjbGllbnQuIEl0IG9ubHkgdXNlcyBnZXRBbGwgdG8gcmVhZCB0aGUgaW5pdGlhbFxuICAgIC8vIHN0YXRlLiBBbnkgc3Vic2VxdWVudCBjaGFuZ2VzIHRvIHRoZSBpdGVtcyBpcyBwZXJzaXN0ZWQgaW4gdGhlXG4gICAgLy8gc2V0SXRlbXMgYW5kIHJlbW92ZWRJdGVtcyBvYmplY3RzLiBjcmVhdGVTZXJ2ZXJDbGllbnQgKm11c3QqIHVzZVxuICAgIC8vIGdldEFsbCwgc2V0QWxsIGFuZCB0aGUgdmFsdWVzIGluIHNldEl0ZW1zIGFuZCByZW1vdmVkSXRlbXMgdG9cbiAgICAvLyBwZXJzaXN0IHRoZSBjaGFuZ2VzICphdCBvbmNlKiB3aGVuIGFwcHJvcHJpYXRlICh1c3VhbGx5IG9ubHkgd2hlblxuICAgIC8vIHRoZSBUT0tFTl9SRUZSRVNIRUQsIFVTRVJfVVBEQVRFRCBvciBTSUdORURfT1VUIGV2ZW50cyBhcmUgZmlyZWQgYnlcbiAgICAvLyB0aGUgU3VwYWJhc2UgQXV0aCBjbGllbnQpLlxuICAgIHJldHVybiB7XG4gICAgICAgIGdldEFsbCxcbiAgICAgICAgc2V0QWxsLFxuICAgICAgICBzZXRJdGVtcyxcbiAgICAgICAgcmVtb3ZlZEl0ZW1zLFxuICAgICAgICBzdG9yYWdlOiB7XG4gICAgICAgICAgICAvLyB0byBzaWduYWwgdG8gdGhlIGxpYnJhcmllcyB0aGF0IHRoZXNlIGNvb2tpZXMgYXJlXG4gICAgICAgICAgICAvLyBjb21pbmcgZnJvbSBhIHNlcnZlciBlbnZpcm9ubWVudCBhbmQgdGhlaXIgdmFsdWVcbiAgICAgICAgICAgIC8vIHNob3VsZCBub3QgYmUgdHJ1c3RlZFxuICAgICAgICAgICAgaXNTZXJ2ZXI6IHRydWUsXG4gICAgICAgICAgICBnZXRJdGVtOiBhc3luYyAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXRJdGVtc1trZXldID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRJdGVtc1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZEl0ZW1zW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGFsbENvb2tpZXMgPSBhd2FpdCBnZXRBbGwoW2tleV0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rZWRDb29raWUgPSBhd2FpdCBjb21iaW5lQ2h1bmtzKGtleSwgYXN5bmMgKGNodW5rTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb29raWUgPSBhbGxDb29raWVzPy5maW5kKCh7IG5hbWUgfSkgPT4gbmFtZSA9PT0gY2h1bmtOYW1lKSB8fCBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvb2tpZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvb2tpZS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWNodW5rZWRDb29raWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBkZWNvZGVkID0gY2h1bmtlZENvb2tpZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNodW5rZWRDb29raWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtlZENvb2tpZS5zdGFydHNXaXRoKEJBU0U2NF9QUkVGSVgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZWQgPSBzdHJpbmdGcm9tQmFzZTY0VVJMKGNodW5rZWRDb29raWUuc3Vic3RyaW5nKEJBU0U2NF9QUkVGSVgubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldEl0ZW06IGFzeW5jIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBhbiBgb25BdXRoU3RhdGVDaGFuZ2VgIGV2ZW50IHRoYXQgY2FuIGxldCB1cyBrbm93IHRoYXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgUEtDRSBjb2RlIHZlcmlmaWVyIGlzIGJlaW5nIHNldC4gVGhlcmVmb3JlLCBpZiB3ZSBzZWUgaXQgYmVpbmdcbiAgICAgICAgICAgICAgICAvLyBzZXQsIHdlIG5lZWQgdG8gYXBwbHkgdGhlIHN0b3JhZ2UgKGNhbGwgYHNldEFsbGAgc28gdGhlIGNvb2tpZSBpc1xuICAgICAgICAgICAgICAgIC8vIHNldCBwcm9wZXJseSkuXG4gICAgICAgICAgICAgICAgaWYgKGtleS5lbmRzV2l0aChcIi1jb2RlLXZlcmlmaWVyXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGFwcGx5U2VydmVyU3RvcmFnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRBbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmV0ZW5kIG9ubHkgdGhhdCB0aGUgY29kZSB2ZXJpZmllciB3YXMgc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRJdGVtczogeyBba2V5XTogdmFsdWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXRlbmQgdGhhdCBub3RoaW5nIHdhcyByZW1vdmVkXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkSXRlbXM6IHt9LFxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb29raWVPcHRpb25zOiBvcHRpb25zPy5jb29raWVPcHRpb25zID8/IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29raWVFbmNvZGluZyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldEl0ZW1zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVtb3ZlZEl0ZW1zW2tleV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlSXRlbTogYXN5bmMgKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEludGVudGlvbmFsbHkgbm90IGFwcGx5aW5nIHRoZSBzdG9yYWdlIHdoZW4gdGhlIGtleSBpcyB0aGUgUEtDRSBjb2RlXG4gICAgICAgICAgICAgICAgLy8gdmVyaWZpZXIsIGFzIHVzdWFsbHkgcmlnaHQgYWZ0ZXIgaXQncyByZW1vdmVkIG90aGVyIGl0ZW1zIGFyZSBzZXQsXG4gICAgICAgICAgICAgICAgLy8gc28gYXBwbGljYXRpb24gb2YgdGhlIHN0b3JhZ2Ugd2lsbCBiZSBoYW5kbGVkIGJ5IHRoZVxuICAgICAgICAgICAgICAgIC8vIGBvbkF1dGhTdGF0ZUNoYW5nZWAgY2FsbGJhY2sgdGhhdCBmb2xsb3dzIHJlbW92YWwgLS0gdXN1YWxseSBhcyBwYXJ0XG4gICAgICAgICAgICAgICAgLy8gb2YgdGhlIGBleGNoYW5nZUNvZGVGb3JTZXNzaW9uYCBjYWxsLlxuICAgICAgICAgICAgICAgIGRlbGV0ZSBzZXRJdGVtc1trZXldO1xuICAgICAgICAgICAgICAgIHJlbW92ZWRJdGVtc1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogV2hlbiBjcmVhdGVTZXJ2ZXJDbGllbnQgbmVlZHMgdG8gYXBwbHkgdGhlIGNyZWF0ZWQgc3RvcmFnZSB0byBjb29raWVzLCBpdFxuICogc2hvdWxkIGNhbGwgdGhpcyBmdW5jdGlvbiB3aGljaCBoYW5kbGVzIGNvcnJlY2x5IHNldHRpbmcgY29va2llcyBmb3Igc3RvcmVkXG4gKiBhbmQgcmVtb3ZlZCBpdGVtcyBpbiB0aGUgc3RvcmFnZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFwcGx5U2VydmVyU3RvcmFnZSh7IGdldEFsbCwgc2V0QWxsLCBzZXRJdGVtcywgcmVtb3ZlZEl0ZW1zLCB9LCBvcHRpb25zKSB7XG4gICAgY29uc3QgY29va2llRW5jb2RpbmcgPSBvcHRpb25zLmNvb2tpZUVuY29kaW5nO1xuICAgIGNvbnN0IGNvb2tpZU9wdGlvbnMgPSBvcHRpb25zLmNvb2tpZU9wdGlvbnMgPz8gbnVsbDtcbiAgICBjb25zdCBhbGxDb29raWVzID0gYXdhaXQgZ2V0QWxsKFtcbiAgICAgICAgLi4uKHNldEl0ZW1zID8gT2JqZWN0LmtleXMoc2V0SXRlbXMpIDogW10pLFxuICAgICAgICAuLi4ocmVtb3ZlZEl0ZW1zID8gT2JqZWN0LmtleXMocmVtb3ZlZEl0ZW1zKSA6IFtdKSxcbiAgICBdKTtcbiAgICBjb25zdCBjb29raWVOYW1lcyA9IGFsbENvb2tpZXM/Lm1hcCgoeyBuYW1lIH0pID0+IG5hbWUpIHx8IFtdO1xuICAgIGNvbnN0IHJlbW92ZUNvb2tpZXMgPSBPYmplY3Qua2V5cyhyZW1vdmVkSXRlbXMpLmZsYXRNYXAoKGl0ZW1OYW1lKSA9PiB7XG4gICAgICAgIHJldHVybiBjb29raWVOYW1lcy5maWx0ZXIoKG5hbWUpID0+IGlzQ2h1bmtMaWtlKG5hbWUsIGl0ZW1OYW1lKSk7XG4gICAgfSk7XG4gICAgY29uc3Qgc2V0Q29va2llcyA9IE9iamVjdC5rZXlzKHNldEl0ZW1zKS5mbGF0TWFwKChpdGVtTmFtZSkgPT4ge1xuICAgICAgICBjb25zdCByZW1vdmVFeGlzdGluZ0Nvb2tpZXNGb3JJdGVtID0gbmV3IFNldChjb29raWVOYW1lcy5maWx0ZXIoKG5hbWUpID0+IGlzQ2h1bmtMaWtlKG5hbWUsIGl0ZW1OYW1lKSkpO1xuICAgICAgICBsZXQgZW5jb2RlZCA9IHNldEl0ZW1zW2l0ZW1OYW1lXTtcbiAgICAgICAgaWYgKGNvb2tpZUVuY29kaW5nID09PSBcImJhc2U2NHVybFwiKSB7XG4gICAgICAgICAgICBlbmNvZGVkID0gQkFTRTY0X1BSRUZJWCArIHN0cmluZ1RvQmFzZTY0VVJMKGVuY29kZWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNodW5rcyA9IGNyZWF0ZUNodW5rcyhpdGVtTmFtZSwgZW5jb2RlZCk7XG4gICAgICAgIGNodW5rcy5mb3JFYWNoKChjaHVuaykgPT4ge1xuICAgICAgICAgICAgcmVtb3ZlRXhpc3RpbmdDb29raWVzRm9ySXRlbS5kZWxldGUoY2h1bmsubmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZW1vdmVDb29raWVzLnB1c2goLi4ucmVtb3ZlRXhpc3RpbmdDb29raWVzRm9ySXRlbSk7XG4gICAgICAgIHJldHVybiBjaHVua3M7XG4gICAgfSk7XG4gICAgY29uc3QgcmVtb3ZlQ29va2llT3B0aW9ucyA9IHtcbiAgICAgICAgLi4uREVGQVVMVF9DT09LSUVfT1BUSU9OUyxcbiAgICAgICAgLi4uY29va2llT3B0aW9ucyxcbiAgICAgICAgbWF4QWdlOiAwLFxuICAgIH07XG4gICAgY29uc3Qgc2V0Q29va2llT3B0aW9ucyA9IHtcbiAgICAgICAgLi4uREVGQVVMVF9DT09LSUVfT1BUSU9OUyxcbiAgICAgICAgLi4uY29va2llT3B0aW9ucyxcbiAgICAgICAgbWF4QWdlOiBERUZBVUxUX0NPT0tJRV9PUFRJT05TLm1heEFnZSxcbiAgICB9O1xuICAgIC8vIHRoZSBOZXh0SlMgY29va2llU3RvcmUgQVBJIGNhbiBnZXQgY29uZnVzZWQgaWYgdGhlIGBuYW1lYCBmcm9tXG4gICAgLy8gb3B0aW9ucy5jb29raWVPcHRpb25zIGxlYWtzXG4gICAgZGVsZXRlIHJlbW92ZUNvb2tpZU9wdGlvbnMubmFtZTtcbiAgICBkZWxldGUgc2V0Q29va2llT3B0aW9ucy5uYW1lO1xuICAgIGF3YWl0IHNldEFsbChbXG4gICAgICAgIC4uLnJlbW92ZUNvb2tpZXMubWFwKChuYW1lKSA9PiAoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiBcIlwiLFxuICAgICAgICAgICAgb3B0aW9uczogcmVtb3ZlQ29va2llT3B0aW9ucyxcbiAgICAgICAgfSkpLFxuICAgICAgICAuLi5zZXRDb29raWVzLm1hcCgoeyBuYW1lLCB2YWx1ZSB9KSA9PiAoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgb3B0aW9uczogc2V0Q29va2llT3B0aW9ucyxcbiAgICAgICAgfSkpLFxuICAgIF0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29va2llcy5qcy5tYXAiXSwibmFtZXMiOlsicGFyc2UiLCJzZXJpYWxpemUiLCJERUZBVUxUX0NPT0tJRV9PUFRJT05TIiwiY29tYmluZUNodW5rcyIsImNyZWF0ZUNodW5rcyIsImlzQnJvd3NlciIsImlzQ2h1bmtMaWtlIiwic3RyaW5nRnJvbUJhc2U2NFVSTCIsInN0cmluZ1RvQmFzZTY0VVJMIiwiQkFTRTY0X1BSRUZJWCIsImNyZWF0ZVN0b3JhZ2VGcm9tT3B0aW9ucyIsIm9wdGlvbnMiLCJpc1NlcnZlckNsaWVudCIsImNvb2tpZXMiLCJjb29raWVFbmNvZGluZyIsInNldEl0ZW1zIiwicmVtb3ZlZEl0ZW1zIiwiZ2V0QWxsIiwic2V0QWxsIiwiZ2V0V2l0aEhpbnRzIiwia2V5SGludHMiLCJjaHVua05hbWVzIiwiZmxhdE1hcCIsImtleUhpbnQiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJtYXAiLCJfIiwiaSIsImNodW5rcyIsInZhbHVlIiwiZ2V0IiwicHVzaCIsIm5hbWUiLCJzZXRDb29raWVzIiwic2V0IiwicmVtb3ZlIiwiY29uc29sZSIsIndhcm4iLCJFcnJvciIsIm5vSGludEdldEFsbCIsInBhcnNlZCIsImRvY3VtZW50IiwiY29va2llIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJzdG9yYWdlIiwiaXNTZXJ2ZXIiLCJnZXRJdGVtIiwia2V5IiwiYWxsQ29va2llcyIsImNodW5rZWRDb29raWUiLCJjaHVua05hbWUiLCJmaW5kIiwiZGVjb2RlZCIsInN0YXJ0c1dpdGgiLCJzdWJzdHJpbmciLCJzZXRJdGVtIiwiY29va2llTmFtZXMiLCJyZW1vdmVDb29raWVzIiwiU2V0IiwiZmlsdGVyIiwiZW5jb2RlZCIsImRlbGV0ZSIsInJlbW92ZUNvb2tpZU9wdGlvbnMiLCJjb29raWVPcHRpb25zIiwibWF4QWdlIiwic2V0Q29va2llT3B0aW9ucyIsImFsbFRvU2V0IiwicmVtb3ZlSXRlbSIsImVuZHNXaXRoIiwiYXBwbHlTZXJ2ZXJTdG9yYWdlIiwiaXRlbU5hbWUiLCJyZW1vdmVFeGlzdGluZ0Nvb2tpZXNGb3JJdGVtIiwiY2h1bmsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/ssr/dist/module/cookies.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/ssr/dist/module/createBrowserClient.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@supabase/ssr/dist/module/createBrowserClient.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createBrowserClient: () => (/* binding */ createBrowserClient)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @supabase/supabase-js */ \"(ssr)/./node_modules/@supabase/supabase-js/dist/index.mjs\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ \"(ssr)/./node_modules/@supabase/ssr/dist/module/version.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@supabase/ssr/dist/module/utils/index.js\");\n/* harmony import */ var _cookies__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cookies */ \"(ssr)/./node_modules/@supabase/ssr/dist/module/cookies.js\");\n\n\n\n\nlet cachedBrowserClient;\nfunction createBrowserClient(supabaseUrl, supabaseKey, options) {\n    // singleton client is created only if isSingleton is set to true, or if isSingleton is not defined and we detect a browser\n    const shouldUseSingleton = options?.isSingleton === true || (!options || !(\"isSingleton\" in options)) && (0,_utils__WEBPACK_IMPORTED_MODULE_1__.isBrowser)();\n    if (shouldUseSingleton && cachedBrowserClient) {\n        return cachedBrowserClient;\n    }\n    if (!supabaseUrl || !supabaseKey) {\n        throw new Error(`@supabase/ssr: Your project's URL and API key are required to create a Supabase client!\\n\\nCheck your Supabase project's API settings to find these values\\n\\nhttps://supabase.com/dashboard/project/_/settings/api`);\n    }\n    const { storage } = (0,_cookies__WEBPACK_IMPORTED_MODULE_2__.createStorageFromOptions)({\n        ...options,\n        cookieEncoding: options?.cookieEncoding ?? \"base64url\"\n    }, false);\n    const client = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_3__.createClient)(supabaseUrl, supabaseKey, {\n        // TODO: resolve type error\n        ...options,\n        global: {\n            ...options?.global,\n            headers: {\n                ...options?.global?.headers,\n                \"X-Client-Info\": `supabase-ssr/${_version__WEBPACK_IMPORTED_MODULE_0__.VERSION} createBrowserClient`\n            }\n        },\n        auth: {\n            ...options?.auth,\n            ...options?.cookieOptions?.name ? {\n                storageKey: options.cookieOptions.name\n            } : null,\n            flowType: \"pkce\",\n            autoRefreshToken: (0,_utils__WEBPACK_IMPORTED_MODULE_1__.isBrowser)(),\n            detectSessionInUrl: (0,_utils__WEBPACK_IMPORTED_MODULE_1__.isBrowser)(),\n            persistSession: true,\n            storage,\n            ...options?.cookies && \"encode\" in options.cookies && options.cookies.encode === \"tokens-only\" ? {\n                userStorage: options?.auth?.userStorage ?? window.localStorage\n            } : null\n        }\n    });\n    if (shouldUseSingleton) {\n        cachedBrowserClient = client;\n    }\n    return client;\n} //# sourceMappingURL=createBrowserClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Nzci9kaXN0L21vZHVsZS9jcmVhdGVCcm93c2VyQ2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXNEO0FBQ2xCO0FBQ0E7QUFDaUI7QUFDckQsSUFBSUk7QUFDRyxTQUFTQyxvQkFBb0JDLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxPQUFPO0lBQ2pFLDJIQUEySDtJQUMzSCxNQUFNQyxxQkFBcUJELFNBQVNFLGdCQUFnQixRQUMvQyxDQUFDLENBQUNGLFdBQVcsQ0FBRSxrQkFBaUJBLE9BQU0sQ0FBQyxLQUFNTixpREFBU0E7SUFDM0QsSUFBSU8sc0JBQXNCTCxxQkFBcUI7UUFDM0MsT0FBT0E7SUFDWDtJQUNBLElBQUksQ0FBQ0UsZUFBZSxDQUFDQyxhQUFhO1FBQzlCLE1BQU0sSUFBSUksTUFBTSxDQUFDLG1OQUFtTixDQUFDO0lBQ3pPO0lBQ0EsTUFBTSxFQUFFQyxPQUFPLEVBQUUsR0FBR1Qsa0VBQXdCQSxDQUFDO1FBQ3pDLEdBQUdLLE9BQU87UUFDVkssZ0JBQWdCTCxTQUFTSyxrQkFBa0I7SUFDL0MsR0FBRztJQUNILE1BQU1DLFNBQVNkLG1FQUFZQSxDQUFDTSxhQUFhQyxhQUFhO1FBQ2xELDJCQUEyQjtRQUMzQixHQUFHQyxPQUFPO1FBQ1ZPLFFBQVE7WUFDSixHQUFHUCxTQUFTTyxNQUFNO1lBQ2xCQyxTQUFTO2dCQUNMLEdBQUdSLFNBQVNPLFFBQVFDLE9BQU87Z0JBQzNCLGlCQUFpQixDQUFDLGFBQWEsRUFBRWYsNkNBQU9BLENBQUMsb0JBQW9CLENBQUM7WUFDbEU7UUFDSjtRQUNBZ0IsTUFBTTtZQUNGLEdBQUdULFNBQVNTLElBQUk7WUFDaEIsR0FBSVQsU0FBU1UsZUFBZUMsT0FDdEI7Z0JBQUVDLFlBQVlaLFFBQVFVLGFBQWEsQ0FBQ0MsSUFBSTtZQUFDLElBQ3pDLElBQUk7WUFDVkUsVUFBVTtZQUNWQyxrQkFBa0JwQixpREFBU0E7WUFDM0JxQixvQkFBb0JyQixpREFBU0E7WUFDN0JzQixnQkFBZ0I7WUFDaEJaO1lBQ0EsR0FBSUosU0FBU2lCLFdBQ1QsWUFBWWpCLFFBQVFpQixPQUFPLElBQzNCakIsUUFBUWlCLE9BQU8sQ0FBQ0MsTUFBTSxLQUFLLGdCQUN6QjtnQkFDRUMsYUFBYW5CLFNBQVNTLE1BQU1VLGVBQWVDLE9BQU9DLFlBQVk7WUFDbEUsSUFDRSxJQUFJO1FBQ2Q7SUFDSjtJQUNBLElBQUlwQixvQkFBb0I7UUFDcEJMLHNCQUFzQlU7SUFDMUI7SUFDQSxPQUFPQTtBQUNYLEVBQ0EsK0NBQStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5jaG9yLXdvcmtmbG93cy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3NyL2Rpc3QvbW9kdWxlL2NyZWF0ZUJyb3dzZXJDbGllbnQuanM/MmU2NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDbGllbnQsIH0gZnJvbSBcIkBzdXBhYmFzZS9zdXBhYmFzZS1qc1wiO1xuaW1wb3J0IHsgVkVSU0lPTiB9IGZyb20gXCIuL3ZlcnNpb25cIjtcbmltcG9ydCB7IGlzQnJvd3NlciB9IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgeyBjcmVhdGVTdG9yYWdlRnJvbU9wdGlvbnMgfSBmcm9tIFwiLi9jb29raWVzXCI7XG5sZXQgY2FjaGVkQnJvd3NlckNsaWVudDtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCcm93c2VyQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSwgb3B0aW9ucykge1xuICAgIC8vIHNpbmdsZXRvbiBjbGllbnQgaXMgY3JlYXRlZCBvbmx5IGlmIGlzU2luZ2xldG9uIGlzIHNldCB0byB0cnVlLCBvciBpZiBpc1NpbmdsZXRvbiBpcyBub3QgZGVmaW5lZCBhbmQgd2UgZGV0ZWN0IGEgYnJvd3NlclxuICAgIGNvbnN0IHNob3VsZFVzZVNpbmdsZXRvbiA9IG9wdGlvbnM/LmlzU2luZ2xldG9uID09PSB0cnVlIHx8XG4gICAgICAgICgoIW9wdGlvbnMgfHwgIShcImlzU2luZ2xldG9uXCIgaW4gb3B0aW9ucykpICYmIGlzQnJvd3NlcigpKTtcbiAgICBpZiAoc2hvdWxkVXNlU2luZ2xldG9uICYmIGNhY2hlZEJyb3dzZXJDbGllbnQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZEJyb3dzZXJDbGllbnQ7XG4gICAgfVxuICAgIGlmICghc3VwYWJhc2VVcmwgfHwgIXN1cGFiYXNlS2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL3NzcjogWW91ciBwcm9qZWN0J3MgVVJMIGFuZCBBUEkga2V5IGFyZSByZXF1aXJlZCB0byBjcmVhdGUgYSBTdXBhYmFzZSBjbGllbnQhXFxuXFxuQ2hlY2sgeW91ciBTdXBhYmFzZSBwcm9qZWN0J3MgQVBJIHNldHRpbmdzIHRvIGZpbmQgdGhlc2UgdmFsdWVzXFxuXFxuaHR0cHM6Ly9zdXBhYmFzZS5jb20vZGFzaGJvYXJkL3Byb2plY3QvXy9zZXR0aW5ncy9hcGlgKTtcbiAgICB9XG4gICAgY29uc3QgeyBzdG9yYWdlIH0gPSBjcmVhdGVTdG9yYWdlRnJvbU9wdGlvbnMoe1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBjb29raWVFbmNvZGluZzogb3B0aW9ucz8uY29va2llRW5jb2RpbmcgPz8gXCJiYXNlNjR1cmxcIixcbiAgICB9LCBmYWxzZSk7XG4gICAgY29uc3QgY2xpZW50ID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSwge1xuICAgICAgICAvLyBUT0RPOiByZXNvbHZlIHR5cGUgZXJyb3JcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgZ2xvYmFsOiB7XG4gICAgICAgICAgICAuLi5vcHRpb25zPy5nbG9iYWwsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucz8uZ2xvYmFsPy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIFwiWC1DbGllbnQtSW5mb1wiOiBgc3VwYWJhc2Utc3NyLyR7VkVSU0lPTn0gY3JlYXRlQnJvd3NlckNsaWVudGAsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBhdXRoOiB7XG4gICAgICAgICAgICAuLi5vcHRpb25zPy5hdXRoLFxuICAgICAgICAgICAgLi4uKG9wdGlvbnM/LmNvb2tpZU9wdGlvbnM/Lm5hbWVcbiAgICAgICAgICAgICAgICA/IHsgc3RvcmFnZUtleTogb3B0aW9ucy5jb29raWVPcHRpb25zLm5hbWUgfVxuICAgICAgICAgICAgICAgIDogbnVsbCksXG4gICAgICAgICAgICBmbG93VHlwZTogXCJwa2NlXCIsXG4gICAgICAgICAgICBhdXRvUmVmcmVzaFRva2VuOiBpc0Jyb3dzZXIoKSxcbiAgICAgICAgICAgIGRldGVjdFNlc3Npb25JblVybDogaXNCcm93c2VyKCksXG4gICAgICAgICAgICBwZXJzaXN0U2Vzc2lvbjogdHJ1ZSxcbiAgICAgICAgICAgIHN0b3JhZ2UsXG4gICAgICAgICAgICAuLi4ob3B0aW9ucz8uY29va2llcyAmJlxuICAgICAgICAgICAgICAgIFwiZW5jb2RlXCIgaW4gb3B0aW9ucy5jb29raWVzICYmXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb29raWVzLmVuY29kZSA9PT0gXCJ0b2tlbnMtb25seVwiXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXJTdG9yYWdlOiBvcHRpb25zPy5hdXRoPy51c2VyU3RvcmFnZSA/PyB3aW5kb3cubG9jYWxTdG9yYWdlLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IG51bGwpLFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGlmIChzaG91bGRVc2VTaW5nbGV0b24pIHtcbiAgICAgICAgY2FjaGVkQnJvd3NlckNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGNsaWVudDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZUJyb3dzZXJDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbImNyZWF0ZUNsaWVudCIsIlZFUlNJT04iLCJpc0Jyb3dzZXIiLCJjcmVhdGVTdG9yYWdlRnJvbU9wdGlvbnMiLCJjYWNoZWRCcm93c2VyQ2xpZW50IiwiY3JlYXRlQnJvd3NlckNsaWVudCIsInN1cGFiYXNlVXJsIiwic3VwYWJhc2VLZXkiLCJvcHRpb25zIiwic2hvdWxkVXNlU2luZ2xldG9uIiwiaXNTaW5nbGV0b24iLCJFcnJvciIsInN0b3JhZ2UiLCJjb29raWVFbmNvZGluZyIsImNsaWVudCIsImdsb2JhbCIsImhlYWRlcnMiLCJhdXRoIiwiY29va2llT3B0aW9ucyIsIm5hbWUiLCJzdG9yYWdlS2V5IiwiZmxvd1R5cGUiLCJhdXRvUmVmcmVzaFRva2VuIiwiZGV0ZWN0U2Vzc2lvbkluVXJsIiwicGVyc2lzdFNlc3Npb24iLCJjb29raWVzIiwiZW5jb2RlIiwidXNlclN0b3JhZ2UiLCJ3aW5kb3ciLCJsb2NhbFN0b3JhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/ssr/dist/module/createBrowserClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/ssr/dist/module/createServerClient.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@supabase/ssr/dist/module/createServerClient.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createServerClient: () => (/* binding */ createServerClient)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @supabase/supabase-js */ \"(ssr)/./node_modules/@supabase/supabase-js/dist/index.mjs\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ \"(ssr)/./node_modules/@supabase/ssr/dist/module/version.js\");\n/* harmony import */ var _cookies__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cookies */ \"(ssr)/./node_modules/@supabase/ssr/dist/module/cookies.js\");\n/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/helpers */ \"(ssr)/./node_modules/@supabase/ssr/dist/module/utils/helpers.js\");\n\n\n\n\nfunction createServerClient(supabaseUrl, supabaseKey, options) {\n    if (!supabaseUrl || !supabaseKey) {\n        throw new Error(`Your project's URL and Key are required to create a Supabase client!\\n\\nCheck your Supabase project's API settings to find these values\\n\\nhttps://supabase.com/dashboard/project/_/settings/api`);\n    }\n    const { storage, getAll, setAll, setItems, removedItems } = (0,_cookies__WEBPACK_IMPORTED_MODULE_1__.createStorageFromOptions)({\n        ...options,\n        cookieEncoding: options?.cookieEncoding ?? \"base64url\"\n    }, true);\n    const client = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_3__.createClient)(supabaseUrl, supabaseKey, {\n        // TODO: resolve type error\n        ...options,\n        global: {\n            ...options?.global,\n            headers: {\n                ...options?.global?.headers,\n                \"X-Client-Info\": `supabase-ssr/${_version__WEBPACK_IMPORTED_MODULE_0__.VERSION} createServerClient`\n            }\n        },\n        auth: {\n            ...options?.cookieOptions?.name ? {\n                storageKey: options.cookieOptions.name\n            } : null,\n            ...options?.auth,\n            flowType: \"pkce\",\n            autoRefreshToken: false,\n            detectSessionInUrl: false,\n            persistSession: true,\n            storage,\n            ...options?.cookies && \"encode\" in options.cookies && options.cookies.encode === \"tokens-only\" ? {\n                userStorage: options?.auth?.userStorage ?? (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_2__.memoryLocalStorageAdapter)()\n            } : null\n        }\n    });\n    client.auth.onAuthStateChange(async (event)=>{\n        // The SIGNED_IN event is fired very often, but we don't need to\n        // apply the storage each time it fires, only if there are changes\n        // that need to be set -- which is if setItems / removeItems have\n        // data.\n        const hasStorageChanges = Object.keys(setItems).length > 0 || Object.keys(removedItems).length > 0;\n        if (hasStorageChanges && (event === \"SIGNED_IN\" || event === \"TOKEN_REFRESHED\" || event === \"USER_UPDATED\" || event === \"PASSWORD_RECOVERY\" || event === \"SIGNED_OUT\" || event === \"MFA_CHALLENGE_VERIFIED\")) {\n            await (0,_cookies__WEBPACK_IMPORTED_MODULE_1__.applyServerStorage)({\n                getAll,\n                setAll,\n                setItems,\n                removedItems\n            }, {\n                cookieOptions: options?.cookieOptions ?? null,\n                cookieEncoding: options?.cookieEncoding ?? \"base64url\"\n            });\n        }\n    });\n    return client;\n} //# sourceMappingURL=createServerClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Nzci9kaXN0L21vZHVsZS9jcmVhdGVTZXJ2ZXJDbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBc0Q7QUFDbEI7QUFDcUM7QUFDYjtBQUNyRCxTQUFTSyxtQkFBbUJDLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxPQUFPO0lBQ2hFLElBQUksQ0FBQ0YsZUFBZSxDQUFDQyxhQUFhO1FBQzlCLE1BQU0sSUFBSUUsTUFBTSxDQUFDLGdNQUFnTSxDQUFDO0lBQ3ROO0lBQ0EsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLFlBQVksRUFBRSxHQUFHWixrRUFBd0JBLENBQUM7UUFDakYsR0FBR00sT0FBTztRQUNWTyxnQkFBZ0JQLFNBQVNPLGtCQUFrQjtJQUMvQyxHQUFHO0lBQ0gsTUFBTUMsU0FBU2hCLG1FQUFZQSxDQUFDTSxhQUFhQyxhQUFhO1FBQ2xELDJCQUEyQjtRQUMzQixHQUFHQyxPQUFPO1FBQ1ZTLFFBQVE7WUFDSixHQUFHVCxTQUFTUyxNQUFNO1lBQ2xCQyxTQUFTO2dCQUNMLEdBQUdWLFNBQVNTLFFBQVFDLE9BQU87Z0JBQzNCLGlCQUFpQixDQUFDLGFBQWEsRUFBRWpCLDZDQUFPQSxDQUFDLG1CQUFtQixDQUFDO1lBQ2pFO1FBQ0o7UUFDQWtCLE1BQU07WUFDRixHQUFJWCxTQUFTWSxlQUFlQyxPQUN0QjtnQkFBRUMsWUFBWWQsUUFBUVksYUFBYSxDQUFDQyxJQUFJO1lBQUMsSUFDekMsSUFBSTtZQUNWLEdBQUdiLFNBQVNXLElBQUk7WUFDaEJJLFVBQVU7WUFDVkMsa0JBQWtCO1lBQ2xCQyxvQkFBb0I7WUFDcEJDLGdCQUFnQjtZQUNoQmhCO1lBQ0EsR0FBSUYsU0FBU21CLFdBQ1QsWUFBWW5CLFFBQVFtQixPQUFPLElBQzNCbkIsUUFBUW1CLE9BQU8sQ0FBQ0MsTUFBTSxLQUFLLGdCQUN6QjtnQkFDRUMsYUFBYXJCLFNBQVNXLE1BQU1VLGVBQWV6Qix5RUFBeUJBO1lBQ3hFLElBQ0UsSUFBSTtRQUNkO0lBQ0o7SUFDQVksT0FBT0csSUFBSSxDQUFDVyxpQkFBaUIsQ0FBQyxPQUFPQztRQUNqQyxnRUFBZ0U7UUFDaEUsa0VBQWtFO1FBQ2xFLGlFQUFpRTtRQUNqRSxRQUFRO1FBQ1IsTUFBTUMsb0JBQW9CQyxPQUFPQyxJQUFJLENBQUNyQixVQUFVc0IsTUFBTSxHQUFHLEtBQUtGLE9BQU9DLElBQUksQ0FBQ3BCLGNBQWNxQixNQUFNLEdBQUc7UUFDakcsSUFBSUgscUJBQ0NELENBQUFBLFVBQVUsZUFDUEEsVUFBVSxxQkFDVkEsVUFBVSxrQkFDVkEsVUFBVSx1QkFDVkEsVUFBVSxnQkFDVkEsVUFBVSx3QkFBdUIsR0FBSTtZQUN6QyxNQUFNNUIsNERBQWtCQSxDQUFDO2dCQUFFUTtnQkFBUUM7Z0JBQVFDO2dCQUFVQztZQUFhLEdBQUc7Z0JBQ2pFTSxlQUFlWixTQUFTWSxpQkFBaUI7Z0JBQ3pDTCxnQkFBZ0JQLFNBQVNPLGtCQUFrQjtZQUMvQztRQUNKO0lBQ0o7SUFDQSxPQUFPQztBQUNYLEVBQ0EsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5jaG9yLXdvcmtmbG93cy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3NyL2Rpc3QvbW9kdWxlL2NyZWF0ZVNlcnZlckNsaWVudC5qcz8zN2IxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNsaWVudCwgfSBmcm9tIFwiQHN1cGFiYXNlL3N1cGFiYXNlLWpzXCI7XG5pbXBvcnQgeyBWRVJTSU9OIH0gZnJvbSBcIi4vdmVyc2lvblwiO1xuaW1wb3J0IHsgY3JlYXRlU3RvcmFnZUZyb21PcHRpb25zLCBhcHBseVNlcnZlclN0b3JhZ2UgfSBmcm9tIFwiLi9jb29raWVzXCI7XG5pbXBvcnQgeyBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyIH0gZnJvbSBcIi4vdXRpbHMvaGVscGVyc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlcnZlckNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VLZXksIG9wdGlvbnMpIHtcbiAgICBpZiAoIXN1cGFiYXNlVXJsIHx8ICFzdXBhYmFzZUtleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdXIgcHJvamVjdCdzIFVSTCBhbmQgS2V5IGFyZSByZXF1aXJlZCB0byBjcmVhdGUgYSBTdXBhYmFzZSBjbGllbnQhXFxuXFxuQ2hlY2sgeW91ciBTdXBhYmFzZSBwcm9qZWN0J3MgQVBJIHNldHRpbmdzIHRvIGZpbmQgdGhlc2UgdmFsdWVzXFxuXFxuaHR0cHM6Ly9zdXBhYmFzZS5jb20vZGFzaGJvYXJkL3Byb2plY3QvXy9zZXR0aW5ncy9hcGlgKTtcbiAgICB9XG4gICAgY29uc3QgeyBzdG9yYWdlLCBnZXRBbGwsIHNldEFsbCwgc2V0SXRlbXMsIHJlbW92ZWRJdGVtcyB9ID0gY3JlYXRlU3RvcmFnZUZyb21PcHRpb25zKHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgY29va2llRW5jb2Rpbmc6IG9wdGlvbnM/LmNvb2tpZUVuY29kaW5nID8/IFwiYmFzZTY0dXJsXCIsXG4gICAgfSwgdHJ1ZSk7XG4gICAgY29uc3QgY2xpZW50ID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSwge1xuICAgICAgICAvLyBUT0RPOiByZXNvbHZlIHR5cGUgZXJyb3JcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgZ2xvYmFsOiB7XG4gICAgICAgICAgICAuLi5vcHRpb25zPy5nbG9iYWwsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucz8uZ2xvYmFsPy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIFwiWC1DbGllbnQtSW5mb1wiOiBgc3VwYWJhc2Utc3NyLyR7VkVSU0lPTn0gY3JlYXRlU2VydmVyQ2xpZW50YCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGF1dGg6IHtcbiAgICAgICAgICAgIC4uLihvcHRpb25zPy5jb29raWVPcHRpb25zPy5uYW1lXG4gICAgICAgICAgICAgICAgPyB7IHN0b3JhZ2VLZXk6IG9wdGlvbnMuY29va2llT3B0aW9ucy5uYW1lIH1cbiAgICAgICAgICAgICAgICA6IG51bGwpLFxuICAgICAgICAgICAgLi4ub3B0aW9ucz8uYXV0aCxcbiAgICAgICAgICAgIGZsb3dUeXBlOiBcInBrY2VcIixcbiAgICAgICAgICAgIGF1dG9SZWZyZXNoVG9rZW46IGZhbHNlLFxuICAgICAgICAgICAgZGV0ZWN0U2Vzc2lvbkluVXJsOiBmYWxzZSxcbiAgICAgICAgICAgIHBlcnNpc3RTZXNzaW9uOiB0cnVlLFxuICAgICAgICAgICAgc3RvcmFnZSxcbiAgICAgICAgICAgIC4uLihvcHRpb25zPy5jb29raWVzICYmXG4gICAgICAgICAgICAgICAgXCJlbmNvZGVcIiBpbiBvcHRpb25zLmNvb2tpZXMgJiZcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvb2tpZXMuZW5jb2RlID09PSBcInRva2Vucy1vbmx5XCJcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgdXNlclN0b3JhZ2U6IG9wdGlvbnM/LmF1dGg/LnVzZXJTdG9yYWdlID8/IG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIoKSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiBudWxsKSxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBjbGllbnQuYXV0aC5vbkF1dGhTdGF0ZUNoYW5nZShhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgLy8gVGhlIFNJR05FRF9JTiBldmVudCBpcyBmaXJlZCB2ZXJ5IG9mdGVuLCBidXQgd2UgZG9uJ3QgbmVlZCB0b1xuICAgICAgICAvLyBhcHBseSB0aGUgc3RvcmFnZSBlYWNoIHRpbWUgaXQgZmlyZXMsIG9ubHkgaWYgdGhlcmUgYXJlIGNoYW5nZXNcbiAgICAgICAgLy8gdGhhdCBuZWVkIHRvIGJlIHNldCAtLSB3aGljaCBpcyBpZiBzZXRJdGVtcyAvIHJlbW92ZUl0ZW1zIGhhdmVcbiAgICAgICAgLy8gZGF0YS5cbiAgICAgICAgY29uc3QgaGFzU3RvcmFnZUNoYW5nZXMgPSBPYmplY3Qua2V5cyhzZXRJdGVtcykubGVuZ3RoID4gMCB8fCBPYmplY3Qua2V5cyhyZW1vdmVkSXRlbXMpLmxlbmd0aCA+IDA7XG4gICAgICAgIGlmIChoYXNTdG9yYWdlQ2hhbmdlcyAmJlxuICAgICAgICAgICAgKGV2ZW50ID09PSBcIlNJR05FRF9JTlwiIHx8XG4gICAgICAgICAgICAgICAgZXZlbnQgPT09IFwiVE9LRU5fUkVGUkVTSEVEXCIgfHxcbiAgICAgICAgICAgICAgICBldmVudCA9PT0gXCJVU0VSX1VQREFURURcIiB8fFxuICAgICAgICAgICAgICAgIGV2ZW50ID09PSBcIlBBU1NXT1JEX1JFQ09WRVJZXCIgfHxcbiAgICAgICAgICAgICAgICBldmVudCA9PT0gXCJTSUdORURfT1VUXCIgfHxcbiAgICAgICAgICAgICAgICBldmVudCA9PT0gXCJNRkFfQ0hBTExFTkdFX1ZFUklGSUVEXCIpKSB7XG4gICAgICAgICAgICBhd2FpdCBhcHBseVNlcnZlclN0b3JhZ2UoeyBnZXRBbGwsIHNldEFsbCwgc2V0SXRlbXMsIHJlbW92ZWRJdGVtcyB9LCB7XG4gICAgICAgICAgICAgICAgY29va2llT3B0aW9uczogb3B0aW9ucz8uY29va2llT3B0aW9ucyA/PyBudWxsLFxuICAgICAgICAgICAgICAgIGNvb2tpZUVuY29kaW5nOiBvcHRpb25zPy5jb29raWVFbmNvZGluZyA/PyBcImJhc2U2NHVybFwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2xpZW50O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlU2VydmVyQ2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJWRVJTSU9OIiwiY3JlYXRlU3RvcmFnZUZyb21PcHRpb25zIiwiYXBwbHlTZXJ2ZXJTdG9yYWdlIiwibWVtb3J5TG9jYWxTdG9yYWdlQWRhcHRlciIsImNyZWF0ZVNlcnZlckNsaWVudCIsInN1cGFiYXNlVXJsIiwic3VwYWJhc2VLZXkiLCJvcHRpb25zIiwiRXJyb3IiLCJzdG9yYWdlIiwiZ2V0QWxsIiwic2V0QWxsIiwic2V0SXRlbXMiLCJyZW1vdmVkSXRlbXMiLCJjb29raWVFbmNvZGluZyIsImNsaWVudCIsImdsb2JhbCIsImhlYWRlcnMiLCJhdXRoIiwiY29va2llT3B0aW9ucyIsIm5hbWUiLCJzdG9yYWdlS2V5IiwiZmxvd1R5cGUiLCJhdXRvUmVmcmVzaFRva2VuIiwiZGV0ZWN0U2Vzc2lvbkluVXJsIiwicGVyc2lzdFNlc3Npb24iLCJjb29raWVzIiwiZW5jb2RlIiwidXNlclN0b3JhZ2UiLCJvbkF1dGhTdGF0ZUNoYW5nZSIsImV2ZW50IiwiaGFzU3RvcmFnZUNoYW5nZXMiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/ssr/dist/module/createServerClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/ssr/dist/module/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@supabase/ssr/dist/module/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_COOKIE_OPTIONS: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_COOKIE_OPTIONS),\n/* harmony export */   MAX_CHUNK_SIZE: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.MAX_CHUNK_SIZE),\n/* harmony export */   codepointToUTF8: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.codepointToUTF8),\n/* harmony export */   combineChunks: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.combineChunks),\n/* harmony export */   createBrowserClient: () => (/* reexport safe */ _createBrowserClient__WEBPACK_IMPORTED_MODULE_0__.createBrowserClient),\n/* harmony export */   createChunks: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.createChunks),\n/* harmony export */   createServerClient: () => (/* reexport safe */ _createServerClient__WEBPACK_IMPORTED_MODULE_1__.createServerClient),\n/* harmony export */   deleteChunks: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.deleteChunks),\n/* harmony export */   isBrowser: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.isBrowser),\n/* harmony export */   isChunkLike: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.isChunkLike),\n/* harmony export */   memoryLocalStorageAdapter: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.memoryLocalStorageAdapter),\n/* harmony export */   parse: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.parse),\n/* harmony export */   parseCookieHeader: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.parseCookieHeader),\n/* harmony export */   serialize: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.serialize),\n/* harmony export */   serializeCookieHeader: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.serializeCookieHeader),\n/* harmony export */   stringFromBase64URL: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.stringFromBase64URL),\n/* harmony export */   stringFromUTF8: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.stringFromUTF8),\n/* harmony export */   stringToBase64URL: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.stringToBase64URL),\n/* harmony export */   stringToUTF8: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.stringToUTF8)\n/* harmony export */ });\n/* harmony import */ var _createBrowserClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createBrowserClient */ \"(ssr)/./node_modules/@supabase/ssr/dist/module/createBrowserClient.js\");\n/* harmony import */ var _createServerClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createServerClient */ \"(ssr)/./node_modules/@supabase/ssr/dist/module/createServerClient.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@supabase/ssr/dist/module/types.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_types__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _types__WEBPACK_IMPORTED_MODULE_2__) if([\"default\",\"createBrowserClient\",\"createServerClient\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _types__WEBPACK_IMPORTED_MODULE_2__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@supabase/ssr/dist/module/utils/index.js\");\n// Check if this package is being used as one of the deprecated auth-helpers packages\nif (typeof process !== \"undefined\" && process.env?.npm_package_name) {\n    const packageName = process.env.npm_package_name;\n    const deprecatedPackages = [\n        \"@supabase/auth-helpers-nextjs\",\n        \"@supabase/auth-helpers-react\",\n        \"@supabase/auth-helpers-remix\",\n        \"@supabase/auth-helpers-sveltekit\"\n    ];\n    if (deprecatedPackages.includes(packageName)) {\n        console.warn(`\n\n   IMPORTANT: Package Consolidation Notice                                \n                                                                            \n The ${packageName.padEnd(35)} package name is deprecated.  \n                                                                            \n You are now using @supabase/ssr - a unified solution for all frameworks.  \n                                                                            \n The auth-helpers packages have been consolidated into @supabase/ssr       \n to provide better maintenance and consistent APIs across frameworks.      \n                                                                            \n Please update your package.json to use @supabase/ssr directly:            \n   npm uninstall ${packageName.padEnd(42)} \n   npm install @supabase/ssr                                               \n                                                                            \n For more information, visit:                                              \n https://supabase.com/docs/guides/auth/server-side                         \n\n    `);\n    }\n}\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Nzci9kaXN0L21vZHVsZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxxRkFBcUY7QUFDckYsSUFBSSxPQUFPQSxZQUFZLGVBQWVBLFFBQVFDLEdBQUcsRUFBRUMsa0JBQWtCO0lBQ2pFLE1BQU1DLGNBQWNILFFBQVFDLEdBQUcsQ0FBQ0MsZ0JBQWdCO0lBQ2hELE1BQU1FLHFCQUFxQjtRQUN2QjtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0QsSUFBSUEsbUJBQW1CQyxRQUFRLENBQUNGLGNBQWM7UUFDMUNHLFFBQVFDLElBQUksQ0FBQyxDQUFDOzs7O01BSWhCLEVBQUVKLFlBQVlLLE1BQU0sQ0FBQyxJQUFJOzs7Ozs7OztrQkFRYixFQUFFTCxZQUFZSyxNQUFNLENBQUMsSUFBSTs7Ozs7O0lBTXZDLENBQUM7SUFDRDtBQUNKO0FBQ3NDO0FBQ0Q7QUFDYjtBQUNBLENBQ3hCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FuY2hvci13b3JrZmxvd3MvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Nzci9kaXN0L21vZHVsZS9pbmRleC5qcz9lZTA1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENoZWNrIGlmIHRoaXMgcGFja2FnZSBpcyBiZWluZyB1c2VkIGFzIG9uZSBvZiB0aGUgZGVwcmVjYXRlZCBhdXRoLWhlbHBlcnMgcGFja2FnZXNcbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudj8ubnBtX3BhY2thZ2VfbmFtZSkge1xuICAgIGNvbnN0IHBhY2thZ2VOYW1lID0gcHJvY2Vzcy5lbnYubnBtX3BhY2thZ2VfbmFtZTtcbiAgICBjb25zdCBkZXByZWNhdGVkUGFja2FnZXMgPSBbXG4gICAgICAgIFwiQHN1cGFiYXNlL2F1dGgtaGVscGVycy1uZXh0anNcIixcbiAgICAgICAgXCJAc3VwYWJhc2UvYXV0aC1oZWxwZXJzLXJlYWN0XCIsXG4gICAgICAgIFwiQHN1cGFiYXNlL2F1dGgtaGVscGVycy1yZW1peFwiLFxuICAgICAgICBcIkBzdXBhYmFzZS9hdXRoLWhlbHBlcnMtc3ZlbHRla2l0XCIsXG4gICAgXTtcbiAgICBpZiAoZGVwcmVjYXRlZFBhY2thZ2VzLmluY2x1ZGVzKHBhY2thZ2VOYW1lKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFxu4pWU4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWXXG7ilZEg4pqg77iPICBJTVBPUlRBTlQ6IFBhY2thZ2UgQ29uc29saWRhdGlvbiBOb3RpY2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKVkVxu4pWRICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKVkVxu4pWRIFRoZSAke3BhY2thZ2VOYW1lLnBhZEVuZCgzNSl9IHBhY2thZ2UgbmFtZSBpcyBkZXByZWNhdGVkLiAg4pWRXG7ilZEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pWRXG7ilZEgWW91IGFyZSBub3cgdXNpbmcgQHN1cGFiYXNlL3NzciAtIGEgdW5pZmllZCBzb2x1dGlvbiBmb3IgYWxsIGZyYW1ld29ya3MuICDilZFcbuKVkSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilZFcbuKVkSBUaGUgYXV0aC1oZWxwZXJzIHBhY2thZ2VzIGhhdmUgYmVlbiBjb25zb2xpZGF0ZWQgaW50byBAc3VwYWJhc2Uvc3NyICAgICAgIOKVkVxu4pWRIHRvIHByb3ZpZGUgYmV0dGVyIG1haW50ZW5hbmNlIGFuZCBjb25zaXN0ZW50IEFQSXMgYWNyb3NzIGZyYW1ld29ya3MuICAgICAg4pWRXG7ilZEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pWRXG7ilZEgUGxlYXNlIHVwZGF0ZSB5b3VyIHBhY2thZ2UuanNvbiB0byB1c2UgQHN1cGFiYXNlL3NzciBkaXJlY3RseTogICAgICAgICAgICDilZFcbuKVkSAgIG5wbSB1bmluc3RhbGwgJHtwYWNrYWdlTmFtZS5wYWRFbmQoNDIpfSDilZFcbuKVkSAgIG5wbSBpbnN0YWxsIEBzdXBhYmFzZS9zc3IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKVkVxu4pWRICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKVkVxu4pWRIEZvciBtb3JlIGluZm9ybWF0aW9uLCB2aXNpdDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pWRXG7ilZEgaHR0cHM6Ly9zdXBhYmFzZS5jb20vZG9jcy9ndWlkZXMvYXV0aC9zZXJ2ZXItc2lkZSAgICAgICAgICAgICAgICAgICAgICAgICDilZFcbuKVmuKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVnVxuICAgIGApO1xuICAgIH1cbn1cbmV4cG9ydCAqIGZyb20gXCIuL2NyZWF0ZUJyb3dzZXJDbGllbnRcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2NyZWF0ZVNlcnZlckNsaWVudFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vdHlwZXNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3V0aWxzXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsicHJvY2VzcyIsImVudiIsIm5wbV9wYWNrYWdlX25hbWUiLCJwYWNrYWdlTmFtZSIsImRlcHJlY2F0ZWRQYWNrYWdlcyIsImluY2x1ZGVzIiwiY29uc29sZSIsIndhcm4iLCJwYWRFbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/ssr/dist/module/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/ssr/dist/module/types.js":
/*!*********************************************************!*\
  !*** ./node_modules/@supabase/ssr/dist/module/types.js ***!
  \*********************************************************/
/***/ (() => {

eval("//# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmNob3Itd29ya2Zsb3dzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zc3IvZGlzdC9tb2R1bGUvdHlwZXMuanM/ZGU4NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUNBQWlDIiwiZmlsZSI6Iihzc3IpLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zc3IvZGlzdC9tb2R1bGUvdHlwZXMuanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/ssr/dist/module/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/ssr/dist/module/utils/base64url.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/ssr/dist/module/utils/base64url.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   codepointToUTF8: () => (/* binding */ codepointToUTF8),\n/* harmony export */   stringFromBase64URL: () => (/* binding */ stringFromBase64URL),\n/* harmony export */   stringFromUTF8: () => (/* binding */ stringFromUTF8),\n/* harmony export */   stringToBase64URL: () => (/* binding */ stringToBase64URL),\n/* harmony export */   stringToUTF8: () => (/* binding */ stringToUTF8)\n/* harmony export */ });\n/**\n * Avoid modifying this file. It's part of\n * https://github.com/supabase-community/base64url-js.  Submit all fixes on\n * that repo!\n */ /**\n * An array of characters that encode 6 bits into a Base64-URL alphabet\n * character.\n */ const TO_BASE64URL = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\".split(\"\");\n/**\n * An array of characters that can appear in a Base64-URL encoded string but\n * should be ignored.\n */ const IGNORE_BASE64URL = \" \t\\n\\r=\".split(\"\");\n/**\n * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2\n * used to skip the character, or if -1 used to error out.\n */ const FROM_BASE64URL = (()=>{\n    const charMap = new Array(128);\n    for(let i = 0; i < charMap.length; i += 1){\n        charMap[i] = -1;\n    }\n    for(let i = 0; i < IGNORE_BASE64URL.length; i += 1){\n        charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;\n    }\n    for(let i = 0; i < TO_BASE64URL.length; i += 1){\n        charMap[TO_BASE64URL[i].charCodeAt(0)] = i;\n    }\n    return charMap;\n})();\n/**\n * Converts a JavaScript string (which may include any valid character) into a\n * Base64-URL encoded string. The string is first encoded in UTF-8 which is\n * then encoded as Base64-URL.\n *\n * @param str The string to convert.\n */ function stringToBase64URL(str) {\n    const base64 = [];\n    let queue = 0;\n    let queuedBits = 0;\n    const emitter = (byte)=>{\n        queue = queue << 8 | byte;\n        queuedBits += 8;\n        while(queuedBits >= 6){\n            const pos = queue >> queuedBits - 6 & 63;\n            base64.push(TO_BASE64URL[pos]);\n            queuedBits -= 6;\n        }\n    };\n    stringToUTF8(str, emitter);\n    if (queuedBits > 0) {\n        queue = queue << 6 - queuedBits;\n        queuedBits = 6;\n        while(queuedBits >= 6){\n            const pos = queue >> queuedBits - 6 & 63;\n            base64.push(TO_BASE64URL[pos]);\n            queuedBits -= 6;\n        }\n    }\n    return base64.join(\"\");\n}\n/**\n * Converts a Base64-URL encoded string into a JavaScript string. It is assumed\n * that the underlying string has been encoded as UTF-8.\n *\n * @param str The Base64-URL encoded string.\n */ function stringFromBase64URL(str) {\n    const conv = [];\n    const emit = (codepoint)=>{\n        conv.push(String.fromCodePoint(codepoint));\n    };\n    const state = {\n        utf8seq: 0,\n        codepoint: 0\n    };\n    let queue = 0;\n    let queuedBits = 0;\n    for(let i = 0; i < str.length; i += 1){\n        const codepoint = str.charCodeAt(i);\n        const bits = FROM_BASE64URL[codepoint];\n        if (bits > -1) {\n            // valid Base64-URL character\n            queue = queue << 6 | bits;\n            queuedBits += 6;\n            while(queuedBits >= 8){\n                stringFromUTF8(queue >> queuedBits - 8 & 0xff, state, emit);\n                queuedBits -= 8;\n            }\n        } else if (bits === -2) {\n            continue;\n        } else {\n            throw new Error(`Invalid Base64-URL character \"${str.at(i)}\" at position ${i}`);\n        }\n    }\n    return conv.join(\"\");\n}\n/**\n * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.\n *\n * @param codepoint The Unicode codepoint.\n * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.\n */ function codepointToUTF8(codepoint, emit) {\n    if (codepoint <= 0x7f) {\n        emit(codepoint);\n        return;\n    } else if (codepoint <= 0x7ff) {\n        emit(0xc0 | codepoint >> 6);\n        emit(0x80 | codepoint & 0x3f);\n        return;\n    } else if (codepoint <= 0xffff) {\n        emit(0xe0 | codepoint >> 12);\n        emit(0x80 | codepoint >> 6 & 0x3f);\n        emit(0x80 | codepoint & 0x3f);\n        return;\n    } else if (codepoint <= 0x10ffff) {\n        emit(0xf0 | codepoint >> 18);\n        emit(0x80 | codepoint >> 12 & 0x3f);\n        emit(0x80 | codepoint >> 6 & 0x3f);\n        emit(0x80 | codepoint & 0x3f);\n        return;\n    }\n    throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);\n}\n/**\n * Converts a JavaScript string to a sequence of UTF-8 bytes.\n *\n * @param str  The string to convert to UTF-8.\n * @param emit Function which will be called for each UTF-8 byte of the string.\n */ function stringToUTF8(str, emit) {\n    for(let i = 0; i < str.length; i += 1){\n        let codepoint = str.charCodeAt(i);\n        if (codepoint > 0xd7ff && codepoint <= 0xdbff) {\n            // most UTF-16 codepoints are Unicode codepoints, except values in this\n            // range where the next UTF-16 codepoint needs to be combined with the\n            // current one to get the Unicode codepoint\n            const highSurrogate = (codepoint - 0xd800) * 0x400 & 0xffff;\n            const lowSurrogate = str.charCodeAt(i + 1) - 0xdc00 & 0xffff;\n            codepoint = (lowSurrogate | highSurrogate) + 0x10000;\n            i += 1;\n        }\n        codepointToUTF8(codepoint, emit);\n    }\n}\n/**\n * Converts a UTF-8 byte to a Unicode codepoint.\n *\n * @param byte  The UTF-8 byte next in the sequence.\n * @param state The shared state between consecutive UTF-8 bytes in the\n *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.\n * @param emit  Function which will be called for each codepoint.\n */ function stringFromUTF8(byte, state, emit) {\n    if (state.utf8seq === 0) {\n        if (byte <= 0x7f) {\n            emit(byte);\n            return;\n        }\n        // count the number of 1 leading bits until you reach 0\n        for(let leadingBit = 1; leadingBit < 6; leadingBit += 1){\n            if ((byte >> 7 - leadingBit & 1) === 0) {\n                state.utf8seq = leadingBit;\n                break;\n            }\n        }\n        if (state.utf8seq === 2) {\n            state.codepoint = byte & 31;\n        } else if (state.utf8seq === 3) {\n            state.codepoint = byte & 15;\n        } else if (state.utf8seq === 4) {\n            state.codepoint = byte & 7;\n        } else {\n            throw new Error(\"Invalid UTF-8 sequence\");\n        }\n        state.utf8seq -= 1;\n    } else if (state.utf8seq > 0) {\n        if (byte <= 0x7f) {\n            throw new Error(\"Invalid UTF-8 sequence\");\n        }\n        state.codepoint = state.codepoint << 6 | byte & 63;\n        state.utf8seq -= 1;\n        if (state.utf8seq === 0) {\n            emit(state.codepoint);\n        }\n    }\n} //# sourceMappingURL=base64url.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Nzci9kaXN0L21vZHVsZS91dGlscy9iYXNlNjR1cmwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7OztDQUlDLEdBQ0Q7OztDQUdDLEdBQ0QsTUFBTUEsZUFBZSxtRUFBbUVDLEtBQUssQ0FBQztBQUM5Rjs7O0NBR0MsR0FDRCxNQUFNQyxtQkFBbUIsVUFBV0QsS0FBSyxDQUFDO0FBQzFDOzs7Q0FHQyxHQUNELE1BQU1FLGlCQUFpQixDQUFDO0lBQ3BCLE1BQU1DLFVBQVUsSUFBSUMsTUFBTTtJQUMxQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsUUFBUUcsTUFBTSxFQUFFRCxLQUFLLEVBQUc7UUFDeENGLE9BQU8sQ0FBQ0UsRUFBRSxHQUFHLENBQUM7SUFDbEI7SUFDQSxJQUFLLElBQUlBLElBQUksR0FBR0EsSUFBSUosaUJBQWlCSyxNQUFNLEVBQUVELEtBQUssRUFBRztRQUNqREYsT0FBTyxDQUFDRixnQkFBZ0IsQ0FBQ0ksRUFBRSxDQUFDRSxVQUFVLENBQUMsR0FBRyxHQUFHLENBQUM7SUFDbEQ7SUFDQSxJQUFLLElBQUlGLElBQUksR0FBR0EsSUFBSU4sYUFBYU8sTUFBTSxFQUFFRCxLQUFLLEVBQUc7UUFDN0NGLE9BQU8sQ0FBQ0osWUFBWSxDQUFDTSxFQUFFLENBQUNFLFVBQVUsQ0FBQyxHQUFHLEdBQUdGO0lBQzdDO0lBQ0EsT0FBT0Y7QUFDWDtBQUNBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNLLGtCQUFrQkMsR0FBRztJQUNqQyxNQUFNQyxTQUFTLEVBQUU7SUFDakIsSUFBSUMsUUFBUTtJQUNaLElBQUlDLGFBQWE7SUFDakIsTUFBTUMsVUFBVSxDQUFDQztRQUNiSCxRQUFRLFNBQVUsSUFBS0c7UUFDdkJGLGNBQWM7UUFDZCxNQUFPQSxjQUFjLEVBQUc7WUFDcEIsTUFBTUcsTUFBTSxTQUFXSCxhQUFhLElBQU07WUFDMUNGLE9BQU9NLElBQUksQ0FBQ2pCLFlBQVksQ0FBQ2dCLElB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QUNKO0FBQ0E7Ozs7Ozs7Q0FPQyxHQUNNLFNBQVNPLGVBQWVkLElBQUksRUFBRVcsS0FBSyxFQUFFSixJQUFJO0lBQzVDLElBQUlJLE1BQU1DLE9BQU8sS0FBSyxHQUFHO1FBQ3JCLElBQUlaLFFBQVEsTUFBTTtZQUNkTyxLQUFLUDtZQUNMO1FBQ0o7UUFDQSx1REFBdUQ7UUFDdkQsSUFBSyxJQUFJcUIsYUFBYSxHQUFHQSxhQUFhLEdBQUdBLGNBQWMsRUFBRztZQUN0RCxJQUFJLENBQUMsUUFBVSxJQUFJQSxhQUFlLE9BQU8sR0FBRztnQkFDeENWLE1BQU1DLE9BQU8sR0FBR1M7Z0JBQ2hCO1lBQ0o7UUFDSjtRQUNBLElBQUlWLE1BQU1DLE9BQU8sS0FBSyxHQUFHO1lBQ3JCRCxNQUFNSCxTQUFTLEdBQUdSLE9BQU87UUFDN0IsT0FDSyxJQUFJVyxNQUFNQyxPQUFPLEtBQUssR0FBRztZQUMxQkQsTUFBTUgsU0FBUyxHQUFHUixPQUFPO1FBQzdCLE9BQ0ssSUFBSVcsTUFBTUMsT0FBTyxLQUFLLEdBQUc7WUFDMUJELE1BQU1ILFNBQVMsR0FBR1IsT0FBTztRQUM3QixPQUNLO1lBQ0QsTUFBTSxJQUFJZSxNQUFNO1FBQ3BCO1FBQ0FKLE1BQU1DLE9BQU8sSUFBSTtJQUNyQixPQUNLLElBQUlELE1BQU1DLE9BQU8sR0FBRyxHQUFHO1FBQ3hCLElBQUlaLFFBQVEsTUFBTTtZQUNkLE1BQU0sSUFBSWUsTUFBTTtRQUNwQjtRQUNBSixNQUFNSCxTQUFTLEdBQUcsTUFBT0EsU0FBUyxJQUFJLElBQU1SLE9BQU87UUFDbkRXLE1BQU1DLE9BQU8sSUFBSTtRQUNqQixJQUFJRCxNQUFNQyxPQUFPLEtBQUssR0FBRztZQUNyQkwsS0FBS0ksTUFBTUgsU0FBUztRQUN4QjtJQUNKO0FBQ0osRUFDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmNob3Itd29ya2Zsb3dzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zc3IvZGlzdC9tb2R1bGUvdXRpbHMvYmFzZTY0dXJsLmpzPzZmZTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBdm9pZCBtb2RpZnlpbmcgdGhpcyBmaWxlLiBJdCdzIHBhcnQgb2ZcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS1jb21tdW5pdHkvYmFzZTY0dXJsLWpzLiAgU3VibWl0IGFsbCBmaXhlcyBvblxuICogdGhhdCByZXBvIVxuICovXG4vKipcbiAqIEFuIGFycmF5IG9mIGNoYXJhY3RlcnMgdGhhdCBlbmNvZGUgNiBiaXRzIGludG8gYSBCYXNlNjQtVVJMIGFscGhhYmV0XG4gKiBjaGFyYWN0ZXIuXG4gKi9cbmNvbnN0IFRPX0JBU0U2NFVSTCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktX1wiLnNwbGl0KFwiXCIpO1xuLyoqXG4gKiBBbiBhcnJheSBvZiBjaGFyYWN0ZXJzIHRoYXQgY2FuIGFwcGVhciBpbiBhIEJhc2U2NC1VUkwgZW5jb2RlZCBzdHJpbmcgYnV0XG4gKiBzaG91bGQgYmUgaWdub3JlZC5cbiAqL1xuY29uc3QgSUdOT1JFX0JBU0U2NFVSTCA9IFwiIFxcdFxcblxccj1cIi5zcGxpdChcIlwiKTtcbi8qKlxuICogQW4gYXJyYXkgb2YgMTI4IG51bWJlcnMgdGhhdCBtYXAgYSBCYXNlNjQtVVJMIGNoYXJhY3RlciB0byA2IGJpdHMsIG9yIGlmIC0yXG4gKiB1c2VkIHRvIHNraXAgdGhlIGNoYXJhY3Rlciwgb3IgaWYgLTEgdXNlZCB0byBlcnJvciBvdXQuXG4gKi9cbmNvbnN0IEZST01fQkFTRTY0VVJMID0gKCgpID0+IHtcbiAgICBjb25zdCBjaGFyTWFwID0gbmV3IEFycmF5KDEyOCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFyTWFwLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNoYXJNYXBbaV0gPSAtMTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBJR05PUkVfQkFTRTY0VVJMLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNoYXJNYXBbSUdOT1JFX0JBU0U2NFVSTFtpXS5jaGFyQ29kZUF0KDApXSA9IC0yO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRPX0JBU0U2NFVSTC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjaGFyTWFwW1RPX0JBU0U2NFVSTFtpXS5jaGFyQ29kZUF0KDApXSA9IGk7XG4gICAgfVxuICAgIHJldHVybiBjaGFyTWFwO1xufSkoKTtcbi8qKlxuICogQ29udmVydHMgYSBKYXZhU2NyaXB0IHN0cmluZyAod2hpY2ggbWF5IGluY2x1ZGUgYW55IHZhbGlkIGNoYXJhY3RlcikgaW50byBhXG4gKiBCYXNlNjQtVVJMIGVuY29kZWQgc3RyaW5nLiBUaGUgc3RyaW5nIGlzIGZpcnN0IGVuY29kZWQgaW4gVVRGLTggd2hpY2ggaXNcbiAqIHRoZW4gZW5jb2RlZCBhcyBCYXNlNjQtVVJMLlxuICpcbiAqIEBwYXJhbSBzdHIgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nVG9CYXNlNjRVUkwoc3RyKSB7XG4gICAgY29uc3QgYmFzZTY0ID0gW107XG4gICAgbGV0IHF1ZXVlID0gMDtcbiAgICBsZXQgcXVldWVkQml0cyA9IDA7XG4gICAgY29uc3QgZW1pdHRlciA9IChieXRlKSA9PiB7XG4gICAgICAgIHF1ZXVlID0gKHF1ZXVlIDw8IDgpIHwgYnl0ZTtcbiAgICAgICAgcXVldWVkQml0cyArPSA4O1xuICAgICAgICB3aGlsZSAocXVldWVkQml0cyA+PSA2KSB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSAocXVldWUgPj4gKHF1ZXVlZEJpdHMgLSA2KSkgJiA2MztcbiAgICAgICAgICAgIGJhc2U2NC5wdXNoKFRPX0JBU0U2NFVSTFtwb3NdKTtcbiAgICAgICAgICAgIHF1ZXVlZEJpdHMgLT0gNjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgc3RyaW5nVG9VVEY4KHN0ciwgZW1pdHRlcik7XG4gICAgaWYgKHF1ZXVlZEJpdHMgPiAwKSB7XG4gICAgICAgIHF1ZXVlID0gcXVldWUgPDwgKDYgLSBxdWV1ZWRCaXRzKTtcbiAgICAgICAgcXVldWVkQml0cyA9IDY7XG4gICAgICAgIHdoaWxlIChxdWV1ZWRCaXRzID49IDYpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IChxdWV1ZSA+PiAocXVldWVkQml0cyAtIDYpKSAmIDYzO1xuICAgICAgICAgICAgYmFzZTY0LnB1c2goVE9fQkFTRTY0VVJMW3Bvc10pO1xuICAgICAgICAgICAgcXVldWVkQml0cyAtPSA2O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiYXNlNjQuam9pbihcIlwiKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBCYXNlNjQtVVJMIGVuY29kZWQgc3RyaW5nIGludG8gYSBKYXZhU2NyaXB0IHN0cmluZy4gSXQgaXMgYXNzdW1lZFxuICogdGhhdCB0aGUgdW5kZXJseWluZyBzdHJpbmcgaGFzIGJlZW4gZW5jb2RlZCBhcyBVVEYtOC5cbiAqXG4gKiBAcGFyYW0gc3RyIFRoZSBCYXNlNjQtVVJMIGVuY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nRnJvbUJhc2U2NFVSTChzdHIpIHtcbiAgICBjb25zdCBjb252ID0gW107XG4gICAgY29uc3QgZW1pdCA9IChjb2RlcG9pbnQpID0+IHtcbiAgICAgICAgY29udi5wdXNoKFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGVwb2ludCkpO1xuICAgIH07XG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgIHV0ZjhzZXE6IDAsXG4gICAgICAgIGNvZGVwb2ludDogMCxcbiAgICB9O1xuICAgIGxldCBxdWV1ZSA9IDA7XG4gICAgbGV0IHF1ZXVlZEJpdHMgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGNvZGVwb2ludCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBjb25zdCBiaXRzID0gRlJPTV9CQVNFNjRVUkxbY29kZXBvaW50XTtcbiAgICAgICAgaWYgKGJpdHMgPiAtMSkge1xuICAgICAgICAgICAgLy8gdmFsaWQgQmFzZTY0LVVSTCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIHF1ZXVlID0gKHF1ZXVlIDw8IDYpIHwgYml0cztcbiAgICAgICAgICAgIHF1ZXVlZEJpdHMgKz0gNjtcbiAgICAgICAgICAgIHdoaWxlIChxdWV1ZWRCaXRzID49IDgpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmdGcm9tVVRGOCgocXVldWUgPj4gKHF1ZXVlZEJpdHMgLSA4KSkgJiAweGZmLCBzdGF0ZSwgZW1pdCk7XG4gICAgICAgICAgICAgICAgcXVldWVkQml0cyAtPSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJpdHMgPT09IC0yKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgc3BhY2VzLCB0YWJzLCBuZXdsaW5lcywgPVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgQmFzZTY0LVVSTCBjaGFyYWN0ZXIgXCIke3N0ci5hdChpKX1cIiBhdCBwb3NpdGlvbiAke2l9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbnYuam9pbihcIlwiKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBVbmljb2RlIGNvZGVwb2ludCB0byBhIG11bHRpLWJ5dGUgVVRGLTggc2VxdWVuY2UuXG4gKlxuICogQHBhcmFtIGNvZGVwb2ludCBUaGUgVW5pY29kZSBjb2RlcG9pbnQuXG4gKiBAcGFyYW0gZW1pdCAgICAgIEZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIFVURi04IGJ5dGUgdGhhdCByZXByZXNlbnRzIHRoZSBjb2RlcG9pbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb2RlcG9pbnRUb1VURjgoY29kZXBvaW50LCBlbWl0KSB7XG4gICAgaWYgKGNvZGVwb2ludCA8PSAweDdmKSB7XG4gICAgICAgIGVtaXQoY29kZXBvaW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlcG9pbnQgPD0gMHg3ZmYpIHtcbiAgICAgICAgZW1pdCgweGMwIHwgKGNvZGVwb2ludCA+PiA2KSk7XG4gICAgICAgIGVtaXQoMHg4MCB8IChjb2RlcG9pbnQgJiAweDNmKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZXBvaW50IDw9IDB4ZmZmZikge1xuICAgICAgICBlbWl0KDB4ZTAgfCAoY29kZXBvaW50ID4+IDEyKSk7XG4gICAgICAgIGVtaXQoMHg4MCB8ICgoY29kZXBvaW50ID4+IDYpICYgMHgzZikpO1xuICAgICAgICBlbWl0KDB4ODAgfCAoY29kZXBvaW50ICYgMHgzZikpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGVwb2ludCA8PSAweDEwZmZmZikge1xuICAgICAgICBlbWl0KDB4ZjAgfCAoY29kZXBvaW50ID4+IDE4KSk7XG4gICAgICAgIGVtaXQoMHg4MCB8ICgoY29kZXBvaW50ID4+IDEyKSAmIDB4M2YpKTtcbiAgICAgICAgZW1pdCgweDgwIHwgKChjb2RlcG9pbnQgPj4gNikgJiAweDNmKSk7XG4gICAgICAgIGVtaXQoMHg4MCB8IChjb2RlcG9pbnQgJiAweDNmKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgVW5pY29kZSBjb2RlcG9pbnQ6ICR7Y29kZXBvaW50LnRvU3RyaW5nKDE2KX1gKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBKYXZhU2NyaXB0IHN0cmluZyB0byBhIHNlcXVlbmNlIG9mIFVURi04IGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBzdHIgIFRoZSBzdHJpbmcgdG8gY29udmVydCB0byBVVEYtOC5cbiAqIEBwYXJhbSBlbWl0IEZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIFVURi04IGJ5dGUgb2YgdGhlIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ1RvVVRGOChzdHIsIGVtaXQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBsZXQgY29kZXBvaW50ID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlcG9pbnQgPiAweGQ3ZmYgJiYgY29kZXBvaW50IDw9IDB4ZGJmZikge1xuICAgICAgICAgICAgLy8gbW9zdCBVVEYtMTYgY29kZXBvaW50cyBhcmUgVW5pY29kZSBjb2RlcG9pbnRzLCBleGNlcHQgdmFsdWVzIGluIHRoaXNcbiAgICAgICAgICAgIC8vIHJhbmdlIHdoZXJlIHRoZSBuZXh0IFVURi0xNiBjb2RlcG9pbnQgbmVlZHMgdG8gYmUgY29tYmluZWQgd2l0aCB0aGVcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgb25lIHRvIGdldCB0aGUgVW5pY29kZSBjb2RlcG9pbnRcbiAgICAgICAgICAgIGNvbnN0IGhpZ2hTdXJyb2dhdGUgPSAoKGNvZGVwb2ludCAtIDB4ZDgwMCkgKiAweDQwMCkgJiAweGZmZmY7XG4gICAgICAgICAgICBjb25zdCBsb3dTdXJyb2dhdGUgPSAoc3RyLmNoYXJDb2RlQXQoaSArIDEpIC0gMHhkYzAwKSAmIDB4ZmZmZjtcbiAgICAgICAgICAgIGNvZGVwb2ludCA9IChsb3dTdXJyb2dhdGUgfCBoaWdoU3Vycm9nYXRlKSArIDB4MTAwMDA7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29kZXBvaW50VG9VVEY4KGNvZGVwb2ludCwgZW1pdCk7XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFVURi04IGJ5dGUgdG8gYSBVbmljb2RlIGNvZGVwb2ludC5cbiAqXG4gKiBAcGFyYW0gYnl0ZSAgVGhlIFVURi04IGJ5dGUgbmV4dCBpbiB0aGUgc2VxdWVuY2UuXG4gKiBAcGFyYW0gc3RhdGUgVGhlIHNoYXJlZCBzdGF0ZSBiZXR3ZWVuIGNvbnNlY3V0aXZlIFVURi04IGJ5dGVzIGluIHRoZVxuICogICAgICAgICAgICAgIHNlcXVlbmNlLCBhbiBvYmplY3Qgd2l0aCB0aGUgc2hhcGUgYHsgdXRmOHNlcTogMCwgY29kZXBvaW50OiAwIH1gLlxuICogQHBhcmFtIGVtaXQgIEZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGNvZGVwb2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ0Zyb21VVEY4KGJ5dGUsIHN0YXRlLCBlbWl0KSB7XG4gICAgaWYgKHN0YXRlLnV0ZjhzZXEgPT09IDApIHtcbiAgICAgICAgaWYgKGJ5dGUgPD0gMHg3Zikge1xuICAgICAgICAgICAgZW1pdChieXRlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIDEgbGVhZGluZyBiaXRzIHVudGlsIHlvdSByZWFjaCAwXG4gICAgICAgIGZvciAobGV0IGxlYWRpbmdCaXQgPSAxOyBsZWFkaW5nQml0IDwgNjsgbGVhZGluZ0JpdCArPSAxKSB7XG4gICAgICAgICAgICBpZiAoKChieXRlID4+ICg3IC0gbGVhZGluZ0JpdCkpICYgMSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS51dGY4c2VxID0gbGVhZGluZ0JpdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUudXRmOHNlcSA9PT0gMikge1xuICAgICAgICAgICAgc3RhdGUuY29kZXBvaW50ID0gYnl0ZSAmIDMxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLnV0ZjhzZXEgPT09IDMpIHtcbiAgICAgICAgICAgIHN0YXRlLmNvZGVwb2ludCA9IGJ5dGUgJiAxNTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS51dGY4c2VxID09PSA0KSB7XG4gICAgICAgICAgICBzdGF0ZS5jb2RlcG9pbnQgPSBieXRlICYgNztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgVVRGLTggc2VxdWVuY2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUudXRmOHNlcSAtPSAxO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZS51dGY4c2VxID4gMCkge1xuICAgICAgICBpZiAoYnl0ZSA8PSAweDdmKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFVURi04IHNlcXVlbmNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmNvZGVwb2ludCA9IChzdGF0ZS5jb2RlcG9pbnQgPDwgNikgfCAoYnl0ZSAmIDYzKTtcbiAgICAgICAgc3RhdGUudXRmOHNlcSAtPSAxO1xuICAgICAgICBpZiAoc3RhdGUudXRmOHNlcSA9PT0gMCkge1xuICAgICAgICAgICAgZW1pdChzdGF0ZS5jb2RlcG9pbnQpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTY0dXJsLmpzLm1hcCJdLCJuYW1lcyI6WyJUT19CQVNFNjRVUkwiLCJzcGxpdCIsIklHTk9SRV9CQVNFNjRVUkwiLCJGUk9NX0JBU0U2NFVSTCIsImNoYXJNYXAiLCJBcnJheSIsImkiLCJsZW5ndGgiLCJjaGFyQ29kZUF0Iiwic3RyaW5nVG9CYXNlNjRVUkwiLCJzdHIiLCJiYXNlNjQiLCJxdWV1ZSIsInF1ZXVlZEJpdHMiLCJlbWl0dGVyIiwiYnl0ZSIsInBvcyIsInB1c2giLCJzdHJpbmdUb1VURjgiLCJqb2luIiwic3RyaW5nRnJvbUJhc2U2NFVSTCIsImNvbnYiLCJlbWl0IiwiY29kZXBvaW50IiwiU3RyaW5nIiwiZnJvbUNvZGVQb2ludCIsInN0YXRlIiwidXRmOHNlcSIsImJpdHMiLCJzdHJpbmdGcm9tVVRGOCIsIkVycm9yIiwiYXQiLCJjb2RlcG9pbnRUb1VURjgiLCJ0b1N0cmluZyIsImhpZ2hTdXJyb2dhdGUiLCJsb3dTdXJyb2dhdGUiLCJsZWFkaW5nQml0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/ssr/dist/module/utils/base64url.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/ssr/dist/module/utils/chunker.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/ssr/dist/module/utils/chunker.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAX_CHUNK_SIZE: () => (/* binding */ MAX_CHUNK_SIZE),\n/* harmony export */   combineChunks: () => (/* binding */ combineChunks),\n/* harmony export */   createChunks: () => (/* binding */ createChunks),\n/* harmony export */   deleteChunks: () => (/* binding */ deleteChunks),\n/* harmony export */   isChunkLike: () => (/* binding */ isChunkLike)\n/* harmony export */ });\nconst MAX_CHUNK_SIZE = 3180;\nconst CHUNK_LIKE_REGEX = /^(.*)[.](0|[1-9][0-9]*)$/;\nfunction isChunkLike(cookieName, key) {\n    if (cookieName === key) {\n        return true;\n    }\n    const chunkLike = cookieName.match(CHUNK_LIKE_REGEX);\n    if (chunkLike && chunkLike[1] === key) {\n        return true;\n    }\n    return false;\n}\n/**\n * create chunks from a string and return an array of object\n */ function createChunks(key, value, chunkSize) {\n    const resolvedChunkSize = chunkSize ?? MAX_CHUNK_SIZE;\n    let encodedValue = encodeURIComponent(value);\n    if (encodedValue.length <= resolvedChunkSize) {\n        return [\n            {\n                name: key,\n                value\n            }\n        ];\n    }\n    const chunks = [];\n    while(encodedValue.length > 0){\n        let encodedChunkHead = encodedValue.slice(0, resolvedChunkSize);\n        const lastEscapePos = encodedChunkHead.lastIndexOf(\"%\");\n        // Check if the last escaped character is truncated.\n        if (lastEscapePos > resolvedChunkSize - 3) {\n            // If so, reslice the string to exclude the whole escape sequence.\n            // We only reduce the size of the string as the chunk must\n            // be smaller than the chunk size.\n            encodedChunkHead = encodedChunkHead.slice(0, lastEscapePos);\n        }\n        let valueHead = \"\";\n        // Check if the chunk was split along a valid unicode boundary.\n        while(encodedChunkHead.length > 0){\n            try {\n                // Try to decode the chunk back and see if it is valid.\n                // Stop when the chunk is valid.\n                valueHead = decodeURIComponent(encodedChunkHead);\n                break;\n            } catch (error) {\n                if (error instanceof URIError && encodedChunkHead.at(-3) === \"%\" && encodedChunkHead.length > 3) {\n                    encodedChunkHead = encodedChunkHead.slice(0, encodedChunkHead.length - 3);\n                } else {\n                    throw error;\n                }\n            }\n        }\n        chunks.push(valueHead);\n        encodedValue = encodedValue.slice(encodedChunkHead.length);\n    }\n    return chunks.map((value, i)=>({\n            name: `${key}.${i}`,\n            value\n        }));\n}\n// Get fully constructed chunks\nasync function combineChunks(key, retrieveChunk) {\n    const value = await retrieveChunk(key);\n    if (value) {\n        return value;\n    }\n    let values = [];\n    for(let i = 0;; i++){\n        const chunkName = `${key}.${i}`;\n        const chunk = await retrieveChunk(chunkName);\n        if (!chunk) {\n            break;\n        }\n        values.push(chunk);\n    }\n    if (values.length > 0) {\n        return values.join(\"\");\n    }\n    return null;\n}\nasync function deleteChunks(key, retrieveChunk, removeChunk) {\n    const value = await retrieveChunk(key);\n    if (value) {\n        await removeChunk(key);\n    }\n    for(let i = 0;; i++){\n        const chunkName = `${key}.${i}`;\n        const chunk = await retrieveChunk(chunkName);\n        if (!chunk) {\n            break;\n        }\n        await removeChunk(chunkName);\n    }\n} //# sourceMappingURL=chunker.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Nzci9kaXN0L21vZHVsZS91dGlscy9jaHVua2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQU8sTUFBTUEsaUJBQWlCLEtBQUs7QUFDbkMsTUFBTUMsbUJBQW1CO0FBQ2xCLFNBQVNDLFlBQVlDLFVBQVUsRUFBRUMsR0FBRztJQUN2QyxJQUFJRCxlQUFlQyxLQUFLO1FBQ3BCLE9BQU87SUFDWDtJQUNBLE1BQU1DLFlBQVlGLFdBQVdHLEtBQUssQ0FBQ0w7SUFDbkMsSUFBSUksYUFBYUEsU0FBUyxDQUFDLEVBQUUsS0FBS0QsS0FBSztRQUNuQyxPQUFPO0lBQ1g7SUFDQSxPQUFPO0FBQ1g7QUFDQTs7Q0FFQyxHQUNNLFNBQVNHLGFBQWFILEdBQUcsRUFBRUksS0FBSyxFQUFFQyxTQUFTO0lBQzlDLE1BQU1DLG9CQUFvQkQsYUFBYVQ7SUFDdkMsSUFBSVcsZUFBZUMsbUJBQW1CSjtJQUN0QyxJQUFJRyxhQUFhRSxNQUFNLElBQUlILG1CQUFtQjtRQUMxQyxPQUFPO1lBQUM7Z0JBQUVJLE1BQU1WO2dCQUFLSTtZQUFNO1NBQUU7SUFDakM7SUFDQSxNQUFNTyxTQUFTLEVBQUU7SUFDakIsTUFBT0osYUFBYUUsTUFBTSxHQUFHLEVBQUc7UUFDNUIsSUFBSUcsbUJBQW1CTCxhQUFhTSxLQUFLLENBQUMsR0FBR1A7UUFDN0MsTUFBTVEsZ0JBQWdCRixpQkFBaUJHLFdBQVcsQ0FBQztRQUNuRCxvREFBb0Q7UUFDcEQsSUFBSUQsZ0JBQWdCUixvQkFBb0IsR0FBRztZQUN2QyxrRUFBa0U7WUFDbEUsMERBQTBEO1lBQzFELGtDQUFrQztZQUNsQ00sbUJBQW1CQSxpQkFBaUJDLEtBQUssQ0FBQyxHQUFHQztRQUNqRDtRQUNBLElBQUlFLFlBQVk7UUFDaEIsK0RBQStEO1FBQy9ELE1BQU9KLGlCQUFpQkgsTUFBTSxHQUFHLEVBQUc7WUFDaEMsSUFBSTtnQkFDQSx1REFBdUQ7Z0JBQ3ZELGdDQUFnQztnQkFDaENPLFlBQVlDLG1CQUFtQkw7Z0JBQy9CO1lBQ0osRUFDQSxPQUFPTSxPQUFPO2dCQUNWLElBQUlBLGlCQUFpQkMsWUFDakJQLGlCQUFpQlEsRUFBRSxDQUFDLENBQUMsT0FBTyxPQUM1QlIsaUJBQWlCSCxNQUFNLEdBQUcsR0FBRztvQkFDN0JHLG1CQUFtQkEsaUJBQWlCQyxLQUFLLENBQUMsR0FBR0QsaUJBQWlCSCxNQUFNLEdBQUc7Z0JBQzNFLE9BQ0s7b0JBQ0QsTUFBTVM7Z0JBQ1Y7WUFDSjtRQUNKO1FBQ0FQLE9BQU9VLElBQUksQ0FBQ0w7UUFDWlQsZUFBZUEsYUFBYU0sS0FBSyxDQUFDRCxpQkFBaUJILE1BQU07SUFDN0Q7SUFDQSxPQUFPRSxPQUFPVyxHQUFHLENBQUMsQ0FBQ2xCLE9BQU9tQixJQUFPO1lBQUViLE1BQU0sQ0FBQyxFQUFFVixJQUFJLENBQUMsRUFBRXVCLEVBQUUsQ0FBQztZQUFFbkI7UUFBTTtBQUNsRTtBQUNBLCtCQUErQjtBQUN4QixlQUFlb0IsY0FBY3hCLEdBQUcsRUFBRXlCLGFBQWE7SUFDbEQsTUFBTXJCLFFBQVEsTUFBTXFCLGNBQWN6QjtJQUNsQyxJQUFJSSxPQUFPO1FBQ1AsT0FBT0E7SUFDWDtJQUNBLElBQUlzQixTQUFTLEVBQUU7SUFDZixJQUFLLElBQUlILElBQUksSUFBSUEsSUFBSztRQUNsQixNQUFNSSxZQUFZLENBQUMsRUFBRTNCLElBQUksQ0FBQyxFQUFFdUIsRUFBRSxDQUFDO1FBQy9CLE1BQU1LLFFBQVEsTUFBTUgsY0FBY0U7UUFDbEMsSUFBSSxDQUFDQyxPQUFPO1lBQ1I7UUFDSjtRQUNBRixPQUFPTCxJQUFJLENBQUNPO0lBQ2hCO0lBQ0EsSUFBSUYsT0FBT2pCLE1BQU0sR0FBRyxHQUFHO1FBQ25CLE9BQU9pQixPQUFPRyxJQUFJLENBQUM7SUFDdkI7SUFDQSxPQUFPO0FBQ1g7QUFDTyxlQUFlQyxhQUFhOUIsR0FBRyxFQUFFeUIsYUFBYSxFQUFFTSxXQUFXO0lBQzlELE1BQU0zQixRQUFRLE1BQU1xQixjQUFjekI7SUFDbEMsSUFBSUksT0FBTztRQUNQLE1BQU0yQixZQUFZL0I7SUFDdEI7SUFDQSxJQUFLLElBQUl1QixJQUFJLElBQUlBLElBQUs7UUFDbEIsTUFBTUksWUFBWSxDQUFDLEVBQUUzQixJQUFJLENBQUMsRUFBRXVCLEVBQUUsQ0FBQztRQUMvQixNQUFNSyxRQUFRLE1BQU1ILGNBQWNFO1FBQ2xDLElBQUksQ0FBQ0MsT0FBTztZQUNSO1FBQ0o7UUFDQSxNQUFNRyxZQUFZSjtJQUN0QjtBQUNKLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5jaG9yLXdvcmtmbG93cy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3NyL2Rpc3QvbW9kdWxlL3V0aWxzL2NodW5rZXIuanM/NzM3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgTUFYX0NIVU5LX1NJWkUgPSAzMTgwO1xuY29uc3QgQ0hVTktfTElLRV9SRUdFWCA9IC9eKC4qKVsuXSgwfFsxLTldWzAtOV0qKSQvO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ2h1bmtMaWtlKGNvb2tpZU5hbWUsIGtleSkge1xuICAgIGlmIChjb29raWVOYW1lID09PSBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rTGlrZSA9IGNvb2tpZU5hbWUubWF0Y2goQ0hVTktfTElLRV9SRUdFWCk7XG4gICAgaWYgKGNodW5rTGlrZSAmJiBjaHVua0xpa2VbMV0gPT09IGtleSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBjcmVhdGUgY2h1bmtzIGZyb20gYSBzdHJpbmcgYW5kIHJldHVybiBhbiBhcnJheSBvZiBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNodW5rcyhrZXksIHZhbHVlLCBjaHVua1NpemUpIHtcbiAgICBjb25zdCByZXNvbHZlZENodW5rU2l6ZSA9IGNodW5rU2l6ZSA/PyBNQVhfQ0hVTktfU0laRTtcbiAgICBsZXQgZW5jb2RlZFZhbHVlID0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICBpZiAoZW5jb2RlZFZhbHVlLmxlbmd0aCA8PSByZXNvbHZlZENodW5rU2l6ZSkge1xuICAgICAgICByZXR1cm4gW3sgbmFtZToga2V5LCB2YWx1ZSB9XTtcbiAgICB9XG4gICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgd2hpbGUgKGVuY29kZWRWYWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBlbmNvZGVkQ2h1bmtIZWFkID0gZW5jb2RlZFZhbHVlLnNsaWNlKDAsIHJlc29sdmVkQ2h1bmtTaXplKTtcbiAgICAgICAgY29uc3QgbGFzdEVzY2FwZVBvcyA9IGVuY29kZWRDaHVua0hlYWQubGFzdEluZGV4T2YoXCIlXCIpO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgbGFzdCBlc2NhcGVkIGNoYXJhY3RlciBpcyB0cnVuY2F0ZWQuXG4gICAgICAgIGlmIChsYXN0RXNjYXBlUG9zID4gcmVzb2x2ZWRDaHVua1NpemUgLSAzKSB7XG4gICAgICAgICAgICAvLyBJZiBzbywgcmVzbGljZSB0aGUgc3RyaW5nIHRvIGV4Y2x1ZGUgdGhlIHdob2xlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgIC8vIFdlIG9ubHkgcmVkdWNlIHRoZSBzaXplIG9mIHRoZSBzdHJpbmcgYXMgdGhlIGNodW5rIG11c3RcbiAgICAgICAgICAgIC8vIGJlIHNtYWxsZXIgdGhhbiB0aGUgY2h1bmsgc2l6ZS5cbiAgICAgICAgICAgIGVuY29kZWRDaHVua0hlYWQgPSBlbmNvZGVkQ2h1bmtIZWFkLnNsaWNlKDAsIGxhc3RFc2NhcGVQb3MpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2YWx1ZUhlYWQgPSBcIlwiO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgY2h1bmsgd2FzIHNwbGl0IGFsb25nIGEgdmFsaWQgdW5pY29kZSBib3VuZGFyeS5cbiAgICAgICAgd2hpbGUgKGVuY29kZWRDaHVua0hlYWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZGVjb2RlIHRoZSBjaHVuayBiYWNrIGFuZCBzZWUgaWYgaXQgaXMgdmFsaWQuXG4gICAgICAgICAgICAgICAgLy8gU3RvcCB3aGVuIHRoZSBjaHVuayBpcyB2YWxpZC5cbiAgICAgICAgICAgICAgICB2YWx1ZUhlYWQgPSBkZWNvZGVVUklDb21wb25lbnQoZW5jb2RlZENodW5rSGVhZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBVUklFcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICBlbmNvZGVkQ2h1bmtIZWFkLmF0KC0zKSA9PT0gXCIlXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlZENodW5rSGVhZC5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kZWRDaHVua0hlYWQgPSBlbmNvZGVkQ2h1bmtIZWFkLnNsaWNlKDAsIGVuY29kZWRDaHVua0hlYWQubGVuZ3RoIC0gMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmtzLnB1c2godmFsdWVIZWFkKTtcbiAgICAgICAgZW5jb2RlZFZhbHVlID0gZW5jb2RlZFZhbHVlLnNsaWNlKGVuY29kZWRDaHVua0hlYWQubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNodW5rcy5tYXAoKHZhbHVlLCBpKSA9PiAoeyBuYW1lOiBgJHtrZXl9LiR7aX1gLCB2YWx1ZSB9KSk7XG59XG4vLyBHZXQgZnVsbHkgY29uc3RydWN0ZWQgY2h1bmtzXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29tYmluZUNodW5rcyhrZXksIHJldHJpZXZlQ2h1bmspIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHJldHJpZXZlQ2h1bmsoa2V5KTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBsZXQgdmFsdWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgY29uc3QgY2h1bmtOYW1lID0gYCR7a2V5fS4ke2l9YDtcbiAgICAgICAgY29uc3QgY2h1bmsgPSBhd2FpdCByZXRyaWV2ZUNodW5rKGNodW5rTmFtZSk7XG4gICAgICAgIGlmICghY2h1bmspIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlcy5wdXNoKGNodW5rKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXMuam9pbihcIlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQ2h1bmtzKGtleSwgcmV0cmlldmVDaHVuaywgcmVtb3ZlQ2h1bmspIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHJldHJpZXZlQ2h1bmsoa2V5KTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgYXdhaXQgcmVtb3ZlQ2h1bmsoa2V5KTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgY29uc3QgY2h1bmtOYW1lID0gYCR7a2V5fS4ke2l9YDtcbiAgICAgICAgY29uc3QgY2h1bmsgPSBhd2FpdCByZXRyaWV2ZUNodW5rKGNodW5rTmFtZSk7XG4gICAgICAgIGlmICghY2h1bmspIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJlbW92ZUNodW5rKGNodW5rTmFtZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmtlci5qcy5tYXAiXSwibmFtZXMiOlsiTUFYX0NIVU5LX1NJWkUiLCJDSFVOS19MSUtFX1JFR0VYIiwiaXNDaHVua0xpa2UiLCJjb29raWVOYW1lIiwia2V5IiwiY2h1bmtMaWtlIiwibWF0Y2giLCJjcmVhdGVDaHVua3MiLCJ2YWx1ZSIsImNodW5rU2l6ZSIsInJlc29sdmVkQ2h1bmtTaXplIiwiZW5jb2RlZFZhbHVlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwibGVuZ3RoIiwibmFtZSIsImNodW5rcyIsImVuY29kZWRDaHVua0hlYWQiLCJzbGljZSIsImxhc3RFc2NhcGVQb3MiLCJsYXN0SW5kZXhPZiIsInZhbHVlSGVhZCIsImRlY29kZVVSSUNvbXBvbmVudCIsImVycm9yIiwiVVJJRXJyb3IiLCJhdCIsInB1c2giLCJtYXAiLCJpIiwiY29tYmluZUNodW5rcyIsInJldHJpZXZlQ2h1bmsiLCJ2YWx1ZXMiLCJjaHVua05hbWUiLCJjaHVuayIsImpvaW4iLCJkZWxldGVDaHVua3MiLCJyZW1vdmVDaHVuayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/ssr/dist/module/utils/chunker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/ssr/dist/module/utils/constants.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/ssr/dist/module/utils/constants.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_COOKIE_OPTIONS: () => (/* binding */ DEFAULT_COOKIE_OPTIONS)\n/* harmony export */ });\nconst DEFAULT_COOKIE_OPTIONS = {\n    path: \"/\",\n    sameSite: \"lax\",\n    httpOnly: false,\n    // https://developer.chrome.com/blog/cookie-max-age-expires\n    // https://httpwg.org/http-extensions/draft-ietf-httpbis-rfc6265bis.html#name-cookie-lifetime-limits\n    maxAge: 400 * 24 * 60 * 60\n}; //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Nzci9kaXN0L21vZHVsZS91dGlscy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLHlCQUF5QjtJQUNsQ0MsTUFBTTtJQUNOQyxVQUFVO0lBQ1ZDLFVBQVU7SUFDViwyREFBMkQ7SUFDM0Qsb0dBQW9HO0lBQ3BHQyxRQUFRLE1BQU0sS0FBSyxLQUFLO0FBQzVCLEVBQUUsQ0FDRixxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmNob3Itd29ya2Zsb3dzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zc3IvZGlzdC9tb2R1bGUvdXRpbHMvY29uc3RhbnRzLmpzPzY5ZTkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IERFRkFVTFRfQ09PS0lFX09QVElPTlMgPSB7XG4gICAgcGF0aDogXCIvXCIsXG4gICAgc2FtZVNpdGU6IFwibGF4XCIsXG4gICAgaHR0cE9ubHk6IGZhbHNlLFxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vYmxvZy9jb29raWUtbWF4LWFnZS1leHBpcmVzXG4gICAgLy8gaHR0cHM6Ly9odHRwd2cub3JnL2h0dHAtZXh0ZW5zaW9ucy9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcy5odG1sI25hbWUtY29va2llLWxpZmV0aW1lLWxpbWl0c1xuICAgIG1heEFnZTogNDAwICogMjQgKiA2MCAqIDYwLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOlsiREVGQVVMVF9DT09LSUVfT1BUSU9OUyIsInBhdGgiLCJzYW1lU2l0ZSIsImh0dHBPbmx5IiwibWF4QWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/ssr/dist/module/utils/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/ssr/dist/module/utils/helpers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/ssr/dist/module/utils/helpers.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   memoryLocalStorageAdapter: () => (/* binding */ memoryLocalStorageAdapter),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseCookieHeader: () => (/* binding */ parseCookieHeader),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   serializeCookieHeader: () => (/* binding */ serializeCookieHeader)\n/* harmony export */ });\n/* harmony import */ var cookie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cookie */ \"(ssr)/./node_modules/cookie/dist/index.js\");\n\n/**\n * @deprecated Since v0.4.0: Please use {@link parseCookieHeader}. `parse` will\n * not be available for import starting v1.0.0 of `@supabase/ssr`.\n */ const parse = cookie__WEBPACK_IMPORTED_MODULE_0__.parse;\n/**\n * @deprecated Since v0.4.0: Please use {@link serializeCookieHeader}.\n * `serialize` will not be available for import starting v1.0.0 of\n * `@supabase/ssr`.\n */ const serialize = cookie__WEBPACK_IMPORTED_MODULE_0__.serialize;\n/**\n * Parses the `Cookie` HTTP header into an array of cookie name-value objects.\n *\n * @param header The `Cookie` HTTP header. Decodes cookie names and values from\n * URI encoding first.\n */ function parseCookieHeader(header) {\n    const parsed = cookie__WEBPACK_IMPORTED_MODULE_0__.parse(header);\n    return Object.keys(parsed ?? {}).map((name)=>({\n            name,\n            value: parsed[name]\n        }));\n}\n/**\n * Converts the arguments to a valid `Set-Cookie` header. Non US-ASCII chars\n * and other forbidden cookie chars will be URI encoded.\n *\n * @param name Name of cookie.\n * @param value Value of cookie.\n */ function serializeCookieHeader(name, value, options) {\n    return cookie__WEBPACK_IMPORTED_MODULE_0__.serialize(name, value, options);\n}\nfunction isBrowser() {\n    return  false && 0;\n}\n/**\n * Returns a localStorage-like object that stores the key-value pairs in\n * memory.\n */ function memoryLocalStorageAdapter(store = {}) {\n    return {\n        getItem: (key)=>{\n            return store[key] || null;\n        },\n        setItem: (key, value)=>{\n            store[key] = value;\n        },\n        removeItem: (key)=>{\n            delete store[key];\n        }\n    };\n} //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Nzci9kaXN0L21vZHVsZS91dGlscy9oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBaUM7QUFDakM7OztDQUdDLEdBQ00sTUFBTUMsUUFBUUQseUNBQVksQ0FBQztBQUNsQzs7OztDQUlDLEdBQ00sTUFBTUUsWUFBWUYsNkNBQWdCLENBQUM7QUFDMUM7Ozs7O0NBS0MsR0FDTSxTQUFTRyxrQkFBa0JDLE1BQU07SUFDcEMsTUFBTUMsU0FBU0wseUNBQVksQ0FBQ0k7SUFDNUIsT0FBT0UsT0FBT0MsSUFBSSxDQUFDRixVQUFVLENBQUMsR0FBR0csR0FBRyxDQUFDLENBQUNDLE9BQVU7WUFDNUNBO1lBQ0FDLE9BQU9MLE1BQU0sQ0FBQ0ksS0FBSztRQUN2QjtBQUNKO0FBQ0E7Ozs7OztDQU1DLEdBQ00sU0FBU0Usc0JBQXNCRixJQUFJLEVBQUVDLEtBQUssRUFBRUUsT0FBTztJQUN0RCxPQUFPWiw2Q0FBZ0IsQ0FBQ1MsTUFBTUMsT0FBT0U7QUFDekM7QUFDTyxTQUFTQztJQUNaLE9BQVEsTUFBNkIsSUFBSSxDQUFzQztBQUNuRjtBQUNBOzs7Q0FHQyxHQUNNLFNBQVNHLDBCQUEwQkMsUUFBUSxDQUFDLENBQUM7SUFDaEQsT0FBTztRQUNIQyxTQUFTLENBQUNDO1lBQ04sT0FBT0YsS0FBSyxDQUFDRSxJQUFJLElBQUk7UUFDekI7UUFDQUMsU0FBUyxDQUFDRCxLQUFLVDtZQUNYTyxLQUFLLENBQUNFLElBQUksR0FBR1Q7UUFDakI7UUFDQVcsWUFBWSxDQUFDRjtZQUNULE9BQU9GLEtBQUssQ0FBQ0UsSUFBSTtRQUNyQjtJQUNKO0FBQ0osRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmNob3Itd29ya2Zsb3dzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zc3IvZGlzdC9tb2R1bGUvdXRpbHMvaGVscGVycy5qcz84ZDI5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNvb2tpZSBmcm9tIFwiY29va2llXCI7XG4vKipcbiAqIEBkZXByZWNhdGVkIFNpbmNlIHYwLjQuMDogUGxlYXNlIHVzZSB7QGxpbmsgcGFyc2VDb29raWVIZWFkZXJ9LiBgcGFyc2VgIHdpbGxcbiAqIG5vdCBiZSBhdmFpbGFibGUgZm9yIGltcG9ydCBzdGFydGluZyB2MS4wLjAgb2YgYEBzdXBhYmFzZS9zc3JgLlxuICovXG5leHBvcnQgY29uc3QgcGFyc2UgPSBjb29raWUucGFyc2U7XG4vKipcbiAqIEBkZXByZWNhdGVkIFNpbmNlIHYwLjQuMDogUGxlYXNlIHVzZSB7QGxpbmsgc2VyaWFsaXplQ29va2llSGVhZGVyfS5cbiAqIGBzZXJpYWxpemVgIHdpbGwgbm90IGJlIGF2YWlsYWJsZSBmb3IgaW1wb3J0IHN0YXJ0aW5nIHYxLjAuMCBvZlxuICogYEBzdXBhYmFzZS9zc3JgLlxuICovXG5leHBvcnQgY29uc3Qgc2VyaWFsaXplID0gY29va2llLnNlcmlhbGl6ZTtcbi8qKlxuICogUGFyc2VzIHRoZSBgQ29va2llYCBIVFRQIGhlYWRlciBpbnRvIGFuIGFycmF5IG9mIGNvb2tpZSBuYW1lLXZhbHVlIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIGhlYWRlciBUaGUgYENvb2tpZWAgSFRUUCBoZWFkZXIuIERlY29kZXMgY29va2llIG5hbWVzIGFuZCB2YWx1ZXMgZnJvbVxuICogVVJJIGVuY29kaW5nIGZpcnN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDb29raWVIZWFkZXIoaGVhZGVyKSB7XG4gICAgY29uc3QgcGFyc2VkID0gY29va2llLnBhcnNlKGhlYWRlcik7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHBhcnNlZCA/PyB7fSkubWFwKChuYW1lKSA9PiAoe1xuICAgICAgICBuYW1lLFxuICAgICAgICB2YWx1ZTogcGFyc2VkW25hbWVdLFxuICAgIH0pKTtcbn1cbi8qKlxuICogQ29udmVydHMgdGhlIGFyZ3VtZW50cyB0byBhIHZhbGlkIGBTZXQtQ29va2llYCBoZWFkZXIuIE5vbiBVUy1BU0NJSSBjaGFyc1xuICogYW5kIG90aGVyIGZvcmJpZGRlbiBjb29raWUgY2hhcnMgd2lsbCBiZSBVUkkgZW5jb2RlZC5cbiAqXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIGNvb2tpZS5cbiAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSBvZiBjb29raWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVDb29raWVIZWFkZXIobmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY29va2llLnNlcmlhbGl6ZShuYW1lLCB2YWx1ZSwgb3B0aW9ucyk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNCcm93c2VyKCkge1xuICAgIHJldHVybiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIGxvY2FsU3RvcmFnZS1saWtlIG9iamVjdCB0aGF0IHN0b3JlcyB0aGUga2V5LXZhbHVlIHBhaXJzIGluXG4gKiBtZW1vcnkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyKHN0b3JlID0ge30pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXRJdGVtOiAoa2V5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmVba2V5XSB8fCBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBzZXRJdGVtOiAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgc3RvcmVba2V5XSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVJdGVtOiAoa2V5KSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgc3RvcmVba2V5XTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVycy5qcy5tYXAiXSwibmFtZXMiOlsiY29va2llIiwicGFyc2UiLCJzZXJpYWxpemUiLCJwYXJzZUNvb2tpZUhlYWRlciIsImhlYWRlciIsInBhcnNlZCIsIk9iamVjdCIsImtleXMiLCJtYXAiLCJuYW1lIiwidmFsdWUiLCJzZXJpYWxpemVDb29raWVIZWFkZXIiLCJvcHRpb25zIiwiaXNCcm93c2VyIiwid2luZG93IiwiZG9jdW1lbnQiLCJtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyIiwic3RvcmUiLCJnZXRJdGVtIiwia2V5Iiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/ssr/dist/module/utils/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/ssr/dist/module/utils/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@supabase/ssr/dist/module/utils/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_COOKIE_OPTIONS: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_COOKIE_OPTIONS),\n/* harmony export */   MAX_CHUNK_SIZE: () => (/* reexport safe */ _chunker__WEBPACK_IMPORTED_MODULE_2__.MAX_CHUNK_SIZE),\n/* harmony export */   codepointToUTF8: () => (/* reexport safe */ _base64url__WEBPACK_IMPORTED_MODULE_3__.codepointToUTF8),\n/* harmony export */   combineChunks: () => (/* reexport safe */ _chunker__WEBPACK_IMPORTED_MODULE_2__.combineChunks),\n/* harmony export */   createChunks: () => (/* reexport safe */ _chunker__WEBPACK_IMPORTED_MODULE_2__.createChunks),\n/* harmony export */   deleteChunks: () => (/* reexport safe */ _chunker__WEBPACK_IMPORTED_MODULE_2__.deleteChunks),\n/* harmony export */   isBrowser: () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_0__.isBrowser),\n/* harmony export */   isChunkLike: () => (/* reexport safe */ _chunker__WEBPACK_IMPORTED_MODULE_2__.isChunkLike),\n/* harmony export */   memoryLocalStorageAdapter: () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_0__.memoryLocalStorageAdapter),\n/* harmony export */   parse: () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_0__.parse),\n/* harmony export */   parseCookieHeader: () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_0__.parseCookieHeader),\n/* harmony export */   serialize: () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_0__.serialize),\n/* harmony export */   serializeCookieHeader: () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_0__.serializeCookieHeader),\n/* harmony export */   stringFromBase64URL: () => (/* reexport safe */ _base64url__WEBPACK_IMPORTED_MODULE_3__.stringFromBase64URL),\n/* harmony export */   stringFromUTF8: () => (/* reexport safe */ _base64url__WEBPACK_IMPORTED_MODULE_3__.stringFromUTF8),\n/* harmony export */   stringToBase64URL: () => (/* reexport safe */ _base64url__WEBPACK_IMPORTED_MODULE_3__.stringToBase64URL),\n/* harmony export */   stringToUTF8: () => (/* reexport safe */ _base64url__WEBPACK_IMPORTED_MODULE_3__.stringToUTF8)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/@supabase/ssr/dist/module/utils/helpers.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@supabase/ssr/dist/module/utils/constants.js\");\n/* harmony import */ var _chunker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunker */ \"(ssr)/./node_modules/@supabase/ssr/dist/module/utils/chunker.js\");\n/* harmony import */ var _base64url__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base64url */ \"(ssr)/./node_modules/@supabase/ssr/dist/module/utils/base64url.js\");\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Nzci9kaXN0L21vZHVsZS91dGlscy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEI7QUFDRTtBQUNGO0FBQ0UsQ0FDNUIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5jaG9yLXdvcmtmbG93cy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3NyL2Rpc3QvbW9kdWxlL3V0aWxzL2luZGV4LmpzP2I5MWQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4vaGVscGVyc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9jaHVua2VyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9iYXNlNjR1cmxcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/ssr/dist/module/utils/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/ssr/dist/module/version.js":
/*!***********************************************************!*\
  !*** ./node_modules/@supabase/ssr/dist/module/version.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VERSION: () => (/* binding */ VERSION)\n/* harmony export */ });\nconst VERSION = \"0.8.0\"; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Nzci9kaXN0L21vZHVsZS92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxNQUFNQSxVQUFVLFFBQVEsQ0FDL0IsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5jaG9yLXdvcmtmbG93cy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3NyL2Rpc3QvbW9kdWxlL3ZlcnNpb24uanM/MmJmMiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgVkVSU0lPTiA9ICcwLjguMCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJWRVJTSU9OIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/ssr/dist/module/version.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/cookies.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@supabase/auth-helpers-nextjs/dist/module/cookies.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyServerStorage: () => (/* binding */ applyServerStorage),\n/* harmony export */   createStorageFromOptions: () => (/* binding */ createStorageFromOptions)\n/* harmony export */ });\n/* harmony import */ var cookie__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cookie */ \"(rsc)/./node_modules/cookie/dist/index.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/utils/index.js\");\n\n\nconst BASE64_PREFIX = \"base64-\";\n/**\n * Creates a storage client that handles cookies correctly for browser and\n * server clients with or without properly provided cookie methods.\n *\n * @param options The options passed to createBrowserClient or createServer client.\n *\n * @param isServerClient Whether it's called from createServerClient.\n */ function createStorageFromOptions(options, isServerClient) {\n    const cookies = options.cookies ?? null;\n    const cookieEncoding = options.cookieEncoding;\n    const setItems = {};\n    const removedItems = {};\n    let getAll;\n    let setAll;\n    if (cookies) {\n        if (\"get\" in cookies) {\n            // Just get is not enough, because the client needs to see what cookies\n            // are already set and unset them if necessary. To attempt to fix this\n            // behavior for most use cases, we pass \"hints\" which is the keys of the\n            // storage items. They are then converted to their corresponding cookie\n            // chunk names and are fetched with get. Only 5 chunks are fetched, which\n            // should be enough for the majority of use cases, but does not solve\n            // those with very large sessions.\n            const getWithHints = async (keyHints)=>{\n                // optimistically find the first 5 potential chunks for the specified key\n                const chunkNames = keyHints.flatMap((keyHint)=>[\n                        keyHint,\n                        ...Array.from({\n                            length: 5\n                        }).map((_, i)=>`${keyHint}.${i}`)\n                    ]);\n                const chunks = [];\n                for(let i = 0; i < chunkNames.length; i += 1){\n                    const value = await cookies.get(chunkNames[i]);\n                    if (!value && typeof value !== \"string\") {\n                        continue;\n                    }\n                    chunks.push({\n                        name: chunkNames[i],\n                        value\n                    });\n                }\n                // TODO: detect and log stale chunks error\n                return chunks;\n            };\n            getAll = async (keyHints)=>await getWithHints(keyHints);\n            if (\"set\" in cookies && \"remove\" in cookies) {\n                setAll = async (setCookies)=>{\n                    for(let i = 0; i < setCookies.length; i += 1){\n                        const { name, value, options } = setCookies[i];\n                        if (value) {\n                            await cookies.set(name, value, options);\n                        } else {\n                            await cookies.remove(name, options);\n                        }\n                    }\n                };\n            } else if (isServerClient) {\n                setAll = async ()=>{\n                    console.warn(\"@supabase/ssr: createServerClient was configured without set and remove cookie methods, but the client needs to set cookies. This can lead to issues such as random logouts, early session termination or increased token refresh requests. If in NextJS, check your middleware.ts file, route handlers and server actions for correctness. Consider switching to the getAll and setAll cookie methods instead of get, set and remove which are deprecated and can be difficult to use correctly.\");\n                };\n            } else {\n                throw new Error(\"@supabase/ssr: createBrowserClient requires configuring a getAll and setAll cookie method (deprecated: alternatively both get, set and remove can be used)\");\n            }\n        } else if (\"getAll\" in cookies) {\n            getAll = async ()=>await cookies.getAll();\n            if (\"setAll\" in cookies) {\n                setAll = cookies.setAll;\n            } else if (isServerClient) {\n                setAll = async ()=>{\n                    console.warn(\"@supabase/ssr: createServerClient was configured without the setAll cookie method, but the client needs to set cookies. This can lead to issues such as random logouts, early session termination or increased token refresh requests. If in NextJS, check your middleware.ts file, route handlers and server actions for correctness.\");\n                };\n            } else {\n                throw new Error(\"@supabase/ssr: createBrowserClient requires configuring both getAll and setAll cookie methods (deprecated: alternatively both get, set and remove can be used)\");\n            }\n        } else {\n            // neither get nor getAll is present on cookies, only will occur if pure JavaScript is used, but cookies is an object\n            throw new Error(`@supabase/ssr: ${isServerClient ? \"createServerClient\" : \"createBrowserClient\"} requires configuring getAll and setAll cookie methods (deprecated: alternatively use get, set and remove).${(0,_utils__WEBPACK_IMPORTED_MODULE_0__.isBrowser)() ? \" As this is called in a browser runtime, consider removing the cookies option object to use the document.cookie API automatically.\" : \"\"}`);\n        }\n    } else if (!isServerClient && (0,_utils__WEBPACK_IMPORTED_MODULE_0__.isBrowser)()) {\n        // The environment is browser, so use the document.cookie API to implement getAll and setAll.\n        const noHintGetAll = ()=>{\n            const parsed = (0,cookie__WEBPACK_IMPORTED_MODULE_1__.parse)(document.cookie);\n            return Object.keys(parsed).map((name)=>({\n                    name,\n                    value: parsed[name] ?? \"\"\n                }));\n        };\n        getAll = ()=>noHintGetAll();\n        setAll = (setCookies)=>{\n            setCookies.forEach(({ name, value, options })=>{\n                document.cookie = (0,cookie__WEBPACK_IMPORTED_MODULE_1__.serialize)(name, value, options);\n            });\n        };\n    } else if (isServerClient) {\n        throw new Error(\"@supabase/ssr: createServerClient must be initialized with cookie options that specify getAll and setAll functions (deprecated, not recommended: alternatively use get, set and remove)\");\n    } else {\n        // getting cookies when there's no window but we're in browser mode can be OK, because the developer probably is not using auth functions\n        getAll = ()=>{\n            return [];\n        };\n        // this is NOT OK because the developer is using auth functions that require setting some state, so that must error out\n        setAll = ()=>{\n            throw new Error(\"@supabase/ssr: createBrowserClient in non-browser runtimes (including Next.js pre-rendering mode) was not initialized cookie options that specify getAll and setAll functions (deprecated: alternatively use get, set and remove), but they were needed\");\n        };\n    }\n    if (!isServerClient) {\n        // This is the storage client to be used in browsers. It only\n        // works on the cookies abstraction, unlike the server client\n        // which only uses cookies to read the initial state. When an\n        // item is set, cookies are both cleared and set to values so\n        // that stale chunks are not left remaining.\n        return {\n            getAll,\n            setAll,\n            setItems,\n            removedItems,\n            storage: {\n                isServer: false,\n                getItem: async (key)=>{\n                    const allCookies = await getAll([\n                        key\n                    ]);\n                    const chunkedCookie = await (0,_utils__WEBPACK_IMPORTED_MODULE_0__.combineChunks)(key, async (chunkName)=>{\n                        const cookie = allCookies?.find(({ name })=>name === chunkName) || null;\n                        if (!cookie) {\n                            return null;\n                        }\n                        return cookie.value;\n                    });\n                    if (!chunkedCookie) {\n                        return null;\n                    }\n                    let decoded = chunkedCookie;\n                    if (chunkedCookie.startsWith(BASE64_PREFIX)) {\n                        decoded = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.stringFromBase64URL)(chunkedCookie.substring(BASE64_PREFIX.length));\n                    }\n                    return decoded;\n                },\n                setItem: async (key, value)=>{\n                    const allCookies = await getAll([\n                        key\n                    ]);\n                    const cookieNames = allCookies?.map(({ name })=>name) || [];\n                    const removeCookies = new Set(cookieNames.filter((name)=>(0,_utils__WEBPACK_IMPORTED_MODULE_0__.isChunkLike)(name, key)));\n                    let encoded = value;\n                    if (cookieEncoding === \"base64url\") {\n                        encoded = BASE64_PREFIX + (0,_utils__WEBPACK_IMPORTED_MODULE_0__.stringToBase64URL)(value);\n                    }\n                    const setCookies = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.createChunks)(key, encoded);\n                    setCookies.forEach(({ name })=>{\n                        removeCookies.delete(name);\n                    });\n                    const removeCookieOptions = {\n                        ..._utils__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_COOKIE_OPTIONS,\n                        ...options?.cookieOptions,\n                        maxAge: 0\n                    };\n                    const setCookieOptions = {\n                        ..._utils__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_COOKIE_OPTIONS,\n                        ...options?.cookieOptions,\n                        maxAge: _utils__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_COOKIE_OPTIONS.maxAge\n                    };\n                    // the NextJS cookieStore API can get confused if the `name` from\n                    // options.cookieOptions leaks\n                    delete removeCookieOptions.name;\n                    delete setCookieOptions.name;\n                    const allToSet = [\n                        ...[\n                            ...removeCookies\n                        ].map((name)=>({\n                                name,\n                                value: \"\",\n                                options: removeCookieOptions\n                            })),\n                        ...setCookies.map(({ name, value })=>({\n                                name,\n                                value,\n                                options: setCookieOptions\n                            }))\n                    ];\n                    if (allToSet.length > 0) {\n                        await setAll(allToSet);\n                    }\n                },\n                removeItem: async (key)=>{\n                    const allCookies = await getAll([\n                        key\n                    ]);\n                    const cookieNames = allCookies?.map(({ name })=>name) || [];\n                    const removeCookies = cookieNames.filter((name)=>(0,_utils__WEBPACK_IMPORTED_MODULE_0__.isChunkLike)(name, key));\n                    const removeCookieOptions = {\n                        ..._utils__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_COOKIE_OPTIONS,\n                        ...options?.cookieOptions,\n                        maxAge: 0\n                    };\n                    // the NextJS cookieStore API can get confused if the `name` from\n                    // options.cookieOptions leaks\n                    delete removeCookieOptions.name;\n                    if (removeCookies.length > 0) {\n                        await setAll(removeCookies.map((name)=>({\n                                name,\n                                value: \"\",\n                                options: removeCookieOptions\n                            })));\n                    }\n                }\n            }\n        };\n    }\n    // This is the server client. It only uses getAll to read the initial\n    // state. Any subsequent changes to the items is persisted in the\n    // setItems and removedItems objects. createServerClient *must* use\n    // getAll, setAll and the values in setItems and removedItems to\n    // persist the changes *at once* when appropriate (usually only when\n    // the TOKEN_REFRESHED, USER_UPDATED or SIGNED_OUT events are fired by\n    // the Supabase Auth client).\n    return {\n        getAll,\n        setAll,\n        setItems,\n        removedItems,\n        storage: {\n            // to signal to the libraries that these cookies are\n            // coming from a server environment and their value\n            // should not be trusted\n            isServer: true,\n            getItem: async (key)=>{\n                if (typeof setItems[key] === \"string\") {\n                    return setItems[key];\n                }\n                if (removedItems[key]) {\n                    return null;\n                }\n                const allCookies = await getAll([\n                    key\n                ]);\n                const chunkedCookie = await (0,_utils__WEBPACK_IMPORTED_MODULE_0__.combineChunks)(key, async (chunkName)=>{\n                    const cookie = allCookies?.find(({ name })=>name === chunkName) || null;\n                    if (!cookie) {\n                        return null;\n                    }\n                    return cookie.value;\n                });\n                if (!chunkedCookie) {\n                    return null;\n                }\n                let decoded = chunkedCookie;\n                if (typeof chunkedCookie === \"string\" && chunkedCookie.startsWith(BASE64_PREFIX)) {\n                    decoded = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.stringFromBase64URL)(chunkedCookie.substring(BASE64_PREFIX.length));\n                }\n                return decoded;\n            },\n            setItem: async (key, value)=>{\n                // We don't have an `onAuthStateChange` event that can let us know that\n                // the PKCE code verifier is being set. Therefore, if we see it being\n                // set, we need to apply the storage (call `setAll` so the cookie is\n                // set properly).\n                if (key.endsWith(\"-code-verifier\")) {\n                    await applyServerStorage({\n                        getAll,\n                        setAll,\n                        // pretend only that the code verifier was set\n                        setItems: {\n                            [key]: value\n                        },\n                        // pretend that nothing was removed\n                        removedItems: {}\n                    }, {\n                        cookieOptions: options?.cookieOptions ?? null,\n                        cookieEncoding\n                    });\n                }\n                setItems[key] = value;\n                delete removedItems[key];\n            },\n            removeItem: async (key)=>{\n                // Intentionally not applying the storage when the key is the PKCE code\n                // verifier, as usually right after it's removed other items are set,\n                // so application of the storage will be handled by the\n                // `onAuthStateChange` callback that follows removal -- usually as part\n                // of the `exchangeCodeForSession` call.\n                delete setItems[key];\n                removedItems[key] = true;\n            }\n        }\n    };\n}\n/**\n * When createServerClient needs to apply the created storage to cookies, it\n * should call this function which handles correcly setting cookies for stored\n * and removed items in the storage.\n */ async function applyServerStorage({ getAll, setAll, setItems, removedItems }, options) {\n    const cookieEncoding = options.cookieEncoding;\n    const cookieOptions = options.cookieOptions ?? null;\n    const allCookies = await getAll([\n        ...setItems ? Object.keys(setItems) : [],\n        ...removedItems ? Object.keys(removedItems) : []\n    ]);\n    const cookieNames = allCookies?.map(({ name })=>name) || [];\n    const removeCookies = Object.keys(removedItems).flatMap((itemName)=>{\n        return cookieNames.filter((name)=>(0,_utils__WEBPACK_IMPORTED_MODULE_0__.isChunkLike)(name, itemName));\n    });\n    const setCookies = Object.keys(setItems).flatMap((itemName)=>{\n        const removeExistingCookiesForItem = new Set(cookieNames.filter((name)=>(0,_utils__WEBPACK_IMPORTED_MODULE_0__.isChunkLike)(name, itemName)));\n        let encoded = setItems[itemName];\n        if (cookieEncoding === \"base64url\") {\n            encoded = BASE64_PREFIX + (0,_utils__WEBPACK_IMPORTED_MODULE_0__.stringToBase64URL)(encoded);\n        }\n        const chunks = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.createChunks)(itemName, encoded);\n        chunks.forEach((chunk)=>{\n            removeExistingCookiesForItem.delete(chunk.name);\n        });\n        removeCookies.push(...removeExistingCookiesForItem);\n        return chunks;\n    });\n    const removeCookieOptions = {\n        ..._utils__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_COOKIE_OPTIONS,\n        ...cookieOptions,\n        maxAge: 0\n    };\n    const setCookieOptions = {\n        ..._utils__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_COOKIE_OPTIONS,\n        ...cookieOptions,\n        maxAge: _utils__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_COOKIE_OPTIONS.maxAge\n    };\n    // the NextJS cookieStore API can get confused if the `name` from\n    // options.cookieOptions leaks\n    delete removeCookieOptions.name;\n    delete setCookieOptions.name;\n    await setAll([\n        ...removeCookies.map((name)=>({\n                name,\n                value: \"\",\n                options: removeCookieOptions\n            })),\n        ...setCookies.map(({ name, value })=>({\n                name,\n                value,\n                options: setCookieOptions\n            }))\n    ]);\n} //# sourceMappingURL=cookies.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtaGVscGVycy1uZXh0anMvZGlzdC9tb2R1bGUvY29va2llcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTBDO0FBQ3FHO0FBQy9JLE1BQU1TLGdCQUFnQjtBQUN0Qjs7Ozs7OztDQU9DLEdBQ00sU0FBU0MseUJBQXlCQyxPQUFPLEVBQUVDLGNBQWM7SUFDNUQsTUFBTUMsVUFBVUYsUUFBUUUsT0FBTyxJQUFJO0lBQ25DLE1BQU1DLGlCQUFpQkgsUUFBUUcsY0FBYztJQUM3QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTUMsZUFBZSxDQUFDO0lBQ3RCLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJTCxTQUFTO1FBQ1QsSUFBSSxTQUFTQSxTQUFTO1lBQ2xCLHVFQUF1RTtZQUN2RSxzRUFBc0U7WUFDdEUsd0VBQXdFO1lBQ3hFLHVFQUF1RTtZQUN2RSx5RUFBeUU7WUFDekUscUVBQXFFO1lBQ3JFLGtDQUFrQztZQUNsQyxNQUFNTSxlQUFlLE9BQU9DO2dCQUN4Qix5RUFBeUU7Z0JBQ3pFLE1BQU1DLGFBQWFELFNBQVNFLE9BQU8sQ0FBQyxDQUFDQyxVQUFZO3dCQUM3Q0E7MkJBQ0dDLE1BQU1DLElBQUksQ0FBQzs0QkFBRUMsUUFBUTt3QkFBRSxHQUFHQyxHQUFHLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTSxDQUFDLEVBQUVOLFFBQVEsQ0FBQyxFQUFFTSxFQUFFLENBQUM7cUJBQy9EO2dCQUNELE1BQU1DLFNBQVMsRUFBRTtnQkFDakIsSUFBSyxJQUFJRCxJQUFJLEdBQUdBLElBQUlSLFdBQVdLLE1BQU0sRUFBRUcsS0FBSyxFQUFHO29CQUMzQyxNQUFNRSxRQUFRLE1BQU1sQixRQUFRbUIsR0FBRyxDQUFDWCxVQUFVLENBQUNRLEVBQUU7b0JBQzdDLElBQUksQ0FBQ0UsU0FBUyxPQUFPQSxVQUFVLFVBQVU7d0JBQ3JDO29CQUNKO29CQUNBRCxPQUFPRyxJQUFJLENBQUM7d0JBQUVDLE1BQU1iLFVB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UzVCLG1EQUFXQSxDQUFDNEIsTUFBTXdDO1FBQzVGLElBQUlWLFVBQVVqRCxRQUFRLENBQUMyRCxTQUFTO1FBQ2hDLElBQUk1RCxtQkFBbUIsYUFBYTtZQUNoQ2tELFVBQVV2RCxnQkFBZ0JELHlEQUFpQkEsQ0FBQ3dEO1FBQ2hEO1FBQ0EsTUFBTWxDLFNBQVMxQixvREFBWUEsQ0FBQ3NFLFVBQVVWO1FBQ3RDbEMsT0FBT2lCLE9BQU8sQ0FBQyxDQUFDNkI7WUFDWkQsNkJBQTZCVixNQUFNLENBQUNXLE1BQU0xQyxJQUFJO1FBQ2xEO1FBQ0EyQixjQUFjNUIsSUFBSSxJQUFJMEM7UUFDdEIsT0FBTzdDO0lBQ1g7SUFDQSxNQUFNb0Msc0JBQXNCO1FBQ3hCLEdBQUdoRSwwREFBc0I7UUFDekIsR0FBR2lFLGFBQWE7UUFDaEJDLFFBQVE7SUFDWjtJQUNBLE1BQU1DLG1CQUFtQjtRQUNyQixHQUFHbkUsMERBQXNCO1FBQ3pCLEdBQUdpRSxhQUFhO1FBQ2hCQyxRQUFRbEUsMERBQXNCQSxDQUFDa0UsTUFBTTtJQUN6QztJQUNBLGlFQUFpRTtJQUNqRSw4QkFBOEI7SUFDOUIsT0FBT0Ysb0JBQW9CaEMsSUFBSTtJQUMvQixPQUFPbUMsaUJBQWlCbkMsSUFBSTtJQUM1QixNQUFNaEIsT0FBTztXQUNOMkMsY0FBY2xDLEdBQUcsQ0FBQyxDQUFDTyxPQUFVO2dCQUM1QkE7Z0JBQ0FILE9BQU87Z0JBQ1BwQixTQUFTdUQ7WUFDYjtXQUNHL0IsV0FBV1IsR0FBRyxDQUFDLENBQUMsRUFBRU8sSUFBSSxFQUFFSCxLQUFLLEVBQUUsR0FBTTtnQkFDcENHO2dCQUNBSDtnQkFDQXBCLFNBQVMwRDtZQUNiO0tBQ0g7QUFDTCxFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FuY2hvci13b3JrZmxvd3MvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtaGVscGVycy1uZXh0anMvZGlzdC9tb2R1bGUvY29va2llcy5qcz9jZDZiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcnNlLCBzZXJpYWxpemUgfSBmcm9tIFwiY29va2llXCI7XG5pbXBvcnQgeyBERUZBVUxUX0NPT0tJRV9PUFRJT05TLCBjb21iaW5lQ2h1bmtzLCBjcmVhdGVDaHVua3MsIGlzQnJvd3NlciwgaXNDaHVua0xpa2UsIHN0cmluZ0Zyb21CYXNlNjRVUkwsIHN0cmluZ1RvQmFzZTY0VVJMLCB9IGZyb20gXCIuL3V0aWxzXCI7XG5jb25zdCBCQVNFNjRfUFJFRklYID0gXCJiYXNlNjQtXCI7XG4vKipcbiAqIENyZWF0ZXMgYSBzdG9yYWdlIGNsaWVudCB0aGF0IGhhbmRsZXMgY29va2llcyBjb3JyZWN0bHkgZm9yIGJyb3dzZXIgYW5kXG4gKiBzZXJ2ZXIgY2xpZW50cyB3aXRoIG9yIHdpdGhvdXQgcHJvcGVybHkgcHJvdmlkZWQgY29va2llIG1ldGhvZHMuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgcGFzc2VkIHRvIGNyZWF0ZUJyb3dzZXJDbGllbnQgb3IgY3JlYXRlU2VydmVyIGNsaWVudC5cbiAqXG4gKiBAcGFyYW0gaXNTZXJ2ZXJDbGllbnQgV2hldGhlciBpdCdzIGNhbGxlZCBmcm9tIGNyZWF0ZVNlcnZlckNsaWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0b3JhZ2VGcm9tT3B0aW9ucyhvcHRpb25zLCBpc1NlcnZlckNsaWVudCkge1xuICAgIGNvbnN0IGNvb2tpZXMgPSBvcHRpb25zLmNvb2tpZXMgPz8gbnVsbDtcbiAgICBjb25zdCBjb29raWVFbmNvZGluZyA9IG9wdGlvbnMuY29va2llRW5jb2Rpbmc7XG4gICAgY29uc3Qgc2V0SXRlbXMgPSB7fTtcbiAgICBjb25zdCByZW1vdmVkSXRlbXMgPSB7fTtcbiAgICBsZXQgZ2V0QWxsO1xuICAgIGxldCBzZXRBbGw7XG4gICAgaWYgKGNvb2tpZXMpIHtcbiAgICAgICAgaWYgKFwiZ2V0XCIgaW4gY29va2llcykge1xuICAgICAgICAgICAgLy8gSnVzdCBnZXQgaXMgbm90IGVub3VnaCwgYmVjYXVzZSB0aGUgY2xpZW50IG5lZWRzIHRvIHNlZSB3aGF0IGNvb2tpZXNcbiAgICAgICAgICAgIC8vIGFyZSBhbHJlYWR5IHNldCBhbmQgdW5zZXQgdGhlbSBpZiBuZWNlc3NhcnkuIFRvIGF0dGVtcHQgdG8gZml4IHRoaXNcbiAgICAgICAgICAgIC8vIGJlaGF2aW9yIGZvciBtb3N0IHVzZSBjYXNlcywgd2UgcGFzcyBcImhpbnRzXCIgd2hpY2ggaXMgdGhlIGtleXMgb2YgdGhlXG4gICAgICAgICAgICAvLyBzdG9yYWdlIGl0ZW1zLiBUaGV5IGFyZSB0aGVuIGNvbnZlcnRlZCB0byB0aGVpciBjb3JyZXNwb25kaW5nIGNvb2tpZVxuICAgICAgICAgICAgLy8gY2h1bmsgbmFtZXMgYW5kIGFyZSBmZXRjaGVkIHdpdGggZ2V0LiBPbmx5IDUgY2h1bmtzIGFyZSBmZXRjaGVkLCB3aGljaFxuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGVub3VnaCBmb3IgdGhlIG1ham9yaXR5IG9mIHVzZSBjYXNlcywgYnV0IGRvZXMgbm90IHNvbHZlXG4gICAgICAgICAgICAvLyB0aG9zZSB3aXRoIHZlcnkgbGFyZ2Ugc2Vzc2lvbnMuXG4gICAgICAgICAgICBjb25zdCBnZXRXaXRoSGludHMgPSBhc3luYyAoa2V5SGludHMpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBvcHRpbWlzdGljYWxseSBmaW5kIHRoZSBmaXJzdCA1IHBvdGVudGlhbCBjaHVua3MgZm9yIHRoZSBzcGVjaWZpZWQga2V5XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmtOYW1lcyA9IGtleUhpbnRzLmZsYXRNYXAoKGtleUhpbnQpID0+IFtcbiAgICAgICAgICAgICAgICAgICAga2V5SGludCxcbiAgICAgICAgICAgICAgICAgICAgLi4uQXJyYXkuZnJvbSh7IGxlbmd0aDogNSB9KS5tYXAoKF8sIGkpID0+IGAke2tleUhpbnR9LiR7aX1gKSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rTmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBjb29raWVzLmdldChjaHVua05hbWVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKHsgbmFtZTogY2h1bmtOYW1lc1tpXSwgdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGRldGVjdCBhbmQgbG9nIHN0YWxlIGNodW5rcyBlcnJvclxuICAgICAgICAgICAgICAgIHJldHVybiBjaHVua3M7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2V0QWxsID0gYXN5bmMgKGtleUhpbnRzKSA9PiBhd2FpdCBnZXRXaXRoSGludHMoa2V5SGludHMpO1xuICAgICAgICAgICAgaWYgKFwic2V0XCIgaW4gY29va2llcyAmJiBcInJlbW92ZVwiIGluIGNvb2tpZXMpIHtcbiAgICAgICAgICAgICAgICBzZXRBbGwgPSBhc3luYyAoc2V0Q29va2llcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldENvb2tpZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgdmFsdWUsIG9wdGlvbnMgfSA9IHNldENvb2tpZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBjb29raWVzLnNldChuYW1lLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBjb29raWVzLnJlbW92ZShuYW1lLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1NlcnZlckNsaWVudCkge1xuICAgICAgICAgICAgICAgIHNldEFsbCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQHN1cGFiYXNlL3NzcjogY3JlYXRlU2VydmVyQ2xpZW50IHdhcyBjb25maWd1cmVkIHdpdGhvdXQgc2V0IGFuZCByZW1vdmUgY29va2llIG1ldGhvZHMsIGJ1dCB0aGUgY2xpZW50IG5lZWRzIHRvIHNldCBjb29raWVzLiBUaGlzIGNhbiBsZWFkIHRvIGlzc3VlcyBzdWNoIGFzIHJhbmRvbSBsb2dvdXRzLCBlYXJseSBzZXNzaW9uIHRlcm1pbmF0aW9uIG9yIGluY3JlYXNlZCB0b2tlbiByZWZyZXNoIHJlcXVlc3RzLiBJZiBpbiBOZXh0SlMsIGNoZWNrIHlvdXIgbWlkZGxld2FyZS50cyBmaWxlLCByb3V0ZSBoYW5kbGVycyBhbmQgc2VydmVyIGFjdGlvbnMgZm9yIGNvcnJlY3RuZXNzLiBDb25zaWRlciBzd2l0Y2hpbmcgdG8gdGhlIGdldEFsbCBhbmQgc2V0QWxsIGNvb2tpZSBtZXRob2RzIGluc3RlYWQgb2YgZ2V0LCBzZXQgYW5kIHJlbW92ZSB3aGljaCBhcmUgZGVwcmVjYXRlZCBhbmQgY2FuIGJlIGRpZmZpY3VsdCB0byB1c2UgY29ycmVjdGx5LlwiKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQHN1cGFiYXNlL3NzcjogY3JlYXRlQnJvd3NlckNsaWVudCByZXF1aXJlcyBjb25maWd1cmluZyBhIGdldEFsbCBhbmQgc2V0QWxsIGNvb2tpZSBtZXRob2QgKGRlcHJlY2F0ZWQ6IGFsdGVybmF0aXZlbHkgYm90aCBnZXQsIHNldCBhbmQgcmVtb3ZlIGNhbiBiZSB1c2VkKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChcImdldEFsbFwiIGluIGNvb2tpZXMpIHtcbiAgICAgICAgICAgIGdldEFsbCA9IGFzeW5jICgpID0+IGF3YWl0IGNvb2tpZXMuZ2V0QWxsKCk7XG4gICAgICAgICAgICBpZiAoXCJzZXRBbGxcIiBpbiBjb29raWVzKSB7XG4gICAgICAgICAgICAgICAgc2V0QWxsID0gY29va2llcy5zZXRBbGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1NlcnZlckNsaWVudCkge1xuICAgICAgICAgICAgICAgIHNldEFsbCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQHN1cGFiYXNlL3NzcjogY3JlYXRlU2VydmVyQ2xpZW50IHdhcyBjb25maWd1cmVkIHdpdGhvdXQgdGhlIHNldEFsbCBjb29raWUgbWV0aG9kLCBidXQgdGhlIGNsaWVudCBuZWVkcyB0byBzZXQgY29va2llcy4gVGhpcyBjYW4gbGVhZCB0byBpc3N1ZXMgc3VjaCBhcyByYW5kb20gbG9nb3V0cywgZWFybHkgc2Vzc2lvbiB0ZXJtaW5hdGlvbiBvciBpbmNyZWFzZWQgdG9rZW4gcmVmcmVzaCByZXF1ZXN0cy4gSWYgaW4gTmV4dEpTLCBjaGVjayB5b3VyIG1pZGRsZXdhcmUudHMgZmlsZSwgcm91dGUgaGFuZGxlcnMgYW5kIHNlcnZlciBhY3Rpb25zIGZvciBjb3JyZWN0bmVzcy5cIik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBzdXBhYmFzZS9zc3I6IGNyZWF0ZUJyb3dzZXJDbGllbnQgcmVxdWlyZXMgY29uZmlndXJpbmcgYm90aCBnZXRBbGwgYW5kIHNldEFsbCBjb29raWUgbWV0aG9kcyAoZGVwcmVjYXRlZDogYWx0ZXJuYXRpdmVseSBib3RoIGdldCwgc2V0IGFuZCByZW1vdmUgY2FuIGJlIHVzZWQpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbmVpdGhlciBnZXQgbm9yIGdldEFsbCBpcyBwcmVzZW50IG9uIGNvb2tpZXMsIG9ubHkgd2lsbCBvY2N1ciBpZiBwdXJlIEphdmFTY3JpcHQgaXMgdXNlZCwgYnV0IGNvb2tpZXMgaXMgYW4gb2JqZWN0XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9zc3I6ICR7aXNTZXJ2ZXJDbGllbnQgPyBcImNyZWF0ZVNlcnZlckNsaWVudFwiIDogXCJjcmVhdGVCcm93c2VyQ2xpZW50XCJ9IHJlcXVpcmVzIGNvbmZpZ3VyaW5nIGdldEFsbCBhbmQgc2V0QWxsIGNvb2tpZSBtZXRob2RzIChkZXByZWNhdGVkOiBhbHRlcm5hdGl2ZWx5IHVzZSBnZXQsIHNldCBhbmQgcmVtb3ZlKS4ke2lzQnJvd3NlcigpID8gXCIgQXMgdGhpcyBpcyBjYWxsZWQgaW4gYSBicm93c2VyIHJ1bnRpbWUsIGNvbnNpZGVyIHJlbW92aW5nIHRoZSBjb29raWVzIG9wdGlvbiBvYmplY3QgdG8gdXNlIHRoZSBkb2N1bWVudC5jb29raWUgQVBJIGF1dG9tYXRpY2FsbHkuXCIgOiBcIlwifWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc1NlcnZlckNsaWVudCAmJiBpc0Jyb3dzZXIoKSkge1xuICAgICAgICAvLyBUaGUgZW52aXJvbm1lbnQgaXMgYnJvd3Nlciwgc28gdXNlIHRoZSBkb2N1bWVudC5jb29raWUgQVBJIHRvIGltcGxlbWVudCBnZXRBbGwgYW5kIHNldEFsbC5cbiAgICAgICAgY29uc3Qgbm9IaW50R2V0QWxsID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2UoZG9jdW1lbnQuY29va2llKTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhwYXJzZWQpLm1hcCgobmFtZSkgPT4gKHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZWRbbmFtZV0gPz8gXCJcIixcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgZ2V0QWxsID0gKCkgPT4gbm9IaW50R2V0QWxsKCk7XG4gICAgICAgIHNldEFsbCA9IChzZXRDb29raWVzKSA9PiB7XG4gICAgICAgICAgICBzZXRDb29raWVzLmZvckVhY2goKHsgbmFtZSwgdmFsdWUsIG9wdGlvbnMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IHNlcmlhbGl6ZShuYW1lLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTZXJ2ZXJDbGllbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQHN1cGFiYXNlL3NzcjogY3JlYXRlU2VydmVyQ2xpZW50IG11c3QgYmUgaW5pdGlhbGl6ZWQgd2l0aCBjb29raWUgb3B0aW9ucyB0aGF0IHNwZWNpZnkgZ2V0QWxsIGFuZCBzZXRBbGwgZnVuY3Rpb25zIChkZXByZWNhdGVkLCBub3QgcmVjb21tZW5kZWQ6IGFsdGVybmF0aXZlbHkgdXNlIGdldCwgc2V0IGFuZCByZW1vdmUpXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gZ2V0dGluZyBjb29raWVzIHdoZW4gdGhlcmUncyBubyB3aW5kb3cgYnV0IHdlJ3JlIGluIGJyb3dzZXIgbW9kZSBjYW4gYmUgT0ssIGJlY2F1c2UgdGhlIGRldmVsb3BlciBwcm9iYWJseSBpcyBub3QgdXNpbmcgYXV0aCBmdW5jdGlvbnNcbiAgICAgICAgZ2V0QWxsID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9O1xuICAgICAgICAvLyB0aGlzIGlzIE5PVCBPSyBiZWNhdXNlIHRoZSBkZXZlbG9wZXIgaXMgdXNpbmcgYXV0aCBmdW5jdGlvbnMgdGhhdCByZXF1aXJlIHNldHRpbmcgc29tZSBzdGF0ZSwgc28gdGhhdCBtdXN0IGVycm9yIG91dFxuICAgICAgICBzZXRBbGwgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJAc3VwYWJhc2Uvc3NyOiBjcmVhdGVCcm93c2VyQ2xpZW50IGluIG5vbi1icm93c2VyIHJ1bnRpbWVzIChpbmNsdWRpbmcgTmV4dC5qcyBwcmUtcmVuZGVyaW5nIG1vZGUpIHdhcyBub3QgaW5pdGlhbGl6ZWQgY29va2llIG9wdGlvbnMgdGhhdCBzcGVjaWZ5IGdldEFsbCBhbmQgc2V0QWxsIGZ1bmN0aW9ucyAoZGVwcmVjYXRlZDogYWx0ZXJuYXRpdmVseSB1c2UgZ2V0LCBzZXQgYW5kIHJlbW92ZSksIGJ1dCB0aGV5IHdlcmUgbmVlZGVkXCIpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoIWlzU2VydmVyQ2xpZW50KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIHN0b3JhZ2UgY2xpZW50IHRvIGJlIHVzZWQgaW4gYnJvd3NlcnMuIEl0IG9ubHlcbiAgICAgICAgLy8gd29ya3Mgb24gdGhlIGNvb2tpZXMgYWJzdHJhY3Rpb24sIHVubGlrZSB0aGUgc2VydmVyIGNsaWVudFxuICAgICAgICAvLyB3aGljaCBvbmx5IHVzZXMgY29va2llcyB0byByZWFkIHRoZSBpbml0aWFsIHN0YXRlLiBXaGVuIGFuXG4gICAgICAgIC8vIGl0ZW0gaXMgc2V0LCBjb29raWVzIGFyZSBib3RoIGNsZWFyZWQgYW5kIHNldCB0byB2YWx1ZXMgc29cbiAgICAgICAgLy8gdGhhdCBzdGFsZSBjaHVua3MgYXJlIG5vdCBsZWZ0IHJlbWFpbmluZy5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldEFsbCwgLy8gZm9yIHR5cGUgY29uc2lzdGVuY3lcbiAgICAgICAgICAgIHNldEFsbCwgLy8gZm9yIHR5cGUgY29uc2lzdGVuY3lcbiAgICAgICAgICAgIHNldEl0ZW1zLCAvLyBmb3IgdHlwZSBjb25zaXN0ZW5jeVxuICAgICAgICAgICAgcmVtb3ZlZEl0ZW1zLCAvLyBmb3IgdHlwZSBjb25zaXN0ZW5jeVxuICAgICAgICAgICAgc3RvcmFnZToge1xuICAgICAgICAgICAgICAgIGlzU2VydmVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBnZXRJdGVtOiBhc3luYyAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbENvb2tpZXMgPSBhd2FpdCBnZXRBbGwoW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVua2VkQ29va2llID0gYXdhaXQgY29tYmluZUNodW5rcyhrZXksIGFzeW5jIChjaHVua05hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvb2tpZSA9IGFsbENvb2tpZXM/LmZpbmQoKHsgbmFtZSB9KSA9PiBuYW1lID09PSBjaHVua05hbWUpIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvb2tpZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvb2tpZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2h1bmtlZENvb2tpZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlY29kZWQgPSBjaHVua2VkQ29va2llO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmtlZENvb2tpZS5zdGFydHNXaXRoKEJBU0U2NF9QUkVGSVgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkID0gc3RyaW5nRnJvbUJhc2U2NFVSTChjaHVua2VkQ29va2llLnN1YnN0cmluZyhCQVNFNjRfUFJFRklYLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0SXRlbTogYXN5bmMgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsQ29va2llcyA9IGF3YWl0IGdldEFsbChba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvb2tpZU5hbWVzID0gYWxsQ29va2llcz8ubWFwKCh7IG5hbWUgfSkgPT4gbmFtZSkgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbW92ZUNvb2tpZXMgPSBuZXcgU2V0KGNvb2tpZU5hbWVzLmZpbHRlcigobmFtZSkgPT4gaXNDaHVua0xpa2UobmFtZSwga2V5KSkpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5jb2RlZCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29va2llRW5jb2RpbmcgPT09IFwiYmFzZTY0dXJsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZWQgPSBCQVNFNjRfUFJFRklYICsgc3RyaW5nVG9CYXNlNjRVUkwodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNldENvb2tpZXMgPSBjcmVhdGVDaHVua3Moa2V5LCBlbmNvZGVkKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q29va2llcy5mb3JFYWNoKCh7IG5hbWUgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ29va2llcy5kZWxldGUobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW1vdmVDb29raWVPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uREVGQVVMVF9DT09LSUVfT1BUSU9OUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnM/LmNvb2tpZU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhBZ2U6IDAsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNldENvb2tpZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5ERUZBVUxUX0NPT0tJRV9PUFRJT05TLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ub3B0aW9ucz8uY29va2llT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEFnZTogREVGQVVMVF9DT09LSUVfT1BUSU9OUy5tYXhBZ2UsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBOZXh0SlMgY29va2llU3RvcmUgQVBJIGNhbiBnZXQgY29uZnVzZWQgaWYgdGhlIGBuYW1lYCBmcm9tXG4gICAgICAgICAgICAgICAgICAgIC8vIG9wdGlvbnMuY29va2llT3B0aW9ucyBsZWFrc1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVtb3ZlQ29va2llT3B0aW9ucy5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2V0Q29va2llT3B0aW9ucy5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxUb1NldCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLlsuLi5yZW1vdmVDb29raWVzXS5tYXAoKG5hbWUpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiByZW1vdmVDb29raWVPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uc2V0Q29va2llcy5tYXAoKHsgbmFtZSwgdmFsdWUgfSkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHNldENvb2tpZU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxUb1NldC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzZXRBbGwoYWxsVG9TZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZW1vdmVJdGVtOiBhc3luYyAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbENvb2tpZXMgPSBhd2FpdCBnZXRBbGwoW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb29raWVOYW1lcyA9IGFsbENvb2tpZXM/Lm1hcCgoeyBuYW1lIH0pID0+IG5hbWUpIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW1vdmVDb29raWVzID0gY29va2llTmFtZXMuZmlsdGVyKChuYW1lKSA9PiBpc0NodW5rTGlrZShuYW1lLCBrZXkpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlQ29va2llT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLkRFRkFVTFRfQ09PS0lFX09QVElPTlMsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zPy5jb29raWVPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4QWdlOiAwLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgTmV4dEpTIGNvb2tpZVN0b3JlIEFQSSBjYW4gZ2V0IGNvbmZ1c2VkIGlmIHRoZSBgbmFtZWAgZnJvbVxuICAgICAgICAgICAgICAgICAgICAvLyBvcHRpb25zLmNvb2tpZU9wdGlvbnMgbGVha3NcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlbW92ZUNvb2tpZU9wdGlvbnMubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92ZUNvb2tpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2V0QWxsKHJlbW92ZUNvb2tpZXMubWFwKChuYW1lKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogcmVtb3ZlQ29va2llT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gVGhpcyBpcyB0aGUgc2VydmVyIGNsaWVudC4gSXQgb25seSB1c2VzIGdldEFsbCB0byByZWFkIHRoZSBpbml0aWFsXG4gICAgLy8gc3RhdGUuIEFueSBzdWJzZXF1ZW50IGNoYW5nZXMgdG8gdGhlIGl0ZW1zIGlzIHBlcnNpc3RlZCBpbiB0aGVcbiAgICAvLyBzZXRJdGVtcyBhbmQgcmVtb3ZlZEl0ZW1zIG9iamVjdHMuIGNyZWF0ZVNlcnZlckNsaWVudCAqbXVzdCogdXNlXG4gICAgLy8gZ2V0QWxsLCBzZXRBbGwgYW5kIHRoZSB2YWx1ZXMgaW4gc2V0SXRlbXMgYW5kIHJlbW92ZWRJdGVtcyB0b1xuICAgIC8vIHBlcnNpc3QgdGhlIGNoYW5nZXMgKmF0IG9uY2UqIHdoZW4gYXBwcm9wcmlhdGUgKHVzdWFsbHkgb25seSB3aGVuXG4gICAgLy8gdGhlIFRPS0VOX1JFRlJFU0hFRCwgVVNFUl9VUERBVEVEIG9yIFNJR05FRF9PVVQgZXZlbnRzIGFyZSBmaXJlZCBieVxuICAgIC8vIHRoZSBTdXBhYmFzZSBBdXRoIGNsaWVudCkuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0QWxsLFxuICAgICAgICBzZXRBbGwsXG4gICAgICAgIHNldEl0ZW1zLFxuICAgICAgICByZW1vdmVkSXRlbXMsXG4gICAgICAgIHN0b3JhZ2U6IHtcbiAgICAgICAgICAgIC8vIHRvIHNpZ25hbCB0byB0aGUgbGlicmFyaWVzIHRoYXQgdGhlc2UgY29va2llcyBhcmVcbiAgICAgICAgICAgIC8vIGNvbWluZyBmcm9tIGEgc2VydmVyIGVudmlyb25tZW50IGFuZCB0aGVpciB2YWx1ZVxuICAgICAgICAgICAgLy8gc2hvdWxkIG5vdCBiZSB0cnVzdGVkXG4gICAgICAgICAgICBpc1NlcnZlcjogdHJ1ZSxcbiAgICAgICAgICAgIGdldEl0ZW06IGFzeW5jIChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldEl0ZW1zW2tleV0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldEl0ZW1zW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkSXRlbXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsQ29va2llcyA9IGF3YWl0IGdldEFsbChba2V5XSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmtlZENvb2tpZSA9IGF3YWl0IGNvbWJpbmVDaHVua3Moa2V5LCBhc3luYyAoY2h1bmtOYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvb2tpZSA9IGFsbENvb2tpZXM/LmZpbmQoKHsgbmFtZSB9KSA9PiBuYW1lID09PSBjaHVua05hbWUpIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29va2llKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29va2llLnZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghY2h1bmtlZENvb2tpZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGRlY29kZWQgPSBjaHVua2VkQ29va2llO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmtlZENvb2tpZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgICAgICBjaHVua2VkQ29va2llLnN0YXJ0c1dpdGgoQkFTRTY0X1BSRUZJWCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlZCA9IHN0cmluZ0Zyb21CYXNlNjRVUkwoY2h1bmtlZENvb2tpZS5zdWJzdHJpbmcoQkFTRTY0X1BSRUZJWC5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0SXRlbTogYXN5bmMgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBoYXZlIGFuIGBvbkF1dGhTdGF0ZUNoYW5nZWAgZXZlbnQgdGhhdCBjYW4gbGV0IHVzIGtub3cgdGhhdFxuICAgICAgICAgICAgICAgIC8vIHRoZSBQS0NFIGNvZGUgdmVyaWZpZXIgaXMgYmVpbmcgc2V0LiBUaGVyZWZvcmUsIGlmIHdlIHNlZSBpdCBiZWluZ1xuICAgICAgICAgICAgICAgIC8vIHNldCwgd2UgbmVlZCB0byBhcHBseSB0aGUgc3RvcmFnZSAoY2FsbCBgc2V0QWxsYCBzbyB0aGUgY29va2llIGlzXG4gICAgICAgICAgICAgICAgLy8gc2V0IHByb3Blcmx5KS5cbiAgICAgICAgICAgICAgICBpZiAoa2V5LmVuZHNXaXRoKFwiLWNvZGUtdmVyaWZpZXJcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgYXBwbHlTZXJ2ZXJTdG9yYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXRlbmQgb25seSB0aGF0IHRoZSBjb2RlIHZlcmlmaWVyIHdhcyBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEl0ZW1zOiB7IFtrZXldOiB2YWx1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJldGVuZCB0aGF0IG5vdGhpbmcgd2FzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWRJdGVtczoge30sXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tpZU9wdGlvbnM6IG9wdGlvbnM/LmNvb2tpZU9wdGlvbnMgPz8gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tpZUVuY29kaW5nLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0SXRlbXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZW1vdmVkSXRlbXNba2V5XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmVJdGVtOiBhc3luYyAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSW50ZW50aW9uYWxseSBub3QgYXBwbHlpbmcgdGhlIHN0b3JhZ2Ugd2hlbiB0aGUga2V5IGlzIHRoZSBQS0NFIGNvZGVcbiAgICAgICAgICAgICAgICAvLyB2ZXJpZmllciwgYXMgdXN1YWxseSByaWdodCBhZnRlciBpdCdzIHJlbW92ZWQgb3RoZXIgaXRlbXMgYXJlIHNldCxcbiAgICAgICAgICAgICAgICAvLyBzbyBhcHBsaWNhdGlvbiBvZiB0aGUgc3RvcmFnZSB3aWxsIGJlIGhhbmRsZWQgYnkgdGhlXG4gICAgICAgICAgICAgICAgLy8gYG9uQXV0aFN0YXRlQ2hhbmdlYCBjYWxsYmFjayB0aGF0IGZvbGxvd3MgcmVtb3ZhbCAtLSB1c3VhbGx5IGFzIHBhcnRcbiAgICAgICAgICAgICAgICAvLyBvZiB0aGUgYGV4Y2hhbmdlQ29kZUZvclNlc3Npb25gIGNhbGwuXG4gICAgICAgICAgICAgICAgZGVsZXRlIHNldEl0ZW1zW2tleV07XG4gICAgICAgICAgICAgICAgcmVtb3ZlZEl0ZW1zW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBXaGVuIGNyZWF0ZVNlcnZlckNsaWVudCBuZWVkcyB0byBhcHBseSB0aGUgY3JlYXRlZCBzdG9yYWdlIHRvIGNvb2tpZXMsIGl0XG4gKiBzaG91bGQgY2FsbCB0aGlzIGZ1bmN0aW9uIHdoaWNoIGhhbmRsZXMgY29ycmVjbHkgc2V0dGluZyBjb29raWVzIGZvciBzdG9yZWRcbiAqIGFuZCByZW1vdmVkIGl0ZW1zIGluIHRoZSBzdG9yYWdlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXBwbHlTZXJ2ZXJTdG9yYWdlKHsgZ2V0QWxsLCBzZXRBbGwsIHNldEl0ZW1zLCByZW1vdmVkSXRlbXMsIH0sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjb29raWVFbmNvZGluZyA9IG9wdGlvbnMuY29va2llRW5jb2Rpbmc7XG4gICAgY29uc3QgY29va2llT3B0aW9ucyA9IG9wdGlvbnMuY29va2llT3B0aW9ucyA/PyBudWxsO1xuICAgIGNvbnN0IGFsbENvb2tpZXMgPSBhd2FpdCBnZXRBbGwoW1xuICAgICAgICAuLi4oc2V0SXRlbXMgPyBPYmplY3Qua2V5cyhzZXRJdGVtcykgOiBbXSksXG4gICAgICAgIC4uLihyZW1vdmVkSXRlbXMgPyBPYmplY3Qua2V5cyhyZW1vdmVkSXRlbXMpIDogW10pLFxuICAgIF0pO1xuICAgIGNvbnN0IGNvb2tpZU5hbWVzID0gYWxsQ29va2llcz8ubWFwKCh7IG5hbWUgfSkgPT4gbmFtZSkgfHwgW107XG4gICAgY29uc3QgcmVtb3ZlQ29va2llcyA9IE9iamVjdC5rZXlzKHJlbW92ZWRJdGVtcykuZmxhdE1hcCgoaXRlbU5hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvb2tpZU5hbWVzLmZpbHRlcigobmFtZSkgPT4gaXNDaHVua0xpa2UobmFtZSwgaXRlbU5hbWUpKTtcbiAgICB9KTtcbiAgICBjb25zdCBzZXRDb29raWVzID0gT2JqZWN0LmtleXMoc2V0SXRlbXMpLmZsYXRNYXAoKGl0ZW1OYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlbW92ZUV4aXN0aW5nQ29va2llc0Zvckl0ZW0gPSBuZXcgU2V0KGNvb2tpZU5hbWVzLmZpbHRlcigobmFtZSkgPT4gaXNDaHVua0xpa2UobmFtZSwgaXRlbU5hbWUpKSk7XG4gICAgICAgIGxldCBlbmNvZGVkID0gc2V0SXRlbXNbaXRlbU5hbWVdO1xuICAgICAgICBpZiAoY29va2llRW5jb2RpbmcgPT09IFwiYmFzZTY0dXJsXCIpIHtcbiAgICAgICAgICAgIGVuY29kZWQgPSBCQVNFNjRfUFJFRklYICsgc3RyaW5nVG9CYXNlNjRVUkwoZW5jb2RlZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2h1bmtzID0gY3JlYXRlQ2h1bmtzKGl0ZW1OYW1lLCBlbmNvZGVkKTtcbiAgICAgICAgY2h1bmtzLmZvckVhY2goKGNodW5rKSA9PiB7XG4gICAgICAgICAgICByZW1vdmVFeGlzdGluZ0Nvb2tpZXNGb3JJdGVtLmRlbGV0ZShjaHVuay5uYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbW92ZUNvb2tpZXMucHVzaCguLi5yZW1vdmVFeGlzdGluZ0Nvb2tpZXNGb3JJdGVtKTtcbiAgICAgICAgcmV0dXJuIGNodW5rcztcbiAgICB9KTtcbiAgICBjb25zdCByZW1vdmVDb29raWVPcHRpb25zID0ge1xuICAgICAgICAuLi5ERUZBVUxUX0NPT0tJRV9PUFRJT05TLFxuICAgICAgICAuLi5jb29raWVPcHRpb25zLFxuICAgICAgICBtYXhBZ2U6IDAsXG4gICAgfTtcbiAgICBjb25zdCBzZXRDb29raWVPcHRpb25zID0ge1xuICAgICAgICAuLi5ERUZBVUxUX0NPT0tJRV9PUFRJT05TLFxuICAgICAgICAuLi5jb29raWVPcHRpb25zLFxuICAgICAgICBtYXhBZ2U6IERFRkFVTFRfQ09PS0lFX09QVElPTlMubWF4QWdlLFxuICAgIH07XG4gICAgLy8gdGhlIE5leHRKUyBjb29raWVTdG9yZSBBUEkgY2FuIGdldCBjb25mdXNlZCBpZiB0aGUgYG5hbWVgIGZyb21cbiAgICAvLyBvcHRpb25zLmNvb2tpZU9wdGlvbnMgbGVha3NcbiAgICBkZWxldGUgcmVtb3ZlQ29va2llT3B0aW9ucy5uYW1lO1xuICAgIGRlbGV0ZSBzZXRDb29raWVPcHRpb25zLm5hbWU7XG4gICAgYXdhaXQgc2V0QWxsKFtcbiAgICAgICAgLi4ucmVtb3ZlQ29va2llcy5tYXAoKG5hbWUpID0+ICh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdmFsdWU6IFwiXCIsXG4gICAgICAgICAgICBvcHRpb25zOiByZW1vdmVDb29raWVPcHRpb25zLFxuICAgICAgICB9KSksXG4gICAgICAgIC4uLnNldENvb2tpZXMubWFwKCh7IG5hbWUsIHZhbHVlIH0pID0+ICh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBvcHRpb25zOiBzZXRDb29raWVPcHRpb25zLFxuICAgICAgICB9KSksXG4gICAgXSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb29raWVzLmpzLm1hcCJdLCJuYW1lcyI6WyJwYXJzZSIsInNlcmlhbGl6ZSIsIkRFRkFVTFRfQ09PS0lFX09QVElPTlMiLCJjb21iaW5lQ2h1bmtzIiwiY3JlYXRlQ2h1bmtzIiwiaXNCcm93c2VyIiwiaXNDaHVua0xpa2UiLCJzdHJpbmdGcm9tQmFzZTY0VVJMIiwic3RyaW5nVG9CYXNlNjRVUkwiLCJCQVNFNjRfUFJFRklYIiwiY3JlYXRlU3RvcmFnZUZyb21PcHRpb25zIiwib3B0aW9ucyIsImlzU2VydmVyQ2xpZW50IiwiY29va2llcyIsImNvb2tpZUVuY29kaW5nIiwic2V0SXRlbXMiLCJyZW1vdmVkSXRlbXMiLCJnZXRBbGwiLCJzZXRBbGwiLCJnZXRXaXRoSGludHMiLCJrZXlIaW50cyIsImNodW5rTmFtZXMiLCJmbGF0TWFwIiwia2V5SGludCIsIkFycmF5IiwiZnJvbSIsImxlbmd0aCIsIm1hcCIsIl8iLCJpIiwiY2h1bmtzIiwidmFsdWUiLCJnZXQiLCJwdXNoIiwibmFtZSIsInNldENvb2tpZXMiLCJzZXQiLCJyZW1vdmUiLCJjb25zb2xlIiwid2FybiIsIkVycm9yIiwibm9IaW50R2V0QWxsIiwicGFyc2VkIiwiZG9jdW1lbnQiLCJjb29raWUiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsInN0b3JhZ2UiLCJpc1NlcnZlciIsImdldEl0ZW0iLCJrZXkiLCJhbGxDb29raWVzIiwiY2h1bmtlZENvb2tpZSIsImNodW5rTmFtZSIsImZpbmQiLCJkZWNvZGVkIiwic3RhcnRzV2l0aCIsInN1YnN0cmluZyIsInNldEl0ZW0iLCJjb29raWVOYW1lcyIsInJlbW92ZUNvb2tpZXMiLCJTZXQiLCJmaWx0ZXIiLCJlbmNvZGVkIiwiZGVsZXRlIiwicmVtb3ZlQ29va2llT3B0aW9ucyIsImNvb2tpZU9wdGlvbnMiLCJtYXhBZ2UiLCJzZXRDb29raWVPcHRpb25zIiwiYWxsVG9TZXQiLCJyZW1vdmVJdGVtIiwiZW5kc1dpdGgiLCJhcHBseVNlcnZlclN0b3JhZ2UiLCJpdGVtTmFtZSIsInJlbW92ZUV4aXN0aW5nQ29va2llc0Zvckl0ZW0iLCJjaHVuayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/cookies.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/createBrowserClient.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@supabase/auth-helpers-nextjs/dist/module/createBrowserClient.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createBrowserClient: () => (/* binding */ createBrowserClient)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"@supabase/supabase-js\");\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./version */ \"(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/version.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/utils/index.js\");\n/* harmony import */ var _cookies__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cookies */ \"(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/cookies.js\");\n\n\n\n\nlet cachedBrowserClient;\nfunction createBrowserClient(supabaseUrl, supabaseKey, options) {\n    // singleton client is created only if isSingleton is set to true, or if isSingleton is not defined and we detect a browser\n    const shouldUseSingleton = options?.isSingleton === true || (!options || !(\"isSingleton\" in options)) && (0,_utils__WEBPACK_IMPORTED_MODULE_2__.isBrowser)();\n    if (shouldUseSingleton && cachedBrowserClient) {\n        return cachedBrowserClient;\n    }\n    if (!supabaseUrl || !supabaseKey) {\n        throw new Error(`@supabase/ssr: Your project's URL and API key are required to create a Supabase client!\\n\\nCheck your Supabase project's API settings to find these values\\n\\nhttps://supabase.com/dashboard/project/_/settings/api`);\n    }\n    const { storage } = (0,_cookies__WEBPACK_IMPORTED_MODULE_3__.createStorageFromOptions)({\n        ...options,\n        cookieEncoding: options?.cookieEncoding ?? \"base64url\"\n    }, false);\n    const client = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseKey, {\n        // TODO: resolve type error\n        ...options,\n        global: {\n            ...options?.global,\n            headers: {\n                ...options?.global?.headers,\n                \"X-Client-Info\": `supabase-ssr/${_version__WEBPACK_IMPORTED_MODULE_1__.VERSION} createBrowserClient`\n            }\n        },\n        auth: {\n            ...options?.auth,\n            ...options?.cookieOptions?.name ? {\n                storageKey: options.cookieOptions.name\n            } : null,\n            flowType: \"pkce\",\n            autoRefreshToken: (0,_utils__WEBPACK_IMPORTED_MODULE_2__.isBrowser)(),\n            detectSessionInUrl: (0,_utils__WEBPACK_IMPORTED_MODULE_2__.isBrowser)(),\n            persistSession: true,\n            storage,\n            ...options?.cookies && \"encode\" in options.cookies && options.cookies.encode === \"tokens-only\" ? {\n                userStorage: options?.auth?.userStorage ?? window.localStorage\n            } : null\n        }\n    });\n    if (shouldUseSingleton) {\n        cachedBrowserClient = client;\n    }\n    return client;\n} //# sourceMappingURL=createBrowserClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtaGVscGVycy1uZXh0anMvZGlzdC9tb2R1bGUvY3JlYXRlQnJvd3NlckNsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBc0Q7QUFDbEI7QUFDQTtBQUNpQjtBQUNyRCxJQUFJSTtBQUNHLFNBQVNDLG9CQUFvQkMsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLE9BQU87SUFDakUsMkhBQTJIO0lBQzNILE1BQU1DLHFCQUFxQkQsU0FBU0UsZ0JBQWdCLFFBQy9DLENBQUMsQ0FBQ0YsV0FBVyxDQUFFLGtCQUFpQkEsT0FBTSxDQUFDLEtBQU1OLGlEQUFTQTtJQUMzRCxJQUFJTyxzQkFBc0JMLHFCQUFxQjtRQUMzQyxPQUFPQTtJQUNYO0lBQ0EsSUFBSSxDQUFDRSxlQUFlLENBQUNDLGFBQWE7UUFDOUIsTUFBTSxJQUFJSSxNQUFNLENBQUMsbU5BQW1OLENBQUM7SUFDek87SUFDQSxNQUFNLEVBQUVDLE9BQU8sRUFBRSxHQUFHVCxrRUFBd0JBLENBQUM7UUFDekMsR0FBR0ssT0FBTztRQUNWSyxnQkFBZ0JMLFNBQVNLLGtCQUFrQjtJQUMvQyxHQUFHO0lBQ0gsTUFBTUMsU0FBU2QsbUVBQVlBLENBQUNNLGFBQWFDLGFBQWE7UUFDbEQsMkJBQTJCO1FBQzNCLEdBQUdDLE9BQU87UUFDVk8sUUFBUTtZQUNKLEdBQUdQLFNBQVNPLE1BQU07WUFDbEJDLFNBQVM7Z0JBQ0wsR0FBR1IsU0FBU08sUUFBUUMsT0FBTztnQkFDM0IsaUJBQWlCLENBQUMsYUFBYSxFQUFFZiw2Q0FBT0EsQ0FBQyxvQkFBb0IsQ0FBQztZQUNsRTtRQUNKO1FBQ0FnQixNQUFNO1lBQ0YsR0FBR1QsU0FBU1MsSUFBSTtZQUNoQixHQUFJVCxTQUFTVSxlQUFlQyxPQUN0QjtnQkFBRUMsWUFBWVosUUFBUVUsYUFBYSxDQUFDQyxJQUFJO1lBQUMsSUFDekMsSUFBSTtZQUNWRSxVQUFVO1lBQ1ZDLGtCQUFrQnBCLGlEQUFTQTtZQUMzQnFCLG9CQUFvQnJCLGlEQUFTQTtZQUM3QnNCLGdCQUFnQjtZQUNoQlo7WUFDQSxHQUFJSixTQUFTaUIsV0FDVCxZQUFZakIsUUFBUWlCLE9BQU8sSUFDM0JqQixRQUFRaUIsT0FBTyxDQUFDQyxNQUFNLEtBQUssZ0JBQ3pCO2dCQUNFQyxhQUFhbkIsU0FBU1MsTUFBTVUsZUFBZUMsT0FBT0MsWUFBWTtZQUNsRSxJQUNFLElBQUk7UUFDZDtJQUNKO0lBQ0EsSUFBSXBCLG9CQUFvQjtRQUNwQkwsc0JBQXNCVTtJQUMxQjtJQUNBLE9BQU9BO0FBQ1gsRUFDQSwrQ0FBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmNob3Itd29ya2Zsb3dzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWhlbHBlcnMtbmV4dGpzL2Rpc3QvbW9kdWxlL2NyZWF0ZUJyb3dzZXJDbGllbnQuanM/ZDE5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDbGllbnQsIH0gZnJvbSBcIkBzdXBhYmFzZS9zdXBhYmFzZS1qc1wiO1xuaW1wb3J0IHsgVkVSU0lPTiB9IGZyb20gXCIuL3ZlcnNpb25cIjtcbmltcG9ydCB7IGlzQnJvd3NlciB9IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgeyBjcmVhdGVTdG9yYWdlRnJvbU9wdGlvbnMgfSBmcm9tIFwiLi9jb29raWVzXCI7XG5sZXQgY2FjaGVkQnJvd3NlckNsaWVudDtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCcm93c2VyQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSwgb3B0aW9ucykge1xuICAgIC8vIHNpbmdsZXRvbiBjbGllbnQgaXMgY3JlYXRlZCBvbmx5IGlmIGlzU2luZ2xldG9uIGlzIHNldCB0byB0cnVlLCBvciBpZiBpc1NpbmdsZXRvbiBpcyBub3QgZGVmaW5lZCBhbmQgd2UgZGV0ZWN0IGEgYnJvd3NlclxuICAgIGNvbnN0IHNob3VsZFVzZVNpbmdsZXRvbiA9IG9wdGlvbnM/LmlzU2luZ2xldG9uID09PSB0cnVlIHx8XG4gICAgICAgICgoIW9wdGlvbnMgfHwgIShcImlzU2luZ2xldG9uXCIgaW4gb3B0aW9ucykpICYmIGlzQnJvd3NlcigpKTtcbiAgICBpZiAoc2hvdWxkVXNlU2luZ2xldG9uICYmIGNhY2hlZEJyb3dzZXJDbGllbnQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZEJyb3dzZXJDbGllbnQ7XG4gICAgfVxuICAgIGlmICghc3VwYWJhc2VVcmwgfHwgIXN1cGFiYXNlS2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL3NzcjogWW91ciBwcm9qZWN0J3MgVVJMIGFuZCBBUEkga2V5IGFyZSByZXF1aXJlZCB0byBjcmVhdGUgYSBTdXBhYmFzZSBjbGllbnQhXFxuXFxuQ2hlY2sgeW91ciBTdXBhYmFzZSBwcm9qZWN0J3MgQVBJIHNldHRpbmdzIHRvIGZpbmQgdGhlc2UgdmFsdWVzXFxuXFxuaHR0cHM6Ly9zdXBhYmFzZS5jb20vZGFzaGJvYXJkL3Byb2plY3QvXy9zZXR0aW5ncy9hcGlgKTtcbiAgICB9XG4gICAgY29uc3QgeyBzdG9yYWdlIH0gPSBjcmVhdGVTdG9yYWdlRnJvbU9wdGlvbnMoe1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBjb29raWVFbmNvZGluZzogb3B0aW9ucz8uY29va2llRW5jb2RpbmcgPz8gXCJiYXNlNjR1cmxcIixcbiAgICB9LCBmYWxzZSk7XG4gICAgY29uc3QgY2xpZW50ID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSwge1xuICAgICAgICAvLyBUT0RPOiByZXNvbHZlIHR5cGUgZXJyb3JcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgZ2xvYmFsOiB7XG4gICAgICAgICAgICAuLi5vcHRpb25zPy5nbG9iYWwsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucz8uZ2xvYmFsPy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIFwiWC1DbGllbnQtSW5mb1wiOiBgc3VwYWJhc2Utc3NyLyR7VkVSU0lPTn0gY3JlYXRlQnJvd3NlckNsaWVudGAsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBhdXRoOiB7XG4gICAgICAgICAgICAuLi5vcHRpb25zPy5hdXRoLFxuICAgICAgICAgICAgLi4uKG9wdGlvbnM/LmNvb2tpZU9wdGlvbnM/Lm5hbWVcbiAgICAgICAgICAgICAgICA/IHsgc3RvcmFnZUtleTogb3B0aW9ucy5jb29raWVPcHRpb25zLm5hbWUgfVxuICAgICAgICAgICAgICAgIDogbnVsbCksXG4gICAgICAgICAgICBmbG93VHlwZTogXCJwa2NlXCIsXG4gICAgICAgICAgICBhdXRvUmVmcmVzaFRva2VuOiBpc0Jyb3dzZXIoKSxcbiAgICAgICAgICAgIGRldGVjdFNlc3Npb25JblVybDogaXNCcm93c2VyKCksXG4gICAgICAgICAgICBwZXJzaXN0U2Vzc2lvbjogdHJ1ZSxcbiAgICAgICAgICAgIHN0b3JhZ2UsXG4gICAgICAgICAgICAuLi4ob3B0aW9ucz8uY29va2llcyAmJlxuICAgICAgICAgICAgICAgIFwiZW5jb2RlXCIgaW4gb3B0aW9ucy5jb29raWVzICYmXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb29raWVzLmVuY29kZSA9PT0gXCJ0b2tlbnMtb25seVwiXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXJTdG9yYWdlOiBvcHRpb25zPy5hdXRoPy51c2VyU3RvcmFnZSA/PyB3aW5kb3cubG9jYWxTdG9yYWdlLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IG51bGwpLFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGlmIChzaG91bGRVc2VTaW5nbGV0b24pIHtcbiAgICAgICAgY2FjaGVkQnJvd3NlckNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGNsaWVudDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZUJyb3dzZXJDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbImNyZWF0ZUNsaWVudCIsIlZFUlNJT04iLCJpc0Jyb3dzZXIiLCJjcmVhdGVTdG9yYWdlRnJvbU9wdGlvbnMiLCJjYWNoZWRCcm93c2VyQ2xpZW50IiwiY3JlYXRlQnJvd3NlckNsaWVudCIsInN1cGFiYXNlVXJsIiwic3VwYWJhc2VLZXkiLCJvcHRpb25zIiwic2hvdWxkVXNlU2luZ2xldG9uIiwiaXNTaW5nbGV0b24iLCJFcnJvciIsInN0b3JhZ2UiLCJjb29raWVFbmNvZGluZyIsImNsaWVudCIsImdsb2JhbCIsImhlYWRlcnMiLCJhdXRoIiwiY29va2llT3B0aW9ucyIsIm5hbWUiLCJzdG9yYWdlS2V5IiwiZmxvd1R5cGUiLCJhdXRvUmVmcmVzaFRva2VuIiwiZGV0ZWN0U2Vzc2lvbkluVXJsIiwicGVyc2lzdFNlc3Npb24iLCJjb29raWVzIiwiZW5jb2RlIiwidXNlclN0b3JhZ2UiLCJ3aW5kb3ciLCJsb2NhbFN0b3JhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/createBrowserClient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/createServerClient.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@supabase/auth-helpers-nextjs/dist/module/createServerClient.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createServerClient: () => (/* binding */ createServerClient)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"@supabase/supabase-js\");\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./version */ \"(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/version.js\");\n/* harmony import */ var _cookies__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cookies */ \"(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/cookies.js\");\n/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/helpers */ \"(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/utils/helpers.js\");\n\n\n\n\nfunction createServerClient(supabaseUrl, supabaseKey, options) {\n    if (!supabaseUrl || !supabaseKey) {\n        throw new Error(`Your project's URL and Key are required to create a Supabase client!\\n\\nCheck your Supabase project's API settings to find these values\\n\\nhttps://supabase.com/dashboard/project/_/settings/api`);\n    }\n    const { storage, getAll, setAll, setItems, removedItems } = (0,_cookies__WEBPACK_IMPORTED_MODULE_2__.createStorageFromOptions)({\n        ...options,\n        cookieEncoding: options?.cookieEncoding ?? \"base64url\"\n    }, true);\n    const client = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseKey, {\n        // TODO: resolve type error\n        ...options,\n        global: {\n            ...options?.global,\n            headers: {\n                ...options?.global?.headers,\n                \"X-Client-Info\": `supabase-ssr/${_version__WEBPACK_IMPORTED_MODULE_1__.VERSION} createServerClient`\n            }\n        },\n        auth: {\n            ...options?.cookieOptions?.name ? {\n                storageKey: options.cookieOptions.name\n            } : null,\n            ...options?.auth,\n            flowType: \"pkce\",\n            autoRefreshToken: false,\n            detectSessionInUrl: false,\n            persistSession: true,\n            storage,\n            ...options?.cookies && \"encode\" in options.cookies && options.cookies.encode === \"tokens-only\" ? {\n                userStorage: options?.auth?.userStorage ?? (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_3__.memoryLocalStorageAdapter)()\n            } : null\n        }\n    });\n    client.auth.onAuthStateChange(async (event)=>{\n        // The SIGNED_IN event is fired very often, but we don't need to\n        // apply the storage each time it fires, only if there are changes\n        // that need to be set -- which is if setItems / removeItems have\n        // data.\n        const hasStorageChanges = Object.keys(setItems).length > 0 || Object.keys(removedItems).length > 0;\n        if (hasStorageChanges && (event === \"SIGNED_IN\" || event === \"TOKEN_REFRESHED\" || event === \"USER_UPDATED\" || event === \"PASSWORD_RECOVERY\" || event === \"SIGNED_OUT\" || event === \"MFA_CHALLENGE_VERIFIED\")) {\n            await (0,_cookies__WEBPACK_IMPORTED_MODULE_2__.applyServerStorage)({\n                getAll,\n                setAll,\n                setItems,\n                removedItems\n            }, {\n                cookieOptions: options?.cookieOptions ?? null,\n                cookieEncoding: options?.cookieEncoding ?? \"base64url\"\n            });\n        }\n    });\n    return client;\n} //# sourceMappingURL=createServerClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtaGVscGVycy1uZXh0anMvZGlzdC9tb2R1bGUvY3JlYXRlU2VydmVyQ2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFzRDtBQUNsQjtBQUNxQztBQUNiO0FBQ3JELFNBQVNLLG1CQUFtQkMsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLE9BQU87SUFDaEUsSUFBSSxDQUFDRixlQUFlLENBQUNDLGFBQWE7UUFDOUIsTUFBTSxJQUFJRSxNQUFNLENBQUMsZ01BQWdNLENBQUM7SUFDdE47SUFDQSxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsWUFBWSxFQUFFLEdBQUdaLGtFQUF3QkEsQ0FBQztRQUNqRixHQUFHTSxPQUFPO1FBQ1ZPLGdCQUFnQlAsU0FBU08sa0JBQWtCO0lBQy9DLEdBQUc7SUFDSCxNQUFNQyxTQUFTaEIsbUVBQVlBLENBQUNNLGFBQWFDLGFBQWE7UUFDbEQsMkJBQTJCO1FBQzNCLEdBQUdDLE9BQU87UUFDVlMsUUFBUTtZQUNKLEdBQUdULFNBQVNTLE1BQU07WUFDbEJDLFNBQVM7Z0JBQ0wsR0FBR1YsU0FBU1MsUUFBUUMsT0FBTztnQkFDM0IsaUJBQWlCLENBQUMsYUFBYSxFQUFFakIsNkNBQU9BLENBQUMsbUJBQW1CLENBQUM7WUFDakU7UUFDSjtRQUNBa0IsTUFBTTtZQUNGLEdBQUlYLFNBQVNZLGVBQWVDLE9BQ3RCO2dCQUFFQyxZQUFZZCxRQUFRWSxhQUFhLENBQUNDLElBQUk7WUFBQyxJQUN6QyxJQUFJO1lBQ1YsR0FBR2IsU0FBU1csSUFBSTtZQUNoQkksVUFBVTtZQUNWQyxrQkFBa0I7WUFDbEJDLG9CQUFvQjtZQUNwQkMsZ0JBQWdCO1lBQ2hCaEI7WUFDQSxHQUFJRixTQUFTbUIsV0FDVCxZQUFZbkIsUUFBUW1CLE9BQU8sSUFDM0JuQixRQUFRbUIsT0FBTyxDQUFDQyxNQUFNLEtBQUssZ0JBQ3pCO2dCQUNFQyxhQUFhckIsU0FBU1csTUFBTVUsZUFBZXpCLHlFQUF5QkE7WUFDeEUsSUFDRSxJQUFJO1FBQ2Q7SUFDSjtJQUNBWSxPQUFPRyxJQUFJLENBQUNXLGlCQUFpQixDQUFDLE9BQU9DO1FBQ2pDLGdFQUFnRTtRQUNoRSxrRUFBa0U7UUFDbEUsaUVBQWlFO1FBQ2pFLFFBQVE7UUFDUixNQUFNQyxvQkFBb0JDLE9BQU9DLElBQUksQ0FBQ3JCLFVBQVVzQixNQUFNLEdBQUcsS0FBS0YsT0FBT0MsSUFBSSxDQUFDcEIsY0FBY3FCLE1BQU0sR0FBRztRQUNqRyxJQUFJSCxxQkFDQ0QsQ0FBQUEsVUFBVSxlQUNQQSxVQUFVLHFCQUNWQSxVQUFVLGtCQUNWQSxVQUFVLHVCQUNWQSxVQUFVLGdCQUNWQSxVQUFVLHdCQUF1QixHQUFJO1lBQ3pDLE1BQU01Qiw0REFBa0JBLENBQUM7Z0JBQUVRO2dCQUFRQztnQkFBUUM7Z0JBQVVDO1lBQWEsR0FBRztnQkFDakVNLGVBQWVaLFNBQVNZLGlCQUFpQjtnQkFDekNMLGdCQUFnQlAsU0FBU08sa0JBQWtCO1lBQy9DO1FBQ0o7SUFDSjtJQUNBLE9BQU9DO0FBQ1gsRUFDQSw4Q0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmNob3Itd29ya2Zsb3dzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWhlbHBlcnMtbmV4dGpzL2Rpc3QvbW9kdWxlL2NyZWF0ZVNlcnZlckNsaWVudC5qcz9iY2ZmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNsaWVudCwgfSBmcm9tIFwiQHN1cGFiYXNlL3N1cGFiYXNlLWpzXCI7XG5pbXBvcnQgeyBWRVJTSU9OIH0gZnJvbSBcIi4vdmVyc2lvblwiO1xuaW1wb3J0IHsgY3JlYXRlU3RvcmFnZUZyb21PcHRpb25zLCBhcHBseVNlcnZlclN0b3JhZ2UgfSBmcm9tIFwiLi9jb29raWVzXCI7XG5pbXBvcnQgeyBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyIH0gZnJvbSBcIi4vdXRpbHMvaGVscGVyc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlcnZlckNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VLZXksIG9wdGlvbnMpIHtcbiAgICBpZiAoIXN1cGFiYXNlVXJsIHx8ICFzdXBhYmFzZUtleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdXIgcHJvamVjdCdzIFVSTCBhbmQgS2V5IGFyZSByZXF1aXJlZCB0byBjcmVhdGUgYSBTdXBhYmFzZSBjbGllbnQhXFxuXFxuQ2hlY2sgeW91ciBTdXBhYmFzZSBwcm9qZWN0J3MgQVBJIHNldHRpbmdzIHRvIGZpbmQgdGhlc2UgdmFsdWVzXFxuXFxuaHR0cHM6Ly9zdXBhYmFzZS5jb20vZGFzaGJvYXJkL3Byb2plY3QvXy9zZXR0aW5ncy9hcGlgKTtcbiAgICB9XG4gICAgY29uc3QgeyBzdG9yYWdlLCBnZXRBbGwsIHNldEFsbCwgc2V0SXRlbXMsIHJlbW92ZWRJdGVtcyB9ID0gY3JlYXRlU3RvcmFnZUZyb21PcHRpb25zKHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgY29va2llRW5jb2Rpbmc6IG9wdGlvbnM/LmNvb2tpZUVuY29kaW5nID8/IFwiYmFzZTY0dXJsXCIsXG4gICAgfSwgdHJ1ZSk7XG4gICAgY29uc3QgY2xpZW50ID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSwge1xuICAgICAgICAvLyBUT0RPOiByZXNvbHZlIHR5cGUgZXJyb3JcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgZ2xvYmFsOiB7XG4gICAgICAgICAgICAuLi5vcHRpb25zPy5nbG9iYWwsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucz8uZ2xvYmFsPy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIFwiWC1DbGllbnQtSW5mb1wiOiBgc3VwYWJhc2Utc3NyLyR7VkVSU0lPTn0gY3JlYXRlU2VydmVyQ2xpZW50YCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGF1dGg6IHtcbiAgICAgICAgICAgIC4uLihvcHRpb25zPy5jb29raWVPcHRpb25zPy5uYW1lXG4gICAgICAgICAgICAgICAgPyB7IHN0b3JhZ2VLZXk6IG9wdGlvbnMuY29va2llT3B0aW9ucy5uYW1lIH1cbiAgICAgICAgICAgICAgICA6IG51bGwpLFxuICAgICAgICAgICAgLi4ub3B0aW9ucz8uYXV0aCxcbiAgICAgICAgICAgIGZsb3dUeXBlOiBcInBrY2VcIixcbiAgICAgICAgICAgIGF1dG9SZWZyZXNoVG9rZW46IGZhbHNlLFxuICAgICAgICAgICAgZGV0ZWN0U2Vzc2lvbkluVXJsOiBmYWxzZSxcbiAgICAgICAgICAgIHBlcnNpc3RTZXNzaW9uOiB0cnVlLFxuICAgICAgICAgICAgc3RvcmFnZSxcbiAgICAgICAgICAgIC4uLihvcHRpb25zPy5jb29raWVzICYmXG4gICAgICAgICAgICAgICAgXCJlbmNvZGVcIiBpbiBvcHRpb25zLmNvb2tpZXMgJiZcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvb2tpZXMuZW5jb2RlID09PSBcInRva2Vucy1vbmx5XCJcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgdXNlclN0b3JhZ2U6IG9wdGlvbnM/LmF1dGg/LnVzZXJTdG9yYWdlID8/IG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIoKSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiBudWxsKSxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBjbGllbnQuYXV0aC5vbkF1dGhTdGF0ZUNoYW5nZShhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgLy8gVGhlIFNJR05FRF9JTiBldmVudCBpcyBmaXJlZCB2ZXJ5IG9mdGVuLCBidXQgd2UgZG9uJ3QgbmVlZCB0b1xuICAgICAgICAvLyBhcHBseSB0aGUgc3RvcmFnZSBlYWNoIHRpbWUgaXQgZmlyZXMsIG9ubHkgaWYgdGhlcmUgYXJlIGNoYW5nZXNcbiAgICAgICAgLy8gdGhhdCBuZWVkIHRvIGJlIHNldCAtLSB3aGljaCBpcyBpZiBzZXRJdGVtcyAvIHJlbW92ZUl0ZW1zIGhhdmVcbiAgICAgICAgLy8gZGF0YS5cbiAgICAgICAgY29uc3QgaGFzU3RvcmFnZUNoYW5nZXMgPSBPYmplY3Qua2V5cyhzZXRJdGVtcykubGVuZ3RoID4gMCB8fCBPYmplY3Qua2V5cyhyZW1vdmVkSXRlbXMpLmxlbmd0aCA+IDA7XG4gICAgICAgIGlmIChoYXNTdG9yYWdlQ2hhbmdlcyAmJlxuICAgICAgICAgICAgKGV2ZW50ID09PSBcIlNJR05FRF9JTlwiIHx8XG4gICAgICAgICAgICAgICAgZXZlbnQgPT09IFwiVE9LRU5fUkVGUkVTSEVEXCIgfHxcbiAgICAgICAgICAgICAgICBldmVudCA9PT0gXCJVU0VSX1VQREFURURcIiB8fFxuICAgICAgICAgICAgICAgIGV2ZW50ID09PSBcIlBBU1NXT1JEX1JFQ09WRVJZXCIgfHxcbiAgICAgICAgICAgICAgICBldmVudCA9PT0gXCJTSUdORURfT1VUXCIgfHxcbiAgICAgICAgICAgICAgICBldmVudCA9PT0gXCJNRkFfQ0hBTExFTkdFX1ZFUklGSUVEXCIpKSB7XG4gICAgICAgICAgICBhd2FpdCBhcHBseVNlcnZlclN0b3JhZ2UoeyBnZXRBbGwsIHNldEFsbCwgc2V0SXRlbXMsIHJlbW92ZWRJdGVtcyB9LCB7XG4gICAgICAgICAgICAgICAgY29va2llT3B0aW9uczogb3B0aW9ucz8uY29va2llT3B0aW9ucyA/PyBudWxsLFxuICAgICAgICAgICAgICAgIGNvb2tpZUVuY29kaW5nOiBvcHRpb25zPy5jb29raWVFbmNvZGluZyA/PyBcImJhc2U2NHVybFwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2xpZW50O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlU2VydmVyQ2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJWRVJTSU9OIiwiY3JlYXRlU3RvcmFnZUZyb21PcHRpb25zIiwiYXBwbHlTZXJ2ZXJTdG9yYWdlIiwibWVtb3J5TG9jYWxTdG9yYWdlQWRhcHRlciIsImNyZWF0ZVNlcnZlckNsaWVudCIsInN1cGFiYXNlVXJsIiwic3VwYWJhc2VLZXkiLCJvcHRpb25zIiwiRXJyb3IiLCJzdG9yYWdlIiwiZ2V0QWxsIiwic2V0QWxsIiwic2V0SXRlbXMiLCJyZW1vdmVkSXRlbXMiLCJjb29raWVFbmNvZGluZyIsImNsaWVudCIsImdsb2JhbCIsImhlYWRlcnMiLCJhdXRoIiwiY29va2llT3B0aW9ucyIsIm5hbWUiLCJzdG9yYWdlS2V5IiwiZmxvd1R5cGUiLCJhdXRvUmVmcmVzaFRva2VuIiwiZGV0ZWN0U2Vzc2lvbkluVXJsIiwicGVyc2lzdFNlc3Npb24iLCJjb29raWVzIiwiZW5jb2RlIiwidXNlclN0b3JhZ2UiLCJvbkF1dGhTdGF0ZUNoYW5nZSIsImV2ZW50IiwiaGFzU3RvcmFnZUNoYW5nZXMiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/createServerClient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/auth-helpers-nextjs/dist/module/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_COOKIE_OPTIONS: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_COOKIE_OPTIONS),\n/* harmony export */   MAX_CHUNK_SIZE: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.MAX_CHUNK_SIZE),\n/* harmony export */   codepointToUTF8: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.codepointToUTF8),\n/* harmony export */   combineChunks: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.combineChunks),\n/* harmony export */   createBrowserClient: () => (/* reexport safe */ _createBrowserClient__WEBPACK_IMPORTED_MODULE_0__.createBrowserClient),\n/* harmony export */   createChunks: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.createChunks),\n/* harmony export */   createServerClient: () => (/* reexport safe */ _createServerClient__WEBPACK_IMPORTED_MODULE_1__.createServerClient),\n/* harmony export */   deleteChunks: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.deleteChunks),\n/* harmony export */   isBrowser: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.isBrowser),\n/* harmony export */   isChunkLike: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.isChunkLike),\n/* harmony export */   memoryLocalStorageAdapter: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.memoryLocalStorageAdapter),\n/* harmony export */   parse: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.parse),\n/* harmony export */   parseCookieHeader: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.parseCookieHeader),\n/* harmony export */   serialize: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.serialize),\n/* harmony export */   serializeCookieHeader: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.serializeCookieHeader),\n/* harmony export */   stringFromBase64URL: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.stringFromBase64URL),\n/* harmony export */   stringFromUTF8: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.stringFromUTF8),\n/* harmony export */   stringToBase64URL: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.stringToBase64URL),\n/* harmony export */   stringToUTF8: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.stringToUTF8)\n/* harmony export */ });\n/* harmony import */ var _createBrowserClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createBrowserClient */ \"(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/createBrowserClient.js\");\n/* harmony import */ var _createServerClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createServerClient */ \"(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/createServerClient.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/types.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_types__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _types__WEBPACK_IMPORTED_MODULE_2__) if([\"default\",\"createBrowserClient\",\"createServerClient\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _types__WEBPACK_IMPORTED_MODULE_2__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/utils/index.js\");\n// Check if this package is being used as one of the deprecated auth-helpers packages\nif (typeof process !== \"undefined\" && process.env?.npm_package_name) {\n    const packageName = process.env.npm_package_name;\n    const deprecatedPackages = [\n        \"@supabase/auth-helpers-nextjs\",\n        \"@supabase/auth-helpers-react\",\n        \"@supabase/auth-helpers-remix\",\n        \"@supabase/auth-helpers-sveltekit\"\n    ];\n    if (deprecatedPackages.includes(packageName)) {\n        console.warn(`\n\n   IMPORTANT: Package Consolidation Notice                                \n                                                                            \n The ${packageName.padEnd(35)} package name is deprecated.  \n                                                                            \n You are now using @supabase/ssr - a unified solution for all frameworks.  \n                                                                            \n The auth-helpers packages have been consolidated into @supabase/ssr       \n to provide better maintenance and consistent APIs across frameworks.      \n                                                                            \n Please update your package.json to use @supabase/ssr directly:            \n   npm uninstall ${packageName.padEnd(42)} \n   npm install @supabase/ssr                                               \n                                                                            \n For more information, visit:                                              \n https://supabase.com/docs/guides/auth/server-side                         \n\n    `);\n    }\n}\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtaGVscGVycy1uZXh0anMvZGlzdC9tb2R1bGUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEscUZBQXFGO0FBQ3JGLElBQUksT0FBT0EsWUFBWSxlQUFlQSxRQUFRQyxHQUFHLEVBQUVDLGtCQUFrQjtJQUNqRSxNQUFNQyxjQUFjSCxRQUFRQyxHQUFHLENBQUNDLGdCQUFnQjtJQUNoRCxNQUFNRSxxQkFBcUI7UUFDdkI7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELElBQUlBLG1CQUFtQkMsUUFBUSxDQUFDRixjQUFjO1FBQzFDRyxRQUFRQyxJQUFJLENBQUMsQ0FBQzs7OztNQUloQixFQUFFSixZQUFZSyxNQUFNLENBQUMsSUFBSTs7Ozs7Ozs7a0JBUWIsRUFBRUwsWUFBWUssTUFBTSxDQUFDLElBQUk7Ozs7OztJQU12QyxDQUFDO0lBQ0Q7QUFDSjtBQUNzQztBQUNEO0FBQ2I7QUFDQSxDQUN4QixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmNob3Itd29ya2Zsb3dzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWhlbHBlcnMtbmV4dGpzL2Rpc3QvbW9kdWxlL2luZGV4LmpzPzdhMjIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2hlY2sgaWYgdGhpcyBwYWNrYWdlIGlzIGJlaW5nIHVzZWQgYXMgb25lIG9mIHRoZSBkZXByZWNhdGVkIGF1dGgtaGVscGVycyBwYWNrYWdlc1xuaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52Py5ucG1fcGFja2FnZV9uYW1lKSB7XG4gICAgY29uc3QgcGFja2FnZU5hbWUgPSBwcm9jZXNzLmVudi5ucG1fcGFja2FnZV9uYW1lO1xuICAgIGNvbnN0IGRlcHJlY2F0ZWRQYWNrYWdlcyA9IFtcbiAgICAgICAgXCJAc3VwYWJhc2UvYXV0aC1oZWxwZXJzLW5leHRqc1wiLFxuICAgICAgICBcIkBzdXBhYmFzZS9hdXRoLWhlbHBlcnMtcmVhY3RcIixcbiAgICAgICAgXCJAc3VwYWJhc2UvYXV0aC1oZWxwZXJzLXJlbWl4XCIsXG4gICAgICAgIFwiQHN1cGFiYXNlL2F1dGgtaGVscGVycy1zdmVsdGVraXRcIixcbiAgICBdO1xuICAgIGlmIChkZXByZWNhdGVkUGFja2FnZXMuaW5jbHVkZXMocGFja2FnZU5hbWUpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgXG7ilZTilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZDilZdcbuKVkSDimqDvuI8gIElNUE9SVEFOVDogUGFja2FnZSBDb25zb2xpZGF0aW9uIE5vdGljZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pWRXG7ilZEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pWRXG7ilZEgVGhlICR7cGFja2FnZU5hbWUucGFkRW5kKDM1KX0gcGFja2FnZSBuYW1lIGlzIGRlcHJlY2F0ZWQuICDilZFcbuKVkSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilZFcbuKVkSBZb3UgYXJlIG5vdyB1c2luZyBAc3VwYWJhc2Uvc3NyIC0gYSB1bmlmaWVkIHNvbHV0aW9uIGZvciBhbGwgZnJhbWV3b3Jrcy4gIOKVkVxu4pWRICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKVkVxu4pWRIFRoZSBhdXRoLWhlbHBlcnMgcGFja2FnZXMgaGF2ZSBiZWVuIGNvbnNvbGlkYXRlZCBpbnRvIEBzdXBhYmFzZS9zc3IgICAgICAg4pWRXG7ilZEgdG8gcHJvdmlkZSBiZXR0ZXIgbWFpbnRlbmFuY2UgYW5kIGNvbnNpc3RlbnQgQVBJcyBhY3Jvc3MgZnJhbWV3b3Jrcy4gICAgICDilZFcbuKVkSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilZFcbuKVkSBQbGVhc2UgdXBkYXRlIHlvdXIgcGFja2FnZS5qc29uIHRvIHVzZSBAc3VwYWJhc2Uvc3NyIGRpcmVjdGx5OiAgICAgICAgICAgIOKVkVxu4pWRICAgbnBtIHVuaW5zdGFsbCAke3BhY2thZ2VOYW1lLnBhZEVuZCg0Mil9IOKVkVxu4pWRICAgbnBtIGluc3RhbGwgQHN1cGFiYXNlL3NzciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pWRXG7ilZEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pWRXG7ilZEgRm9yIG1vcmUgaW5mb3JtYXRpb24sIHZpc2l0OiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilZFcbuKVkSBodHRwczovL3N1cGFiYXNlLmNvbS9kb2NzL2d1aWRlcy9hdXRoL3NlcnZlci1zaWRlICAgICAgICAgICAgICAgICAgICAgICAgIOKVkVxu4pWa4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWdXG4gICAgYCk7XG4gICAgfVxufVxuZXhwb3J0ICogZnJvbSBcIi4vY3JlYXRlQnJvd3NlckNsaWVudFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vY3JlYXRlU2VydmVyQ2xpZW50XCI7XG5leHBvcnQgKiBmcm9tIFwiLi90eXBlc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vdXRpbHNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJwcm9jZXNzIiwiZW52IiwibnBtX3BhY2thZ2VfbmFtZSIsInBhY2thZ2VOYW1lIiwiZGVwcmVjYXRlZFBhY2thZ2VzIiwiaW5jbHVkZXMiLCJjb25zb2xlIiwid2FybiIsInBhZEVuZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/types.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/auth-helpers-nextjs/dist/module/types.js ***!
  \*************************************************************************/
/***/ (() => {

eval("//# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmNob3Itd29ya2Zsb3dzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWhlbHBlcnMtbmV4dGpzL2Rpc3QvbW9kdWxlL3R5cGVzLmpzP2MyYjMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlDQUFpQyIsImZpbGUiOiIocnNjKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1oZWxwZXJzLW5leHRqcy9kaXN0L21vZHVsZS90eXBlcy5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/utils/base64url.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@supabase/auth-helpers-nextjs/dist/module/utils/base64url.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   codepointToUTF8: () => (/* binding */ codepointToUTF8),\n/* harmony export */   stringFromBase64URL: () => (/* binding */ stringFromBase64URL),\n/* harmony export */   stringFromUTF8: () => (/* binding */ stringFromUTF8),\n/* harmony export */   stringToBase64URL: () => (/* binding */ stringToBase64URL),\n/* harmony export */   stringToUTF8: () => (/* binding */ stringToUTF8)\n/* harmony export */ });\n/**\n * Avoid modifying this file. It's part of\n * https://github.com/supabase-community/base64url-js.  Submit all fixes on\n * that repo!\n */ /**\n * An array of characters that encode 6 bits into a Base64-URL alphabet\n * character.\n */ const TO_BASE64URL = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\".split(\"\");\n/**\n * An array of characters that can appear in a Base64-URL encoded string but\n * should be ignored.\n */ const IGNORE_BASE64URL = \" \t\\n\\r=\".split(\"\");\n/**\n * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2\n * used to skip the character, or if -1 used to error out.\n */ const FROM_BASE64URL = (()=>{\n    const charMap = new Array(128);\n    for(let i = 0; i < charMap.length; i += 1){\n        charMap[i] = -1;\n    }\n    for(let i = 0; i < IGNORE_BASE64URL.length; i += 1){\n        charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;\n    }\n    for(let i = 0; i < TO_BASE64URL.length; i += 1){\n        charMap[TO_BASE64URL[i].charCodeAt(0)] = i;\n    }\n    return charMap;\n})();\n/**\n * Converts a JavaScript string (which may include any valid character) into a\n * Base64-URL encoded string. The string is first encoded in UTF-8 which is\n * then encoded as Base64-URL.\n *\n * @param str The string to convert.\n */ function stringToBase64URL(str) {\n    const base64 = [];\n    let queue = 0;\n    let queuedBits = 0;\n    const emitter = (byte)=>{\n        queue = queue << 8 | byte;\n        queuedBits += 8;\n        while(queuedBits >= 6){\n            const pos = queue >> queuedBits - 6 & 63;\n            base64.push(TO_BASE64URL[pos]);\n            queuedBits -= 6;\n        }\n    };\n    stringToUTF8(str, emitter);\n    if (queuedBits > 0) {\n        queue = queue << 6 - queuedBits;\n        queuedBits = 6;\n        while(queuedBits >= 6){\n            const pos = queue >> queuedBits - 6 & 63;\n            base64.push(TO_BASE64URL[pos]);\n            queuedBits -= 6;\n        }\n    }\n    return base64.join(\"\");\n}\n/**\n * Converts a Base64-URL encoded string into a JavaScript string. It is assumed\n * that the underlying string has been encoded as UTF-8.\n *\n * @param str The Base64-URL encoded string.\n */ function stringFromBase64URL(str) {\n    const conv = [];\n    const emit = (codepoint)=>{\n        conv.push(String.fromCodePoint(codepoint));\n    };\n    const state = {\n        utf8seq: 0,\n        codepoint: 0\n    };\n    let queue = 0;\n    let queuedBits = 0;\n    for(let i = 0; i < str.length; i += 1){\n        const codepoint = str.charCodeAt(i);\n        const bits = FROM_BASE64URL[codepoint];\n        if (bits > -1) {\n            // valid Base64-URL character\n            queue = queue << 6 | bits;\n            queuedBits += 6;\n            while(queuedBits >= 8){\n                stringFromUTF8(queue >> queuedBits - 8 & 0xff, state, emit);\n                queuedBits -= 8;\n            }\n        } else if (bits === -2) {\n            continue;\n        } else {\n            throw new Error(`Invalid Base64-URL character \"${str.at(i)}\" at position ${i}`);\n        }\n    }\n    return conv.join(\"\");\n}\n/**\n * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.\n *\n * @param codepoint The Unicode codepoint.\n * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.\n */ function codepointToUTF8(codepoint, emit) {\n    if (codepoint <= 0x7f) {\n        emit(codepoint);\n        return;\n    } else if (codepoint <= 0x7ff) {\n        emit(0xc0 | codepoint >> 6);\n        emit(0x80 | codepoint & 0x3f);\n        return;\n    } else if (codepoint <= 0xffff) {\n        emit(0xe0 | codepoint >> 12);\n        emit(0x80 | codepoint >> 6 & 0x3f);\n        emit(0x80 | codepoint & 0x3f);\n        return;\n    } else if (codepoint <= 0x10ffff) {\n        emit(0xf0 | codepoint >> 18);\n        emit(0x80 | codepoint >> 12 & 0x3f);\n        emit(0x80 | codepoint >> 6 & 0x3f);\n        emit(0x80 | codepoint & 0x3f);\n        return;\n    }\n    throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);\n}\n/**\n * Converts a JavaScript string to a sequence of UTF-8 bytes.\n *\n * @param str  The string to convert to UTF-8.\n * @param emit Function which will be called for each UTF-8 byte of the string.\n */ function stringToUTF8(str, emit) {\n    for(let i = 0; i < str.length; i += 1){\n        let codepoint = str.charCodeAt(i);\n        if (codepoint > 0xd7ff && codepoint <= 0xdbff) {\n            // most UTF-16 codepoints are Unicode codepoints, except values in this\n            // range where the next UTF-16 codepoint needs to be combined with the\n            // current one to get the Unicode codepoint\n            const highSurrogate = (codepoint - 0xd800) * 0x400 & 0xffff;\n            const lowSurrogate = str.charCodeAt(i + 1) - 0xdc00 & 0xffff;\n            codepoint = (lowSurrogate | highSurrogate) + 0x10000;\n            i += 1;\n        }\n        codepointToUTF8(codepoint, emit);\n    }\n}\n/**\n * Converts a UTF-8 byte to a Unicode codepoint.\n *\n * @param byte  The UTF-8 byte next in the sequence.\n * @param state The shared state between consecutive UTF-8 bytes in the\n *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.\n * @param emit  Function which will be called for each codepoint.\n */ function stringFromUTF8(byte, state, emit) {\n    if (state.utf8seq === 0) {\n        if (byte <= 0x7f) {\n            emit(byte);\n            return;\n        }\n        // count the number of 1 leading bits until you reach 0\n        for(let leadingBit = 1; leadingBit < 6; leadingBit += 1){\n            if ((byte >> 7 - leadingBit & 1) === 0) {\n                state.utf8seq = leadingBit;\n                break;\n            }\n        }\n        if (state.utf8seq === 2) {\n            state.codepoint = byte & 31;\n        } else if (state.utf8seq === 3) {\n            state.codepoint = byte & 15;\n        } else if (state.utf8seq === 4) {\n            state.codepoint = byte & 7;\n        } else {\n            throw new Error(\"Invalid UTF-8 sequence\");\n        }\n        state.utf8seq -= 1;\n    } else if (state.utf8seq > 0) {\n        if (byte <= 0x7f) {\n            throw new Error(\"Invalid UTF-8 sequence\");\n        }\n        state.codepoint = state.codepoint << 6 | byte & 63;\n        state.utf8seq -= 1;\n        if (state.utf8seq === 0) {\n            emit(state.codepoint);\n        }\n    }\n} //# sourceMappingURL=base64url.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtaGVscGVycy1uZXh0anMvZGlzdC9tb2R1bGUvdXRpbHMvYmFzZTY0dXJsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7Q0FJQyxHQUNEOzs7Q0FHQyxHQUNELE1BQU1BLGVBQWUsbUVBQW1FQyxLQUFLLENBQUM7QUFDOUY7OztDQUdDLEdBQ0QsTUFBTUMsbUJBQW1CLFVBQVdELEtBQUssQ0FBQztBQUMxQzs7O0NBR0MsR0FDRCxNQUFNRSxpQkFBaUIsQ0FBQztJQUNwQixNQUFNQyxVQUFVLElBQUlDLE1BQU07SUFDMUIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLFFBQVFHLE1BQU0sRUFBRUQsS0FBSyxFQUFHO1FBQ3hDRixPQUFPLENBQUNFLEVBQUUsR0FBRyxDQUFDO0lBQ2xCO0lBQ0EsSUFBSyxJQUFJQSxJQUFJLEdBQUdBLElBQUlKLGlCQUFpQkssTUFBTSxFQUFFRCxLQUFLLEVBQUc7UUFDakRGLE9BQU8sQ0FBQ0YsZ0JBQWdCLENBQUNJLEVBQUUsQ0FBQ0UsVUFBVSxDQUFDLEdBQUcsR0FBRyxDQUFDO0lBQ2xEO0lBQ0EsSUFBSyxJQUFJRixJQUFJLEdBQUdBLElBQUlOLGFBQWFPLE1BQU0sRUFBRUQsS0FBSyxFQUFHO1FBQzdDRixPQUFPLENBQUNKLFlBQVksQ0FBQ00sRUFBRSxDQUFDRSxVQUFVLENBQUMsR0FBRyxHQUFHRjtJQUM3QztJQUNBLE9BQU9GO0FBQ1g7QUFDQTs7Ozs7O0NBTUMsR0FDTSxTQUFTSyxrQkFBa0JDLEdBQUc7SUFDakMsTUFBTUMsU0FBUyxFQUFFO0lBQ2pCLElBQUlDLFFBQVE7SUFDWixJQUFJQyxhQUFhO0lBQ2pCLE1BQU1DLFVBQVUsQ0FBQ0M7UUFDYkgsUUFBUSxTQUFVLElBQUtHO1FBQ3ZCRixjQUFjO1FBQ2QsTUFBT0EsY0FBYyxFQUFHO1lBQ3BCLE1BQU1HLE1BQU0sU0FBV0gsYUFBYSxJQUFNO1lBQzFDRixPQUFPTSxJQUFJLENBQUNq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QlQsV0FBV0Q7SUFDL0I7QUFDSjtBQUNBOzs7Ozs7O0NBT0MsR0FDTSxTQUFTTyxlQUFlZCxJQUFJLEVBQUVXLEtBQUssRUFBRUosSUFBSTtJQUM1QyxJQUFJSSxNQUFNQyxPQUFPLEtBQUssR0FBRztRQUNyQixJQUFJWixRQUFRLE1BQU07WUFDZE8sS0FBS1A7WUFDTDtRQUNKO1FBQ0EsdURBQXVEO1FBQ3ZELElBQUssSUFBSXFCLGFBQWEsR0FBR0EsYUFBYSxHQUFHQSxjQUFjLEVBQUc7WUFDdEQsSUFBSSxDQUFDLFFBQVUsSUFBSUEsYUFBZSxPQUFPLEdBQUc7Z0JBQ3hDVixNQUFNQyxPQUFPLEdBQUdTO2dCQUNoQjtZQUNKO1FBQ0o7UUFDQSxJQUFJVixNQUFNQyxPQUFPLEtBQUssR0FBRztZQUNyQkQsTUFBTUgsU0FBUyxHQUFHUixPQUFPO1FBQzdCLE9BQ0ssSUFBSVcsTUFBTUMsT0FBTyxLQUFLLEdBQUc7WUFDMUJELE1BQU1ILFNBQVMsR0FBR1IsT0FBTztRQUM3QixPQUNLLElBQUlXLE1BQU1DLE9BQU8sS0FBSyxHQUFHO1lBQzFCRCxNQUFNSCxTQUFTLEdBQUdSLE9BQU87UUFDN0IsT0FDSztZQUNELE1BQU0sSUFBSWUsTUFBTTtRQUNwQjtRQUNBSixNQUFNQyxPQUFPLElBQUk7SUFDckIsT0FDSyxJQUFJRCxNQUFNQyxPQUFPLEdBQUcsR0FBRztRQUN4QixJQUFJWixRQUFRLE1BQU07WUFDZCxNQUFNLElBQUllLE1BQU07UUFDcEI7UUFDQUosTUFBTUgsU0FBUyxHQUFHLE1BQU9BLFNBQVMsSUFBSSxJQUFNUixPQUFPO1FBQ25EVyxNQUFNQyxPQUFPLElBQUk7UUFDakIsSUFBSUQsTUFBTUMsT0FBTyxLQUFLLEdBQUc7WUFDckJMLEtBQUtJLE1BQU1ILFNBQVM7UUFDeEI7SUFDSjtBQUNKLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5jaG9yLXdvcmtmbG93cy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1oZWxwZXJzLW5leHRqcy9kaXN0L21vZHVsZS91dGlscy9iYXNlNjR1cmwuanM/OTA2YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEF2b2lkIG1vZGlmeWluZyB0aGlzIGZpbGUuIEl0J3MgcGFydCBvZlxuICogaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlLWNvbW11bml0eS9iYXNlNjR1cmwtanMuICBTdWJtaXQgYWxsIGZpeGVzIG9uXG4gKiB0aGF0IHJlcG8hXG4gKi9cbi8qKlxuICogQW4gYXJyYXkgb2YgY2hhcmFjdGVycyB0aGF0IGVuY29kZSA2IGJpdHMgaW50byBhIEJhc2U2NC1VUkwgYWxwaGFiZXRcbiAqIGNoYXJhY3Rlci5cbiAqL1xuY29uc3QgVE9fQkFTRTY0VVJMID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fXCIuc3BsaXQoXCJcIik7XG4vKipcbiAqIEFuIGFycmF5IG9mIGNoYXJhY3RlcnMgdGhhdCBjYW4gYXBwZWFyIGluIGEgQmFzZTY0LVVSTCBlbmNvZGVkIHN0cmluZyBidXRcbiAqIHNob3VsZCBiZSBpZ25vcmVkLlxuICovXG5jb25zdCBJR05PUkVfQkFTRTY0VVJMID0gXCIgXFx0XFxuXFxyPVwiLnNwbGl0KFwiXCIpO1xuLyoqXG4gKiBBbiBhcnJheSBvZiAxMjggbnVtYmVycyB0aGF0IG1hcCBhIEJhc2U2NC1VUkwgY2hhcmFjdGVyIHRvIDYgYml0cywgb3IgaWYgLTJcbiAqIHVzZWQgdG8gc2tpcCB0aGUgY2hhcmFjdGVyLCBvciBpZiAtMSB1c2VkIHRvIGVycm9yIG91dC5cbiAqL1xuY29uc3QgRlJPTV9CQVNFNjRVUkwgPSAoKCkgPT4ge1xuICAgIGNvbnN0IGNoYXJNYXAgPSBuZXcgQXJyYXkoMTI4KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJNYXAubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY2hhck1hcFtpXSA9IC0xO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IElHTk9SRV9CQVNFNjRVUkwubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY2hhck1hcFtJR05PUkVfQkFTRTY0VVJMW2ldLmNoYXJDb2RlQXQoMCldID0gLTI7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgVE9fQkFTRTY0VVJMLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNoYXJNYXBbVE9fQkFTRTY0VVJMW2ldLmNoYXJDb2RlQXQoMCldID0gaTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJNYXA7XG59KSgpO1xuLyoqXG4gKiBDb252ZXJ0cyBhIEphdmFTY3JpcHQgc3RyaW5nICh3aGljaCBtYXkgaW5jbHVkZSBhbnkgdmFsaWQgY2hhcmFjdGVyKSBpbnRvIGFcbiAqIEJhc2U2NC1VUkwgZW5jb2RlZCBzdHJpbmcuIFRoZSBzdHJpbmcgaXMgZmlyc3QgZW5jb2RlZCBpbiBVVEYtOCB3aGljaCBpc1xuICogdGhlbiBlbmNvZGVkIGFzIEJhc2U2NC1VUkwuXG4gKlxuICogQHBhcmFtIHN0ciBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdUb0Jhc2U2NFVSTChzdHIpIHtcbiAgICBjb25zdCBiYXNlNjQgPSBbXTtcbiAgICBsZXQgcXVldWUgPSAwO1xuICAgIGxldCBxdWV1ZWRCaXRzID0gMDtcbiAgICBjb25zdCBlbWl0dGVyID0gKGJ5dGUpID0+IHtcbiAgICAgICAgcXVldWUgPSAocXVldWUgPDwgOCkgfCBieXRlO1xuICAgICAgICBxdWV1ZWRCaXRzICs9IDg7XG4gICAgICAgIHdoaWxlIChxdWV1ZWRCaXRzID49IDYpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IChxdWV1ZSA+PiAocXVldWVkQml0cyAtIDYpKSAmIDYzO1xuICAgICAgICAgICAgYmFzZTY0LnB1c2goVE9fQkFTRTY0VVJMW3Bvc10pO1xuICAgICAgICAgICAgcXVldWVkQml0cyAtPSA2O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBzdHJpbmdUb1VURjgoc3RyLCBlbWl0dGVyKTtcbiAgICBpZiAocXVldWVkQml0cyA+IDApIHtcbiAgICAgICAgcXVldWUgPSBxdWV1ZSA8PCAoNiAtIHF1ZXVlZEJpdHMpO1xuICAgICAgICBxdWV1ZWRCaXRzID0gNjtcbiAgICAgICAgd2hpbGUgKHF1ZXVlZEJpdHMgPj0gNikge1xuICAgICAgICAgICAgY29uc3QgcG9zID0gKHF1ZXVlID4+IChxdWV1ZWRCaXRzIC0gNikpICYgNjM7XG4gICAgICAgICAgICBiYXNlNjQucHVzaChUT19CQVNFNjRVUkxbcG9zXSk7XG4gICAgICAgICAgICBxdWV1ZWRCaXRzIC09IDY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhc2U2NC5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIEJhc2U2NC1VUkwgZW5jb2RlZCBzdHJpbmcgaW50byBhIEphdmFTY3JpcHQgc3RyaW5nLiBJdCBpcyBhc3N1bWVkXG4gKiB0aGF0IHRoZSB1bmRlcmx5aW5nIHN0cmluZyBoYXMgYmVlbiBlbmNvZGVkIGFzIFVURi04LlxuICpcbiAqIEBwYXJhbSBzdHIgVGhlIEJhc2U2NC1VUkwgZW5jb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdGcm9tQmFzZTY0VVJMKHN0cikge1xuICAgIGNvbnN0IGNvbnYgPSBbXTtcbiAgICBjb25zdCBlbWl0ID0gKGNvZGVwb2ludCkgPT4ge1xuICAgICAgICBjb252LnB1c2goU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZXBvaW50KSk7XG4gICAgfTtcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgdXRmOHNlcTogMCxcbiAgICAgICAgY29kZXBvaW50OiAwLFxuICAgIH07XG4gICAgbGV0IHF1ZXVlID0gMDtcbiAgICBsZXQgcXVldWVkQml0cyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgY29kZXBvaW50ID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGNvbnN0IGJpdHMgPSBGUk9NX0JBU0U2NFVSTFtjb2RlcG9pbnRdO1xuICAgICAgICBpZiAoYml0cyA+IC0xKSB7XG4gICAgICAgICAgICAvLyB2YWxpZCBCYXNlNjQtVVJMIGNoYXJhY3RlclxuICAgICAgICAgICAgcXVldWUgPSAocXVldWUgPDwgNikgfCBiaXRzO1xuICAgICAgICAgICAgcXVldWVkQml0cyArPSA2O1xuICAgICAgICAgICAgd2hpbGUgKHF1ZXVlZEJpdHMgPj0gOCkge1xuICAgICAgICAgICAgICAgIHN0cmluZ0Zyb21VVEY4KChxdWV1ZSA+PiAocXVldWVkQml0cyAtIDgpKSAmIDB4ZmYsIHN0YXRlLCBlbWl0KTtcbiAgICAgICAgICAgICAgICBxdWV1ZWRCaXRzIC09IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYml0cyA9PT0gLTIpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBzcGFjZXMsIHRhYnMsIG5ld2xpbmVzLCA9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBCYXNlNjQtVVJMIGNoYXJhY3RlciBcIiR7c3RyLmF0KGkpfVwiIGF0IHBvc2l0aW9uICR7aX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udi5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgY29kZXBvaW50IHRvIGEgbXVsdGktYnl0ZSBVVEYtOCBzZXF1ZW5jZS5cbiAqXG4gKiBAcGFyYW0gY29kZXBvaW50IFRoZSBVbmljb2RlIGNvZGVwb2ludC5cbiAqIEBwYXJhbSBlbWl0ICAgICAgRnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggVVRGLTggYnl0ZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNvZGVwb2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvZGVwb2ludFRvVVRGOChjb2RlcG9pbnQsIGVtaXQpIHtcbiAgICBpZiAoY29kZXBvaW50IDw9IDB4N2YpIHtcbiAgICAgICAgZW1pdChjb2RlcG9pbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGVwb2ludCA8PSAweDdmZikge1xuICAgICAgICBlbWl0KDB4YzAgfCAoY29kZXBvaW50ID4+IDYpKTtcbiAgICAgICAgZW1pdCgweDgwIHwgKGNvZGVwb2ludCAmIDB4M2YpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlcG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgIGVtaXQoMHhlMCB8IChjb2RlcG9pbnQgPj4gMTIpKTtcbiAgICAgICAgZW1pdCgweDgwIHwgKChjb2RlcG9pbnQgPj4gNikgJiAweDNmKSk7XG4gICAgICAgIGVtaXQoMHg4MCB8IChjb2RlcG9pbnQgJiAweDNmKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZXBvaW50IDw9IDB4MTBmZmZmKSB7XG4gICAgICAgIGVtaXQoMHhmMCB8IChjb2RlcG9pbnQgPj4gMTgpKTtcbiAgICAgICAgZW1pdCgweDgwIHwgKChjb2RlcG9pbnQgPj4gMTIpICYgMHgzZikpO1xuICAgICAgICBlbWl0KDB4ODAgfCAoKGNvZGVwb2ludCA+PiA2KSAmIDB4M2YpKTtcbiAgICAgICAgZW1pdCgweDgwIHwgKGNvZGVwb2ludCAmIDB4M2YpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBVbmljb2RlIGNvZGVwb2ludDogJHtjb2RlcG9pbnQudG9TdHJpbmcoMTYpfWApO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIEphdmFTY3JpcHQgc3RyaW5nIHRvIGEgc2VxdWVuY2Ugb2YgVVRGLTggYnl0ZXMuXG4gKlxuICogQHBhcmFtIHN0ciAgVGhlIHN0cmluZyB0byBjb252ZXJ0IHRvIFVURi04LlxuICogQHBhcmFtIGVtaXQgRnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggVVRGLTggYnl0ZSBvZiB0aGUgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nVG9VVEY4KHN0ciwgZW1pdCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCBjb2RlcG9pbnQgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGVwb2ludCA+IDB4ZDdmZiAmJiBjb2RlcG9pbnQgPD0gMHhkYmZmKSB7XG4gICAgICAgICAgICAvLyBtb3N0IFVURi0xNiBjb2RlcG9pbnRzIGFyZSBVbmljb2RlIGNvZGVwb2ludHMsIGV4Y2VwdCB2YWx1ZXMgaW4gdGhpc1xuICAgICAgICAgICAgLy8gcmFuZ2Ugd2hlcmUgdGhlIG5leHQgVVRGLTE2IGNvZGVwb2ludCBuZWVkcyB0byBiZSBjb21iaW5lZCB3aXRoIHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCBvbmUgdG8gZ2V0IHRoZSBVbmljb2RlIGNvZGVwb2ludFxuICAgICAgICAgICAgY29uc3QgaGlnaFN1cnJvZ2F0ZSA9ICgoY29kZXBvaW50IC0gMHhkODAwKSAqIDB4NDAwKSAmIDB4ZmZmZjtcbiAgICAgICAgICAgIGNvbnN0IGxvd1N1cnJvZ2F0ZSA9IChzdHIuY2hhckNvZGVBdChpICsgMSkgLSAweGRjMDApICYgMHhmZmZmO1xuICAgICAgICAgICAgY29kZXBvaW50ID0gKGxvd1N1cnJvZ2F0ZSB8IGhpZ2hTdXJyb2dhdGUpICsgMHgxMDAwMDtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBjb2RlcG9pbnRUb1VURjgoY29kZXBvaW50LCBlbWl0KTtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIGEgVVRGLTggYnl0ZSB0byBhIFVuaWNvZGUgY29kZXBvaW50LlxuICpcbiAqIEBwYXJhbSBieXRlICBUaGUgVVRGLTggYnl0ZSBuZXh0IGluIHRoZSBzZXF1ZW5jZS5cbiAqIEBwYXJhbSBzdGF0ZSBUaGUgc2hhcmVkIHN0YXRlIGJldHdlZW4gY29uc2VjdXRpdmUgVVRGLTggYnl0ZXMgaW4gdGhlXG4gKiAgICAgICAgICAgICAgc2VxdWVuY2UsIGFuIG9iamVjdCB3aXRoIHRoZSBzaGFwZSBgeyB1dGY4c2VxOiAwLCBjb2RlcG9pbnQ6IDAgfWAuXG4gKiBAcGFyYW0gZW1pdCAgRnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggY29kZXBvaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nRnJvbVVURjgoYnl0ZSwgc3RhdGUsIGVtaXQpIHtcbiAgICBpZiAoc3RhdGUudXRmOHNlcSA9PT0gMCkge1xuICAgICAgICBpZiAoYnl0ZSA8PSAweDdmKSB7XG4gICAgICAgICAgICBlbWl0KGJ5dGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvdW50IHRoZSBudW1iZXIgb2YgMSBsZWFkaW5nIGJpdHMgdW50aWwgeW91IHJlYWNoIDBcbiAgICAgICAgZm9yIChsZXQgbGVhZGluZ0JpdCA9IDE7IGxlYWRpbmdCaXQgPCA2OyBsZWFkaW5nQml0ICs9IDEpIHtcbiAgICAgICAgICAgIGlmICgoKGJ5dGUgPj4gKDcgLSBsZWFkaW5nQml0KSkgJiAxKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnV0ZjhzZXEgPSBsZWFkaW5nQml0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS51dGY4c2VxID09PSAyKSB7XG4gICAgICAgICAgICBzdGF0ZS5jb2RlcG9pbnQgPSBieXRlICYgMzE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUudXRmOHNlcSA9PT0gMykge1xuICAgICAgICAgICAgc3RhdGUuY29kZXBvaW50ID0gYnl0ZSAmIDE1O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLnV0ZjhzZXEgPT09IDQpIHtcbiAgICAgICAgICAgIHN0YXRlLmNvZGVwb2ludCA9IGJ5dGUgJiA3O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBVVEYtOCBzZXF1ZW5jZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS51dGY4c2VxIC09IDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXRlLnV0ZjhzZXEgPiAwKSB7XG4gICAgICAgIGlmIChieXRlIDw9IDB4N2YpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgVVRGLTggc2VxdWVuY2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuY29kZXBvaW50ID0gKHN0YXRlLmNvZGVwb2ludCA8PCA2KSB8IChieXRlICYgNjMpO1xuICAgICAgICBzdGF0ZS51dGY4c2VxIC09IDE7XG4gICAgICAgIGlmIChzdGF0ZS51dGY4c2VxID09PSAwKSB7XG4gICAgICAgICAgICBlbWl0KHN0YXRlLmNvZGVwb2ludCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjR1cmwuanMubWFwIl0sIm5hbWVzIjpbIlRPX0JBU0U2NFVSTCIsInNwbGl0IiwiSUdOT1JFX0JBU0U2NFVSTCIsIkZST01fQkFTRTY0VVJMIiwiY2hhck1hcCIsIkFycmF5IiwiaSIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJzdHJpbmdUb0Jhc2U2NFVSTCIsInN0ciIsImJhc2U2NCIsInF1ZXVlIiwicXVldWVkQml0cyIsImVtaXR0ZXIiLCJieXRlIiwicG9zIiwicHVzaCIsInN0cmluZ1RvVVRGOCIsImpvaW4iLCJzdHJpbmdGcm9tQmFzZTY0VVJMIiwiY29udiIsImVtaXQiLCJjb2RlcG9pbnQiLCJTdHJpbmciLCJmcm9tQ29kZVBvaW50Iiwic3RhdGUiLCJ1dGY4c2VxIiwiYml0cyIsInN0cmluZ0Zyb21VVEY4IiwiRXJyb3IiLCJhdCIsImNvZGVwb2ludFRvVVRGOCIsInRvU3RyaW5nIiwiaGlnaFN1cnJvZ2F0ZSIsImxvd1N1cnJvZ2F0ZSIsImxlYWRpbmdCaXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/utils/base64url.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/utils/chunker.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@supabase/auth-helpers-nextjs/dist/module/utils/chunker.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAX_CHUNK_SIZE: () => (/* binding */ MAX_CHUNK_SIZE),\n/* harmony export */   combineChunks: () => (/* binding */ combineChunks),\n/* harmony export */   createChunks: () => (/* binding */ createChunks),\n/* harmony export */   deleteChunks: () => (/* binding */ deleteChunks),\n/* harmony export */   isChunkLike: () => (/* binding */ isChunkLike)\n/* harmony export */ });\nconst MAX_CHUNK_SIZE = 3180;\nconst CHUNK_LIKE_REGEX = /^(.*)[.](0|[1-9][0-9]*)$/;\nfunction isChunkLike(cookieName, key) {\n    if (cookieName === key) {\n        return true;\n    }\n    const chunkLike = cookieName.match(CHUNK_LIKE_REGEX);\n    if (chunkLike && chunkLike[1] === key) {\n        return true;\n    }\n    return false;\n}\n/**\n * create chunks from a string and return an array of object\n */ function createChunks(key, value, chunkSize) {\n    const resolvedChunkSize = chunkSize ?? MAX_CHUNK_SIZE;\n    let encodedValue = encodeURIComponent(value);\n    if (encodedValue.length <= resolvedChunkSize) {\n        return [\n            {\n                name: key,\n                value\n            }\n        ];\n    }\n    const chunks = [];\n    while(encodedValue.length > 0){\n        let encodedChunkHead = encodedValue.slice(0, resolvedChunkSize);\n        const lastEscapePos = encodedChunkHead.lastIndexOf(\"%\");\n        // Check if the last escaped character is truncated.\n        if (lastEscapePos > resolvedChunkSize - 3) {\n            // If so, reslice the string to exclude the whole escape sequence.\n            // We only reduce the size of the string as the chunk must\n            // be smaller than the chunk size.\n            encodedChunkHead = encodedChunkHead.slice(0, lastEscapePos);\n        }\n        let valueHead = \"\";\n        // Check if the chunk was split along a valid unicode boundary.\n        while(encodedChunkHead.length > 0){\n            try {\n                // Try to decode the chunk back and see if it is valid.\n                // Stop when the chunk is valid.\n                valueHead = decodeURIComponent(encodedChunkHead);\n                break;\n            } catch (error) {\n                if (error instanceof URIError && encodedChunkHead.at(-3) === \"%\" && encodedChunkHead.length > 3) {\n                    encodedChunkHead = encodedChunkHead.slice(0, encodedChunkHead.length - 3);\n                } else {\n                    throw error;\n                }\n            }\n        }\n        chunks.push(valueHead);\n        encodedValue = encodedValue.slice(encodedChunkHead.length);\n    }\n    return chunks.map((value, i)=>({\n            name: `${key}.${i}`,\n            value\n        }));\n}\n// Get fully constructed chunks\nasync function combineChunks(key, retrieveChunk) {\n    const value = await retrieveChunk(key);\n    if (value) {\n        return value;\n    }\n    let values = [];\n    for(let i = 0;; i++){\n        const chunkName = `${key}.${i}`;\n        const chunk = await retrieveChunk(chunkName);\n        if (!chunk) {\n            break;\n        }\n        values.push(chunk);\n    }\n    if (values.length > 0) {\n        return values.join(\"\");\n    }\n    return null;\n}\nasync function deleteChunks(key, retrieveChunk, removeChunk) {\n    const value = await retrieveChunk(key);\n    if (value) {\n        await removeChunk(key);\n    }\n    for(let i = 0;; i++){\n        const chunkName = `${key}.${i}`;\n        const chunk = await retrieveChunk(chunkName);\n        if (!chunk) {\n            break;\n        }\n        await removeChunk(chunkName);\n    }\n} //# sourceMappingURL=chunker.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtaGVscGVycy1uZXh0anMvZGlzdC9tb2R1bGUvdXRpbHMvY2h1bmtlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFPLE1BQU1BLGlCQUFpQixLQUFLO0FBQ25DLE1BQU1DLG1CQUFtQjtBQUNsQixTQUFTQyxZQUFZQyxVQUFVLEVBQUVDLEdBQUc7SUFDdkMsSUFBSUQsZUFBZUMsS0FBSztRQUNwQixPQUFPO0lBQ1g7SUFDQSxNQUFNQyxZQUFZRixXQUFXRyxLQUFLLENBQUNMO0lBQ25DLElBQUlJLGFBQWFBLFNBQVMsQ0FBQyxFQUFFLEtBQUtELEtBQUs7UUFDbkMsT0FBTztJQUNYO0lBQ0EsT0FBTztBQUNYO0FBQ0E7O0NBRUMsR0FDTSxTQUFTRyxhQUFhSCxHQUFHLEVBQUVJLEtBQUssRUFBRUMsU0FBUztJQUM5QyxNQUFNQyxvQkFBb0JELGFBQWFUO0lBQ3ZDLElBQUlXLGVBQWVDLG1CQUFtQko7SUFDdEMsSUFBSUcsYUFBYUUsTUFBTSxJQUFJSCxtQkFBbUI7UUFDMUMsT0FBTztZQUFDO2dCQUFFSSxNQUFNVjtnQkFBS0k7WUFBTTtTQUFFO0lBQ2pDO0lBQ0EsTUFBTU8sU0FBUyxFQUFFO0lBQ2pCLE1BQU9KLGFBQWFFLE1BQU0sR0FBRyxFQUFHO1FBQzVCLElBQUlHLG1CQUFtQkwsYUFBYU0sS0FBSyxDQUFDLEdBQUdQO1FBQzdDLE1BQU1RLGdCQUFnQkYsaUJBQWlCRyxXQUFXLENBQUM7UUFDbkQsb0RBQW9EO1FBQ3BELElBQUlELGdCQUFnQlIsb0JBQW9CLEdBQUc7WUFDdkMsa0VBQWtFO1lBQ2xFLDBEQUEwRDtZQUMxRCxrQ0FBa0M7WUFDbENNLG1CQUFtQkEsaUJBQWlCQyxLQUFLLENBQUMsR0FBR0M7UUFDakQ7UUFDQSxJQUFJRSxZQUFZO1FBQ2hCLCtEQUErRDtRQUMvRCxNQUFPSixpQkFBaUJILE1BQU0sR0FBRyxFQUFHO1lBQ2hDLElBQUk7Z0JBQ0EsdURBQXVEO2dCQUN2RCxnQ0FBZ0M7Z0JBQ2hDTyxZQUFZQyxtQkFBbUJMO2dCQUMvQjtZQUNKLEVBQ0EsT0FBT00sT0FBTztnQkFDVixJQUFJQSxpQkFBaUJDLFlBQ2pCUCxpQkFBaUJRLEVBQUUsQ0FBQyxDQUFDLE9BQU8sT0FDNUJSLGlCQUFpQkgsTUFBTSxHQUFHLEdBQUc7b0JBQzdCRyxtQkFBbUJBLGlCQUFpQkMsS0FBSyxDQUFDLEdBQUdELGlCQUFpQkgsTUFBTSxHQUFHO2dCQUMzRSxPQUNLO29CQUNELE1BQU1TO2dCQUNWO1lBQ0o7UUFDSjtRQUNBUCxPQUFPVSxJQUFJLENBQUNMO1FBQ1pULGVBQWVBLGFBQWFNLEtBQUssQ0FBQ0QsaUJBQWlCSCxNQUFNO0lBQzdEO0lBQ0EsT0FBT0UsT0FBT1csR0FBRyxDQUFDLENBQUNsQixPQUFPbUIsSUFBTztZQUFFYixNQUFNLENBQUMsRUFBRVYsSUFBSSxDQUFDLEVBQUV1QixFQUFFLENBQUM7WUFBRW5CO1FBQU07QUFDbEU7QUFDQSwrQkFBK0I7QUFDeEIsZUFBZW9CLGNBQWN4QixHQUFHLEVBQUV5QixhQUFhO0lBQ2xELE1BQU1yQixRQUFRLE1BQU1xQixjQUFjekI7SUFDbEMsSUFBSUksT0FBTztRQUNQLE9BQU9BO0lBQ1g7SUFDQSxJQUFJc0IsU0FBUyxFQUFFO0lBQ2YsSUFBSyxJQUFJSCxJQUFJLElBQUlBLElBQUs7UUFDbEIsTUFBTUksWUFBWSxDQUFDLEVBQUUzQixJQUFJLENBQUMsRUFBRXVCLEVBQUUsQ0FBQztRQUMvQixNQUFNSyxRQUFRLE1BQU1ILGNBQWNFO1FBQ2xDLElBQUksQ0FBQ0MsT0FBTztZQUNSO1FBQ0o7UUFDQUYsT0FBT0wsSUFBSSxDQUFDTztJQUNoQjtJQUNBLElBQUlGLE9BQU9qQixNQUFNLEdBQUcsR0FBRztRQUNuQixPQUFPaUIsT0FBT0csSUFBSSxDQUFDO0lBQ3ZCO0lBQ0EsT0FBTztBQUNYO0FBQ08sZUFBZUMsYUFBYTlCLEdBQUcsRUFBRXlCLGFBQWEsRUFBRU0sV0FBVztJQUM5RCxNQUFNM0IsUUFBUSxNQUFNcUIsY0FBY3pCO0lBQ2xDLElBQUlJLE9BQU87UUFDUCxNQUFNMkIsWUFBWS9CO0lBQ3RCO0lBQ0EsSUFBSyxJQUFJdUIsSUFBSSxJQUFJQSxJQUFLO1FBQ2xCLE1BQU1JLFlBQVksQ0FBQyxFQUFFM0IsSUFBSSxDQUFDLEVBQUV1QixFQUFFLENBQUM7UUFDL0IsTUFBTUssUUFBUSxNQUFNSCxjQUFjRTtRQUNsQyxJQUFJLENBQUNDLE9BQU87WUFDUjtRQUNKO1FBQ0EsTUFBTUcsWUFBWUo7SUFDdEI7QUFDSixFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FuY2hvci13b3JrZmxvd3MvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtaGVscGVycy1uZXh0anMvZGlzdC9tb2R1bGUvdXRpbHMvY2h1bmtlci5qcz8zNDYxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBNQVhfQ0hVTktfU0laRSA9IDMxODA7XG5jb25zdCBDSFVOS19MSUtFX1JFR0VYID0gL14oLiopWy5dKDB8WzEtOV1bMC05XSopJC87XG5leHBvcnQgZnVuY3Rpb24gaXNDaHVua0xpa2UoY29va2llTmFtZSwga2V5KSB7XG4gICAgaWYgKGNvb2tpZU5hbWUgPT09IGtleSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgY2h1bmtMaWtlID0gY29va2llTmFtZS5tYXRjaChDSFVOS19MSUtFX1JFR0VYKTtcbiAgICBpZiAoY2h1bmtMaWtlICYmIGNodW5rTGlrZVsxXSA9PT0ga2V5KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIGNyZWF0ZSBjaHVua3MgZnJvbSBhIHN0cmluZyBhbmQgcmV0dXJuIGFuIGFycmF5IG9mIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2h1bmtzKGtleSwgdmFsdWUsIGNodW5rU2l6ZSkge1xuICAgIGNvbnN0IHJlc29sdmVkQ2h1bmtTaXplID0gY2h1bmtTaXplID8/IE1BWF9DSFVOS19TSVpFO1xuICAgIGxldCBlbmNvZGVkVmFsdWUgPSBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgIGlmIChlbmNvZGVkVmFsdWUubGVuZ3RoIDw9IHJlc29sdmVkQ2h1bmtTaXplKSB7XG4gICAgICAgIHJldHVybiBbeyBuYW1lOiBrZXksIHZhbHVlIH1dO1xuICAgIH1cbiAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICB3aGlsZSAoZW5jb2RlZFZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGV0IGVuY29kZWRDaHVua0hlYWQgPSBlbmNvZGVkVmFsdWUuc2xpY2UoMCwgcmVzb2x2ZWRDaHVua1NpemUpO1xuICAgICAgICBjb25zdCBsYXN0RXNjYXBlUG9zID0gZW5jb2RlZENodW5rSGVhZC5sYXN0SW5kZXhPZihcIiVcIik7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBsYXN0IGVzY2FwZWQgY2hhcmFjdGVyIGlzIHRydW5jYXRlZC5cbiAgICAgICAgaWYgKGxhc3RFc2NhcGVQb3MgPiByZXNvbHZlZENodW5rU2l6ZSAtIDMpIHtcbiAgICAgICAgICAgIC8vIElmIHNvLCByZXNsaWNlIHRoZSBzdHJpbmcgdG8gZXhjbHVkZSB0aGUgd2hvbGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgLy8gV2Ugb25seSByZWR1Y2UgdGhlIHNpemUgb2YgdGhlIHN0cmluZyBhcyB0aGUgY2h1bmsgbXVzdFxuICAgICAgICAgICAgLy8gYmUgc21hbGxlciB0aGFuIHRoZSBjaHVuayBzaXplLlxuICAgICAgICAgICAgZW5jb2RlZENodW5rSGVhZCA9IGVuY29kZWRDaHVua0hlYWQuc2xpY2UoMCwgbGFzdEVzY2FwZVBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZhbHVlSGVhZCA9IFwiXCI7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjaHVuayB3YXMgc3BsaXQgYWxvbmcgYSB2YWxpZCB1bmljb2RlIGJvdW5kYXJ5LlxuICAgICAgICB3aGlsZSAoZW5jb2RlZENodW5rSGVhZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIFRyeSB0byBkZWNvZGUgdGhlIGNodW5rIGJhY2sgYW5kIHNlZSBpZiBpdCBpcyB2YWxpZC5cbiAgICAgICAgICAgICAgICAvLyBTdG9wIHdoZW4gdGhlIGNodW5rIGlzIHZhbGlkLlxuICAgICAgICAgICAgICAgIHZhbHVlSGVhZCA9IGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVkQ2h1bmtIZWFkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFVSSUVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZWRDaHVua0hlYWQuYXQoLTMpID09PSBcIiVcIiAmJlxuICAgICAgICAgICAgICAgICAgICBlbmNvZGVkQ2h1bmtIZWFkLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlZENodW5rSGVhZCA9IGVuY29kZWRDaHVua0hlYWQuc2xpY2UoMCwgZW5jb2RlZENodW5rSGVhZC5sZW5ndGggLSAzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaHVua3MucHVzaCh2YWx1ZUhlYWQpO1xuICAgICAgICBlbmNvZGVkVmFsdWUgPSBlbmNvZGVkVmFsdWUuc2xpY2UoZW5jb2RlZENodW5rSGVhZC5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gY2h1bmtzLm1hcCgodmFsdWUsIGkpID0+ICh7IG5hbWU6IGAke2tleX0uJHtpfWAsIHZhbHVlIH0pKTtcbn1cbi8vIEdldCBmdWxseSBjb25zdHJ1Y3RlZCBjaHVua3NcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb21iaW5lQ2h1bmtzKGtleSwgcmV0cmlldmVDaHVuaykge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcmV0cmlldmVDaHVuayhrZXkpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICBjb25zdCBjaHVua05hbWUgPSBgJHtrZXl9LiR7aX1gO1xuICAgICAgICBjb25zdCBjaHVuayA9IGF3YWl0IHJldHJpZXZlQ2h1bmsoY2h1bmtOYW1lKTtcbiAgICAgICAgaWYgKCFjaHVuaykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzLnB1c2goY2h1bmspO1xuICAgIH1cbiAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5qb2luKFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVDaHVua3Moa2V5LCByZXRyaWV2ZUNodW5rLCByZW1vdmVDaHVuaykge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcmV0cmlldmVDaHVuayhrZXkpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBhd2FpdCByZW1vdmVDaHVuayhrZXkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICBjb25zdCBjaHVua05hbWUgPSBgJHtrZXl9LiR7aX1gO1xuICAgICAgICBjb25zdCBjaHVuayA9IGF3YWl0IHJldHJpZXZlQ2h1bmsoY2h1bmtOYW1lKTtcbiAgICAgICAgaWYgKCFjaHVuaykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcmVtb3ZlQ2h1bmsoY2h1bmtOYW1lKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVua2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJNQVhfQ0hVTktfU0laRSIsIkNIVU5LX0xJS0VfUkVHRVgiLCJpc0NodW5rTGlrZSIsImNvb2tpZU5hbWUiLCJrZXkiLCJjaHVua0xpa2UiLCJtYXRjaCIsImNyZWF0ZUNodW5rcyIsInZhbHVlIiwiY2h1bmtTaXplIiwicmVzb2x2ZWRDaHVua1NpemUiLCJlbmNvZGVkVmFsdWUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJsZW5ndGgiLCJuYW1lIiwiY2h1bmtzIiwiZW5jb2RlZENodW5rSGVhZCIsInNsaWNlIiwibGFzdEVzY2FwZVBvcyIsImxhc3RJbmRleE9mIiwidmFsdWVIZWFkIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZXJyb3IiLCJVUklFcnJvciIsImF0IiwicHVzaCIsIm1hcCIsImkiLCJjb21iaW5lQ2h1bmtzIiwicmV0cmlldmVDaHVuayIsInZhbHVlcyIsImNodW5rTmFtZSIsImNodW5rIiwiam9pbiIsImRlbGV0ZUNodW5rcyIsInJlbW92ZUNodW5rIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/utils/chunker.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/utils/constants.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@supabase/auth-helpers-nextjs/dist/module/utils/constants.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_COOKIE_OPTIONS: () => (/* binding */ DEFAULT_COOKIE_OPTIONS)\n/* harmony export */ });\nconst DEFAULT_COOKIE_OPTIONS = {\n    path: \"/\",\n    sameSite: \"lax\",\n    httpOnly: false,\n    // https://developer.chrome.com/blog/cookie-max-age-expires\n    // https://httpwg.org/http-extensions/draft-ietf-httpbis-rfc6265bis.html#name-cookie-lifetime-limits\n    maxAge: 400 * 24 * 60 * 60\n}; //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtaGVscGVycy1uZXh0anMvZGlzdC9tb2R1bGUvdXRpbHMvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxNQUFNQSx5QkFBeUI7SUFDbENDLE1BQU07SUFDTkMsVUFBVTtJQUNWQyxVQUFVO0lBQ1YsMkRBQTJEO0lBQzNELG9HQUFvRztJQUNwR0MsUUFBUSxNQUFNLEtBQUssS0FBSztBQUM1QixFQUFFLENBQ0YscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5jaG9yLXdvcmtmbG93cy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1oZWxwZXJzLW5leHRqcy9kaXN0L21vZHVsZS91dGlscy9jb25zdGFudHMuanM/NTc5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgREVGQVVMVF9DT09LSUVfT1BUSU9OUyA9IHtcbiAgICBwYXRoOiBcIi9cIixcbiAgICBzYW1lU2l0ZTogXCJsYXhcIixcbiAgICBodHRwT25seTogZmFsc2UsXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9ibG9nL2Nvb2tpZS1tYXgtYWdlLWV4cGlyZXNcbiAgICAvLyBodHRwczovL2h0dHB3Zy5vcmcvaHR0cC1leHRlbnNpb25zL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzLmh0bWwjbmFtZS1jb29raWUtbGlmZXRpbWUtbGltaXRzXG4gICAgbWF4QWdlOiA0MDAgKiAyNCAqIDYwICogNjAsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJERUZBVUxUX0NPT0tJRV9PUFRJT05TIiwicGF0aCIsInNhbWVTaXRlIiwiaHR0cE9ubHkiLCJtYXhBZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/utils/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/utils/helpers.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@supabase/auth-helpers-nextjs/dist/module/utils/helpers.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   memoryLocalStorageAdapter: () => (/* binding */ memoryLocalStorageAdapter),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseCookieHeader: () => (/* binding */ parseCookieHeader),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   serializeCookieHeader: () => (/* binding */ serializeCookieHeader)\n/* harmony export */ });\n/* harmony import */ var cookie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cookie */ \"(rsc)/./node_modules/cookie/dist/index.js\");\n\n/**\n * @deprecated Since v0.4.0: Please use {@link parseCookieHeader}. `parse` will\n * not be available for import starting v1.0.0 of `@supabase/ssr`.\n */ const parse = cookie__WEBPACK_IMPORTED_MODULE_0__.parse;\n/**\n * @deprecated Since v0.4.0: Please use {@link serializeCookieHeader}.\n * `serialize` will not be available for import starting v1.0.0 of\n * `@supabase/ssr`.\n */ const serialize = cookie__WEBPACK_IMPORTED_MODULE_0__.serialize;\n/**\n * Parses the `Cookie` HTTP header into an array of cookie name-value objects.\n *\n * @param header The `Cookie` HTTP header. Decodes cookie names and values from\n * URI encoding first.\n */ function parseCookieHeader(header) {\n    const parsed = cookie__WEBPACK_IMPORTED_MODULE_0__.parse(header);\n    return Object.keys(parsed ?? {}).map((name)=>({\n            name,\n            value: parsed[name]\n        }));\n}\n/**\n * Converts the arguments to a valid `Set-Cookie` header. Non US-ASCII chars\n * and other forbidden cookie chars will be URI encoded.\n *\n * @param name Name of cookie.\n * @param value Value of cookie.\n */ function serializeCookieHeader(name, value, options) {\n    return cookie__WEBPACK_IMPORTED_MODULE_0__.serialize(name, value, options);\n}\nfunction isBrowser() {\n    return  false && 0;\n}\n/**\n * Returns a localStorage-like object that stores the key-value pairs in\n * memory.\n */ function memoryLocalStorageAdapter(store = {}) {\n    return {\n        getItem: (key)=>{\n            return store[key] || null;\n        },\n        setItem: (key, value)=>{\n            store[key] = value;\n        },\n        removeItem: (key)=>{\n            delete store[key];\n        }\n    };\n} //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtaGVscGVycy1uZXh0anMvZGlzdC9tb2R1bGUvdXRpbHMvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWlDO0FBQ2pDOzs7Q0FHQyxHQUNNLE1BQU1DLFFBQVFELHlDQUFZLENBQUM7QUFDbEM7Ozs7Q0FJQyxHQUNNLE1BQU1FLFlBQVlGLDZDQUFnQixDQUFDO0FBQzFDOzs7OztDQUtDLEdBQ00sU0FBU0csa0JBQWtCQyxNQUFNO0lBQ3BDLE1BQU1DLFNBQVNMLHlDQUFZLENBQUNJO0lBQzVCLE9BQU9FLE9BQU9DLElBQUksQ0FBQ0YsVUFBVSxDQUFDLEdBQUdHLEdBQUcsQ0FBQyxDQUFDQyxPQUFVO1lBQzVDQTtZQUNBQyxPQUFPTCxNQUFNLENBQUNJLEtBQUs7UUFDdkI7QUFDSjtBQUNBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNFLHNCQUFzQkYsSUFBSSxFQUFFQyxLQUFLLEVBQUVFLE9BQU87SUFDdEQsT0FBT1osNkNBQWdCLENBQUNTLE1BQU1DLE9BQU9FO0FBQ3pDO0FBQ08sU0FBU0M7SUFDWixPQUFRLE1BQTZCLElBQUksQ0FBc0M7QUFDbkY7QUFDQTs7O0NBR0MsR0FDTSxTQUFTRywwQkFBMEJDLFFBQVEsQ0FBQyxDQUFDO0lBQ2hELE9BQU87UUFDSEMsU0FBUyxDQUFDQztZQUNOLE9BQU9GLEtBQUssQ0FBQ0UsSUFBSSxJQUFJO1FBQ3pCO1FBQ0FDLFNBQVMsQ0FBQ0QsS0FBS1Q7WUFDWE8sS0FBSyxDQUFDRSxJQUFJLEdBQUdUO1FBQ2pCO1FBQ0FXLFlBQVksQ0FBQ0Y7WUFDVCxPQUFPRixLQUFLLENBQUNFLElBQUk7UUFDckI7SUFDSjtBQUNKLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5jaG9yLXdvcmtmbG93cy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1oZWxwZXJzLW5leHRqcy9kaXN0L21vZHVsZS91dGlscy9oZWxwZXJzLmpzP2JjYTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY29va2llIGZyb20gXCJjb29raWVcIjtcbi8qKlxuICogQGRlcHJlY2F0ZWQgU2luY2UgdjAuNC4wOiBQbGVhc2UgdXNlIHtAbGluayBwYXJzZUNvb2tpZUhlYWRlcn0uIGBwYXJzZWAgd2lsbFxuICogbm90IGJlIGF2YWlsYWJsZSBmb3IgaW1wb3J0IHN0YXJ0aW5nIHYxLjAuMCBvZiBgQHN1cGFiYXNlL3NzcmAuXG4gKi9cbmV4cG9ydCBjb25zdCBwYXJzZSA9IGNvb2tpZS5wYXJzZTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgU2luY2UgdjAuNC4wOiBQbGVhc2UgdXNlIHtAbGluayBzZXJpYWxpemVDb29raWVIZWFkZXJ9LlxuICogYHNlcmlhbGl6ZWAgd2lsbCBub3QgYmUgYXZhaWxhYmxlIGZvciBpbXBvcnQgc3RhcnRpbmcgdjEuMC4wIG9mXG4gKiBgQHN1cGFiYXNlL3NzcmAuXG4gKi9cbmV4cG9ydCBjb25zdCBzZXJpYWxpemUgPSBjb29raWUuc2VyaWFsaXplO1xuLyoqXG4gKiBQYXJzZXMgdGhlIGBDb29raWVgIEhUVFAgaGVhZGVyIGludG8gYW4gYXJyYXkgb2YgY29va2llIG5hbWUtdmFsdWUgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gaGVhZGVyIFRoZSBgQ29va2llYCBIVFRQIGhlYWRlci4gRGVjb2RlcyBjb29raWUgbmFtZXMgYW5kIHZhbHVlcyBmcm9tXG4gKiBVUkkgZW5jb2RpbmcgZmlyc3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNvb2tpZUhlYWRlcihoZWFkZXIpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBjb29raWUucGFyc2UoaGVhZGVyKTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocGFyc2VkID8/IHt9KS5tYXAoKG5hbWUpID0+ICh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZhbHVlOiBwYXJzZWRbbmFtZV0sXG4gICAgfSkpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgYXJndW1lbnRzIHRvIGEgdmFsaWQgYFNldC1Db29raWVgIGhlYWRlci4gTm9uIFVTLUFTQ0lJIGNoYXJzXG4gKiBhbmQgb3RoZXIgZm9yYmlkZGVuIGNvb2tpZSBjaGFycyB3aWxsIGJlIFVSSSBlbmNvZGVkLlxuICpcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgY29va2llLlxuICogQHBhcmFtIHZhbHVlIFZhbHVlIG9mIGNvb2tpZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZUNvb2tpZUhlYWRlcihuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBjb29raWUuc2VyaWFsaXplKG5hbWUsIHZhbHVlLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgbG9jYWxTdG9yYWdlLWxpa2Ugb2JqZWN0IHRoYXQgc3RvcmVzIHRoZSBrZXktdmFsdWUgcGFpcnMgaW5cbiAqIG1lbW9yeS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIoc3RvcmUgPSB7fSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldEl0ZW06IChrZXkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdG9yZVtrZXldIHx8IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEl0ZW06IChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBzdG9yZVtrZXldID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUl0ZW06IChrZXkpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSBzdG9yZVtrZXldO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJjb29raWUiLCJwYXJzZSIsInNlcmlhbGl6ZSIsInBhcnNlQ29va2llSGVhZGVyIiwiaGVhZGVyIiwicGFyc2VkIiwiT2JqZWN0Iiwia2V5cyIsIm1hcCIsIm5hbWUiLCJ2YWx1ZSIsInNlcmlhbGl6ZUNvb2tpZUhlYWRlciIsIm9wdGlvbnMiLCJpc0Jyb3dzZXIiLCJ3aW5kb3ciLCJkb2N1bWVudCIsIm1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIiLCJzdG9yZSIsImdldEl0ZW0iLCJrZXkiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/utils/helpers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/utils/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@supabase/auth-helpers-nextjs/dist/module/utils/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_COOKIE_OPTIONS: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_COOKIE_OPTIONS),\n/* harmony export */   MAX_CHUNK_SIZE: () => (/* reexport safe */ _chunker__WEBPACK_IMPORTED_MODULE_2__.MAX_CHUNK_SIZE),\n/* harmony export */   codepointToUTF8: () => (/* reexport safe */ _base64url__WEBPACK_IMPORTED_MODULE_3__.codepointToUTF8),\n/* harmony export */   combineChunks: () => (/* reexport safe */ _chunker__WEBPACK_IMPORTED_MODULE_2__.combineChunks),\n/* harmony export */   createChunks: () => (/* reexport safe */ _chunker__WEBPACK_IMPORTED_MODULE_2__.createChunks),\n/* harmony export */   deleteChunks: () => (/* reexport safe */ _chunker__WEBPACK_IMPORTED_MODULE_2__.deleteChunks),\n/* harmony export */   isBrowser: () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_0__.isBrowser),\n/* harmony export */   isChunkLike: () => (/* reexport safe */ _chunker__WEBPACK_IMPORTED_MODULE_2__.isChunkLike),\n/* harmony export */   memoryLocalStorageAdapter: () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_0__.memoryLocalStorageAdapter),\n/* harmony export */   parse: () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_0__.parse),\n/* harmony export */   parseCookieHeader: () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_0__.parseCookieHeader),\n/* harmony export */   serialize: () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_0__.serialize),\n/* harmony export */   serializeCookieHeader: () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_0__.serializeCookieHeader),\n/* harmony export */   stringFromBase64URL: () => (/* reexport safe */ _base64url__WEBPACK_IMPORTED_MODULE_3__.stringFromBase64URL),\n/* harmony export */   stringFromUTF8: () => (/* reexport safe */ _base64url__WEBPACK_IMPORTED_MODULE_3__.stringFromUTF8),\n/* harmony export */   stringToBase64URL: () => (/* reexport safe */ _base64url__WEBPACK_IMPORTED_MODULE_3__.stringToBase64URL),\n/* harmony export */   stringToUTF8: () => (/* reexport safe */ _base64url__WEBPACK_IMPORTED_MODULE_3__.stringToUTF8)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/utils/helpers.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/utils/constants.js\");\n/* harmony import */ var _chunker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunker */ \"(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/utils/chunker.js\");\n/* harmony import */ var _base64url__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base64url */ \"(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/utils/base64url.js\");\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtaGVscGVycy1uZXh0anMvZGlzdC9tb2R1bGUvdXRpbHMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBCO0FBQ0U7QUFDRjtBQUNFLENBQzVCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FuY2hvci13b3JrZmxvd3MvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtaGVscGVycy1uZXh0anMvZGlzdC9tb2R1bGUvdXRpbHMvaW5kZXguanM/ZDZjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tIFwiLi9oZWxwZXJzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9jb25zdGFudHNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2NodW5rZXJcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2Jhc2U2NHVybFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/utils/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/version.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@supabase/auth-helpers-nextjs/dist/module/version.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VERSION: () => (/* binding */ VERSION)\n/* harmony export */ });\nconst VERSION = \"0.15.0\"; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtaGVscGVycy1uZXh0anMvZGlzdC9tb2R1bGUvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsVUFBVSxTQUFTLENBQ2hDLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FuY2hvci13b3JrZmxvd3MvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtaGVscGVycy1uZXh0anMvZGlzdC9tb2R1bGUvdmVyc2lvbi5qcz80ZTZhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBWRVJTSU9OID0gJzAuMTUuMCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJWRVJTSU9OIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/module/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-ui-react/dist/index.es.js":
/*!***************************************************************!*\
  !*** ./node_modules/@supabase/auth-ui-react/dist/index.es.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Auth: () => (/* binding */ S),\n/* harmony export */   AuthCard: () => (/* binding */ j1),\n/* harmony export */   ForgottenPassword: () => (/* binding */ Q1),\n/* harmony export */   MagicLink: () => (/* binding */ Y1),\n/* harmony export */   SignIn: () => (/* binding */ K1),\n/* harmony export */   SignUp: () => (/* binding */ q1),\n/* harmony export */   SocialAuth: () => (/* binding */ J1),\n/* harmony export */   UpdatePassword: () => (/* binding */ X1),\n/* harmony export */   VerifyOtp: () => (/* binding */ e0)\n/* harmony export */ });\n/* harmony import */ var _stitches_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @stitches/core */ \"(ssr)/./node_modules/@stitches/core/dist/index.mjs\");\n/* harmony import */ var _supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/auth-ui-shared */ \"(ssr)/./node_modules/@supabase/auth-ui-shared/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\nconst g1 = (0,_stitches_core__WEBPACK_IMPORTED_MODULE_2__.css)({\n    fontFamily: \"$bodyFontFamily\",\n    fontSize: \"$baseBodySize\",\n    marginBottom: \"$anchorBottomMargin\",\n    color: \"$anchorTextColor\",\n    display: \"block\",\n    textAlign: \"center\",\n    textDecoration: \"underline\",\n    \"&:hover\": {\n        color: \"$anchorTextHoverColor\"\n    }\n}), V = ({ children: t, appearance: l, ...n })=>{\n    var o;\n    const r = (0,_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.generateClassNames)(\"anchor\", g1(), l);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"a\", {\n        ...n,\n        style: (o = l == null ? void 0 : l.style) == null ? void 0 : o.anchor,\n        className: r.join(\" \")\n    }, t);\n}, h1 = (0,_stitches_core__WEBPACK_IMPORTED_MODULE_2__.css)({\n    fontFamily: \"$buttonFontFamily\",\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    gap: \"8px\",\n    borderRadius: \"$borderRadiusButton\",\n    fontSize: \"$baseButtonSize\",\n    padding: \"$buttonPadding\",\n    cursor: \"pointer\",\n    borderWidth: \"$buttonBorderWidth\",\n    borderStyle: \"solid\",\n    width: \"100%\",\n    transitionProperty: \"background-color\",\n    transitionTimingFunction: \"cubic-bezier(0.4, 0, 0.2, 1)\",\n    transitionDuration: \"100ms\",\n    \"&:disabled\": {\n        opacity: 0.7,\n        cursor: \"unset\"\n    },\n    variants: {\n        color: {\n            default: {\n                backgroundColor: \"$defaultButtonBackground\",\n                color: \"$defaultButtonText\",\n                borderColor: \"$defaultButtonBorder\",\n                \"&:hover:not(:disabled)\": {\n                    backgroundColor: \"$defaultButtonBackgroundHover\"\n                }\n            },\n            primary: {\n                backgroundColor: \"$brand\",\n                color: \"$brandButtonText\",\n                borderColor: \"$brandAccent\",\n                \"&:hover:not(:disabled)\": {\n                    backgroundColor: \"$brandAccent\"\n                }\n            }\n        }\n    }\n}), U = ({ children: t, color: l = \"default\", appearance: n, icon: r, loading: o = !1, ...v })=>{\n    var C;\n    const E = (0,_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.generateClassNames)(\"button\", h1({\n        color: l\n    }), n);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"button\", {\n        ...v,\n        style: (C = n == null ? void 0 : n.style) == null ? void 0 : C.button,\n        className: E.join(\" \"),\n        disabled: o\n    }, r, t);\n}, f1 = (0,_stitches_core__WEBPACK_IMPORTED_MODULE_2__.css)({\n    display: \"flex\",\n    gap: \"4px\",\n    variants: {\n        direction: {\n            horizontal: {\n                display: \"grid\",\n                gridTemplateColumns: \"repeat(auto-fit, minmax(48px, 1fr))\"\n            },\n            vertical: {\n                flexDirection: \"column\",\n                margin: \"8px 0\"\n            }\n        },\n        gap: {\n            small: {\n                gap: \"4px\"\n            },\n            medium: {\n                gap: \"8px\"\n            },\n            large: {\n                gap: \"16px\"\n            }\n        }\n    }\n}), N = ({ children: t, appearance: l, ...n })=>{\n    var o;\n    const r = (0,_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.generateClassNames)(\"container\", f1({\n        direction: n.direction,\n        gap: n.gap\n    }), l);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", {\n        ...n,\n        style: (o = l == null ? void 0 : l.style) == null ? void 0 : o.container,\n        className: r.join(\" \")\n    }, t);\n}, E1 = (0,_stitches_core__WEBPACK_IMPORTED_MODULE_2__.css)({\n    background: \"$dividerBackground\",\n    display: \"block\",\n    margin: \"16px 0\",\n    height: \"1px\",\n    width: \"100%\"\n}), C1 = ({ children: t, appearance: l, ...n })=>{\n    var o;\n    const r = (0,_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.generateClassNames)(\"divider\", E1(), l);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", {\n        ...n,\n        style: (o = l == null ? void 0 : l.style) == null ? void 0 : o.divider,\n        className: r.join(\" \")\n    });\n}, w1 = (0,_stitches_core__WEBPACK_IMPORTED_MODULE_2__.css)({\n    fontFamily: \"$inputFontFamily\",\n    background: \"$inputBackground\",\n    borderRadius: \"$inputBorderRadius\",\n    padding: \"$inputPadding\",\n    cursor: \"text\",\n    borderWidth: \"$inputBorderWidth\",\n    borderColor: \"$inputBorder\",\n    borderStyle: \"solid\",\n    fontSize: \"$baseInputSize\",\n    width: \"100%\",\n    color: \"$inputText\",\n    boxSizing: \"border-box\",\n    \"&:hover\": {\n        borderColor: \"$inputBorderHover\",\n        outline: \"none\"\n    },\n    \"&:focus\": {\n        borderColor: \"$inputBorderFocus\",\n        outline: \"none\"\n    },\n    \"&::placeholder\": {\n        color: \"$inputPlaceholder\",\n        letterSpacing: \"initial\"\n    },\n    transitionProperty: \"background-color, border\",\n    transitionTimingFunction: \"cubic-bezier(0.4, 0, 0.2, 1)\",\n    transitionDuration: \"100ms\",\n    variants: {\n        type: {\n            default: {\n                letterSpacing: \"0px\"\n            },\n            password: {\n                letterSpacing: \"0px\"\n            }\n        }\n    }\n}), D = ({ children: t, appearance: l, ...n })=>{\n    var o;\n    const r = (0,_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.generateClassNames)(\"input\", w1({\n        type: n.type === \"password\" ? \"password\" : \"default\"\n    }), l);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"input\", {\n        ...n,\n        style: (o = l == null ? void 0 : l.style) == null ? void 0 : o.input,\n        className: r.join(\" \")\n    }, t);\n}, v1 = (0,_stitches_core__WEBPACK_IMPORTED_MODULE_2__.css)({\n    fontFamily: \"$labelFontFamily\",\n    fontSize: \"$baseLabelSize\",\n    marginBottom: \"$labelBottomMargin\",\n    color: \"$inputLabelText\",\n    display: \"block\"\n}), H = ({ children: t, appearance: l, ...n })=>{\n    var o;\n    const r = (0,_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.generateClassNames)(\"label\", v1(), l);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"label\", {\n        ...n,\n        style: (o = l == null ? void 0 : l.style) == null ? void 0 : o.label,\n        className: r.join(\" \")\n    }, t);\n}, x1 = (0,_stitches_core__WEBPACK_IMPORTED_MODULE_2__.css)({\n    fontFamily: \"$bodyFontFamily\",\n    fontSize: \"$baseInputSize\",\n    marginBottom: \"$labelBottomMargin\",\n    display: \"block\",\n    textAlign: \"center\",\n    borderRadius: \"0.375rem\",\n    padding: \"1.5rem 1rem\",\n    lineHeight: \"1rem\",\n    color: \"$messageText\",\n    backgroundColor: \"$messageBackground\",\n    border: \"1px solid $messageBorder\",\n    variants: {\n        color: {\n            danger: {\n                color: \"$messageTextDanger\",\n                backgroundColor: \"$messageBackgroundDanger\",\n                border: \"1px solid $messageBorderDanger\"\n            }\n        }\n    }\n}), F = ({ children: t, appearance: l, ...n })=>{\n    var o;\n    const r = (0,_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.generateClassNames)(\"message\", x1({\n        color: n.color\n    }), l);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"span\", {\n        ...n,\n        style: (o = l == null ? void 0 : l.style) == null ? void 0 : o.message,\n        className: r.join(\" \")\n    }, t);\n};\nfunction X({ setAuthView: t = ()=>{}, supabaseClient: l, redirectTo: n, i18n: r, appearance: o, showLinks: v = !1 }) {\n    var _;\n    const [E, C] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [w, d] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [i, m] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [c, y] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), x = async (h)=>{\n        var s, M;\n        if (h.preventDefault(), d(\"\"), m(\"\"), y(!0), E.length === 0) {\n            d((s = r == null ? void 0 : r.magic_link) == null ? void 0 : s.empty_email_address), y(!1);\n            return;\n        }\n        const { error: g } = await l.auth.signInWithOtp({\n            email: E,\n            options: {\n                emailRedirectTo: n\n            }\n        });\n        g ? d(g.message) : m((M = r == null ? void 0 : r.magic_link) == null ? void 0 : M.confirmation_text), y(!1);\n    }, a = r == null ? void 0 : r.magic_link;\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"form\", {\n        id: \"auth-magic-link\",\n        onSubmit: x\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(N, {\n        gap: \"large\",\n        direction: \"vertical\",\n        appearance: o\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(H, {\n        htmlFor: \"email\",\n        appearance: o\n    }, a == null ? void 0 : a.email_input_label), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(D, {\n        id: \"email\",\n        name: \"email\",\n        type: \"email\",\n        autoFocus: !0,\n        placeholder: a == null ? void 0 : a.email_input_placeholder,\n        onChange: (h)=>{\n            d && d(\"\"), C(h.target.value);\n        },\n        appearance: o\n    })), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(U, {\n        color: \"primary\",\n        type: \"submit\",\n        loading: c,\n        appearance: o\n    }, c ? a == null ? void 0 : a.loading_button_label : a == null ? void 0 : a.button_label), v && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(V, {\n        href: \"#auth-sign-in\",\n        onClick: (h)=>{\n            h.preventDefault(), t(_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.SIGN_IN);\n        },\n        appearance: o\n    }, (_ = r == null ? void 0 : r.sign_in) == null ? void 0 : _.link_text), i && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(F, {\n        appearance: o\n    }, i), w && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(F, {\n        color: \"danger\",\n        appearance: o\n    }, w)));\n}\nconst L = (0,_stitches_core__WEBPACK_IMPORTED_MODULE_2__.css)({\n    width: \"21px\",\n    height: \"21px\"\n}), _1 = ({ provider: t })=>t == \"google\" ? y1() : t == \"facebook\" ? L1() : t == \"twitter\" ? b1() : t == \"apple\" ? p1() : t == \"github\" ? k1() : t == \"gitlab\" ? M1() : t == \"bitbucket\" ? S1() : t == \"discord\" ? N1() : t == \"azure\" ? F1() : t == \"keycloak\" ? z1() : t == \"linkedin\" ? $1() : t == \"notion\" ? B1() : t == \"slack\" ? D1() : t == \"spotify\" ? H1() : t == \"twitch\" ? P1() : t == \"workos\" ? V1() : t == \"kakao\" ? I1() : null, y1 = ()=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"svg\", {\n        className: L(),\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 48 48\",\n        width: \"21px\",\n        height: \"21px\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#FFC107\",\n        d: \"M43.611,20.083H42V20H24v8h11.303c-1.649,4.657-6.08,8-11.303,8c-6.627,0-12-5.373-12-12c0-6.627,5.373-12,12-12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C12.955,4,4,12.955,4,24c0,11.045,8.955,20,20,20c11.045,0,20-8.955,20-20C44,22.659,43.862,21.35,43.611,20.083z\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#FF3D00\",\n        d: \"M6.306,14.691l6.571,4.819C14.655,15.108,18.961,12,24,12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C16.318,4,9.656,8.337,6.306,14.691z\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#4CAF50\",\n        d: \"M24,44c5.166,0,9.86-1.977,13.409-5.192l-6.19-5.238C29.211,35.091,26.715,36,24,36c-5.202,0-9.619-3.317-11.283-7.946l-6.522,5.025C9.505,39.556,16.227,44,24,44z\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#1976D2\",\n        d: \"M43.611,20.083H42V20H24v8h11.303c-0.792,2.237-2.231,4.166-4.087,5.571c0.001-0.001,0.002-0.001,0.003-0.002l6.19,5.238C36.971,39.205,44,34,44,24C44,22.659,43.862,21.35,43.611,20.083z\"\n    })), L1 = ()=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"svg\", {\n        className: L(),\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 48 48\",\n        width: \"21px\",\n        height: \"21px\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#039be5\",\n        d: \"M24 5A19 19 0 1 0 24 43A19 19 0 1 0 24 5Z\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#fff\",\n        d: \"M26.572,29.036h4.917l0.772-4.995h-5.69v-2.73c0-2.075,0.678-3.915,2.619-3.915h3.119v-4.359c-0.548-0.074-1.707-0.236-3.897-0.236c-4.573,0-7.254,2.415-7.254,7.917v3.323h-4.701v4.995h4.701v13.729C22.089,42.905,23.032,43,24,43c0.875,0,1.729-0.08,2.572-0.194V29.036z\"\n    })), b1 = ()=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"svg\", {\n        className: L(),\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 48 48\",\n        width: \"21px\",\n        height: \"21px\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#03A9F4\",\n        d: \"M42,12.429c-1.323,0.586-2.746,0.977-4.247,1.162c1.526-0.906,2.7-2.351,3.251-4.058c-1.428,0.837-3.01,1.452-4.693,1.776C34.967,9.884,33.05,9,30.926,9c-4.08,0-7.387,3.278-7.387,7.32c0,0.572,0.067,1.129,0.193,1.67c-6.138-0.308-11.582-3.226-15.224-7.654c-0.64,1.082-1,2.349-1,3.686c0,2.541,1.301,4.778,3.285,6.096c-1.211-0.037-2.351-0.374-3.349-0.914c0,0.022,0,0.055,0,0.086c0,3.551,2.547,6.508,5.923,7.181c-0.617,0.169-1.269,0.263-1.941,0.263c-0.477,0-0.942-0.054-1.392-0.135c0.94,2.902,3.667,5.023,6.898,5.086c-2.528,1.96-5.712,3.134-9.174,3.134c-0.598,0-1.183-0.034-1.761-0.104C9.268,36.786,13.152,38,17.321,38c13.585,0,21.017-11.156,21.017-20.834c0-0.317-0.01-0.633-0.025-0.945C39.763,15.197,41.013,13.905,42,12.429\"\n    })), p1 = ()=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"svg\", {\n        className: L(),\n        fill: \"gray\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 24 24\",\n        width: \"21px\",\n        height: \"21px\"\n    }, \" \", /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        d: \"M 15.904297 1.078125 C 15.843359 1.06875 15.774219 1.0746094 15.699219 1.0996094 C 14.699219 1.2996094 13.600391 1.8996094 12.900391 2.5996094 C 12.300391 3.1996094 11.800781 4.1996094 11.800781 5.0996094 C 11.800781 5.2996094 11.999219 5.5 12.199219 5.5 C 13.299219 5.4 14.399609 4.7996094 15.099609 4.0996094 C 15.699609 3.2996094 16.199219 2.4 16.199219 1.5 C 16.199219 1.275 16.087109 1.10625 15.904297 1.078125 z M 16.199219 5.4003906 C 14.399219 5.4003906 13.600391 6.5 12.400391 6.5 C 11.100391 6.5 9.9003906 5.5 8.4003906 5.5 C 6.3003906 5.5 3.0996094 7.4996094 3.0996094 12.099609 C 2.9996094 16.299609 6.8 21 9 21 C 10.3 21 10.600391 20.199219 12.400391 20.199219 C 14.200391 20.199219 14.600391 21 15.900391 21 C 17.400391 21 18.500391 19.399609 19.400391 18.099609 C 19.800391 17.399609 20.100391 17.000391 20.400391 16.400391 C 20.600391 16.000391 20.4 15.600391 20 15.400391 C 17.4 14.100391 16.900781 9.9003906 19.800781 8.4003906 C 20.300781 8.1003906 20.4 7.4992188 20 7.1992188 C 18.9 6.1992187 17.299219 5.4003906 16.199219 5.4003906 z\"\n    })), k1 = ()=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"svg\", {\n        className: L(),\n        fill: \"gray\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 30 30\",\n        width: \"21px\",\n        height: \"21px\"\n    }, \" \", /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        d: \"M15,3C8.373,3,3,8.373,3,15c0,5.623,3.872,10.328,9.092,11.63C12.036,26.468,12,26.28,12,26.047v-2.051 c-0.487,0-1.303,0-1.508,0c-0.821,0-1.551-0.353-1.905-1.009c-0.393-0.729-0.461-1.844-1.435-2.526 c-0.289-0.227-0.069-0.486,0.264-0.451c0.615,0.174,1.125,0.596,1.605,1.222c0.478,0.627,0.703,0.769,1.596,0.769 c0.433,0,1.081-0.025,1.691-0.121c0.328-0.833,0.895-1.6,1.588-1.962c-3.996-0.411-5.903-2.399-5.903-5.098 c0-1.162,0.495-2.286,1.336-3.233C9.053,10.647,8.706,8.73,9.435,8c1.798,0,2.885,1.166,3.146,1.481C13.477,9.174,14.461,9,15.495,9 c1.036,0,2.024,0.174,2.922,0.483C18.675,9.17,19.763,8,21.565,8c0.732,0.731,0.381,2.656,0.102,3.594 c0.836,0.945,1.328,2.066,1.328,3.226c0,2.697-1.904,4.684-5.894,5.097C18.199,20.49,19,22.1,19,23.313v2.734 c0,0.104-0.023,0.179-0.035,0.268C23.641,24.676,27,20.236,27,15C27,8.373,21.627,3,15,3z\"\n    })), M1 = ()=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"svg\", {\n        className: L(),\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 48 48\",\n        width: \"21px\",\n        height: \"21px\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#e53935\",\n        d: \"M24 43L16 20 32 20z\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#ff7043\",\n        d: \"M24 43L42 20 32 20z\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#e53935\",\n        d: \"M37 5L42 20 32 20z\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#ffa726\",\n        d: \"M24 43L42 20 45 28z\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#ff7043\",\n        d: \"M24 43L6 20 16 20z\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#e53935\",\n        d: \"M11 5L6 20 16 20z\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#ffa726\",\n        d: \"M24 43L6 20 3 28z\"\n    })), S1 = ()=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"svg\", {\n        className: L(),\n        xmlns: \"http://www.w3.org/2000/svg\",\n        width: \"512\",\n        height: \"512\",\n        viewBox: \"0 0 62.42 62.42\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"defs\", null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"linearGradient\", {\n        id: \"New_Gradient_Swatch_1\",\n        x1: \"64.01\",\n        y1: \"30.27\",\n        x2: \"32.99\",\n        y2: \"54.48\",\n        gradientUnits: \"userSpaceOnUse\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"stop\", {\n        offset: \"0.18\",\n        stopColor: \"#0052cc\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"stop\", {\n        offset: \"1\",\n        stopColor: \"#2684ff\"\n    }))), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"title\", null, \"Bitbucket-blue\"), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"g\", {\n        id: \"Layer_2\",\n        \"data-name\": \"Layer 2\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"g\", {\n        id: \"Blue\",\n        transform: \"translate(0 -3.13)\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        d: \"M2,6.26A2,2,0,0,0,0,8.58L8.49,60.12a2.72,2.72,0,0,0,2.66,2.27H51.88a2,2,0,0,0,2-1.68L62.37,8.59a2,2,0,0,0-2-2.32ZM37.75,43.51h-13L21.23,25.12H40.9Z\",\n        fill: \"#2684ff\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        d: \"M59.67,25.12H40.9L37.75,43.51h-13L9.4,61.73a2.71,2.71,0,0,0,1.75.66H51.89a2,2,0,0,0,2-1.68Z\",\n        fill: \"url(#New_Gradient_Swatch_1)\"\n    })))), N1 = ()=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"svg\", {\n        className: L(),\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 48 48\",\n        width: \"21px\",\n        height: \"21px\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#536dfe\",\n        d: \"M39.248,10.177c-2.804-1.287-5.812-2.235-8.956-2.778c-0.057-0.01-0.114,0.016-0.144,0.068\tc-0.387,0.688-0.815,1.585-1.115,2.291c-3.382-0.506-6.747-0.506-10.059,0c-0.3-0.721-0.744-1.603-1.133-2.291\tc-0.03-0.051-0.087-0.077-0.144-0.068c-3.143,0.541-6.15,1.489-8.956,2.778c-0.024,0.01-0.045,0.028-0.059,0.051\tc-5.704,8.522-7.267,16.835-6.5,25.044c0.003,0.04,0.026,0.079,0.057,0.103c3.763,2.764,7.409,4.442,10.987,5.554\tc0.057,0.017,0.118-0.003,0.154-0.051c0.846-1.156,1.601-2.374,2.248-3.656c0.038-0.075,0.002-0.164-0.076-0.194\tc-1.197-0.454-2.336-1.007-3.432-1.636c-0.087-0.051-0.094-0.175-0.014-0.234c0.231-0.173,0.461-0.353,0.682-0.534\tc0.04-0.033,0.095-0.04,0.142-0.019c7.201,3.288,14.997,3.288,22.113,0c0.047-0.023,0.102-0.016,0.144,0.017\tc0.22,0.182,0.451,0.363,0.683,0.536c0.08,0.059,0.075,0.183-0.012,0.234c-1.096,0.641-2.236,1.182-3.434,1.634\tc-0.078,0.03-0.113,0.12-0.075,0.196c0.661,1.28,1.415,2.498,2.246,3.654c0.035,0.049,0.097,0.07,0.154,0.052\tc3.595-1.112,7.241-2.79,11.004-5.554c0.033-0.024,0.054-0.061,0.057-0.101c0.917-9.491-1.537-17.735-6.505-25.044\tC39.293,10.205,39.272,10.187,39.248,10.177z M16.703,30.273c-2.168,0-3.954-1.99-3.954-4.435s1.752-4.435,3.954-4.435\tc2.22,0,3.989,2.008,3.954,4.435C20.658,28.282,18.906,30.273,16.703,30.273z M31.324,30.273c-2.168,0-3.954-1.99-3.954-4.435\ts1.752-4.435,3.954-4.435c2.22,0,3.989,2.008,3.954,4.435C35.278,28.282,33.544,30.273,31.324,30.273z\"\n    })), F1 = ()=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"svg\", {\n        className: L(),\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 48 48\",\n        width: \"21px\",\n        height: \"21px\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"linearGradient\", {\n        id: \"k8yl7~hDat~FaoWq8WjN6a\",\n        x1: \"-1254.397\",\n        x2: \"-1261.911\",\n        y1: \"877.268\",\n        y2: \"899.466\",\n        gradientTransform: \"translate(1981.75 -1362.063) scale(1.5625)\",\n        gradientUnits: \"userSpaceOnUse\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"stop\", {\n        offset: \"0\",\n        stopColor: \"#114a8b\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"stop\", {\n        offset: \"1\",\n        stopColor: \"#0669bc\"\n    })), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"url(#k8yl7~hDat~FaoWq8WjN6a)\",\n        d: \"M17.634,6h11.305L17.203,40.773c-0.247,0.733-0.934,1.226-1.708,1.226H6.697 c-0.994,0-1.8-0.806-1.8-1.8c0-0.196,0.032-0.39,0.094-0.576L15.926,7.227C16.173,6.494,16.86,6,17.634,6L17.634,6z\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#0078d4\",\n        d: \"M34.062,29.324H16.135c-0.458-0.001-0.83,0.371-0.831,0.829c0,0.231,0.095,0.451,0.264,0.608 l11.52,10.752C27.423,41.826,27.865,42,28.324,42h10.151L34.062,29.324z\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"linearGradient\", {\n        id: \"k8yl7~hDat~FaoWq8WjN6b\",\n        x1: \"-1252.05\",\n        x2: \"-1253.788\",\n        y1: \"887.612\",\n        y2: \"888.2\",\n        gradientTransform: \"translate(1981.75 -1362.063) scale(1.5625)\",\n        gradientUnits: \"userSpaceOnUse\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"stop\", {\n        offset: \"0\",\n        stopOpacity: \".3\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"stop\", {\n        offset: \".071\",\n        stopOpacity: \".2\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"stop\", {\n        offset: \".321\",\n        stopOpacity: \".1\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"stop\", {\n        offset: \".623\",\n        stopOpacity: \".05\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"stop\", {\n        offset: \"1\",\n        stopOpacity: \"0\"\n    })), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"url(#k8yl7~hDat~FaoWq8WjN6b)\",\n        d: \"M17.634,6c-0.783-0.003-1.476,0.504-1.712,1.25L5.005,39.595 c-0.335,0.934,0.151,1.964,1.085,2.299C6.286,41.964,6.493,42,6.702,42h9.026c0.684-0.122,1.25-0.603,1.481-1.259l2.177-6.416 l7.776,7.253c0.326,0.27,0.735,0.419,1.158,0.422h10.114l-4.436-12.676l-12.931,0.003L28.98,6H17.634z\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"linearGradient\", {\n        id: \"k8yl7~hDat~FaoWq8WjN6c\",\n        x1: \"-1252.952\",\n        x2: \"-1244.704\",\n        y1: \"876.6\",\n        y2: \"898.575\",\n        gradientTransform: \"translate(1981.75 -1362.063) scale(1.5625)\",\n        gradientUnits: \"userSpaceOnUse\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"stop\", {\n        offset: \"0\",\n        stopColor: \"#3ccbf4\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"stop\", {\n        offset: \"1\",\n        stopColor: \"#2892df\"\n    })), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"url(#k8yl7~hDat~FaoWq8WjN6c)\",\n        d: \"M32.074,7.225C31.827,6.493,31.141,6,30.368,6h-12.6c0.772,0,1.459,0.493,1.705,1.224 l10.935,32.399c0.318,0.942-0.188,1.963-1.13,2.281C29.093,41.968,28.899,42,28.703,42h12.6c0.994,0,1.8-0.806,1.8-1.801 c0-0.196-0.032-0.39-0.095-0.575L32.074,7.225z\"\n    })), z1 = ()=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"svg\", {\n        className: L(),\n        width: \"512\",\n        height: \"512\",\n        viewBox: \"0 0 512 512\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        d: \"M472.136 163.959H408.584C407.401 163.959 406.218 163.327 405.666 162.3L354.651 73.6591C354.02 72.632 352.916 72 351.654 72H143.492C142.309 72 141.126 72.632 140.574 73.6591L87.5084 165.618L36.414 254.259C35.862 255.286 35.862 256.55 36.414 257.656L87.5084 346.297L140.495 438.335C141.047 439.362 142.23 440.073 143.413 439.994H351.654C352.837 439.994 354.02 439.362 354.651 438.335L405.745 349.694C406.297 348.667 407.48 347.956 408.663 348.035H472.215C474.344 348.035 476 346.297 476 344.243V167.83C475.921 165.697 474.186 163.959 472.136 163.959ZM228.728 349.694L212.721 377.345C212.485 377.74 212.091 378.135 211.696 378.372C211.223 378.609 210.75 378.767 210.198 378.767H178.422C177.318 378.767 176.293 378.214 175.82 377.187L128.431 294.787L123.779 286.65L106.748 257.498C106.511 257.103 106.353 256.629 106.432 256.076C106.432 255.602 106.59 255.049 106.827 254.654L123.937 224.949L175.899 134.886C176.451 133.938 177.476 133.306 178.501 133.306H210.198C210.75 133.306 211.302 133.464 211.854 133.701C212.248 133.938 212.643 134.254 212.879 134.728L228.886 162.537C229.359 163.485 229.28 164.67 228.728 165.539L177.397 254.654C177.16 255.049 177.081 255.523 177.081 255.918C177.081 256.392 177.239 256.787 177.397 257.182L228.728 346.218C229.438 347.403 229.359 348.667 228.728 349.694V349.694ZM388.083 257.498L371.051 286.65L366.399 294.787L319.011 377.187C318.459 378.135 317.512 378.767 316.409 378.767H284.632C284.08 378.767 283.607 378.609 283.134 378.372C282.74 378.135 282.346 377.819 282.109 377.345L266.103 349.694C265.393 348.667 265.393 347.403 266.024 346.376L317.355 257.34C317.591 256.945 317.67 256.471 317.67 256.076C317.67 255.602 317.513 255.207 317.355 254.812L266.024 165.697C265.472 164.749 265.393 163.643 265.866 162.695L281.873 134.886C282.109 134.491 282.503 134.096 282.898 133.859C283.371 133.543 283.923 133.464 284.553 133.464H316.409C317.512 133.464 318.538 134.017 319.011 135.044L370.972 225.107L388.083 254.812C388.319 255.286 388.477 255.76 388.477 256.234C388.477 256.55 388.319 257.024 388.083 257.498V257.498Z\",\n        fill: \"#008AAA\"\n    })), $1 = ()=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"svg\", {\n        className: L(),\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 48 48\",\n        width: \"21px\",\n        height: \"21px\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#0288D1\",\n        d: \"M42,37c0,2.762-2.238,5-5,5H11c-2.761,0-5-2.238-5-5V11c0-2.762,2.239-5,5-5h26c2.762,0,5,2.238,5,5V37z\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#FFF\",\n        d: \"M12 19H17V36H12zM14.485 17h-.028C12.965 17 12 15.888 12 14.499 12 13.08 12.995 12 14.514 12c1.521 0 2.458 1.08 2.486 2.499C17 15.887 16.035 17 14.485 17zM36 36h-5v-9.099c0-2.198-1.225-3.698-3.192-3.698-1.501 0-2.313 1.012-2.707 1.99C24.957 25.543 25 26.511 25 27v9h-5V19h5v2.616C25.721 20.5 26.85 19 29.738 19c3.578 0 6.261 2.25 6.261 7.274L36 36 36 36z\"\n    })), B1 = ()=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"svg\", {\n        className: L(),\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 48 48\",\n        width: \"21px\",\n        height: \"21px\",\n        fillRule: \"evenodd\",\n        clipRule: \"evenodd\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#fff\",\n        fillRule: \"evenodd\",\n        d: \"M11.553,11.099c1.232,1.001,1.694,0.925,4.008,0.77 l21.812-1.31c0.463,0,0.078-0.461-0.076-0.538l-3.622-2.619c-0.694-0.539-1.619-1.156-3.391-1.002l-21.12,1.54 c-0.77,0.076-0.924,0.461-0.617,0.77L11.553,11.099z\",\n        clipRule: \"evenodd\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#fff\",\n        fillRule: \"evenodd\",\n        d: \"M12.862,16.182v22.95c0,1.233,0.616,1.695,2.004,1.619 l23.971-1.387c1.388-0.076,1.543-0.925,1.543-1.927V14.641c0-1-0.385-1.54-1.234-1.463l-25.05,1.463 C13.171,14.718,12.862,15.181,12.862,16.182L12.862,16.182z\",\n        clipRule: \"evenodd\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#424242\",\n        fillRule: \"evenodd\",\n        d: \"M11.553,11.099c1.232,1.001,1.694,0.925,4.008,0.77 l21.812-1.31c0.463,0,0.078-0.461-0.076-0.538l-3.622-2.619c-0.694-0.539-1.619-1.156-3.391-1.002l-21.12,1.54 c-0.77,0.076-0.924,0.461-0.617,0.77L11.553,11.099z M12.862,16.182v22.95c0,1.233,0.616,1.695,2.004,1.619l23.971-1.387 c1.388-0.076,1.543-0.925,1.543-1.927V14.641c0-1-0.385-1.54-1.234-1.463l-25.05,1.463C13.171,14.718,12.862,15.181,12.862,16.182 L12.862,16.182z M36.526,17.413c0.154,0.694,0,1.387-0.695,1.465l-1.155,0.23v16.943c-1.003,0.539-1.928,0.847-2.698,0.847 c-1.234,0-1.543-0.385-2.467-1.54l-7.555-11.86v11.475l2.391,0.539c0,0,0,1.386-1.929,1.386l-5.317,0.308 c-0.154-0.308,0-1.078,0.539-1.232l1.388-0.385V20.418l-1.927-0.154c-0.155-0.694,0.23-1.694,1.31-1.772l5.704-0.385l7.862,12.015 V19.493l-2.005-0.23c-0.154-0.848,0.462-1.464,1.233-1.54L36.526,17.413z M7.389,5.862l21.968-1.618 c2.698-0.231,3.392-0.076,5.087,1.155l7.013,4.929C42.614,11.176,43,11.407,43,12.33v27.032c0,1.694-0.617,2.696-2.775,2.849 l-25.512,1.541c-1.62,0.077-2.391-0.154-3.239-1.232l-5.164-6.7C5.385,34.587,5,33.664,5,32.585V8.556 C5,7.171,5.617,6.015,7.389,5.862z\",\n        clipRule: \"evenodd\"\n    })), D1 = ()=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"svg\", {\n        className: L(),\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 48 48\",\n        width: \"21px\",\n        height: \"21px\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#33d375\",\n        d: \"M33,8c0-2.209-1.791-4-4-4s-4,1.791-4,4c0,1.254,0,9.741,0,11c0,2.209,1.791,4,4,4s4-1.791,4-4\tC33,17.741,33,9.254,33,8z\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#33d375\",\n        d: \"M43,19c0,2.209-1.791,4-4,4c-1.195,0-4,0-4,0s0-2.986,0-4c0-2.209,1.791-4,4-4S43,16.791,43,19z\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#40c4ff\",\n        d: \"M8,14c-2.209,0-4,1.791-4,4s1.791,4,4,4c1.254,0,9.741,0,11,0c2.209,0,4-1.791,4-4s-1.791-4-4-4\tC17.741,14,9.254,14,8,14z\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#40c4ff\",\n        d: \"M19,4c2.209,0,4,1.791,4,4c0,1.195,0,4,0,4s-2.986,0-4,0c-2.209,0-4-1.791-4-4S16.791,4,19,4z\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#e91e63\",\n        d: \"M14,39.006C14,41.212,15.791,43,18,43s4-1.788,4-3.994c0-1.252,0-9.727,0-10.984\tc0-2.206-1.791-3.994-4-3.994s-4,1.788-4,3.994C14,29.279,14,37.754,14,39.006z\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#e91e63\",\n        d: \"M4,28.022c0-2.206,1.791-3.994,4-3.994c1.195,0,4,0,4,0s0,2.981,0,3.994c0,2.206-1.791,3.994-4,3.994\tS4,30.228,4,28.022z\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#ffc107\",\n        d: \"M39,33c2.209,0,4-1.791,4-4s-1.791-4-4-4c-1.254,0-9.741,0-11,0c-2.209,0-4,1.791-4,4s1.791,4,4,4\tC29.258,33,37.746,33,39,33z\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#ffc107\",\n        d: \"M28,43c-2.209,0-4-1.791-4-4c0-1.195,0-4,0-4s2.986,0,4,0c2.209,0,4,1.791,4,4S30.209,43,28,43z\"\n    })), H1 = ()=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"svg\", {\n        className: L(),\n        width: \"512\",\n        height: \"512\",\n        viewBox: \"0 0 512 512\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        d: \"M255.498 31.0034C131.513 31.0034 31 131.515 31 255.502C31 379.492 131.513 480 255.498 480C379.497 480 480 379.495 480 255.502C480 131.522 379.497 31.0135 255.495 31.0135L255.498 31V31.0034ZM358.453 354.798C354.432 361.391 345.801 363.486 339.204 359.435C286.496 327.237 220.139 319.947 141.993 337.801C134.463 339.516 126.957 334.798 125.24 327.264C123.516 319.731 128.217 312.225 135.767 310.511C221.284 290.972 294.639 299.384 353.816 335.549C360.413 339.596 362.504 348.2 358.453 354.798ZM385.932 293.67C380.864 301.903 370.088 304.503 361.858 299.438C301.512 262.345 209.528 251.602 138.151 273.272C128.893 276.067 119.118 270.851 116.309 261.61C113.521 252.353 118.74 242.597 127.981 239.782C209.512 215.044 310.87 227.026 380.17 269.612C388.4 274.68 391 285.456 385.935 293.676V293.673L385.932 293.67ZM388.293 230.016C315.935 187.039 196.56 183.089 127.479 204.055C116.387 207.42 104.654 201.159 101.293 190.063C97.9326 178.964 104.189 167.241 115.289 163.87C194.59 139.796 326.418 144.446 409.723 193.902C419.722 199.826 422.995 212.71 417.068 222.675C411.168 232.653 398.247 235.943 388.303 230.016H388.293V230.016Z\",\n        fill: \"#1ED760\"\n    })), P1 = ()=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"svg\", {\n        className: L(),\n        width: \"512\",\n        height: \"512\",\n        viewBox: \"0 0 512 512\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        d: \"M416 240L352 304H288L232 360V304H160V64H416V240Z\",\n        fill: \"white\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        d: \"M144 32L64 112V400H160V480L240 400H304L448 256V32H144ZM416 240L352 304H288L232 360V304H160V64H416V240Z\",\n        fill: \"#9146FF\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        d: \"M368 120H336V216H368V120Z\",\n        fill: \"#9146FF\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        d: \"M280 120H248V216H280V120Z\",\n        fill: \"#9146FF\"\n    })), V1 = ()=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"svg\", {\n        className: L(),\n        width: \"512\",\n        height: \"512\",\n        viewBox: \"0 0 512 512\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        d: \"M33 256.043C33 264.556 35.3159 273.069 39.4845 280.202L117.993 415.493C126.098 429.298 138.373 440.572 153.657 445.634C183.764 455.528 214.797 442.873 229.618 417.333L248.609 384.661L173.806 256.043L252.777 119.831L271.768 87.1591C277.557 77.2654 284.968 69.4424 294 63H285.894H172.185C150.878 63 131.193 74.2742 120.54 92.6812L39.7161 231.884C35.3159 239.016 33 247.53 33 256.043Z\",\n        fill: \"#6363F1\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        d: \"M480 256.058C480 247.539 477.684 239.021 473.516 231.883L393.849 94.6596C379.028 69.3331 347.995 56.4396 317.888 66.34C302.603 71.4053 290.329 82.6871 282.224 96.5015L264.391 127.354L339.194 256.058L260.223 392.131L241.232 424.825C235.443 434.495 228.032 442.553 219 449H227.106H340.815C362.122 449 381.807 437.718 392.46 419.299L473.284 280.003C477.684 272.866 480 264.577 480 256.058Z\",\n        fill: \"#6363F1\"\n    })), I1 = ()=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"svg\", {\n        className: L(),\n        xmlns: \"http://www.w3.org/2000/svg\",\n        width: \"2500\",\n        height: \"2500\",\n        viewBox: \"0 0 256 256\"\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#FFE812\",\n        d: \"M256 236c0 11.046-8.954 20-20 20H20c-11.046 0-20-8.954-20-20V20C0 8.954 8.954 0 20 0h216c11.046 0 20 8.954 20 20v216z\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        d: \"M128 36C70.562 36 24 72.713 24 118c0 29.279 19.466 54.97 48.748 69.477-1.593 5.494-10.237 35.344-10.581 37.689 0 0-.207 1.762.934 2.434s2.483.15 2.483.15c3.272-.457 37.943-24.811 43.944-29.04 5.995.849 12.168 1.29 18.472 1.29 57.438 0 104-36.712 104-82 0-45.287-46.562-82-104-82z\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", {\n        fill: \"#FFE812\",\n        d: \"M70.5 146.625c-3.309 0-6-2.57-6-5.73V105.25h-9.362c-3.247 0-5.888-2.636-5.888-5.875s2.642-5.875 5.888-5.875h30.724c3.247 0 5.888 2.636 5.888 5.875s-2.642 5.875-5.888 5.875H76.5v35.645c0 3.16-2.691 5.73-6 5.73zM123.112 146.547c-2.502 0-4.416-1.016-4.993-2.65l-2.971-7.778-18.296-.001-2.973 7.783c-.575 1.631-2.488 2.646-4.99 2.646a9.155 9.155 0 0 1-3.814-.828c-1.654-.763-3.244-2.861-1.422-8.52l14.352-37.776c1.011-2.873 4.082-5.833 7.99-5.922 3.919.088 6.99 3.049 8.003 5.928l14.346 37.759c1.826 5.672.236 7.771-1.418 8.532a9.176 9.176 0 0 1-3.814.827c-.001 0 0 0 0 0zm-11.119-21.056L106 108.466l-5.993 17.025h11.986zM138 145.75c-3.171 0-5.75-2.468-5.75-5.5V99.5c0-3.309 2.748-6 6.125-6s6.125 2.691 6.125 6v35.25h12.75c3.171 0 5.75 2.468 5.75 5.5s-2.579 5.5-5.75 5.5H138zM171.334 146.547c-3.309 0-6-2.691-6-6V99.5c0-3.309 2.691-6 6-6s6 2.691 6 6v12.896l16.74-16.74c.861-.861 2.044-1.335 3.328-1.335 1.498 0 3.002.646 4.129 1.772 1.051 1.05 1.678 2.401 1.764 3.804.087 1.415-.384 2.712-1.324 3.653l-13.673 13.671 14.769 19.566a5.951 5.951 0 0 1 1.152 4.445 5.956 5.956 0 0 1-2.328 3.957 5.94 5.94 0 0 1-3.609 1.211 5.953 5.953 0 0 1-4.793-2.385l-14.071-18.644-2.082 2.082v13.091a6.01 6.01 0 0 1-6.002 6.003z\"\n    }));\nfunction A1({ supabaseClient: t, socialLayout: l = \"vertical\", providers: n = [\n    \"github\",\n    \"google\",\n    \"azure\"\n], providerScopes: r, queryParams: o, redirectTo: v, onlyThirdPartyProviders: E = !0, view: C = \"sign_in\", i18n: w, appearance: d }) {\n    const [i, m] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), [c, y] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), x = l === \"vertical\", a = C === \"magic_link\" ? \"sign_in\" : C, _ = async (g)=>{\n        m(!0);\n        const { error: s } = await t.auth.signInWithOAuth({\n            provider: g,\n            options: {\n                redirectTo: v,\n                scopes: r == null ? void 0 : r[g],\n                queryParams: o\n            }\n        });\n        s && y(s.message), m(!1);\n    };\n    function h(g) {\n        const s = g.toLowerCase();\n        return g.charAt(0).toUpperCase() + s.slice(1);\n    }\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, n && n.length > 0 && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(N, {\n        gap: \"large\",\n        direction: \"vertical\",\n        appearance: d\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(N, {\n        direction: x ? \"vertical\" : \"horizontal\",\n        gap: x ? \"small\" : \"medium\",\n        appearance: d\n    }, n.map((g)=>{\n        var s;\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(U, {\n            key: g,\n            color: \"default\",\n            loading: i,\n            onClick: ()=>_(g),\n            appearance: d\n        }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_1, {\n            provider: g\n        }), x && (0,_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.template)((s = w == null ? void 0 : w[a]) == null ? void 0 : s.social_provider_text, {\n            provider: h(g)\n        }));\n    }))), !E && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(C1, {\n        appearance: d\n    })));\n}\nfunction Q({ authView: t = \"sign_in\", defaultEmail: l = \"\", defaultPassword: n = \"\", setAuthView: r = ()=>{}, setDefaultEmail: o = (x)=>{}, setDefaultPassword: v = (x)=>{}, supabaseClient: E, showLinks: C = !1, redirectTo: w, additionalData: d, magicLink: i, i18n: m, appearance: c, children: y }) {\n    var T, G, Z, j;\n    const x = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(!0), [a, _] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(l), [h, g] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(n), [s, M] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [p, B] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), [P, A] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>(x.current = !0, _(l), g(n), ()=>{\n            x.current = !1;\n        }), [\n        t\n    ]);\n    const O = async (k)=>{\n        var q;\n        switch(k.preventDefault(), M(\"\"), B(!0), t){\n            case \"sign_in\":\n                const { error: K } = await E.auth.signInWithPassword({\n                    email: a,\n                    password: h\n                });\n                K && M(K.message);\n                break;\n            case \"sign_up\":\n                let Y = {\n                    emailRedirectTo: w\n                };\n                d && (Y.data = d);\n                const { data: { user: r1, session: o1 }, error: J } = await E.auth.signUp({\n                    email: a,\n                    password: h,\n                    options: Y\n                });\n                J ? M(J.message) : r1 && !o1 && A((q = m == null ? void 0 : m.sign_up) == null ? void 0 : q.confirmation_text);\n                break;\n        }\n        x.current && B(!1);\n    }, z = (k)=>{\n        o(a), v(h), r(k);\n    }, f = m == null ? void 0 : m[t];\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"form\", {\n        id: t === \"sign_in\" ? \"auth-sign-in\" : \"auth-sign-up\",\n        onSubmit: O,\n        autoComplete: \"on\",\n        style: {\n            width: \"100%\"\n        }\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(N, {\n        direction: \"vertical\",\n        gap: \"large\",\n        appearance: c\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(N, {\n        direction: \"vertical\",\n        gap: \"large\",\n        appearance: c\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(H, {\n        htmlFor: \"email\",\n        appearance: c\n    }, f == null ? void 0 : f.email_label), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(D, {\n        id: \"email\",\n        type: \"email\",\n        name: \"email\",\n        placeholder: f == null ? void 0 : f.email_input_placeholder,\n        defaultValue: a,\n        onChange: (k)=>_(k.target.value),\n        autoComplete: \"email\",\n        appearance: c\n    })), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(H, {\n        htmlFor: \"password\",\n        appearance: c\n    }, f == null ? void 0 : f.password_label), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(D, {\n        id: \"password\",\n        type: \"password\",\n        name: \"password\",\n        placeholder: f == null ? void 0 : f.password_input_placeholder,\n        defaultValue: h,\n        onChange: (k)=>g(k.target.value),\n        autoComplete: t === \"sign_in\" ? \"current-password\" : \"new-password\",\n        appearance: c\n    })), y), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(U, {\n        type: \"submit\",\n        color: \"primary\",\n        loading: p,\n        appearance: c\n    }, p ? f == null ? void 0 : f.loading_button_label : f == null ? void 0 : f.button_label), C && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(N, {\n        direction: \"vertical\",\n        gap: \"small\",\n        appearance: c\n    }, t === _supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.SIGN_IN && i && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(V, {\n        href: \"#auth-magic-link\",\n        onClick: (k)=>{\n            k.preventDefault(), r(_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.MAGIC_LINK);\n        },\n        appearance: c\n    }, (T = m == null ? void 0 : m.magic_link) == null ? void 0 : T.link_text), t === _supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.SIGN_IN && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(V, {\n        href: \"#auth-forgot-password\",\n        onClick: (k)=>{\n            k.preventDefault(), r(_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.FORGOTTEN_PASSWORD);\n        },\n        appearance: c\n    }, (G = m == null ? void 0 : m.forgotten_password) == null ? void 0 : G.link_text), t === _supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.SIGN_IN ? /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(V, {\n        href: \"#auth-sign-up\",\n        onClick: (k)=>{\n            k.preventDefault(), z(_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.SIGN_UP);\n        },\n        appearance: c\n    }, (Z = m == null ? void 0 : m.sign_up) == null ? void 0 : Z.link_text) : /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(V, {\n        href: \"#auth-sign-in\",\n        onClick: (k)=>{\n            k.preventDefault(), z(_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.SIGN_IN);\n        },\n        appearance: c\n    }, (j = m == null ? void 0 : m.sign_in) == null ? void 0 : j.link_text))), P && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(F, {\n        appearance: c\n    }, P), s && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(F, {\n        color: \"danger\",\n        appearance: c\n    }, s));\n}\nfunction e1({ setAuthView: t = ()=>{}, supabaseClient: l, redirectTo: n, i18n: r, appearance: o, showLinks: v = !1 }) {\n    var _;\n    const [E, C] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [w, d] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [i, m] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [c, y] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), x = async (h)=>{\n        var s;\n        h.preventDefault(), d(\"\"), m(\"\"), y(!0);\n        const { error: g } = await l.auth.resetPasswordForEmail(E, {\n            redirectTo: n\n        });\n        g ? d(g.message) : m((s = r == null ? void 0 : r.forgotten_password) == null ? void 0 : s.confirmation_text), y(!1);\n    }, a = r == null ? void 0 : r.forgotten_password;\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"form\", {\n        id: \"auth-forgot-password\",\n        onSubmit: x\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(N, {\n        direction: \"vertical\",\n        gap: \"large\",\n        appearance: o\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(N, {\n        gap: \"large\",\n        direction: \"vertical\",\n        appearance: o\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(H, {\n        htmlFor: \"email\",\n        appearance: o\n    }, a == null ? void 0 : a.email_label), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(D, {\n        id: \"email\",\n        name: \"email\",\n        type: \"email\",\n        autoFocus: !0,\n        placeholder: a == null ? void 0 : a.email_input_placeholder,\n        onChange: (h)=>C(h.target.value),\n        appearance: o\n    })), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(U, {\n        type: \"submit\",\n        color: \"primary\",\n        loading: c,\n        appearance: o\n    }, c ? a == null ? void 0 : a.loading_button_label : a == null ? void 0 : a.button_label), v && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(V, {\n        href: \"#auth-sign-in\",\n        onClick: (h)=>{\n            h.preventDefault(), t(_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.SIGN_IN);\n        },\n        appearance: o\n    }, (_ = r == null ? void 0 : r.sign_in) == null ? void 0 : _.link_text), i && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(F, {\n        appearance: o\n    }, i), w && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(F, {\n        color: \"danger\",\n        appearance: o\n    }, w))));\n}\nfunction t1({ supabaseClient: t, i18n: l, appearance: n }) {\n    const [r, o] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [v, E] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [C, w] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [d, i] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), m = async (y)=>{\n        var a;\n        y.preventDefault(), E(\"\"), w(\"\"), i(!0);\n        const { error: x } = await t.auth.updateUser({\n            password: r\n        });\n        x ? E(x.message) : w((a = l == null ? void 0 : l.update_password) == null ? void 0 : a.confirmation_text), i(!1);\n    }, c = l == null ? void 0 : l.update_password;\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"form\", {\n        id: \"auth-update-password\",\n        onSubmit: m\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(N, {\n        gap: \"large\",\n        direction: \"vertical\",\n        appearance: n\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(H, {\n        htmlFor: \"password\",\n        appearance: n\n    }, c == null ? void 0 : c.password_label), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(D, {\n        id: \"password\",\n        name: \"password\",\n        placeholder: c == null ? void 0 : c.password_input_placeholder,\n        type: \"password\",\n        autoFocus: !0,\n        onChange: (y)=>o(y.target.value),\n        appearance: n\n    })), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(U, {\n        type: \"submit\",\n        color: \"primary\",\n        loading: d,\n        appearance: n\n    }, d ? c == null ? void 0 : c.loading_button_label : c == null ? void 0 : c.button_label), C && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(F, {\n        appearance: n\n    }, C), v && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(F, {\n        color: \"danger\",\n        appearance: n\n    }, v)));\n}\nfunction U1({ setAuthView: t = ()=>{}, supabaseClient: l, otpType: n = \"email\", i18n: r, appearance: o, showLinks: v = !1 }) {\n    var M;\n    const [E, C] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [w, d] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [i, m] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [c, y] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [x, a] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [_, h] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), g = async (p)=>{\n        p.preventDefault(), y(\"\"), a(\"\"), h(!0);\n        let B = {\n            email: E,\n            token: i,\n            type: n\n        };\n        [\n            \"sms\",\n            \"phone_change\"\n        ].includes(n) && (B = {\n            phone: w,\n            token: i,\n            type: n\n        });\n        const { error: P } = await l.auth.verifyOtp(B);\n        P && y(P.message), h(!1);\n    }, s = r == null ? void 0 : r.verify_otp;\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"form\", {\n        id: \"auth-magic-link\",\n        onSubmit: g\n    }, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(N, {\n        gap: \"large\",\n        direction: \"vertical\",\n        appearance: o\n    }, [\n        \"sms\",\n        \"phone_change\"\n    ].includes(n) ? /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(H, {\n        htmlFor: \"phone\",\n        appearance: o\n    }, s == null ? void 0 : s.phone_input_label), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(D, {\n        id: \"phone\",\n        name: \"phone\",\n        type: \"text\",\n        autoFocus: !0,\n        placeholder: s == null ? void 0 : s.phone_input_placeholder,\n        onChange: (p)=>d(p.target.value),\n        appearance: o\n    })) : /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(H, {\n        htmlFor: \"email\",\n        appearance: o\n    }, s == null ? void 0 : s.email_input_label), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(D, {\n        id: \"email\",\n        name: \"email\",\n        type: \"email\",\n        autoFocus: !0,\n        placeholder: s == null ? void 0 : s.email_input_placeholder,\n        onChange: (p)=>C(p.target.value),\n        appearance: o\n    })), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(H, {\n        htmlFor: \"token\",\n        appearance: o\n    }, s == null ? void 0 : s.token_input_label), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(D, {\n        id: \"token\",\n        name: \"token\",\n        type: \"text\",\n        placeholder: s == null ? void 0 : s.token_input_placeholder,\n        onChange: (p)=>m(p.target.value),\n        appearance: o\n    })), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(U, {\n        color: \"primary\",\n        type: \"submit\",\n        loading: _,\n        appearance: o\n    }, _ ? s == null ? void 0 : s.loading_button_label : s == null ? void 0 : s.button_label), v && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(V, {\n        href: \"#auth-sign-in\",\n        onClick: (p)=>{\n            p.preventDefault(), t(_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.SIGN_IN);\n        },\n        appearance: o\n    }, (M = r == null ? void 0 : r.sign_in) == null ? void 0 : M.link_text), x && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(F, {\n        appearance: o\n    }, x), c && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(F, {\n        color: \"danger\",\n        appearance: o\n    }, c)));\n}\nconst l1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    user: null,\n    session: null\n}), R1 = (t)=>{\n    const { supabaseClient: l } = t, [n, r] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), [o, v] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)((n == null ? void 0 : n.user) ?? null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        (async ()=>{\n            var d;\n            const { data: w } = await l.auth.getSession();\n            r(w.session), v(((d = w.session) == null ? void 0 : d.user) ?? null);\n        })();\n        const { data: C } = l.auth.onAuthStateChange(async (w, d)=>{\n            r(d), v((d == null ? void 0 : d.user) ?? null);\n        });\n        return ()=>{\n            C == null || C.subscription.unsubscribe();\n        };\n    }, []);\n    const E = {\n        session: n,\n        user: o\n    };\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(l1.Provider, {\n        value: E,\n        ...t\n    });\n}, O1 = ()=>{\n    const t = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(l1);\n    if (t === void 0) throw new Error(\"useUser must be used within a UserContextProvider.\");\n    return t;\n};\nfunction S({ supabaseClient: t, socialLayout: l = \"vertical\", providers: n, providerScopes: r, queryParams: o, view: v = \"sign_in\", redirectTo: E, onlyThirdPartyProviders: C = !1, magicLink: w = !1, showLinks: d = !0, appearance: i, theme: m = \"default\", localization: c = {\n    variables: {}\n}, otpType: y = \"email\", additionalData: x, children: a }) {\n    const _ = (0,_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.merge)(_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.en, c.variables ?? {}), [h, g] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(v), [s, M] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [p, B] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), P = h === \"sign_in\" || h === \"sign_up\" || h === \"magic_link\";\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        var z, f;\n        (0,_stitches_core__WEBPACK_IMPORTED_MODULE_2__.createStitches)({\n            theme: (0,_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.merge)(((z = i == null ? void 0 : i.theme) == null ? void 0 : z.default) ?? {}, ((f = i == null ? void 0 : i.variables) == null ? void 0 : f.default) ?? {})\n        });\n    }, [\n        i\n    ]);\n    const A = ({ children: z })=>{\n        var f;\n        return(// @ts-ignore\n        /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", {\n            className: m !== \"default\" ? (0,_stitches_core__WEBPACK_IMPORTED_MODULE_2__.createTheme)((0,_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.merge)(// @ts-ignore\n            i == null ? void 0 : i.theme[m], ((f = i == null ? void 0 : i.variables) == null ? void 0 : f[m]) ?? {})) : \"\"\n        }, P && /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(A1, {\n            appearance: i,\n            supabaseClient: t,\n            providers: n,\n            providerScopes: r,\n            queryParams: o,\n            socialLayout: l,\n            redirectTo: E,\n            onlyThirdPartyProviders: C,\n            i18n: _,\n            view: h\n        }), !C && z));\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const { data: z } = t.auth.onAuthStateChange((f)=>{\n            f === \"PASSWORD_RECOVERY\" ? g(\"update_password\") : f === \"USER_UPDATED\" && g(\"sign_in\");\n        });\n        return g(v), ()=>z.subscription.unsubscribe();\n    }, [\n        v\n    ]);\n    const O = {\n        supabaseClient: t,\n        setAuthView: g,\n        defaultEmail: s,\n        defaultPassword: p,\n        setDefaultEmail: M,\n        setDefaultPassword: B,\n        redirectTo: E,\n        magicLink: w,\n        showLinks: d,\n        i18n: _,\n        appearance: i\n    };\n    switch(h){\n        case _supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.SIGN_IN:\n            return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(A, null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(Q, {\n                ...O,\n                authView: \"sign_in\"\n            }));\n        case _supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.SIGN_UP:\n            return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(A, null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(Q, {\n                appearance: i,\n                supabaseClient: t,\n                authView: \"sign_up\",\n                setAuthView: g,\n                defaultEmail: s,\n                defaultPassword: p,\n                setDefaultEmail: M,\n                setDefaultPassword: B,\n                redirectTo: E,\n                magicLink: w,\n                showLinks: d,\n                i18n: _,\n                additionalData: x,\n                children: a\n            }));\n        case _supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.FORGOTTEN_PASSWORD:\n            return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(A, null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(e1, {\n                appearance: i,\n                supabaseClient: t,\n                setAuthView: g,\n                redirectTo: E,\n                showLinks: d,\n                i18n: _\n            }));\n        case _supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.MAGIC_LINK:\n            return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(A, null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(X, {\n                appearance: i,\n                supabaseClient: t,\n                setAuthView: g,\n                redirectTo: E,\n                showLinks: d,\n                i18n: _\n            }));\n        case _supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.UPDATE_PASSWORD:\n            return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(t1, {\n                appearance: i,\n                supabaseClient: t,\n                i18n: _\n            });\n        case _supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.VERIFY_OTP:\n            return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(U1, {\n                appearance: i,\n                supabaseClient: t,\n                otpType: y,\n                i18n: _\n            });\n        default:\n            return null;\n    }\n}\nS.ForgottenPassword = e1;\nS.UpdatePassword = t1;\nS.MagicLink = X;\nS.UserContextProvider = R1;\nS.useUser = O1;\nconst W1 = (0,_stitches_core__WEBPACK_IMPORTED_MODULE_2__.css)({\n    borderRadius: \"12px\",\n    boxShadow: \"rgba(100, 100, 111, 0.2) 0px 7px 29px 0px\",\n    width: \"360px\",\n    padding: \"28px 32px\"\n}), j1 = ({ children: t, appearance: l })=>{\n    const n = [\n        `${_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.PREPENDED_CLASS_NAMES}_ui-card`,\n        W1(),\n        l == null ? void 0 : l.className\n    ];\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", {\n        className: n.join(\" \")\n    }, t);\n}, q1 = (t)=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(S, {\n        showLinks: !1,\n        ...t,\n        onlyThirdPartyProviders: !1,\n        view: \"sign_up\"\n    }), K1 = (t)=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(S, {\n        showLinks: !1,\n        ...t,\n        onlyThirdPartyProviders: !1,\n        view: \"sign_in\"\n    }), Y1 = (t)=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(S, {\n        ...t,\n        view: \"magic_link\",\n        showLinks: !1\n    }), J1 = (t)=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(S, {\n        ...t,\n        view: \"sign_in\",\n        showLinks: !1,\n        onlyThirdPartyProviders: !0\n    }), Q1 = (t)=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(S, {\n        showLinks: !1,\n        ...t,\n        view: \"forgotten_password\"\n    }), X1 = (t)=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(S, {\n        ...t,\n        view: \"update_password\"\n    }), e0 = (t)=>/* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(S, {\n        ...t,\n        view: \"verify_otp\"\n    });\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtdWktcmVhY3QvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBbUY7QUFDK0Q7QUFDcEM7QUFDOUcsTUFBTTZCLEtBQUs1QixtREFBQ0EsQ0FBQztJQUNYNkIsWUFBWTtJQUNaQyxVQUFVO0lBQ1ZDLGNBQWM7SUFDZEMsT0FBTztJQUNQQyxTQUFTO0lBQ1RDLFdBQVc7SUFDWEMsZ0JBQWdCO0lBQ2hCLFdBQVc7UUFDVEgsT0FBTztJQUNUO0FBQ0YsSUFBSUksSUFBSSxDQUFDLEVBQUVDLFVBQVVDLENBQUMsRUFBRUMsWUFBWUMsQ0FBQyxFQUFFLEdBQUdDLEdBQUc7SUFDM0MsSUFBSUM7SUFDSixNQUFNQyxJQUFJckMsNEVBQUNBLENBQ1QsVUFDQXNCLE1BQ0FZO0lBRUYsT0FBTyxhQUFhLGlCQUFHdkIsZ0RBQWUsQ0FDcEMsS0FDQTtRQUNFLEdBQUd3QixDQUFDO1FBQ0pJLE9BQU8sQ0FBQ0gsSUFBSUYsS0FBSyxPQUFPLEtBQUssSUFBSUEsRUFBRUssS0FBSyxLQUFLLE9BQU8sS0FBSyxJQUFJSCxFQUFFSSxNQUFNO1FBQ3JFQyxXQUFXSixFQUFFSyxJQUFJLENBQUM7SUFDcEIsR0FDQVY7QUFFSixHQUFHVyxLQUFLakQsbURBQUNBLENBQUM7SUFDUjZCLFlBQVk7SUFDWkksU0FBUztJQUNUaUIsWUFBWTtJQUNaQyxnQkFBZ0I7SUFDaEJDLEtBQUs7SUFDTEMsY0FBYztJQUNkdkIsVUFBVTtJQUNWd0IsU0FBUztJQUNUQyxRQUFRO0lBQ1JDLGFBQWE7SUFDYkMsYUFBYTtJQUNiQyxPQUFPO0lBQ1BDLG9CQUFvQjtJQUNwQkMsMEJBQTBCO0lBQzFCQyxvQkFBb0I7SUFDcEIsY0FBYztRQUNaQyxTQUFTO1FBQ1RQLFFBQVE7SUFDVjtJQUNBUSxVQUFVO1FBQ1IvQixPQUFPO1lBQ0xnQyxTQUFTO2dCQUNQQyxpQkFBaUI7Z0JBQ2pCakMsT0FBTztnQkFDUGtDLGFB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RixLQUFLLENBQUM3UCxJQUFNLGFBQWEsaUJBQUdyQixnREFBZSxDQUFDa1EsR0FBRztRQUFFLEdBQUc3TyxDQUFDO1FBQUUrSixNQUFNO1FBQWNsRixXQUFXLENBQUM7SUFBRSxJQUFJaUwsS0FBSyxDQUFDOVAsSUFBTSxhQUFhLGlCQUFHckIsZ0RBQWUsQ0FDeklrUSxHQUNBO1FBQ0UsR0FBRzdPLENBQUM7UUFDSitKLE1BQU07UUFDTmxGLFdBQVcsQ0FBQztRQUNaaUYseUJBQXlCLENBQUM7SUFDNUIsSUFDQ2lHLEtBQUssQ0FBQy9QLElBQU0sYUFBYSxpQkFBR3JCLGdEQUFlLENBQUNrUSxHQUFHO1FBQUVoSyxXQUFXLENBQUM7UUFBRyxHQUFHN0UsQ0FBQztRQUFFK0osTUFBTTtJQUFxQixJQUFJaUcsS0FBSyxDQUFDaFEsSUFBTSxhQUFhLGlCQUFHckIsZ0RBQWUsQ0FBQ2tRLEdBQUc7UUFBRSxHQUFHN08sQ0FBQztRQUFFK0osTUFBTTtJQUFrQixJQUFJa0csS0FBSyxDQUFDalEsSUFBTSxhQUFhLGlCQUFHckIsZ0RBQWUsQ0FBQ2tRLEdBQUc7UUFBRSxHQUFHN08sQ0FBQztRQUFFK0osTUFBTTtJQUFhO0FBV25RIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5jaG9yLXdvcmtmbG93cy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC11aS1yZWFjdC9kaXN0L2luZGV4LmVzLmpzP2M3NGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3NzIGFzICQsIGNyZWF0ZVN0aXRjaGVzIGFzIG4xLCBjcmVhdGVUaGVtZSBhcyBzMSB9IGZyb20gXCJAc3RpdGNoZXMvY29yZVwiO1xuaW1wb3J0IHsgZ2VuZXJhdGVDbGFzc05hbWVzIGFzIEksIFZJRVdTIGFzIGIsIHRlbXBsYXRlIGFzIGMxLCBtZXJnZSBhcyBXLCBlbiBhcyBhMSwgUFJFUEVOREVEX0NMQVNTX05BTUVTIGFzIGkxIH0gZnJvbSBcIkBzdXBhYmFzZS9hdXRoLXVpLXNoYXJlZFwiO1xuaW1wb3J0IGUsIHsgdXNlU3RhdGUgYXMgdSwgdXNlUmVmIGFzIG0xLCB1c2VFZmZlY3QgYXMgUiwgY3JlYXRlQ29udGV4dCBhcyBkMSwgdXNlQ29udGV4dCBhcyB1MSB9IGZyb20gXCJyZWFjdFwiO1xuY29uc3QgZzEgPSAkKHtcbiAgZm9udEZhbWlseTogXCIkYm9keUZvbnRGYW1pbHlcIixcbiAgZm9udFNpemU6IFwiJGJhc2VCb2R5U2l6ZVwiLFxuICBtYXJnaW5Cb3R0b206IFwiJGFuY2hvckJvdHRvbU1hcmdpblwiLFxuICBjb2xvcjogXCIkYW5jaG9yVGV4dENvbG9yXCIsXG4gIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgdGV4dEFsaWduOiBcImNlbnRlclwiLFxuICB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIixcbiAgXCImOmhvdmVyXCI6IHtcbiAgICBjb2xvcjogXCIkYW5jaG9yVGV4dEhvdmVyQ29sb3JcIlxuICB9XG59KSwgViA9ICh7IGNoaWxkcmVuOiB0LCBhcHBlYXJhbmNlOiBsLCAuLi5uIH0pID0+IHtcbiAgdmFyIG87XG4gIGNvbnN0IHIgPSBJKFxuICAgIFwiYW5jaG9yXCIsXG4gICAgZzEoKSxcbiAgICBsXG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwiYVwiLFxuICAgIHtcbiAgICAgIC4uLm4sXG4gICAgICBzdHlsZTogKG8gPSBsID09IG51bGwgPyB2b2lkIDAgOiBsLnN0eWxlKSA9PSBudWxsID8gdm9pZCAwIDogby5hbmNob3IsXG4gICAgICBjbGFzc05hbWU6IHIuam9pbihcIiBcIilcbiAgICB9LFxuICAgIHRcbiAgKTtcbn0sIGgxID0gJCh7XG4gIGZvbnRGYW1pbHk6IFwiJGJ1dHRvbkZvbnRGYW1pbHlcIixcbiAgZGlzcGxheTogXCJmbGV4XCIsXG4gIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gIGp1c3RpZnlDb250ZW50OiBcImNlbnRlclwiLFxuICBnYXA6IFwiOHB4XCIsXG4gIGJvcmRlclJhZGl1czogXCIkYm9yZGVyUmFkaXVzQnV0dG9uXCIsXG4gIGZvbnRTaXplOiBcIiRiYXNlQnV0dG9uU2l6ZVwiLFxuICBwYWRkaW5nOiBcIiRidXR0b25QYWRkaW5nXCIsXG4gIGN1cnNvcjogXCJwb2ludGVyXCIsXG4gIGJvcmRlcldpZHRoOiBcIiRidXR0b25Cb3JkZXJXaWR0aFwiLFxuICBib3JkZXJTdHlsZTogXCJzb2xpZFwiLFxuICB3aWR0aDogXCIxMDAlXCIsXG4gIHRyYW5zaXRpb25Qcm9wZXJ0eTogXCJiYWNrZ3JvdW5kLWNvbG9yXCIsXG4gIHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogXCJjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpXCIsXG4gIHRyYW5zaXRpb25EdXJhdGlvbjogXCIxMDBtc1wiLFxuICBcIiY6ZGlzYWJsZWRcIjoge1xuICAgIG9wYWNpdHk6IDAuNyxcbiAgICBjdXJzb3I6IFwidW5zZXRcIlxuICB9LFxuICB2YXJpYW50czoge1xuICAgIGNvbG9yOiB7XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIkZGVmYXVsdEJ1dHRvbkJhY2tncm91bmRcIixcbiAgICAgICAgY29sb3I6IFwiJGRlZmF1bHRCdXR0b25UZXh0XCIsXG4gICAgICAgIGJvcmRlckNvbG9yOiBcIiRkZWZhdWx0QnV0dG9uQm9yZGVyXCIsXG4gICAgICAgIFwiJjpob3Zlcjpub3QoOmRpc2FibGVkKVwiOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiRkZWZhdWx0QnV0dG9uQmFja2dyb3VuZEhvdmVyXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByaW1hcnk6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiRicmFuZFwiLFxuICAgICAgICBjb2xvcjogXCIkYnJhbmRCdXR0b25UZXh0XCIsXG4gICAgICAgIGJvcmRlckNvbG9yOiBcIiRicmFuZEFjY2VudFwiLFxuICAgICAgICBcIiY6aG92ZXI6bm90KDpkaXNhYmxlZClcIjoge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIkYnJhbmRBY2NlbnRcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KSwgVSA9ICh7XG4gIGNoaWxkcmVuOiB0LFxuICBjb2xvcjogbCA9IFwiZGVmYXVsdFwiLFxuICBhcHBlYXJhbmNlOiBuLFxuICBpY29uOiByLFxuICBsb2FkaW5nOiBvID0gITEsXG4gIC4uLnZcbn0pID0+IHtcbiAgdmFyIEM7XG4gIGNvbnN0IEUgPSBJKFxuICAgIFwiYnV0dG9uXCIsXG4gICAgaDEoeyBjb2xvcjogbCB9KSxcbiAgICBuXG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwiYnV0dG9uXCIsXG4gICAge1xuICAgICAgLi4udixcbiAgICAgIHN0eWxlOiAoQyA9IG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uc3R5bGUpID09IG51bGwgPyB2b2lkIDAgOiBDLmJ1dHRvbixcbiAgICAgIGNsYXNzTmFtZTogRS5qb2luKFwiIFwiKSxcbiAgICAgIGRpc2FibGVkOiBvXG4gICAgfSxcbiAgICByLFxuICAgIHRcbiAgKTtcbn0sIGYxID0gJCh7XG4gIGRpc3BsYXk6IFwiZmxleFwiLFxuICBnYXA6IFwiNHB4XCIsXG4gIHZhcmlhbnRzOiB7XG4gICAgZGlyZWN0aW9uOiB7XG4gICAgICBob3Jpem9udGFsOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiZ3JpZFwiLFxuICAgICAgICBncmlkVGVtcGxhdGVDb2x1bW5zOiBcInJlcGVhdChhdXRvLWZpdCwgbWlubWF4KDQ4cHgsIDFmcikpXCJcbiAgICAgIH0sXG4gICAgICB2ZXJ0aWNhbDoge1xuICAgICAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgICAgICBtYXJnaW46IFwiOHB4IDBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZ2FwOiB7XG4gICAgICBzbWFsbDoge1xuICAgICAgICBnYXA6IFwiNHB4XCJcbiAgICAgIH0sXG4gICAgICBtZWRpdW06IHtcbiAgICAgICAgZ2FwOiBcIjhweFwiXG4gICAgICB9LFxuICAgICAgbGFyZ2U6IHtcbiAgICAgICAgZ2FwOiBcIjE2cHhcIlxuICAgICAgfVxuICAgIH1cbiAgfVxufSksIE4gPSAoe1xuICBjaGlsZHJlbjogdCxcbiAgYXBwZWFyYW5jZTogbCxcbiAgLi4ublxufSkgPT4ge1xuICB2YXIgbztcbiAgY29uc3QgciA9IEkoXG4gICAgXCJjb250YWluZXJcIixcbiAgICBmMSh7XG4gICAgICBkaXJlY3Rpb246IG4uZGlyZWN0aW9uLFxuICAgICAgZ2FwOiBuLmdhcFxuICAgIH0pLFxuICAgIGxcbiAgKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJkaXZcIixcbiAgICB7XG4gICAgICAuLi5uLFxuICAgICAgc3R5bGU6IChvID0gbCA9PSBudWxsID8gdm9pZCAwIDogbC5zdHlsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IG8uY29udGFpbmVyLFxuICAgICAgY2xhc3NOYW1lOiByLmpvaW4oXCIgXCIpXG4gICAgfSxcbiAgICB0XG4gICk7XG59LCBFMSA9ICQoe1xuICBiYWNrZ3JvdW5kOiBcIiRkaXZpZGVyQmFja2dyb3VuZFwiLFxuICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gIG1hcmdpbjogXCIxNnB4IDBcIixcbiAgaGVpZ2h0OiBcIjFweFwiLFxuICB3aWR0aDogXCIxMDAlXCJcbn0pLCBDMSA9ICh7XG4gIGNoaWxkcmVuOiB0LFxuICBhcHBlYXJhbmNlOiBsLFxuICAuLi5uXG59KSA9PiB7XG4gIHZhciBvO1xuICBjb25zdCByID0gSShcbiAgICBcImRpdmlkZXJcIixcbiAgICBFMSgpLFxuICAgIGxcbiAgKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJkaXZcIixcbiAgICB7XG4gICAgICAuLi5uLFxuICAgICAgc3R5bGU6IChvID0gbCA9PSBudWxsID8gdm9pZCAwIDogbC5zdHlsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IG8uZGl2aWRlcixcbiAgICAgIGNsYXNzTmFtZTogci5qb2luKFwiIFwiKVxuICAgIH1cbiAgKTtcbn0sIHcxID0gJCh7XG4gIGZvbnRGYW1pbHk6IFwiJGlucHV0Rm9udEZhbWlseVwiLFxuICBiYWNrZ3JvdW5kOiBcIiRpbnB1dEJhY2tncm91bmRcIixcbiAgYm9yZGVyUmFkaXVzOiBcIiRpbnB1dEJvcmRlclJhZGl1c1wiLFxuICBwYWRkaW5nOiBcIiRpbnB1dFBhZGRpbmdcIixcbiAgY3Vyc29yOiBcInRleHRcIixcbiAgYm9yZGVyV2lkdGg6IFwiJGlucHV0Qm9yZGVyV2lkdGhcIixcbiAgYm9yZGVyQ29sb3I6IFwiJGlucHV0Qm9yZGVyXCIsXG4gIGJvcmRlclN0eWxlOiBcInNvbGlkXCIsXG4gIGZvbnRTaXplOiBcIiRiYXNlSW5wdXRTaXplXCIsXG4gIHdpZHRoOiBcIjEwMCVcIixcbiAgY29sb3I6IFwiJGlucHV0VGV4dFwiLFxuICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICBcIiY6aG92ZXJcIjoge1xuICAgIGJvcmRlckNvbG9yOiBcIiRpbnB1dEJvcmRlckhvdmVyXCIsXG4gICAgb3V0bGluZTogXCJub25lXCJcbiAgfSxcbiAgXCImOmZvY3VzXCI6IHtcbiAgICBib3JkZXJDb2xvcjogXCIkaW5wdXRCb3JkZXJGb2N1c1wiLFxuICAgIG91dGxpbmU6IFwibm9uZVwiXG4gIH0sXG4gIFwiJjo6cGxhY2Vob2xkZXJcIjoge1xuICAgIGNvbG9yOiBcIiRpbnB1dFBsYWNlaG9sZGVyXCIsXG4gICAgbGV0dGVyU3BhY2luZzogXCJpbml0aWFsXCJcbiAgfSxcbiAgdHJhbnNpdGlvblByb3BlcnR5OiBcImJhY2tncm91bmQtY29sb3IsIGJvcmRlclwiLFxuICB0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IFwiY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKVwiLFxuICB0cmFuc2l0aW9uRHVyYXRpb246IFwiMTAwbXNcIixcbiAgdmFyaWFudHM6IHtcbiAgICB0eXBlOiB7XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGxldHRlclNwYWNpbmc6IFwiMHB4XCJcbiAgICAgIH0sXG4gICAgICBwYXNzd29yZDoge1xuICAgICAgICBsZXR0ZXJTcGFjaW5nOiBcIjBweFwiXG4gICAgICB9XG4gICAgfVxuICB9XG59KSwgRCA9ICh7IGNoaWxkcmVuOiB0LCBhcHBlYXJhbmNlOiBsLCAuLi5uIH0pID0+IHtcbiAgdmFyIG87XG4gIGNvbnN0IHIgPSBJKFxuICAgIFwiaW5wdXRcIixcbiAgICB3MSh7XG4gICAgICB0eXBlOiBuLnR5cGUgPT09IFwicGFzc3dvcmRcIiA/IFwicGFzc3dvcmRcIiA6IFwiZGVmYXVsdFwiXG4gICAgfSksXG4gICAgbFxuICApO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcImlucHV0XCIsXG4gICAge1xuICAgICAgLi4ubixcbiAgICAgIHN0eWxlOiAobyA9IGwgPT0gbnVsbCA/IHZvaWQgMCA6IGwuc3R5bGUpID09IG51bGwgPyB2b2lkIDAgOiBvLmlucHV0LFxuICAgICAgY2xhc3NOYW1lOiByLmpvaW4oXCIgXCIpXG4gICAgfSxcbiAgICB0XG4gICk7XG59LCB2MSA9ICQoe1xuICBmb250RmFtaWx5OiBcIiRsYWJlbEZvbnRGYW1pbHlcIixcbiAgZm9udFNpemU6IFwiJGJhc2VMYWJlbFNpemVcIixcbiAgbWFyZ2luQm90dG9tOiBcIiRsYWJlbEJvdHRvbU1hcmdpblwiLFxuICBjb2xvcjogXCIkaW5wdXRMYWJlbFRleHRcIixcbiAgZGlzcGxheTogXCJibG9ja1wiXG59KSwgSCA9ICh7IGNoaWxkcmVuOiB0LCBhcHBlYXJhbmNlOiBsLCAuLi5uIH0pID0+IHtcbiAgdmFyIG87XG4gIGNvbnN0IHIgPSBJKFxuICAgIFwibGFiZWxcIixcbiAgICB2MSgpLFxuICAgIGxcbiAgKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJsYWJlbFwiLFxuICAgIHtcbiAgICAgIC4uLm4sXG4gICAgICBzdHlsZTogKG8gPSBsID09IG51bGwgPyB2b2lkIDAgOiBsLnN0eWxlKSA9PSBudWxsID8gdm9pZCAwIDogby5sYWJlbCxcbiAgICAgIGNsYXNzTmFtZTogci5qb2luKFwiIFwiKVxuICAgIH0sXG4gICAgdFxuICApO1xufSwgeDEgPSAkKHtcbiAgZm9udEZhbWlseTogXCIkYm9keUZvbnRGYW1pbHlcIixcbiAgZm9udFNpemU6IFwiJGJhc2VJbnB1dFNpemVcIixcbiAgbWFyZ2luQm90dG9tOiBcIiRsYWJlbEJvdHRvbU1hcmdpblwiLFxuICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgYm9yZGVyUmFkaXVzOiBcIjAuMzc1cmVtXCIsXG4gIHBhZGRpbmc6IFwiMS41cmVtIDFyZW1cIixcbiAgbGluZUhlaWdodDogXCIxcmVtXCIsXG4gIGNvbG9yOiBcIiRtZXNzYWdlVGV4dFwiLFxuICBiYWNrZ3JvdW5kQ29sb3I6IFwiJG1lc3NhZ2VCYWNrZ3JvdW5kXCIsXG4gIGJvcmRlcjogXCIxcHggc29saWQgJG1lc3NhZ2VCb3JkZXJcIixcbiAgdmFyaWFudHM6IHtcbiAgICBjb2xvcjoge1xuICAgICAgZGFuZ2VyOiB7XG4gICAgICAgIGNvbG9yOiBcIiRtZXNzYWdlVGV4dERhbmdlclwiLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiJG1lc3NhZ2VCYWNrZ3JvdW5kRGFuZ2VyXCIsXG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgJG1lc3NhZ2VCb3JkZXJEYW5nZXJcIlxuICAgICAgfVxuICAgIH1cbiAgfVxufSksIEYgPSAoe1xuICBjaGlsZHJlbjogdCxcbiAgYXBwZWFyYW5jZTogbCxcbiAgLi4ublxufSkgPT4ge1xuICB2YXIgbztcbiAgY29uc3QgciA9IEkoXG4gICAgXCJtZXNzYWdlXCIsXG4gICAgeDEoeyBjb2xvcjogbi5jb2xvciB9KSxcbiAgICBsXG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwic3BhblwiLFxuICAgIHtcbiAgICAgIC4uLm4sXG4gICAgICBzdHlsZTogKG8gPSBsID09IG51bGwgPyB2b2lkIDAgOiBsLnN0eWxlKSA9PSBudWxsID8gdm9pZCAwIDogby5tZXNzYWdlLFxuICAgICAgY2xhc3NOYW1lOiByLmpvaW4oXCIgXCIpXG4gICAgfSxcbiAgICB0XG4gICk7XG59O1xuZnVuY3Rpb24gWCh7XG4gIHNldEF1dGhWaWV3OiB0ID0gKCkgPT4ge1xuICB9LFxuICBzdXBhYmFzZUNsaWVudDogbCxcbiAgcmVkaXJlY3RUbzogbixcbiAgaTE4bjogcixcbiAgYXBwZWFyYW5jZTogbyxcbiAgc2hvd0xpbmtzOiB2ID0gITFcbn0pIHtcbiAgdmFyIF87XG4gIGNvbnN0IFtFLCBDXSA9IHUoXCJcIiksIFt3LCBkXSA9IHUoXCJcIiksIFtpLCBtXSA9IHUoXCJcIiksIFtjLCB5XSA9IHUoITEpLCB4ID0gYXN5bmMgKGgpID0+IHtcbiAgICB2YXIgcywgTTtcbiAgICBpZiAoaC5wcmV2ZW50RGVmYXVsdCgpLCBkKFwiXCIpLCBtKFwiXCIpLCB5KCEwKSwgRS5sZW5ndGggPT09IDApIHtcbiAgICAgIGQoKHMgPSByID09IG51bGwgPyB2b2lkIDAgOiByLm1hZ2ljX2xpbmspID09IG51bGwgPyB2b2lkIDAgOiBzLmVtcHR5X2VtYWlsX2FkZHJlc3MpLCB5KCExKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBlcnJvcjogZyB9ID0gYXdhaXQgbC5hdXRoLnNpZ25JbldpdGhPdHAoe1xuICAgICAgZW1haWw6IEUsXG4gICAgICBvcHRpb25zOiB7IGVtYWlsUmVkaXJlY3RUbzogbiB9XG4gICAgfSk7XG4gICAgZyA/IGQoZy5tZXNzYWdlKSA6IG0oKE0gPSByID09IG51bGwgPyB2b2lkIDAgOiByLm1hZ2ljX2xpbmspID09IG51bGwgPyB2b2lkIDAgOiBNLmNvbmZpcm1hdGlvbl90ZXh0KSwgeSghMSk7XG4gIH0sIGEgPSByID09IG51bGwgPyB2b2lkIDAgOiByLm1hZ2ljX2xpbms7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiZm9ybVwiLCB7IGlkOiBcImF1dGgtbWFnaWMtbGlua1wiLCBvblN1Ym1pdDogeCB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KE4sIHsgZ2FwOiBcImxhcmdlXCIsIGRpcmVjdGlvbjogXCJ2ZXJ0aWNhbFwiLCBhcHBlYXJhbmNlOiBvIH0sIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChILCB7IGh0bWxGb3I6IFwiZW1haWxcIiwgYXBwZWFyYW5jZTogbyB9LCBhID09IG51bGwgPyB2b2lkIDAgOiBhLmVtYWlsX2lucHV0X2xhYmVsKSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBELFxuICAgIHtcbiAgICAgIGlkOiBcImVtYWlsXCIsXG4gICAgICBuYW1lOiBcImVtYWlsXCIsXG4gICAgICB0eXBlOiBcImVtYWlsXCIsXG4gICAgICBhdXRvRm9jdXM6ICEwLFxuICAgICAgcGxhY2Vob2xkZXI6IGEgPT0gbnVsbCA/IHZvaWQgMCA6IGEuZW1haWxfaW5wdXRfcGxhY2Vob2xkZXIsXG4gICAgICBvbkNoYW5nZTogKGgpID0+IHtcbiAgICAgICAgZCAmJiBkKFwiXCIpLCBDKGgudGFyZ2V0LnZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBhcHBlYXJhbmNlOiBvXG4gICAgfVxuICApKSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBVLFxuICAgIHtcbiAgICAgIGNvbG9yOiBcInByaW1hcnlcIixcbiAgICAgIHR5cGU6IFwic3VibWl0XCIsXG4gICAgICBsb2FkaW5nOiBjLFxuICAgICAgYXBwZWFyYW5jZTogb1xuICAgIH0sXG4gICAgYyA/IGEgPT0gbnVsbCA/IHZvaWQgMCA6IGEubG9hZGluZ19idXR0b25fbGFiZWwgOiBhID09IG51bGwgPyB2b2lkIDAgOiBhLmJ1dHRvbl9sYWJlbFxuICApLCB2ICYmIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgVixcbiAgICB7XG4gICAgICBocmVmOiBcIiNhdXRoLXNpZ24taW5cIixcbiAgICAgIG9uQ2xpY2s6IChoKSA9PiB7XG4gICAgICAgIGgucHJldmVudERlZmF1bHQoKSwgdChiLlNJR05fSU4pO1xuICAgICAgfSxcbiAgICAgIGFwcGVhcmFuY2U6IG9cbiAgICB9LFxuICAgIChfID0gciA9PSBudWxsID8gdm9pZCAwIDogci5zaWduX2luKSA9PSBudWxsID8gdm9pZCAwIDogXy5saW5rX3RleHRcbiAgKSwgaSAmJiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KEYsIHsgYXBwZWFyYW5jZTogbyB9LCBpKSwgdyAmJiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KEYsIHsgY29sb3I6IFwiZGFuZ2VyXCIsIGFwcGVhcmFuY2U6IG8gfSwgdykpKTtcbn1cbmNvbnN0IEwgPSAkKHtcbiAgd2lkdGg6IFwiMjFweFwiLFxuICBoZWlnaHQ6IFwiMjFweFwiXG59KSwgXzEgPSAoeyBwcm92aWRlcjogdCB9KSA9PiB0ID09IFwiZ29vZ2xlXCIgPyB5MSgpIDogdCA9PSBcImZhY2Vib29rXCIgPyBMMSgpIDogdCA9PSBcInR3aXR0ZXJcIiA/IGIxKCkgOiB0ID09IFwiYXBwbGVcIiA/IHAxKCkgOiB0ID09IFwiZ2l0aHViXCIgPyBrMSgpIDogdCA9PSBcImdpdGxhYlwiID8gTTEoKSA6IHQgPT0gXCJiaXRidWNrZXRcIiA/IFMxKCkgOiB0ID09IFwiZGlzY29yZFwiID8gTjEoKSA6IHQgPT0gXCJhenVyZVwiID8gRjEoKSA6IHQgPT0gXCJrZXljbG9ha1wiID8gejEoKSA6IHQgPT0gXCJsaW5rZWRpblwiID8gJDEoKSA6IHQgPT0gXCJub3Rpb25cIiA/IEIxKCkgOiB0ID09IFwic2xhY2tcIiA/IEQxKCkgOiB0ID09IFwic3BvdGlmeVwiID8gSDEoKSA6IHQgPT0gXCJ0d2l0Y2hcIiA/IFAxKCkgOiB0ID09IFwid29ya29zXCIgPyBWMSgpIDogdCA9PSBcImtha2FvXCIgPyBJMSgpIDogbnVsbCwgeTEgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICBcInN2Z1wiLFxuICB7XG4gICAgY2xhc3NOYW1lOiBMKCksXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICB2aWV3Qm94OiBcIjAgMCA0OCA0OFwiLFxuICAgIHdpZHRoOiBcIjIxcHhcIixcbiAgICBoZWlnaHQ6IFwiMjFweFwiXG4gIH0sXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJwYXRoXCIsXG4gICAge1xuICAgICAgZmlsbDogXCIjRkZDMTA3XCIsXG4gICAgICBkOiBcIk00My42MTEsMjAuMDgzSDQyVjIwSDI0djhoMTEuMzAzYy0xLjY0OSw0LjY1Ny02LjA4LDgtMTEuMzAzLDhjLTYuNjI3LDAtMTItNS4zNzMtMTItMTJjMC02LjYyNyw1LjM3My0xMiwxMi0xMmMzLjA1OSwwLDUuODQyLDEuMTU0LDcuOTYxLDMuMDM5bDUuNjU3LTUuNjU3QzM0LjA0Niw2LjA1MywyOS4yNjgsNCwyNCw0QzEyLjk1NSw0LDQsMTIuOTU1LDQsMjRjMCwxMS4wNDUsOC45NTUsMjAsMjAsMjBjMTEuMDQ1LDAsMjAtOC45NTUsMjAtMjBDNDQsMjIuNjU5LDQzLjg2MiwyMS4zNSw0My42MTEsMjAuMDgzelwiXG4gICAgfVxuICApLFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwicGF0aFwiLFxuICAgIHtcbiAgICAgIGZpbGw6IFwiI0ZGM0QwMFwiLFxuICAgICAgZDogXCJNNi4zMDYsMTQuNjkxbDYuNTcxLDQuODE5QzE0LjY1NSwxNS4xMDgsMTguOTYxLDEyLDI0LDEyYzMuMDU5LDAsNS44NDIsMS4xNTQsNy45NjEsMy4wMzlsNS42NTctNS42NTdDMzQuMDQ2LDYuMDUzLDI5LjI2OCw0LDI0LDRDMTYuMzE4LDQsOS42NTYsOC4zMzcsNi4zMDYsMTQuNjkxelwiXG4gICAgfVxuICApLFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwicGF0aFwiLFxuICAgIHtcbiAgICAgIGZpbGw6IFwiIzRDQUY1MFwiLFxuICAgICAgZDogXCJNMjQsNDRjNS4xNjYsMCw5Ljg2LTEuOTc3LDEzLjQwOS01LjE5MmwtNi4xOS01LjIzOEMyOS4yMTEsMzUuMDkxLDI2LjcxNSwzNiwyNCwzNmMtNS4yMDIsMC05LjYxOS0zLjMxNy0xMS4yODMtNy45NDZsLTYuNTIyLDUuMDI1QzkuNTA1LDM5LjU1NiwxNi4yMjcsNDQsMjQsNDR6XCJcbiAgICB9XG4gICksXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJwYXRoXCIsXG4gICAge1xuICAgICAgZmlsbDogXCIjMTk3NkQyXCIsXG4gICAgICBkOiBcIk00My42MTEsMjAuMDgzSDQyVjIwSDI0djhoMTEuMzAzYy0wLjc5MiwyLjIzNy0yLjIzMSw0LjE2Ni00LjA4Nyw1LjU3MWMwLjAwMS0wLjAwMSwwLjAwMi0wLjAwMSwwLjAwMy0wLjAwMmw2LjE5LDUuMjM4QzM2Ljk3MSwzOS4yMDUsNDQsMzQsNDQsMjRDNDQsMjIuNjU5LDQzLjg2MiwyMS4zNSw0My42MTEsMjAuMDgzelwiXG4gICAgfVxuICApXG4pLCBMMSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gIFwic3ZnXCIsXG4gIHtcbiAgICBjbGFzc05hbWU6IEwoKSxcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIHZpZXdCb3g6IFwiMCAwIDQ4IDQ4XCIsXG4gICAgd2lkdGg6IFwiMjFweFwiLFxuICAgIGhlaWdodDogXCIyMXB4XCJcbiAgfSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBmaWxsOiBcIiMwMzliZTVcIiwgZDogXCJNMjQgNUExOSAxOSAwIDEgMCAyNCA0M0ExOSAxOSAwIDEgMCAyNCA1WlwiIH0pLFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwicGF0aFwiLFxuICAgIHtcbiAgICAgIGZpbGw6IFwiI2ZmZlwiLFxuICAgICAgZDogXCJNMjYuNTcyLDI5LjAzNmg0LjkxN2wwLjc3Mi00Ljk5NWgtNS42OXYtMi43M2MwLTIuMDc1LDAuNjc4LTMuOTE1LDIuNjE5LTMuOTE1aDMuMTE5di00LjM1OWMtMC41NDgtMC4wNzQtMS43MDctMC4yMzYtMy44OTctMC4yMzZjLTQuNTczLDAtNy4yNTQsMi40MTUtNy4yNTQsNy45MTd2My4zMjNoLTQuNzAxdjQuOTk1aDQuNzAxdjEzLjcyOUMyMi4wODksNDIuOTA1LDIzLjAzMiw0MywyNCw0M2MwLjg3NSwwLDEuNzI5LTAuMDgsMi41NzItMC4xOTRWMjkuMDM2elwiXG4gICAgfVxuICApXG4pLCBiMSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gIFwic3ZnXCIsXG4gIHtcbiAgICBjbGFzc05hbWU6IEwoKSxcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIHZpZXdCb3g6IFwiMCAwIDQ4IDQ4XCIsXG4gICAgd2lkdGg6IFwiMjFweFwiLFxuICAgIGhlaWdodDogXCIyMXB4XCJcbiAgfSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcInBhdGhcIixcbiAgICB7XG4gICAgICBmaWxsOiBcIiMwM0E5RjRcIixcbiAgICAgIGQ6IFwiTTQyLDEyLjQyOWMtMS4zMjMsMC41ODYtMi43NDYsMC45NzctNC4yNDcsMS4xNjJjMS41MjYtMC45MDYsMi43LTIuMzUxLDMuMjUxLTQuMDU4Yy0xLjQyOCwwLjgzNy0zLjAxLDEuNDUyLTQuNjkzLDEuNzc2QzM0Ljk2Nyw5Ljg4NCwzMy4wNSw5LDMwLjkyNiw5Yy00LjA4LDAtNy4zODcsMy4yNzgtNy4zODcsNy4zMmMwLDAuNTcyLDAuMDY3LDEuMTI5LDAuMTkzLDEuNjdjLTYuMTM4LTAuMzA4LTExLjU4Mi0zLjIyNi0xNS4yMjQtNy42NTRjLTAuNjQsMS4wODItMSwyLjM0OS0xLDMuNjg2YzAsMi41NDEsMS4zMDEsNC43NzgsMy4yODUsNi4wOTZjLTEuMjExLTAuMDM3LTIuMzUxLTAuMzc0LTMuMzQ5LTAuOTE0YzAsMC4wMjIsMCwwLjA1NSwwLDAuMDg2YzAsMy41NTEsMi41NDcsNi41MDgsNS45MjMsNy4xODFjLTAuNjE3LDAuMTY5LTEuMjY5LDAuMjYzLTEuOTQxLDAuMjYzYy0wLjQ3NywwLTAuOTQyLTAuMDU0LTEuMzkyLTAuMTM1YzAuOTQsMi45MDIsMy42NjcsNS4wMjMsNi44OTgsNS4wODZjLTIuNTI4LDEuOTYtNS43MTIsMy4xMzQtOS4xNzQsMy4xMzRjLTAuNTk4LDAtMS4xODMtMC4wMzQtMS43NjEtMC4xMDRDOS4yNjgsMzYuNzg2LDEzLjE1MiwzOCwxNy4zMjEsMzhjMTMuNTg1LDAsMjEuMDE3LTExLjE1NiwyMS4wMTctMjAuODM0YzAtMC4zMTctMC4wMS0wLjYzMy0wLjAyNS0wLjk0NUMzOS43NjMsMTUuMTk3LDQxLjAxMywxMy45MDUsNDIsMTIuNDI5XCJcbiAgICB9XG4gIClcbiksIHAxID0gKCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgXCJzdmdcIixcbiAge1xuICAgIGNsYXNzTmFtZTogTCgpLFxuICAgIGZpbGw6IFwiZ3JheVwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgdmlld0JveDogXCIwIDAgMjQgMjRcIixcbiAgICB3aWR0aDogXCIyMXB4XCIsXG4gICAgaGVpZ2h0OiBcIjIxcHhcIlxuICB9LFxuICBcIiBcIixcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0gMTUuOTA0Mjk3IDEuMDc4MTI1IEMgMTUuODQzMzU5IDEuMDY4NzUgMTUuNzc0MjE5IDEuMDc0NjA5NCAxNS42OTkyMTkgMS4wOTk2MDk0IEMgMTQuNjk5MjE5IDEuMjk5NjA5NCAxMy42MDAzOTEgMS44OTk2MDk0IDEyLjkwMDM5MSAyLjU5OTYwOTQgQyAxMi4zMDAzOTEgMy4xOTk2MDk0IDExLjgwMDc4MSA0LjE5OTYwOTQgMTEuODAwNzgxIDUuMDk5NjA5NCBDIDExLjgwMDc4MSA1LjI5OTYwOTQgMTEuOTk5MjE5IDUuNSAxMi4xOTkyMTkgNS41IEMgMTMuMjk5MjE5IDUuNCAxNC4zOTk2MDkgNC43OTk2MDk0IDE1LjA5OTYwOSA0LjA5OTYwOTQgQyAxNS42OTk2MDkgMy4yOTk2MDk0IDE2LjE5OTIxOSAyLjQgMTYuMTk5MjE5IDEuNSBDIDE2LjE5OTIxOSAxLjI3NSAxNi4wODcxMDkgMS4xMDYyNSAxNS45MDQyOTcgMS4wNzgxMjUgeiBNIDE2LjE5OTIxOSA1LjQwMDM5MDYgQyAxNC4zOTkyMTkgNS40MDAzOTA2IDEzLjYwMDM5MSA2LjUgMTIuNDAwMzkxIDYuNSBDIDExLjEwMDM5MSA2LjUgOS45MDAzOTA2IDUuNSA4LjQwMDM5MDYgNS41IEMgNi4zMDAzOTA2IDUuNSAzLjA5OTYwOTQgNy40OTk2MDk0IDMuMDk5NjA5NCAxMi4wOTk2MDkgQyAyLjk5OTYwOTQgMTYuMjk5NjA5IDYuOCAyMSA5IDIxIEMgMTAuMyAyMSAxMC42MDAzOTEgMjAuMTk5MjE5IDEyLjQwMDM5MSAyMC4xOTkyMTkgQyAxNC4yMDAzOTEgMjAuMTk5MjE5IDE0LjYwMDM5MSAyMSAxNS45MDAzOTEgMjEgQyAxNy40MDAzOTEgMjEgMTguNTAwMzkxIDE5LjM5OTYwOSAxOS40MDAzOTEgMTguMDk5NjA5IEMgMTkuODAwMzkxIDE3LjM5OTYwOSAyMC4xMDAzOTEgMTcuMDAwMzkxIDIwLjQwMDM5MSAxNi40MDAzOTEgQyAyMC42MDAzOTEgMTYuMDAwMzkxIDIwLjQgMTUuNjAwMzkxIDIwIDE1LjQwMDM5MSBDIDE3LjQgMTQuMTAwMzkxIDE2LjkwMDc4MSA5LjkwMDM5MDYgMTkuODAwNzgxIDguNDAwMzkwNiBDIDIwLjMwMDc4MSA4LjEwMDM5MDYgMjAuNCA3LjQ5OTIxODggMjAgNy4xOTkyMTg4IEMgMTguOSA2LjE5OTIxODcgMTcuMjk5MjE5IDUuNDAwMzkwNiAxNi4xOTkyMTkgNS40MDAzOTA2IHpcIiB9KVxuKSwgazEgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICBcInN2Z1wiLFxuICB7XG4gICAgY2xhc3NOYW1lOiBMKCksXG4gICAgZmlsbDogXCJncmF5XCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICB2aWV3Qm94OiBcIjAgMCAzMCAzMFwiLFxuICAgIHdpZHRoOiBcIjIxcHhcIixcbiAgICBoZWlnaHQ6IFwiMjFweFwiXG4gIH0sXG4gIFwiIFwiLFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTE1LDNDOC4zNzMsMywzLDguMzczLDMsMTVjMCw1LjYyMywzLjg3MiwxMC4zMjgsOS4wOTIsMTEuNjNDMTIuMDM2LDI2LjQ2OCwxMiwyNi4yOCwxMiwyNi4wNDd2LTIuMDUxIGMtMC40ODcsMC0xLjMwMywwLTEuNTA4LDBjLTAuODIxLDAtMS41NTEtMC4zNTMtMS45MDUtMS4wMDljLTAuMzkzLTAuNzI5LTAuNDYxLTEuODQ0LTEuNDM1LTIuNTI2IGMtMC4yODktMC4yMjctMC4wNjktMC40ODYsMC4yNjQtMC40NTFjMC42MTUsMC4xNzQsMS4xMjUsMC41OTYsMS42MDUsMS4yMjJjMC40NzgsMC42MjcsMC43MDMsMC43NjksMS41OTYsMC43NjkgYzAuNDMzLDAsMS4wODEtMC4wMjUsMS42OTEtMC4xMjFjMC4zMjgtMC44MzMsMC44OTUtMS42LDEuNTg4LTEuOTYyYy0zLjk5Ni0wLjQxMS01LjkwMy0yLjM5OS01LjkwMy01LjA5OCBjMC0xLjE2MiwwLjQ5NS0yLjI4NiwxLjMzNi0zLjIzM0M5LjA1MywxMC42NDcsOC43MDYsOC43Myw5LjQzNSw4YzEuNzk4LDAsMi44ODUsMS4xNjYsMy4xNDYsMS40ODFDMTMuNDc3LDkuMTc0LDE0LjQ2MSw5LDE1LjQ5NSw5IGMxLjAzNiwwLDIuMDI0LDAuMTc0LDIuOTIyLDAuNDgzQzE4LjY3NSw5LjE3LDE5Ljc2Myw4LDIxLjU2NSw4YzAuNzMyLDAuNzMxLDAuMzgxLDIuNjU2LDAuMTAyLDMuNTk0IGMwLjgzNiwwLjk0NSwxLjMyOCwyLjA2NiwxLjMyOCwzLjIyNmMwLDIuNjk3LTEuOTA0LDQuNjg0LTUuODk0LDUuMDk3QzE4LjE5OSwyMC40OSwxOSwyMi4xLDE5LDIzLjMxM3YyLjczNCBjMCwwLjEwNC0wLjAyMywwLjE3OS0wLjAzNSwwLjI2OEMyMy42NDEsMjQuNjc2LDI3LDIwLjIzNiwyNywxNUMyNyw4LjM3MywyMS42MjcsMywxNSwzelwiIH0pXG4pLCBNMSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gIFwic3ZnXCIsXG4gIHtcbiAgICBjbGFzc05hbWU6IEwoKSxcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIHZpZXdCb3g6IFwiMCAwIDQ4IDQ4XCIsXG4gICAgd2lkdGg6IFwiMjFweFwiLFxuICAgIGhlaWdodDogXCIyMXB4XCJcbiAgfSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBmaWxsOiBcIiNlNTM5MzVcIiwgZDogXCJNMjQgNDNMMTYgMjAgMzIgMjB6XCIgfSksXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZmlsbDogXCIjZmY3MDQzXCIsIGQ6IFwiTTI0IDQzTDQyIDIwIDMyIDIwelwiIH0pLFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGZpbGw6IFwiI2U1MzkzNVwiLCBkOiBcIk0zNyA1TDQyIDIwIDMyIDIwelwiIH0pLFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGZpbGw6IFwiI2ZmYTcyNlwiLCBkOiBcIk0yNCA0M0w0MiAyMCA0NSAyOHpcIiB9KSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBmaWxsOiBcIiNmZjcwNDNcIiwgZDogXCJNMjQgNDNMNiAyMCAxNiAyMHpcIiB9KSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBmaWxsOiBcIiNlNTM5MzVcIiwgZDogXCJNMTEgNUw2IDIwIDE2IDIwelwiIH0pLFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGZpbGw6IFwiI2ZmYTcyNlwiLCBkOiBcIk0yNCA0M0w2IDIwIDMgMjh6XCIgfSlcbiksIFMxID0gKCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgXCJzdmdcIixcbiAge1xuICAgIGNsYXNzTmFtZTogTCgpLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgd2lkdGg6IFwiNTEyXCIsXG4gICAgaGVpZ2h0OiBcIjUxMlwiLFxuICAgIHZpZXdCb3g6IFwiMCAwIDYyLjQyIDYyLjQyXCJcbiAgfSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImRlZnNcIiwgbnVsbCwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcImxpbmVhckdyYWRpZW50XCIsXG4gICAge1xuICAgICAgaWQ6IFwiTmV3X0dyYWRpZW50X1N3YXRjaF8xXCIsXG4gICAgICB4MTogXCI2NC4wMVwiLFxuICAgICAgeTE6IFwiMzAuMjdcIixcbiAgICAgIHgyOiBcIjMyLjk5XCIsXG4gICAgICB5MjogXCI1NC40OFwiLFxuICAgICAgZ3JhZGllbnRVbml0czogXCJ1c2VyU3BhY2VPblVzZVwiXG4gICAgfSxcbiAgICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IG9mZnNldDogXCIwLjE4XCIsIHN0b3BDb2xvcjogXCIjMDA1MmNjXCIgfSksXG4gICAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiMVwiLCBzdG9wQ29sb3I6IFwiIzI2ODRmZlwiIH0pXG4gICkpLFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwidGl0bGVcIiwgbnVsbCwgXCJCaXRidWNrZXQtYmx1ZVwiKSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImdcIiwgeyBpZDogXCJMYXllcl8yXCIsIFwiZGF0YS1uYW1lXCI6IFwiTGF5ZXIgMlwiIH0sIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHsgaWQ6IFwiQmx1ZVwiLCB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKDAgLTMuMTMpXCIgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcInBhdGhcIixcbiAgICB7XG4gICAgICBkOiBcIk0yLDYuMjZBMiwyLDAsMCwwLDAsOC41OEw4LjQ5LDYwLjEyYTIuNzIsMi43MiwwLDAsMCwyLjY2LDIuMjdINTEuODhhMiwyLDAsMCwwLDItMS42OEw2Mi4zNyw4LjU5YTIsMiwwLDAsMC0yLTIuMzJaTTM3Ljc1LDQzLjUxaC0xM0wyMS4yMywyNS4xMkg0MC45WlwiLFxuICAgICAgZmlsbDogXCIjMjY4NGZmXCJcbiAgICB9XG4gICksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJwYXRoXCIsXG4gICAge1xuICAgICAgZDogXCJNNTkuNjcsMjUuMTJINDAuOUwzNy43NSw0My41MWgtMTNMOS40LDYxLjczYTIuNzEsMi43MSwwLDAsMCwxLjc1LjY2SDUxLjg5YTIsMiwwLDAsMCwyLTEuNjhaXCIsXG4gICAgICBmaWxsOiBcInVybCgjTmV3X0dyYWRpZW50X1N3YXRjaF8xKVwiXG4gICAgfVxuICApKSlcbiksIE4xID0gKCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgXCJzdmdcIixcbiAge1xuICAgIGNsYXNzTmFtZTogTCgpLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgdmlld0JveDogXCIwIDAgNDggNDhcIixcbiAgICB3aWR0aDogXCIyMXB4XCIsXG4gICAgaGVpZ2h0OiBcIjIxcHhcIlxuICB9LFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwicGF0aFwiLFxuICAgIHtcbiAgICAgIGZpbGw6IFwiIzUzNmRmZVwiLFxuICAgICAgZDogXCJNMzkuMjQ4LDEwLjE3N2MtMi44MDQtMS4yODctNS44MTItMi4yMzUtOC45NTYtMi43NzhjLTAuMDU3LTAuMDEtMC4xMTQsMC4wMTYtMC4xNDQsMC4wNjhcdGMtMC4zODcsMC42ODgtMC44MTUsMS41ODUtMS4xMTUsMi4yOTFjLTMuMzgyLTAuNTA2LTYuNzQ3LTAuNTA2LTEwLjA1OSwwYy0wLjMtMC43MjEtMC43NDQtMS42MDMtMS4xMzMtMi4yOTFcdGMtMC4wMy0wLjA1MS0wLjA4Ny0wLjA3Ny0wLjE0NC0wLjA2OGMtMy4xNDMsMC41NDEtNi4xNSwxLjQ4OS04Ljk1NiwyLjc3OGMtMC4wMjQsMC4wMS0wLjA0NSwwLjAyOC0wLjA1OSwwLjA1MVx0Yy01LjcwNCw4LjUyMi03LjI2NywxNi44MzUtNi41LDI1LjA0NGMwLjAwMywwLjA0LDAuMDI2LDAuMDc5LDAuMDU3LDAuMTAzYzMuNzYzLDIuNzY0LDcuNDA5LDQuNDQyLDEwLjk4Nyw1LjU1NFx0YzAuMDU3LDAuMDE3LDAuMTE4LTAuMDAzLDAuMTU0LTAuMDUxYzAuODQ2LTEuMTU2LDEuNjAxLTIuMzc0LDIuMjQ4LTMuNjU2YzAuMDM4LTAuMDc1LDAuMDAyLTAuMTY0LTAuMDc2LTAuMTk0XHRjLTEuMTk3LTAuNDU0LTIuMzM2LTEuMDA3LTMuNDMyLTEuNjM2Yy0wLjA4Ny0wLjA1MS0wLjA5NC0wLjE3NS0wLjAxNC0wLjIzNGMwLjIzMS0wLjE3MywwLjQ2MS0wLjM1MywwLjY4Mi0wLjUzNFx0YzAuMDQtMC4wMzMsMC4wOTUtMC4wNCwwLjE0Mi0wLjAxOWM3LjIwMSwzLjI4OCwxNC45OTcsMy4yODgsMjIuMTEzLDBjMC4wNDctMC4wMjMsMC4xMDItMC4wMTYsMC4xNDQsMC4wMTdcdGMwLjIyLDAuMTgyLDAuNDUxLDAuMzYzLDAuNjgzLDAuNTM2YzAuMDgsMC4wNTksMC4wNzUsMC4xODMtMC4wMTIsMC4yMzRjLTEuMDk2LDAuNjQxLTIuMjM2LDEuMTgyLTMuNDM0LDEuNjM0XHRjLTAuMDc4LDAuMDMtMC4xMTMsMC4xMi0wLjA3NSwwLjE5NmMwLjY2MSwxLjI4LDEuNDE1LDIuNDk4LDIuMjQ2LDMuNjU0YzAuMDM1LDAuMDQ5LDAuMDk3LDAuMDcsMC4xNTQsMC4wNTJcdGMzLjU5NS0xLjExMiw3LjI0MS0yLjc5LDExLjAwNC01LjU1NGMwLjAzMy0wLjAyNCwwLjA1NC0wLjA2MSwwLjA1Ny0wLjEwMWMwLjkxNy05LjQ5MS0xLjUzNy0xNy43MzUtNi41MDUtMjUuMDQ0XHRDMzkuMjkzLDEwLjIwNSwzOS4yNzIsMTAuMTg3LDM5LjI0OCwxMC4xNzd6IE0xNi43MDMsMzAuMjczYy0yLjE2OCwwLTMuOTU0LTEuOTktMy45NTQtNC40MzVzMS43NTItNC40MzUsMy45NTQtNC40MzVcdGMyLjIyLDAsMy45ODksMi4wMDgsMy45NTQsNC40MzVDMjAuNjU4LDI4LjI4MiwxOC45MDYsMzAuMjczLDE2LjcwMywzMC4yNzN6IE0zMS4zMjQsMzAuMjczYy0yLjE2OCwwLTMuOTU0LTEuOTktMy45NTQtNC40MzVcdHMxLjc1Mi00LjQzNSwzLjk1NC00LjQzNWMyLjIyLDAsMy45ODksMi4wMDgsMy45NTQsNC40MzVDMzUuMjc4LDI4LjI4MiwzMy41NDQsMzAuMjczLDMxLjMyNCwzMC4yNzN6XCJcbiAgICB9XG4gIClcbiksIEYxID0gKCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgXCJzdmdcIixcbiAge1xuICAgIGNsYXNzTmFtZTogTCgpLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgdmlld0JveDogXCIwIDAgNDggNDhcIixcbiAgICB3aWR0aDogXCIyMXB4XCIsXG4gICAgaGVpZ2h0OiBcIjIxcHhcIlxuICB9LFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwibGluZWFyR3JhZGllbnRcIixcbiAgICB7XG4gICAgICBpZDogXCJrOHlsN35oRGF0fkZhb1dxOFdqTjZhXCIsXG4gICAgICB4MTogXCItMTI1NC4zOTdcIixcbiAgICAgIHgyOiBcIi0xMjYxLjkxMVwiLFxuICAgICAgeTE6IFwiODc3LjI2OFwiLFxuICAgICAgeTI6IFwiODk5LjQ2NlwiLFxuICAgICAgZ3JhZGllbnRUcmFuc2Zvcm06IFwidHJhbnNsYXRlKDE5ODEuNzUgLTEzNjIuMDYzKSBzY2FsZSgxLjU2MjUpXCIsXG4gICAgICBncmFkaWVudFVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCJcbiAgICB9LFxuICAgIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjBcIiwgc3RvcENvbG9yOiBcIiMxMTRhOGJcIiB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IG9mZnNldDogXCIxXCIsIHN0b3BDb2xvcjogXCIjMDY2OWJjXCIgfSlcbiAgKSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcInBhdGhcIixcbiAgICB7XG4gICAgICBmaWxsOiBcInVybCgjazh5bDd+aERhdH5GYW9XcThXak42YSlcIixcbiAgICAgIGQ6IFwiTTE3LjYzNCw2aDExLjMwNUwxNy4yMDMsNDAuNzczYy0wLjI0NywwLjczMy0wLjkzNCwxLjIyNi0xLjcwOCwxLjIyNkg2LjY5NyBjLTAuOTk0LDAtMS44LTAuODA2LTEuOC0xLjhjMC0wLjE5NiwwLjAzMi0wLjM5LDAuMDk0LTAuNTc2TDE1LjkyNiw3LjIyN0MxNi4xNzMsNi40OTQsMTYuODYsNiwxNy42MzQsNkwxNy42MzQsNnpcIlxuICAgIH1cbiAgKSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcInBhdGhcIixcbiAgICB7XG4gICAgICBmaWxsOiBcIiMwMDc4ZDRcIixcbiAgICAgIGQ6IFwiTTM0LjA2MiwyOS4zMjRIMTYuMTM1Yy0wLjQ1OC0wLjAwMS0wLjgzLDAuMzcxLTAuODMxLDAuODI5YzAsMC4yMzEsMC4wOTUsMC40NTEsMC4yNjQsMC42MDggbDExLjUyLDEwLjc1MkMyNy40MjMsNDEuODI2LDI3Ljg2NSw0MiwyOC4zMjQsNDJoMTAuMTUxTDM0LjA2MiwyOS4zMjR6XCJcbiAgICB9XG4gICksXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJsaW5lYXJHcmFkaWVudFwiLFxuICAgIHtcbiAgICAgIGlkOiBcIms4eWw3fmhEYXR+RmFvV3E4V2pONmJcIixcbiAgICAgIHgxOiBcIi0xMjUyLjA1XCIsXG4gICAgICB4MjogXCItMTI1My43ODhcIixcbiAgICAgIHkxOiBcIjg4Ny42MTJcIixcbiAgICAgIHkyOiBcIjg4OC4yXCIsXG4gICAgICBncmFkaWVudFRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoMTk4MS43NSAtMTM2Mi4wNjMpIHNjYWxlKDEuNTYyNSlcIixcbiAgICAgIGdyYWRpZW50VW5pdHM6IFwidXNlclNwYWNlT25Vc2VcIlxuICAgIH0sXG4gICAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiMFwiLCBzdG9wT3BhY2l0eTogXCIuM1wiIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIi4wNzFcIiwgc3RvcE9wYWNpdHk6IFwiLjJcIiB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IG9mZnNldDogXCIuMzIxXCIsIHN0b3BPcGFjaXR5OiBcIi4xXCIgfSksXG4gICAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiLjYyM1wiLCBzdG9wT3BhY2l0eTogXCIuMDVcIiB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IG9mZnNldDogXCIxXCIsIHN0b3BPcGFjaXR5OiBcIjBcIiB9KVxuICApLFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwicGF0aFwiLFxuICAgIHtcbiAgICAgIGZpbGw6IFwidXJsKCNrOHlsN35oRGF0fkZhb1dxOFdqTjZiKVwiLFxuICAgICAgZDogXCJNMTcuNjM0LDZjLTAuNzgzLTAuMDAzLTEuNDc2LDAuNTA0LTEuNzEyLDEuMjVMNS4wMDUsMzkuNTk1IGMtMC4zMzUsMC45MzQsMC4xNTEsMS45NjQsMS4wODUsMi4yOTlDNi4yODYsNDEuOTY0LDYuNDkzLDQyLDYuNzAyLDQyaDkuMDI2YzAuNjg0LTAuMTIyLDEuMjUtMC42MDMsMS40ODEtMS4yNTlsMi4xNzctNi40MTYgbDcuNzc2LDcuMjUzYzAuMzI2LDAuMjcsMC43MzUsMC40MTksMS4xNTgsMC40MjJoMTAuMTE0bC00LjQzNi0xMi42NzZsLTEyLjkzMSwwLjAwM0wyOC45OCw2SDE3LjYzNHpcIlxuICAgIH1cbiAgKSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcImxpbmVhckdyYWRpZW50XCIsXG4gICAge1xuICAgICAgaWQ6IFwiazh5bDd+aERhdH5GYW9XcThXak42Y1wiLFxuICAgICAgeDE6IFwiLTEyNTIuOTUyXCIsXG4gICAgICB4MjogXCItMTI0NC43MDRcIixcbiAgICAgIHkxOiBcIjg3Ni42XCIsXG4gICAgICB5MjogXCI4OTguNTc1XCIsXG4gICAgICBncmFkaWVudFRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoMTk4MS43NSAtMTM2Mi4wNjMpIHNjYWxlKDEuNTYyNSlcIixcbiAgICAgIGdyYWRpZW50VW5pdHM6IFwidXNlclNwYWNlT25Vc2VcIlxuICAgIH0sXG4gICAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiMFwiLCBzdG9wQ29sb3I6IFwiIzNjY2JmNFwiIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjFcIiwgc3RvcENvbG9yOiBcIiMyODkyZGZcIiB9KVxuICApLFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwicGF0aFwiLFxuICAgIHtcbiAgICAgIGZpbGw6IFwidXJsKCNrOHlsN35oRGF0fkZhb1dxOFdqTjZjKVwiLFxuICAgICAgZDogXCJNMzIuMDc0LDcuMjI1QzMxLjgyNyw2LjQ5MywzMS4xNDEsNiwzMC4zNjgsNmgtMTIuNmMwLjc3MiwwLDEuNDU5LDAuNDkzLDEuNzA1LDEuMjI0IGwxMC45MzUsMzIuMzk5YzAuMzE4LDAuOTQyLTAuMTg4LDEuOTYzLTEuMTMsMi4yODFDMjkuMDkzLDQxLjk2OCwyOC44OTksNDIsMjguNzAzLDQyaDEyLjZjMC45OTQsMCwxLjgtMC44MDYsMS44LTEuODAxIGMwLTAuMTk2LTAuMDMyLTAuMzktMC4wOTUtMC41NzVMMzIuMDc0LDcuMjI1elwiXG4gICAgfVxuICApXG4pLCB6MSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gIFwic3ZnXCIsXG4gIHtcbiAgICBjbGFzc05hbWU6IEwoKSxcbiAgICB3aWR0aDogXCI1MTJcIixcbiAgICBoZWlnaHQ6IFwiNTEyXCIsXG4gICAgdmlld0JveDogXCIwIDAgNTEyIDUxMlwiLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgfSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcInBhdGhcIixcbiAgICB7XG4gICAgICBkOiBcIk00NzIuMTM2IDE2My45NTlINDA4LjU4NEM0MDcuNDAxIDE2My45NTkgNDA2LjIxOCAxNjMuMzI3IDQwNS42NjYgMTYyLjNMMzU0LjY1MSA3My42NTkxQzM1NC4wMiA3Mi42MzIgMzUyLjkxNiA3MiAzNTEuNjU0IDcySDE0My40OTJDMTQyLjMwOSA3MiAxNDEuMTI2IDcyLjYzMiAxNDAuNTc0IDczLjY1OTFMODcuNTA4NCAxNjUuNjE4TDM2LjQxNCAyNTQuMjU5QzM1Ljg2MiAyNTUuMjg2IDM1Ljg2MiAyNTYuNTUgMzYuNDE0IDI1Ny42NTZMODcuNTA4NCAzNDYuMjk3TDE0MC40OTUgNDM4LjMzNUMxNDEuMDQ3IDQzOS4zNjIgMTQyLjIzIDQ0MC4wNzMgMTQzLjQxMyA0MzkuOTk0SDM1MS42NTRDMzUyLjgzNyA0MzkuOTk0IDM1NC4wMiA0MzkuMzYyIDM1NC42NTEgNDM4LjMzNUw0MDUuNzQ1IDM0OS42OTRDNDA2LjI5NyAzNDguNjY3IDQwNy40OCAzNDcuOTU2IDQwOC42NjMgMzQ4LjAzNUg0NzIuMjE1QzQ3NC4zNDQgMzQ4LjAzNSA0NzYgMzQ2LjI5NyA0NzYgMzQ0LjI0M1YxNjcuODNDNDc1LjkyMSAxNjUuNjk3IDQ3NC4xODYgMTYzLjk1OSA0NzIuMTM2IDE2My45NTlaTTIyOC43MjggMzQ5LjY5NEwyMTIuNzIxIDM3Ny4zNDVDMjEyLjQ4NSAzNzcuNzQgMjEyLjA5MSAzNzguMTM1IDIxMS42OTYgMzc4LjM3MkMyMTEuMjIzIDM3OC42MDkgMjEwLjc1IDM3OC43NjcgMjEwLjE5OCAzNzguNzY3SDE3OC40MjJDMTc3LjMxOCAzNzguNzY3IDE3Ni4yOTMgMzc4LjIxNCAxNzUuODIgMzc3LjE4N0wxMjguNDMxIDI5NC43ODdMMTIzLjc3OSAyODYuNjVMMTA2Ljc0OCAyNTcuNDk4QzEwNi41MTEgMjU3LjEwMyAxMDYuMzUzIDI1Ni42MjkgMTA2LjQzMiAyNTYuMDc2QzEwNi40MzIgMjU1LjYwMiAxMDYuNTkgMjU1LjA0OSAxMDYuODI3IDI1NC42NTRMMTIzLjkzNyAyMjQuOTQ5TDE3NS44OTkgMTM0Ljg4NkMxNzYuNDUxIDEzMy45MzggMTc3LjQ3NiAxMzMuMzA2IDE3OC41MDEgMTMzLjMwNkgyMTAuMTk4QzIxMC43NSAxMzMuMzA2IDIxMS4zMDIgMTMzLjQ2NCAyMTEuODU0IDEzMy43MDFDMjEyLjI0OCAxMzMuOTM4IDIxMi42NDMgMTM0LjI1NCAyMTIuODc5IDEzNC43MjhMMjI4Ljg4NiAxNjIuNTM3QzIyOS4zNTkgMTYzLjQ4NSAyMjkuMjggMTY0LjY3IDIyOC43MjggMTY1LjUzOUwxNzcuMzk3IDI1NC42NTRDMTc3LjE2IDI1NS4wNDkgMTc3LjA4MSAyNTUuNTIzIDE3Ny4wODEgMjU1LjkxOEMxNzcuMDgxIDI1Ni4zOTIgMTc3LjIzOSAyNTYuNzg3IDE3Ny4zOTcgMjU3LjE4MkwyMjguNzI4IDM0Ni4yMThDMjI5LjQzOCAzNDcuNDAzIDIyOS4zNTkgMzQ4LjY2NyAyMjguNzI4IDM0OS42OTRWMzQ5LjY5NFpNMzg4LjA4MyAyNTcuNDk4TDM3MS4wNTEgMjg2LjY1TDM2Ni4zOTkgMjk0Ljc4N0wzMTkuMDExIDM3Ny4xODdDMzE4LjQ1OSAzNzguMTM1IDMxNy41MTIgMzc4Ljc2NyAzMTYuNDA5IDM3OC43NjdIMjg0LjYzMkMyODQuMDggMzc4Ljc2NyAyODMuNjA3IDM3OC42MDkgMjgzLjEzNCAzNzguMzcyQzI4Mi43NCAzNzguMTM1IDI4Mi4zNDYgMzc3LjgxOSAyODIuMTA5IDM3Ny4zNDVMMjY2LjEwMyAzNDkuNjk0QzI2NS4zOTMgMzQ4LjY2NyAyNjUuMzkzIDM0Ny40MDMgMjY2LjAyNCAzNDYuMzc2TDMxNy4zNTUgMjU3LjM0QzMxNy41OTEgMjU2Ljk0NSAzMTcuNjcgMjU2LjQ3MSAzMTcuNjcgMjU2LjA3NkMzMTcuNjcgMjU1LjYwMiAzMTcuNTEzIDI1NS4yMDcgMzE3LjM1NSAyNTQuODEyTDI2Ni4wMjQgMTY1LjY5N0MyNjUuNDcyIDE2NC43NDkgMjY1LjM5MyAxNjMuNjQzIDI2NS44NjYgMTYyLjY5NUwyODEuODczIDEzNC44ODZDMjgyLjEwOSAxMzQuNDkxIDI4Mi41MDMgMTM0LjA5NiAyODIuODk4IDEzMy44NTlDMjgzLjM3MSAxMzMuNTQzIDI4My45MjMgMTMzLjQ2NCAyODQuNTUzIDEzMy40NjRIMzE2LjQwOUMzMTcuNTEyIDEzMy40NjQgMzE4LjUzOCAxMzQuMDE3IDMxOS4wMTEgMTM1LjA0NEwzNzAuOTcyIDIyNS4xMDdMMzg4LjA4MyAyNTQuODEyQzM4OC4zMTkgMjU1LjI4NiAzODguNDc3IDI1NS43NiAzODguNDc3IDI1Ni4yMzRDMzg4LjQ3NyAyNTYuNTUgMzg4LjMxOSAyNTcuMDI0IDM4OC4wODMgMjU3LjQ5OFYyNTcuNDk4WlwiLFxuICAgICAgZmlsbDogXCIjMDA4QUFBXCJcbiAgICB9XG4gIClcbiksICQxID0gKCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgXCJzdmdcIixcbiAge1xuICAgIGNsYXNzTmFtZTogTCgpLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgdmlld0JveDogXCIwIDAgNDggNDhcIixcbiAgICB3aWR0aDogXCIyMXB4XCIsXG4gICAgaGVpZ2h0OiBcIjIxcHhcIlxuICB9LFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwicGF0aFwiLFxuICAgIHtcbiAgICAgIGZpbGw6IFwiIzAyODhEMVwiLFxuICAgICAgZDogXCJNNDIsMzdjMCwyLjc2Mi0yLjIzOCw1LTUsNUgxMWMtMi43NjEsMC01LTIuMjM4LTUtNVYxMWMwLTIuNzYyLDIuMjM5LTUsNS01aDI2YzIuNzYyLDAsNSwyLjIzOCw1LDVWMzd6XCJcbiAgICB9XG4gICksXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJwYXRoXCIsXG4gICAge1xuICAgICAgZmlsbDogXCIjRkZGXCIsXG4gICAgICBkOiBcIk0xMiAxOUgxN1YzNkgxMnpNMTQuNDg1IDE3aC0uMDI4QzEyLjk2NSAxNyAxMiAxNS44ODggMTIgMTQuNDk5IDEyIDEzLjA4IDEyLjk5NSAxMiAxNC41MTQgMTJjMS41MjEgMCAyLjQ1OCAxLjA4IDIuNDg2IDIuNDk5QzE3IDE1Ljg4NyAxNi4wMzUgMTcgMTQuNDg1IDE3ek0zNiAzNmgtNXYtOS4wOTljMC0yLjE5OC0xLjIyNS0zLjY5OC0zLjE5Mi0zLjY5OC0xLjUwMSAwLTIuMzEzIDEuMDEyLTIuNzA3IDEuOTlDMjQuOTU3IDI1LjU0MyAyNSAyNi41MTEgMjUgMjd2OWgtNVYxOWg1djIuNjE2QzI1LjcyMSAyMC41IDI2Ljg1IDE5IDI5LjczOCAxOWMzLjU3OCAwIDYuMjYxIDIuMjUgNi4yNjEgNy4yNzRMMzYgMzYgMzYgMzZ6XCJcbiAgICB9XG4gIClcbiksIEIxID0gKCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgXCJzdmdcIixcbiAge1xuICAgIGNsYXNzTmFtZTogTCgpLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgdmlld0JveDogXCIwIDAgNDggNDhcIixcbiAgICB3aWR0aDogXCIyMXB4XCIsXG4gICAgaGVpZ2h0OiBcIjIxcHhcIixcbiAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiXG4gIH0sXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJwYXRoXCIsXG4gICAge1xuICAgICAgZmlsbDogXCIjZmZmXCIsXG4gICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBkOiBcIk0xMS41NTMsMTEuMDk5YzEuMjMyLDEuMDAxLDEuNjk0LDAuOTI1LDQuMDA4LDAuNzcgbDIxLjgxMi0xLjMxYzAuNDYzLDAsMC4wNzgtMC40NjEtMC4wNzYtMC41MzhsLTMuNjIyLTIuNjE5Yy0wLjY5NC0wLjUzOS0xLjYxOS0xLjE1Ni0zLjM5MS0xLjAwMmwtMjEuMTIsMS41NCBjLTAuNzcsMC4wNzYtMC45MjQsMC40NjEtMC42MTcsMC43N0wxMS41NTMsMTEuMDk5elwiLFxuICAgICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiXG4gICAgfVxuICApLFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwicGF0aFwiLFxuICAgIHtcbiAgICAgIGZpbGw6IFwiI2ZmZlwiLFxuICAgICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgZDogXCJNMTIuODYyLDE2LjE4MnYyMi45NWMwLDEuMjMzLDAuNjE2LDEuNjk1LDIuMDA0LDEuNjE5IGwyMy45NzEtMS4zODdjMS4zODgtMC4wNzYsMS41NDMtMC45MjUsMS41NDMtMS45MjdWMTQuNjQxYzAtMS0wLjM4NS0xLjU0LTEuMjM0LTEuNDYzbC0yNS4wNSwxLjQ2MyBDMTMuMTcxLDE0LjcxOCwxMi44NjIsMTUuMTgxLDEyLjg2MiwxNi4xODJMMTIuODYyLDE2LjE4MnpcIixcbiAgICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIlxuICAgIH1cbiAgKSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcInBhdGhcIixcbiAgICB7XG4gICAgICBmaWxsOiBcIiM0MjQyNDJcIixcbiAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGQ6IFwiTTExLjU1MywxMS4wOTljMS4yMzIsMS4wMDEsMS42OTQsMC45MjUsNC4wMDgsMC43NyBsMjEuODEyLTEuMzFjMC40NjMsMCwwLjA3OC0wLjQ2MS0wLjA3Ni0wLjUzOGwtMy42MjItMi42MTljLTAuNjk0LTAuNTM5LTEuNjE5LTEuMTU2LTMuMzkxLTEuMDAybC0yMS4xMiwxLjU0IGMtMC43NywwLjA3Ni0wLjkyNCwwLjQ2MS0wLjYxNywwLjc3TDExLjU1MywxMS4wOTl6IE0xMi44NjIsMTYuMTgydjIyLjk1YzAsMS4yMzMsMC42MTYsMS42OTUsMi4wMDQsMS42MTlsMjMuOTcxLTEuMzg3IGMxLjM4OC0wLjA3NiwxLjU0My0wLjkyNSwxLjU0My0xLjkyN1YxNC42NDFjMC0xLTAuMzg1LTEuNTQtMS4yMzQtMS40NjNsLTI1LjA1LDEuNDYzQzEzLjE3MSwxNC43MTgsMTIuODYyLDE1LjE4MSwxMi44NjIsMTYuMTgyIEwxMi44NjIsMTYuMTgyeiBNMzYuNTI2LDE3LjQxM2MwLjE1NCwwLjY5NCwwLDEuMzg3LTAuNjk1LDEuNDY1bC0xLjE1NSwwLjIzdjE2Ljk0M2MtMS4wMDMsMC41MzktMS45MjgsMC44NDctMi42OTgsMC44NDcgYy0xLjIzNCwwLTEuNTQzLTAuMzg1LTIuNDY3LTEuNTRsLTcuNTU1LTExLjg2djExLjQ3NWwyLjM5MSwwLjUzOWMwLDAsMCwxLjM4Ni0xLjkyOSwxLjM4NmwtNS4zMTcsMC4zMDggYy0wLjE1NC0wLjMwOCwwLTEuMDc4LDAuNTM5LTEuMjMybDEuMzg4LTAuMzg1VjIwLjQxOGwtMS45MjctMC4xNTRjLTAuMTU1LTAuNjk0LDAuMjMtMS42OTQsMS4zMS0xLjc3Mmw1LjcwNC0wLjM4NWw3Ljg2MiwxMi4wMTUgVjE5LjQ5M2wtMi4wMDUtMC4yM2MtMC4xNTQtMC44NDgsMC40NjItMS40NjQsMS4yMzMtMS41NEwzNi41MjYsMTcuNDEzeiBNNy4zODksNS44NjJsMjEuOTY4LTEuNjE4IGMyLjY5OC0wLjIzMSwzLjM5Mi0wLjA3Niw1LjA4NywxLjE1NWw3LjAxMyw0LjkyOUM0Mi42MTQsMTEuMTc2LDQzLDExLjQwNyw0MywxMi4zM3YyNy4wMzJjMCwxLjY5NC0wLjYxNywyLjY5Ni0yLjc3NSwyLjg0OSBsLTI1LjUxMiwxLjU0MWMtMS42MiwwLjA3Ny0yLjM5MS0wLjE1NC0zLjIzOS0xLjIzMmwtNS4xNjQtNi43QzUuMzg1LDM0LjU4Nyw1LDMzLjY2NCw1LDMyLjU4NVY4LjU1NiBDNSw3LjE3MSw1LjYxNyw2LjAxNSw3LjM4OSw1Ljg2MnpcIixcbiAgICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIlxuICAgIH1cbiAgKVxuKSwgRDEgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICBcInN2Z1wiLFxuICB7XG4gICAgY2xhc3NOYW1lOiBMKCksXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICB2aWV3Qm94OiBcIjAgMCA0OCA0OFwiLFxuICAgIHdpZHRoOiBcIjIxcHhcIixcbiAgICBoZWlnaHQ6IFwiMjFweFwiXG4gIH0sXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJwYXRoXCIsXG4gICAge1xuICAgICAgZmlsbDogXCIjMzNkMzc1XCIsXG4gICAgICBkOiBcIk0zMyw4YzAtMi4yMDktMS43OTEtNC00LTRzLTQsMS43OTEtNCw0YzAsMS4yNTQsMCw5Ljc0MSwwLDExYzAsMi4yMDksMS43OTEsNCw0LDRzNC0xLjc5MSw0LTRcdEMzMywxNy43NDEsMzMsOS4yNTQsMzMsOHpcIlxuICAgIH1cbiAgKSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcInBhdGhcIixcbiAgICB7XG4gICAgICBmaWxsOiBcIiMzM2QzNzVcIixcbiAgICAgIGQ6IFwiTTQzLDE5YzAsMi4yMDktMS43OTEsNC00LDRjLTEuMTk1LDAtNCwwLTQsMHMwLTIuOTg2LDAtNGMwLTIuMjA5LDEuNzkxLTQsNC00UzQzLDE2Ljc5MSw0MywxOXpcIlxuICAgIH1cbiAgKSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcInBhdGhcIixcbiAgICB7XG4gICAgICBmaWxsOiBcIiM0MGM0ZmZcIixcbiAgICAgIGQ6IFwiTTgsMTRjLTIuMjA5LDAtNCwxLjc5MS00LDRzMS43OTEsNCw0LDRjMS4yNTQsMCw5Ljc0MSwwLDExLDBjMi4yMDksMCw0LTEuNzkxLDQtNHMtMS43OTEtNC00LTRcdEMxNy43NDEsMTQsOS4yNTQsMTQsOCwxNHpcIlxuICAgIH1cbiAgKSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcInBhdGhcIixcbiAgICB7XG4gICAgICBmaWxsOiBcIiM0MGM0ZmZcIixcbiAgICAgIGQ6IFwiTTE5LDRjMi4yMDksMCw0LDEuNzkxLDQsNGMwLDEuMTk1LDAsNCwwLDRzLTIuOTg2LDAtNCwwYy0yLjIwOSwwLTQtMS43OTEtNC00UzE2Ljc5MSw0LDE5LDR6XCJcbiAgICB9XG4gICksXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJwYXRoXCIsXG4gICAge1xuICAgICAgZmlsbDogXCIjZTkxZTYzXCIsXG4gICAgICBkOiBcIk0xNCwzOS4wMDZDMTQsNDEuMjEyLDE1Ljc5MSw0MywxOCw0M3M0LTEuNzg4LDQtMy45OTRjMC0xLjI1MiwwLTkuNzI3LDAtMTAuOTg0XHRjMC0yLjIwNi0xLjc5MS0zLjk5NC00LTMuOTk0cy00LDEuNzg4LTQsMy45OTRDMTQsMjkuMjc5LDE0LDM3Ljc1NCwxNCwzOS4wMDZ6XCJcbiAgICB9XG4gICksXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJwYXRoXCIsXG4gICAge1xuICAgICAgZmlsbDogXCIjZTkxZTYzXCIsXG4gICAgICBkOiBcIk00LDI4LjAyMmMwLTIuMjA2LDEuNzkxLTMuOTk0LDQtMy45OTRjMS4xOTUsMCw0LDAsNCwwczAsMi45ODEsMCwzLjk5NGMwLDIuMjA2LTEuNzkxLDMuOTk0LTQsMy45OTRcdFM0LDMwLjIyOCw0LDI4LjAyMnpcIlxuICAgIH1cbiAgKSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcInBhdGhcIixcbiAgICB7XG4gICAgICBmaWxsOiBcIiNmZmMxMDdcIixcbiAgICAgIGQ6IFwiTTM5LDMzYzIuMjA5LDAsNC0xLjc5MSw0LTRzLTEuNzkxLTQtNC00Yy0xLjI1NCwwLTkuNzQxLDAtMTEsMGMtMi4yMDksMC00LDEuNzkxLTQsNHMxLjc5MSw0LDQsNFx0QzI5LjI1OCwzMywzNy43NDYsMzMsMzksMzN6XCJcbiAgICB9XG4gICksXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJwYXRoXCIsXG4gICAge1xuICAgICAgZmlsbDogXCIjZmZjMTA3XCIsXG4gICAgICBkOiBcIk0yOCw0M2MtMi4yMDksMC00LTEuNzkxLTQtNGMwLTEuMTk1LDAtNCwwLTRzMi45ODYsMCw0LDBjMi4yMDksMCw0LDEuNzkxLDQsNFMzMC4yMDksNDMsMjgsNDN6XCJcbiAgICB9XG4gIClcbiksIEgxID0gKCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgXCJzdmdcIixcbiAge1xuICAgIGNsYXNzTmFtZTogTCgpLFxuICAgIHdpZHRoOiBcIjUxMlwiLFxuICAgIGhlaWdodDogXCI1MTJcIixcbiAgICB2aWV3Qm94OiBcIjAgMCA1MTIgNTEyXCIsXG4gICAgZmlsbDogXCJub25lXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICB9LFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwicGF0aFwiLFxuICAgIHtcbiAgICAgIGQ6IFwiTTI1NS40OTggMzEuMDAzNEMxMzEuNTEzIDMxLjAwMzQgMzEgMTMxLjUxNSAzMSAyNTUuNTAyQzMxIDM3OS40OTIgMTMxLjUxMyA0ODAgMjU1LjQ5OCA0ODBDMzc5LjQ5NyA0ODAgNDgwIDM3OS40OTUgNDgwIDI1NS41MDJDNDgwIDEzMS41MjIgMzc5LjQ5NyAzMS4wMTM1IDI1NS40OTUgMzEuMDEzNUwyNTUuNDk4IDMxVjMxLjAwMzRaTTM1OC40NTMgMzU0Ljc5OEMzNTQuNDMyIDM2MS4zOTEgMzQ1LjgwMSAzNjMuNDg2IDMzOS4yMDQgMzU5LjQzNUMyODYuNDk2IDMyNy4yMzcgMjIwLjEzOSAzMTkuOTQ3IDE0MS45OTMgMzM3LjgwMUMxMzQuNDYzIDMzOS41MTYgMTI2Ljk1NyAzMzQuNzk4IDEyNS4yNCAzMjcuMjY0QzEyMy41MTYgMzE5LjczMSAxMjguMjE3IDMxMi4yMjUgMTM1Ljc2NyAzMTAuNTExQzIyMS4yODQgMjkwLjk3MiAyOTQuNjM5IDI5OS4zODQgMzUzLjgxNiAzMzUuNTQ5QzM2MC40MTMgMzM5LjU5NiAzNjIuNTA0IDM0OC4yIDM1OC40NTMgMzU0Ljc5OFpNMzg1LjkzMiAyOTMuNjdDMzgwLjg2NCAzMDEuOTAzIDM3MC4wODggMzA0LjUwMyAzNjEuODU4IDI5OS40MzhDMzAxLjUxMiAyNjIuMzQ1IDIwOS41MjggMjUxLjYwMiAxMzguMTUxIDI3My4yNzJDMTI4Ljg5MyAyNzYuMDY3IDExOS4xMTggMjcwLjg1MSAxMTYuMzA5IDI2MS42MUMxMTMuNTIxIDI1Mi4zNTMgMTE4Ljc0IDI0Mi41OTcgMTI3Ljk4MSAyMzkuNzgyQzIwOS41MTIgMjE1LjA0NCAzMTAuODcgMjI3LjAyNiAzODAuMTcgMjY5LjYxMkMzODguNCAyNzQuNjggMzkxIDI4NS40NTYgMzg1LjkzNSAyOTMuNjc2VjI5My42NzNMMzg1LjkzMiAyOTMuNjdaTTM4OC4yOTMgMjMwLjAxNkMzMTUuOTM1IDE4Ny4wMzkgMTk2LjU2IDE4My4wODkgMTI3LjQ3OSAyMDQuMDU1QzExNi4zODcgMjA3LjQyIDEwNC42NTQgMjAxLjE1OSAxMDEuMjkzIDE5MC4wNjNDOTcuOTMyNiAxNzguOTY0IDEwNC4xODkgMTY3LjI0MSAxMTUuMjg5IDE2My44N0MxOTQuNTkgMTM5Ljc5NiAzMjYuNDE4IDE0NC40NDYgNDA5LjcyMyAxOTMuOTAyQzQxOS43MjIgMTk5LjgyNiA0MjIuOTk1IDIxMi43MSA0MTcuMDY4IDIyMi42NzVDNDExLjE2OCAyMzIuNjUzIDM5OC4yNDcgMjM1Ljk0MyAzODguMzAzIDIzMC4wMTZIMzg4LjI5M1YyMzAuMDE2WlwiLFxuICAgICAgZmlsbDogXCIjMUVENzYwXCJcbiAgICB9XG4gIClcbiksIFAxID0gKCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgXCJzdmdcIixcbiAge1xuICAgIGNsYXNzTmFtZTogTCgpLFxuICAgIHdpZHRoOiBcIjUxMlwiLFxuICAgIGhlaWdodDogXCI1MTJcIixcbiAgICB2aWV3Qm94OiBcIjAgMCA1MTIgNTEyXCIsXG4gICAgZmlsbDogXCJub25lXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICB9LFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTQxNiAyNDBMMzUyIDMwNEgyODhMMjMyIDM2MFYzMDRIMTYwVjY0SDQxNlYyNDBaXCIsIGZpbGw6IFwid2hpdGVcIiB9KSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcInBhdGhcIixcbiAgICB7XG4gICAgICBkOiBcIk0xNDQgMzJMNjQgMTEyVjQwMEgxNjBWNDgwTDI0MCA0MDBIMzA0TDQ0OCAyNTZWMzJIMTQ0Wk00MTYgMjQwTDM1MiAzMDRIMjg4TDIzMiAzNjBWMzA0SDE2MFY2NEg0MTZWMjQwWlwiLFxuICAgICAgZmlsbDogXCIjOTE0NkZGXCJcbiAgICB9XG4gICksXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMzY4IDEyMEgzMzZWMjE2SDM2OFYxMjBaXCIsIGZpbGw6IFwiIzkxNDZGRlwiIH0pLFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTI4MCAxMjBIMjQ4VjIxNkgyODBWMTIwWlwiLCBmaWxsOiBcIiM5MTQ2RkZcIiB9KVxuKSwgVjEgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICBcInN2Z1wiLFxuICB7XG4gICAgY2xhc3NOYW1lOiBMKCksXG4gICAgd2lkdGg6IFwiNTEyXCIsXG4gICAgaGVpZ2h0OiBcIjUxMlwiLFxuICAgIHZpZXdCb3g6IFwiMCAwIDUxMiA1MTJcIixcbiAgICBmaWxsOiBcIm5vbmVcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gIH0sXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJwYXRoXCIsXG4gICAge1xuICAgICAgZDogXCJNMzMgMjU2LjA0M0MzMyAyNjQuNTU2IDM1LjMxNTkgMjczLjA2OSAzOS40ODQ1IDI4MC4yMDJMMTE3Ljk5MyA0MTUuNDkzQzEyNi4wOTggNDI5LjI5OCAxMzguMzczIDQ0MC41NzIgMTUzLjY1NyA0NDUuNjM0QzE4My43NjQgNDU1LjUyOCAyMTQuNzk3IDQ0Mi44NzMgMjI5LjYxOCA0MTcuMzMzTDI0OC42MDkgMzg0LjY2MUwxNzMuODA2IDI1Ni4wNDNMMjUyLjc3NyAxMTkuODMxTDI3MS43NjggODcuMTU5MUMyNzcuNTU3IDc3LjI2NTQgMjg0Ljk2OCA2OS40NDI0IDI5NCA2M0gyODUuODk0SDE3Mi4xODVDMTUwLjg3OCA2MyAxMzEuMTkzIDc0LjI3NDIgMTIwLjU0IDkyLjY4MTJMMzkuNzE2MSAyMzEuODg0QzM1LjMxNTkgMjM5LjAxNiAzMyAyNDcuNTMgMzMgMjU2LjA0M1pcIixcbiAgICAgIGZpbGw6IFwiIzYzNjNGMVwiXG4gICAgfVxuICApLFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwicGF0aFwiLFxuICAgIHtcbiAgICAgIGQ6IFwiTTQ4MCAyNTYuMDU4QzQ4MCAyNDcuNTM5IDQ3Ny42ODQgMjM5LjAyMSA0NzMuNTE2IDIzMS44ODNMMzkzLjg0OSA5NC42NTk2QzM3OS4wMjggNjkuMzMzMSAzNDcuOTk1IDU2LjQzOTYgMzE3Ljg4OCA2Ni4zNEMzMDIuNjAzIDcxLjQwNTMgMjkwLjMyOSA4Mi42ODcxIDI4Mi4yMjQgOTYuNTAxNUwyNjQuMzkxIDEyNy4zNTRMMzM5LjE5NCAyNTYuMDU4TDI2MC4yMjMgMzkyLjEzMUwyNDEuMjMyIDQyNC44MjVDMjM1LjQ0MyA0MzQuNDk1IDIyOC4wMzIgNDQyLjU1MyAyMTkgNDQ5SDIyNy4xMDZIMzQwLjgxNUMzNjIuMTIyIDQ0OSAzODEuODA3IDQzNy43MTggMzkyLjQ2IDQxOS4yOTlMNDczLjI4NCAyODAuMDAzQzQ3Ny42ODQgMjcyLjg2NiA0ODAgMjY0LjU3NyA0ODAgMjU2LjA1OFpcIixcbiAgICAgIGZpbGw6IFwiIzYzNjNGMVwiXG4gICAgfVxuICApXG4pLCBJMSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gIFwic3ZnXCIsXG4gIHtcbiAgICBjbGFzc05hbWU6IEwoKSxcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIHdpZHRoOiBcIjI1MDBcIixcbiAgICBoZWlnaHQ6IFwiMjUwMFwiLFxuICAgIHZpZXdCb3g6IFwiMCAwIDI1NiAyNTZcIlxuICB9LFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwicGF0aFwiLFxuICAgIHtcbiAgICAgIGZpbGw6IFwiI0ZGRTgxMlwiLFxuICAgICAgZDogXCJNMjU2IDIzNmMwIDExLjA0Ni04Ljk1NCAyMC0yMCAyMEgyMGMtMTEuMDQ2IDAtMjAtOC45NTQtMjAtMjBWMjBDMCA4Ljk1NCA4Ljk1NCAwIDIwIDBoMjE2YzExLjA0NiAwIDIwIDguOTU0IDIwIDIwdjIxNnpcIlxuICAgIH1cbiAgKSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0xMjggMzZDNzAuNTYyIDM2IDI0IDcyLjcxMyAyNCAxMThjMCAyOS4yNzkgMTkuNDY2IDU0Ljk3IDQ4Ljc0OCA2OS40NzctMS41OTMgNS40OTQtMTAuMjM3IDM1LjM0NC0xMC41ODEgMzcuNjg5IDAgMC0uMjA3IDEuNzYyLjkzNCAyLjQzNHMyLjQ4My4xNSAyLjQ4My4xNWMzLjI3Mi0uNDU3IDM3Ljk0My0yNC44MTEgNDMuOTQ0LTI5LjA0IDUuOTk1Ljg0OSAxMi4xNjggMS4yOSAxOC40NzIgMS4yOSA1Ny40MzggMCAxMDQtMzYuNzEyIDEwNC04MiAwLTQ1LjI4Ny00Ni41NjItODItMTA0LTgyelwiIH0pLFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwicGF0aFwiLFxuICAgIHtcbiAgICAgIGZpbGw6IFwiI0ZGRTgxMlwiLFxuICAgICAgZDogXCJNNzAuNSAxNDYuNjI1Yy0zLjMwOSAwLTYtMi41Ny02LTUuNzNWMTA1LjI1aC05LjM2MmMtMy4yNDcgMC01Ljg4OC0yLjYzNi01Ljg4OC01Ljg3NXMyLjY0Mi01Ljg3NSA1Ljg4OC01Ljg3NWgzMC43MjRjMy4yNDcgMCA1Ljg4OCAyLjYzNiA1Ljg4OCA1Ljg3NXMtMi42NDIgNS44NzUtNS44ODggNS44NzVINzYuNXYzNS42NDVjMCAzLjE2LTIuNjkxIDUuNzMtNiA1Ljczek0xMjMuMTEyIDE0Ni41NDdjLTIuNTAyIDAtNC40MTYtMS4wMTYtNC45OTMtMi42NWwtMi45NzEtNy43NzgtMTguMjk2LS4wMDEtMi45NzMgNy43ODNjLS41NzUgMS42MzEtMi40ODggMi42NDYtNC45OSAyLjY0NmE5LjE1NSA5LjE1NSAwIDAgMS0zLjgxNC0uODI4Yy0xLjY1NC0uNzYzLTMuMjQ0LTIuODYxLTEuNDIyLTguNTJsMTQuMzUyLTM3Ljc3NmMxLjAxMS0yLjg3MyA0LjA4Mi01LjgzMyA3Ljk5LTUuOTIyIDMuOTE5LjA4OCA2Ljk5IDMuMDQ5IDguMDAzIDUuOTI4bDE0LjM0NiAzNy43NTljMS44MjYgNS42NzIuMjM2IDcuNzcxLTEuNDE4IDguNTMyYTkuMTc2IDkuMTc2IDAgMCAxLTMuODE0LjgyN2MtLjAwMSAwIDAgMCAwIDB6bS0xMS4xMTktMjEuMDU2TDEwNiAxMDguNDY2bC01Ljk5MyAxNy4wMjVoMTEuOTg2ek0xMzggMTQ1Ljc1Yy0zLjE3MSAwLTUuNzUtMi40NjgtNS43NS01LjVWOTkuNWMwLTMuMzA5IDIuNzQ4LTYgNi4xMjUtNnM2LjEyNSAyLjY5MSA2LjEyNSA2djM1LjI1aDEyLjc1YzMuMTcxIDAgNS43NSAyLjQ2OCA1Ljc1IDUuNXMtMi41NzkgNS41LTUuNzUgNS41SDEzOHpNMTcxLjMzNCAxNDYuNTQ3Yy0zLjMwOSAwLTYtMi42OTEtNi02Vjk5LjVjMC0zLjMwOSAyLjY5MS02IDYtNnM2IDIuNjkxIDYgNnYxMi44OTZsMTYuNzQtMTYuNzRjLjg2MS0uODYxIDIuMDQ0LTEuMzM1IDMuMzI4LTEuMzM1IDEuNDk4IDAgMy4wMDIuNjQ2IDQuMTI5IDEuNzcyIDEuMDUxIDEuMDUgMS42NzggMi40MDEgMS43NjQgMy44MDQuMDg3IDEuNDE1LS4zODQgMi43MTItMS4zMjQgMy42NTNsLTEzLjY3MyAxMy42NzEgMTQuNzY5IDE5LjU2NmE1Ljk1MSA1Ljk1MSAwIDAgMSAxLjE1MiA0LjQ0NSA1Ljk1NiA1Ljk1NiAwIDAgMS0yLjMyOCAzLjk1NyA1Ljk0IDUuOTQgMCAwIDEtMy42MDkgMS4yMTEgNS45NTMgNS45NTMgMCAwIDEtNC43OTMtMi4zODVsLTE0LjA3MS0xOC42NDQtMi4wODIgMi4wODJ2MTMuMDkxYTYuMDEgNi4wMSAwIDAgMS02LjAwMiA2LjAwM3pcIlxuICAgIH1cbiAgKVxuKTtcbmZ1bmN0aW9uIEExKHtcbiAgc3VwYWJhc2VDbGllbnQ6IHQsXG4gIHNvY2lhbExheW91dDogbCA9IFwidmVydGljYWxcIixcbiAgcHJvdmlkZXJzOiBuID0gW1wiZ2l0aHViXCIsIFwiZ29vZ2xlXCIsIFwiYXp1cmVcIl0sXG4gIHByb3ZpZGVyU2NvcGVzOiByLFxuICBxdWVyeVBhcmFtczogbyxcbiAgcmVkaXJlY3RUbzogdixcbiAgb25seVRoaXJkUGFydHlQcm92aWRlcnM6IEUgPSAhMCxcbiAgdmlldzogQyA9IFwic2lnbl9pblwiLFxuICBpMThuOiB3LFxuICBhcHBlYXJhbmNlOiBkXG59KSB7XG4gIGNvbnN0IFtpLCBtXSA9IHUoITEpLCBbYywgeV0gPSB1KFwiXCIpLCB4ID0gbCA9PT0gXCJ2ZXJ0aWNhbFwiLCBhID0gQyA9PT0gXCJtYWdpY19saW5rXCIgPyBcInNpZ25faW5cIiA6IEMsIF8gPSBhc3luYyAoZykgPT4ge1xuICAgIG0oITApO1xuICAgIGNvbnN0IHsgZXJyb3I6IHMgfSA9IGF3YWl0IHQuYXV0aC5zaWduSW5XaXRoT0F1dGgoe1xuICAgICAgcHJvdmlkZXI6IGcsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHJlZGlyZWN0VG86IHYsXG4gICAgICAgIHNjb3BlczogciA9PSBudWxsID8gdm9pZCAwIDogcltnXSxcbiAgICAgICAgcXVlcnlQYXJhbXM6IG9cbiAgICAgIH1cbiAgICB9KTtcbiAgICBzICYmIHkocy5tZXNzYWdlKSwgbSghMSk7XG4gIH07XG4gIGZ1bmN0aW9uIGgoZykge1xuICAgIGNvbnN0IHMgPSBnLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIGcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzLnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KGUuRnJhZ21lbnQsIG51bGwsIG4gJiYgbi5sZW5ndGggPiAwICYmIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoZS5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChOLCB7IGdhcDogXCJsYXJnZVwiLCBkaXJlY3Rpb246IFwidmVydGljYWxcIiwgYXBwZWFyYW5jZTogZCB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIE4sXG4gICAge1xuICAgICAgZGlyZWN0aW9uOiB4ID8gXCJ2ZXJ0aWNhbFwiIDogXCJob3Jpem9udGFsXCIsXG4gICAgICBnYXA6IHggPyBcInNtYWxsXCIgOiBcIm1lZGl1bVwiLFxuICAgICAgYXBwZWFyYW5jZTogZFxuICAgIH0sXG4gICAgbi5tYXAoKGcpID0+IHtcbiAgICAgIHZhciBzO1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIFUsXG4gICAgICAgIHtcbiAgICAgICAgICBrZXk6IGcsXG4gICAgICAgICAgY29sb3I6IFwiZGVmYXVsdFwiLFxuICAgICAgICAgIGxvYWRpbmc6IGksXG4gICAgICAgICAgb25DbGljazogKCkgPT4gXyhnKSxcbiAgICAgICAgICBhcHBlYXJhbmNlOiBkXG4gICAgICAgIH0sXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXzEsIHsgcHJvdmlkZXI6IGcgfSksXG4gICAgICAgIHggJiYgYzEoXG4gICAgICAgICAgKHMgPSB3ID09IG51bGwgPyB2b2lkIDAgOiB3W2FdKSA9PSBudWxsID8gdm9pZCAwIDogcy5zb2NpYWxfcHJvdmlkZXJfdGV4dCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwcm92aWRlcjogaChnKVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9KVxuICApKSwgIUUgJiYgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChDMSwgeyBhcHBlYXJhbmNlOiBkIH0pKSk7XG59XG5mdW5jdGlvbiBRKHtcbiAgYXV0aFZpZXc6IHQgPSBcInNpZ25faW5cIixcbiAgZGVmYXVsdEVtYWlsOiBsID0gXCJcIixcbiAgZGVmYXVsdFBhc3N3b3JkOiBuID0gXCJcIixcbiAgc2V0QXV0aFZpZXc6IHIgPSAoKSA9PiB7XG4gIH0sXG4gIHNldERlZmF1bHRFbWFpbDogbyA9ICh4KSA9PiB7XG4gIH0sXG4gIHNldERlZmF1bHRQYXNzd29yZDogdiA9ICh4KSA9PiB7XG4gIH0sXG4gIHN1cGFiYXNlQ2xpZW50OiBFLFxuICBzaG93TGlua3M6IEMgPSAhMSxcbiAgcmVkaXJlY3RUbzogdyxcbiAgYWRkaXRpb25hbERhdGE6IGQsXG4gIG1hZ2ljTGluazogaSxcbiAgaTE4bjogbSxcbiAgYXBwZWFyYW5jZTogYyxcbiAgY2hpbGRyZW46IHlcbn0pIHtcbiAgdmFyIFQsIEcsIFosIGo7XG4gIGNvbnN0IHggPSBtMSghMCksIFthLCBfXSA9IHUobCksIFtoLCBnXSA9IHUobiksIFtzLCBNXSA9IHUoXCJcIiksIFtwLCBCXSA9IHUoITEpLCBbUCwgQV0gPSB1KFwiXCIpO1xuICBSKCgpID0+ICh4LmN1cnJlbnQgPSAhMCwgXyhsKSwgZyhuKSwgKCkgPT4ge1xuICAgIHguY3VycmVudCA9ICExO1xuICB9KSwgW3RdKTtcbiAgY29uc3QgTyA9IGFzeW5jIChrKSA9PiB7XG4gICAgdmFyIHE7XG4gICAgc3dpdGNoIChrLnByZXZlbnREZWZhdWx0KCksIE0oXCJcIiksIEIoITApLCB0KSB7XG4gICAgICBjYXNlIFwic2lnbl9pblwiOlxuICAgICAgICBjb25zdCB7IGVycm9yOiBLIH0gPSBhd2FpdCBFLmF1dGguc2lnbkluV2l0aFBhc3N3b3JkKHtcbiAgICAgICAgICBlbWFpbDogYSxcbiAgICAgICAgICBwYXNzd29yZDogaFxuICAgICAgICB9KTtcbiAgICAgICAgSyAmJiBNKEsubWVzc2FnZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNpZ25fdXBcIjpcbiAgICAgICAgbGV0IFkgPSB7XG4gICAgICAgICAgZW1haWxSZWRpcmVjdFRvOiB3XG4gICAgICAgIH07XG4gICAgICAgIGQgJiYgKFkuZGF0YSA9IGQpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZGF0YTogeyB1c2VyOiByMSwgc2Vzc2lvbjogbzEgfSxcbiAgICAgICAgICBlcnJvcjogSlxuICAgICAgICB9ID0gYXdhaXQgRS5hdXRoLnNpZ25VcCh7XG4gICAgICAgICAgZW1haWw6IGEsXG4gICAgICAgICAgcGFzc3dvcmQ6IGgsXG4gICAgICAgICAgb3B0aW9uczogWVxuICAgICAgICB9KTtcbiAgICAgICAgSiA/IE0oSi5tZXNzYWdlKSA6IHIxICYmICFvMSAmJiBBKChxID0gbSA9PSBudWxsID8gdm9pZCAwIDogbS5zaWduX3VwKSA9PSBudWxsID8gdm9pZCAwIDogcS5jb25maXJtYXRpb25fdGV4dCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB4LmN1cnJlbnQgJiYgQighMSk7XG4gIH0sIHogPSAoaykgPT4ge1xuICAgIG8oYSksIHYoaCksIHIoayk7XG4gIH0sIGYgPSBtID09IG51bGwgPyB2b2lkIDAgOiBtW3RdO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcImZvcm1cIixcbiAgICB7XG4gICAgICBpZDogdCA9PT0gXCJzaWduX2luXCIgPyBcImF1dGgtc2lnbi1pblwiIDogXCJhdXRoLXNpZ24tdXBcIixcbiAgICAgIG9uU3VibWl0OiBPLFxuICAgICAgYXV0b0NvbXBsZXRlOiBcIm9uXCIsXG4gICAgICBzdHlsZTogeyB3aWR0aDogXCIxMDAlXCIgfVxuICAgIH0sXG4gICAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChOLCB7IGRpcmVjdGlvbjogXCJ2ZXJ0aWNhbFwiLCBnYXA6IFwibGFyZ2VcIiwgYXBwZWFyYW5jZTogYyB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KE4sIHsgZGlyZWN0aW9uOiBcInZlcnRpY2FsXCIsIGdhcDogXCJsYXJnZVwiLCBhcHBlYXJhbmNlOiBjIH0sIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChILCB7IGh0bWxGb3I6IFwiZW1haWxcIiwgYXBwZWFyYW5jZTogYyB9LCBmID09IG51bGwgPyB2b2lkIDAgOiBmLmVtYWlsX2xhYmVsKSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICAgIEQsXG4gICAgICB7XG4gICAgICAgIGlkOiBcImVtYWlsXCIsXG4gICAgICAgIHR5cGU6IFwiZW1haWxcIixcbiAgICAgICAgbmFtZTogXCJlbWFpbFwiLFxuICAgICAgICBwbGFjZWhvbGRlcjogZiA9PSBudWxsID8gdm9pZCAwIDogZi5lbWFpbF9pbnB1dF9wbGFjZWhvbGRlcixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBhLFxuICAgICAgICBvbkNoYW5nZTogKGspID0+IF8oay50YXJnZXQudmFsdWUpLFxuICAgICAgICBhdXRvQ29tcGxldGU6IFwiZW1haWxcIixcbiAgICAgICAgYXBwZWFyYW5jZTogY1xuICAgICAgfVxuICAgICkpLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoSCwgeyBodG1sRm9yOiBcInBhc3N3b3JkXCIsIGFwcGVhcmFuY2U6IGMgfSwgZiA9PSBudWxsID8gdm9pZCAwIDogZi5wYXNzd29yZF9sYWJlbCksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBELFxuICAgICAge1xuICAgICAgICBpZDogXCJwYXNzd29yZFwiLFxuICAgICAgICB0eXBlOiBcInBhc3N3b3JkXCIsXG4gICAgICAgIG5hbWU6IFwicGFzc3dvcmRcIixcbiAgICAgICAgcGxhY2Vob2xkZXI6IGYgPT0gbnVsbCA/IHZvaWQgMCA6IGYucGFzc3dvcmRfaW5wdXRfcGxhY2Vob2xkZXIsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogaCxcbiAgICAgICAgb25DaGFuZ2U6IChrKSA9PiBnKGsudGFyZ2V0LnZhbHVlKSxcbiAgICAgICAgYXV0b0NvbXBsZXRlOiB0ID09PSBcInNpZ25faW5cIiA/IFwiY3VycmVudC1wYXNzd29yZFwiIDogXCJuZXctcGFzc3dvcmRcIixcbiAgICAgICAgYXBwZWFyYW5jZTogY1xuICAgICAgfVxuICAgICkpLCB5KSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICAgIFUsXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwic3VibWl0XCIsXG4gICAgICAgIGNvbG9yOiBcInByaW1hcnlcIixcbiAgICAgICAgbG9hZGluZzogcCxcbiAgICAgICAgYXBwZWFyYW5jZTogY1xuICAgICAgfSxcbiAgICAgIHAgPyBmID09IG51bGwgPyB2b2lkIDAgOiBmLmxvYWRpbmdfYnV0dG9uX2xhYmVsIDogZiA9PSBudWxsID8gdm9pZCAwIDogZi5idXR0b25fbGFiZWxcbiAgICApLCBDICYmIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoTiwgeyBkaXJlY3Rpb246IFwidmVydGljYWxcIiwgZ2FwOiBcInNtYWxsXCIsIGFwcGVhcmFuY2U6IGMgfSwgdCA9PT0gYi5TSUdOX0lOICYmIGkgJiYgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICAgIFYsXG4gICAgICB7XG4gICAgICAgIGhyZWY6IFwiI2F1dGgtbWFnaWMtbGlua1wiLFxuICAgICAgICBvbkNsaWNrOiAoaykgPT4ge1xuICAgICAgICAgIGsucHJldmVudERlZmF1bHQoKSwgcihiLk1BR0lDX0xJTkspO1xuICAgICAgICB9LFxuICAgICAgICBhcHBlYXJhbmNlOiBjXG4gICAgICB9LFxuICAgICAgKFQgPSBtID09IG51bGwgPyB2b2lkIDAgOiBtLm1hZ2ljX2xpbmspID09IG51bGwgPyB2b2lkIDAgOiBULmxpbmtfdGV4dFxuICAgICksIHQgPT09IGIuU0lHTl9JTiAmJiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgICAgVixcbiAgICAgIHtcbiAgICAgICAgaHJlZjogXCIjYXV0aC1mb3Jnb3QtcGFzc3dvcmRcIixcbiAgICAgICAgb25DbGljazogKGspID0+IHtcbiAgICAgICAgICBrLnByZXZlbnREZWZhdWx0KCksIHIoYi5GT1JHT1RURU5fUEFTU1dPUkQpO1xuICAgICAgICB9LFxuICAgICAgICBhcHBlYXJhbmNlOiBjXG4gICAgICB9LFxuICAgICAgKEcgPSBtID09IG51bGwgPyB2b2lkIDAgOiBtLmZvcmdvdHRlbl9wYXNzd29yZCkgPT0gbnVsbCA/IHZvaWQgMCA6IEcubGlua190ZXh0XG4gICAgKSwgdCA9PT0gYi5TSUdOX0lOID8gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICAgIFYsXG4gICAgICB7XG4gICAgICAgIGhyZWY6IFwiI2F1dGgtc2lnbi11cFwiLFxuICAgICAgICBvbkNsaWNrOiAoaykgPT4ge1xuICAgICAgICAgIGsucHJldmVudERlZmF1bHQoKSwgeihiLlNJR05fVVApO1xuICAgICAgICB9LFxuICAgICAgICBhcHBlYXJhbmNlOiBjXG4gICAgICB9LFxuICAgICAgKFogPSBtID09IG51bGwgPyB2b2lkIDAgOiBtLnNpZ25fdXApID09IG51bGwgPyB2b2lkIDAgOiBaLmxpbmtfdGV4dFxuICAgICkgOiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgICAgVixcbiAgICAgIHtcbiAgICAgICAgaHJlZjogXCIjYXV0aC1zaWduLWluXCIsXG4gICAgICAgIG9uQ2xpY2s6IChrKSA9PiB7XG4gICAgICAgICAgay5wcmV2ZW50RGVmYXVsdCgpLCB6KGIuU0lHTl9JTik7XG4gICAgICAgIH0sXG4gICAgICAgIGFwcGVhcmFuY2U6IGNcbiAgICAgIH0sXG4gICAgICAoaiA9IG0gPT0gbnVsbCA/IHZvaWQgMCA6IG0uc2lnbl9pbikgPT0gbnVsbCA/IHZvaWQgMCA6IGoubGlua190ZXh0XG4gICAgKSkpLFxuICAgIFAgJiYgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChGLCB7IGFwcGVhcmFuY2U6IGMgfSwgUCksXG4gICAgcyAmJiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KEYsIHsgY29sb3I6IFwiZGFuZ2VyXCIsIGFwcGVhcmFuY2U6IGMgfSwgcylcbiAgKTtcbn1cbmZ1bmN0aW9uIGUxKHtcbiAgc2V0QXV0aFZpZXc6IHQgPSAoKSA9PiB7XG4gIH0sXG4gIHN1cGFiYXNlQ2xpZW50OiBsLFxuICByZWRpcmVjdFRvOiBuLFxuICBpMThuOiByLFxuICBhcHBlYXJhbmNlOiBvLFxuICBzaG93TGlua3M6IHYgPSAhMVxufSkge1xuICB2YXIgXztcbiAgY29uc3QgW0UsIENdID0gdShcIlwiKSwgW3csIGRdID0gdShcIlwiKSwgW2ksIG1dID0gdShcIlwiKSwgW2MsIHldID0gdSghMSksIHggPSBhc3luYyAoaCkgPT4ge1xuICAgIHZhciBzO1xuICAgIGgucHJldmVudERlZmF1bHQoKSwgZChcIlwiKSwgbShcIlwiKSwgeSghMCk7XG4gICAgY29uc3QgeyBlcnJvcjogZyB9ID0gYXdhaXQgbC5hdXRoLnJlc2V0UGFzc3dvcmRGb3JFbWFpbChFLCB7XG4gICAgICByZWRpcmVjdFRvOiBuXG4gICAgfSk7XG4gICAgZyA/IGQoZy5tZXNzYWdlKSA6IG0oKHMgPSByID09IG51bGwgPyB2b2lkIDAgOiByLmZvcmdvdHRlbl9wYXNzd29yZCkgPT0gbnVsbCA/IHZvaWQgMCA6IHMuY29uZmlybWF0aW9uX3RleHQpLCB5KCExKTtcbiAgfSwgYSA9IHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuZm9yZ290dGVuX3Bhc3N3b3JkO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImZvcm1cIiwgeyBpZDogXCJhdXRoLWZvcmdvdC1wYXNzd29yZFwiLCBvblN1Ym1pdDogeCB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KE4sIHsgZGlyZWN0aW9uOiBcInZlcnRpY2FsXCIsIGdhcDogXCJsYXJnZVwiLCBhcHBlYXJhbmNlOiBvIH0sIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoTiwgeyBnYXA6IFwibGFyZ2VcIiwgZGlyZWN0aW9uOiBcInZlcnRpY2FsXCIsIGFwcGVhcmFuY2U6IG8gfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KEgsIHsgaHRtbEZvcjogXCJlbWFpbFwiLCBhcHBlYXJhbmNlOiBvIH0sIGEgPT0gbnVsbCA/IHZvaWQgMCA6IGEuZW1haWxfbGFiZWwpLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIEQsXG4gICAge1xuICAgICAgaWQ6IFwiZW1haWxcIixcbiAgICAgIG5hbWU6IFwiZW1haWxcIixcbiAgICAgIHR5cGU6IFwiZW1haWxcIixcbiAgICAgIGF1dG9Gb2N1czogITAsXG4gICAgICBwbGFjZWhvbGRlcjogYSA9PSBudWxsID8gdm9pZCAwIDogYS5lbWFpbF9pbnB1dF9wbGFjZWhvbGRlcixcbiAgICAgIG9uQ2hhbmdlOiAoaCkgPT4gQyhoLnRhcmdldC52YWx1ZSksXG4gICAgICBhcHBlYXJhbmNlOiBvXG4gICAgfVxuICApKSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBVLFxuICAgIHtcbiAgICAgIHR5cGU6IFwic3VibWl0XCIsXG4gICAgICBjb2xvcjogXCJwcmltYXJ5XCIsXG4gICAgICBsb2FkaW5nOiBjLFxuICAgICAgYXBwZWFyYW5jZTogb1xuICAgIH0sXG4gICAgYyA/IGEgPT0gbnVsbCA/IHZvaWQgMCA6IGEubG9hZGluZ19idXR0b25fbGFiZWwgOiBhID09IG51bGwgPyB2b2lkIDAgOiBhLmJ1dHRvbl9sYWJlbFxuICApLCB2ICYmIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgVixcbiAgICB7XG4gICAgICBocmVmOiBcIiNhdXRoLXNpZ24taW5cIixcbiAgICAgIG9uQ2xpY2s6IChoKSA9PiB7XG4gICAgICAgIGgucHJldmVudERlZmF1bHQoKSwgdChiLlNJR05fSU4pO1xuICAgICAgfSxcbiAgICAgIGFwcGVhcmFuY2U6IG9cbiAgICB9LFxuICAgIChfID0gciA9PSBudWxsID8gdm9pZCAwIDogci5zaWduX2luKSA9PSBudWxsID8gdm9pZCAwIDogXy5saW5rX3RleHRcbiAgKSwgaSAmJiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KEYsIHsgYXBwZWFyYW5jZTogbyB9LCBpKSwgdyAmJiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KEYsIHsgY29sb3I6IFwiZGFuZ2VyXCIsIGFwcGVhcmFuY2U6IG8gfSwgdykpKSk7XG59XG5mdW5jdGlvbiB0MSh7XG4gIHN1cGFiYXNlQ2xpZW50OiB0LFxuICBpMThuOiBsLFxuICBhcHBlYXJhbmNlOiBuXG59KSB7XG4gIGNvbnN0IFtyLCBvXSA9IHUoXCJcIiksIFt2LCBFXSA9IHUoXCJcIiksIFtDLCB3XSA9IHUoXCJcIiksIFtkLCBpXSA9IHUoITEpLCBtID0gYXN5bmMgKHkpID0+IHtcbiAgICB2YXIgYTtcbiAgICB5LnByZXZlbnREZWZhdWx0KCksIEUoXCJcIiksIHcoXCJcIiksIGkoITApO1xuICAgIGNvbnN0IHsgZXJyb3I6IHggfSA9IGF3YWl0IHQuYXV0aC51cGRhdGVVc2VyKHsgcGFzc3dvcmQ6IHIgfSk7XG4gICAgeCA/IEUoeC5tZXNzYWdlKSA6IHcoKGEgPSBsID09IG51bGwgPyB2b2lkIDAgOiBsLnVwZGF0ZV9wYXNzd29yZCkgPT0gbnVsbCA/IHZvaWQgMCA6IGEuY29uZmlybWF0aW9uX3RleHQpLCBpKCExKTtcbiAgfSwgYyA9IGwgPT0gbnVsbCA/IHZvaWQgMCA6IGwudXBkYXRlX3Bhc3N3b3JkO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImZvcm1cIiwgeyBpZDogXCJhdXRoLXVwZGF0ZS1wYXNzd29yZFwiLCBvblN1Ym1pdDogbSB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KE4sIHsgZ2FwOiBcImxhcmdlXCIsIGRpcmVjdGlvbjogXCJ2ZXJ0aWNhbFwiLCBhcHBlYXJhbmNlOiBuIH0sIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChILCB7IGh0bWxGb3I6IFwicGFzc3dvcmRcIiwgYXBwZWFyYW5jZTogbiB9LCBjID09IG51bGwgPyB2b2lkIDAgOiBjLnBhc3N3b3JkX2xhYmVsKSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBELFxuICAgIHtcbiAgICAgIGlkOiBcInBhc3N3b3JkXCIsXG4gICAgICBuYW1lOiBcInBhc3N3b3JkXCIsXG4gICAgICBwbGFjZWhvbGRlcjogYyA9PSBudWxsID8gdm9pZCAwIDogYy5wYXNzd29yZF9pbnB1dF9wbGFjZWhvbGRlcixcbiAgICAgIHR5cGU6IFwicGFzc3dvcmRcIixcbiAgICAgIGF1dG9Gb2N1czogITAsXG4gICAgICBvbkNoYW5nZTogKHkpID0+IG8oeS50YXJnZXQudmFsdWUpLFxuICAgICAgYXBwZWFyYW5jZTogblxuICAgIH1cbiAgKSksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgVSxcbiAgICB7XG4gICAgICB0eXBlOiBcInN1Ym1pdFwiLFxuICAgICAgY29sb3I6IFwicHJpbWFyeVwiLFxuICAgICAgbG9hZGluZzogZCxcbiAgICAgIGFwcGVhcmFuY2U6IG5cbiAgICB9LFxuICAgIGQgPyBjID09IG51bGwgPyB2b2lkIDAgOiBjLmxvYWRpbmdfYnV0dG9uX2xhYmVsIDogYyA9PSBudWxsID8gdm9pZCAwIDogYy5idXR0b25fbGFiZWxcbiAgKSwgQyAmJiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KEYsIHsgYXBwZWFyYW5jZTogbiB9LCBDKSwgdiAmJiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KEYsIHsgY29sb3I6IFwiZGFuZ2VyXCIsIGFwcGVhcmFuY2U6IG4gfSwgdikpKTtcbn1cbmZ1bmN0aW9uIFUxKHtcbiAgc2V0QXV0aFZpZXc6IHQgPSAoKSA9PiB7XG4gIH0sXG4gIHN1cGFiYXNlQ2xpZW50OiBsLFxuICBvdHBUeXBlOiBuID0gXCJlbWFpbFwiLFxuICBpMThuOiByLFxuICBhcHBlYXJhbmNlOiBvLFxuICBzaG93TGlua3M6IHYgPSAhMVxufSkge1xuICB2YXIgTTtcbiAgY29uc3QgW0UsIENdID0gdShcIlwiKSwgW3csIGRdID0gdShcIlwiKSwgW2ksIG1dID0gdShcIlwiKSwgW2MsIHldID0gdShcIlwiKSwgW3gsIGFdID0gdShcIlwiKSwgW18sIGhdID0gdSghMSksIGcgPSBhc3luYyAocCkgPT4ge1xuICAgIHAucHJldmVudERlZmF1bHQoKSwgeShcIlwiKSwgYShcIlwiKSwgaCghMCk7XG4gICAgbGV0IEIgPSB7XG4gICAgICBlbWFpbDogRSxcbiAgICAgIHRva2VuOiBpLFxuICAgICAgdHlwZTogblxuICAgIH07XG4gICAgW1wic21zXCIsIFwicGhvbmVfY2hhbmdlXCJdLmluY2x1ZGVzKG4pICYmIChCID0ge1xuICAgICAgcGhvbmU6IHcsXG4gICAgICB0b2tlbjogaSxcbiAgICAgIHR5cGU6IG5cbiAgICB9KTtcbiAgICBjb25zdCB7IGVycm9yOiBQIH0gPSBhd2FpdCBsLmF1dGgudmVyaWZ5T3RwKEIpO1xuICAgIFAgJiYgeShQLm1lc3NhZ2UpLCBoKCExKTtcbiAgfSwgcyA9IHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIudmVyaWZ5X290cDtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIsIHsgaWQ6IFwiYXV0aC1tYWdpYy1saW5rXCIsIG9uU3VibWl0OiBnIH0sIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoTiwgeyBnYXA6IFwibGFyZ2VcIiwgZGlyZWN0aW9uOiBcInZlcnRpY2FsXCIsIGFwcGVhcmFuY2U6IG8gfSwgW1wic21zXCIsIFwicGhvbmVfY2hhbmdlXCJdLmluY2x1ZGVzKG4pID8gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KEgsIHsgaHRtbEZvcjogXCJwaG9uZVwiLCBhcHBlYXJhbmNlOiBvIH0sIHMgPT0gbnVsbCA/IHZvaWQgMCA6IHMucGhvbmVfaW5wdXRfbGFiZWwpLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIEQsXG4gICAge1xuICAgICAgaWQ6IFwicGhvbmVcIixcbiAgICAgIG5hbWU6IFwicGhvbmVcIixcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgYXV0b0ZvY3VzOiAhMCxcbiAgICAgIHBsYWNlaG9sZGVyOiBzID09IG51bGwgPyB2b2lkIDAgOiBzLnBob25lX2lucHV0X3BsYWNlaG9sZGVyLFxuICAgICAgb25DaGFuZ2U6IChwKSA9PiBkKHAudGFyZ2V0LnZhbHVlKSxcbiAgICAgIGFwcGVhcmFuY2U6IG9cbiAgICB9XG4gICkpIDogLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KEgsIHsgaHRtbEZvcjogXCJlbWFpbFwiLCBhcHBlYXJhbmNlOiBvIH0sIHMgPT0gbnVsbCA/IHZvaWQgMCA6IHMuZW1haWxfaW5wdXRfbGFiZWwpLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIEQsXG4gICAge1xuICAgICAgaWQ6IFwiZW1haWxcIixcbiAgICAgIG5hbWU6IFwiZW1haWxcIixcbiAgICAgIHR5cGU6IFwiZW1haWxcIixcbiAgICAgIGF1dG9Gb2N1czogITAsXG4gICAgICBwbGFjZWhvbGRlcjogcyA9PSBudWxsID8gdm9pZCAwIDogcy5lbWFpbF9pbnB1dF9wbGFjZWhvbGRlcixcbiAgICAgIG9uQ2hhbmdlOiAocCkgPT4gQyhwLnRhcmdldC52YWx1ZSksXG4gICAgICBhcHBlYXJhbmNlOiBvXG4gICAgfVxuICApKSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KEgsIHsgaHRtbEZvcjogXCJ0b2tlblwiLCBhcHBlYXJhbmNlOiBvIH0sIHMgPT0gbnVsbCA/IHZvaWQgMCA6IHMudG9rZW5faW5wdXRfbGFiZWwpLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIEQsXG4gICAge1xuICAgICAgaWQ6IFwidG9rZW5cIixcbiAgICAgIG5hbWU6IFwidG9rZW5cIixcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgcGxhY2Vob2xkZXI6IHMgPT0gbnVsbCA/IHZvaWQgMCA6IHMudG9rZW5faW5wdXRfcGxhY2Vob2xkZXIsXG4gICAgICBvbkNoYW5nZTogKHApID0+IG0ocC50YXJnZXQudmFsdWUpLFxuICAgICAgYXBwZWFyYW5jZTogb1xuICAgIH1cbiAgKSksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgVSxcbiAgICB7XG4gICAgICBjb2xvcjogXCJwcmltYXJ5XCIsXG4gICAgICB0eXBlOiBcInN1Ym1pdFwiLFxuICAgICAgbG9hZGluZzogXyxcbiAgICAgIGFwcGVhcmFuY2U6IG9cbiAgICB9LFxuICAgIF8gPyBzID09IG51bGwgPyB2b2lkIDAgOiBzLmxvYWRpbmdfYnV0dG9uX2xhYmVsIDogcyA9PSBudWxsID8gdm9pZCAwIDogcy5idXR0b25fbGFiZWxcbiAgKSwgdiAmJiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFYsXG4gICAge1xuICAgICAgaHJlZjogXCIjYXV0aC1zaWduLWluXCIsXG4gICAgICBvbkNsaWNrOiAocCkgPT4ge1xuICAgICAgICBwLnByZXZlbnREZWZhdWx0KCksIHQoYi5TSUdOX0lOKTtcbiAgICAgIH0sXG4gICAgICBhcHBlYXJhbmNlOiBvXG4gICAgfSxcbiAgICAoTSA9IHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuc2lnbl9pbikgPT0gbnVsbCA/IHZvaWQgMCA6IE0ubGlua190ZXh0XG4gICksIHggJiYgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChGLCB7IGFwcGVhcmFuY2U6IG8gfSwgeCksIGMgJiYgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChGLCB7IGNvbG9yOiBcImRhbmdlclwiLCBhcHBlYXJhbmNlOiBvIH0sIGMpKSk7XG59XG5jb25zdCBsMSA9IGQxKHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9KSwgUjEgPSAodCkgPT4ge1xuICBjb25zdCB7IHN1cGFiYXNlQ2xpZW50OiBsIH0gPSB0LCBbbiwgcl0gPSB1KG51bGwpLCBbbywgdl0gPSB1KChuID09IG51bGwgPyB2b2lkIDAgOiBuLnVzZXIpID8/IG51bGwpO1xuICBSKCgpID0+IHtcbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgdmFyIGQ7XG4gICAgICBjb25zdCB7IGRhdGE6IHcgfSA9IGF3YWl0IGwuYXV0aC5nZXRTZXNzaW9uKCk7XG4gICAgICByKHcuc2Vzc2lvbiksIHYoKChkID0gdy5zZXNzaW9uKSA9PSBudWxsID8gdm9pZCAwIDogZC51c2VyKSA/PyBudWxsKTtcbiAgICB9KSgpO1xuICAgIGNvbnN0IHsgZGF0YTogQyB9ID0gbC5hdXRoLm9uQXV0aFN0YXRlQ2hhbmdlKFxuICAgICAgYXN5bmMgKHcsIGQpID0+IHtcbiAgICAgICAgcihkKSwgdigoZCA9PSBudWxsID8gdm9pZCAwIDogZC51c2VyKSA/PyBudWxsKTtcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBDID09IG51bGwgfHwgQy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIGNvbnN0IEUgPSB7XG4gICAgc2Vzc2lvbjogbixcbiAgICB1c2VyOiBvXG4gIH07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KGwxLlByb3ZpZGVyLCB7IHZhbHVlOiBFLCAuLi50IH0pO1xufSwgTzEgPSAoKSA9PiB7XG4gIGNvbnN0IHQgPSB1MShsMSk7XG4gIGlmICh0ID09PSB2b2lkIDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXNlVXNlciBtdXN0IGJlIHVzZWQgd2l0aGluIGEgVXNlckNvbnRleHRQcm92aWRlci5cIik7XG4gIHJldHVybiB0O1xufTtcbmZ1bmN0aW9uIFMoe1xuICBzdXBhYmFzZUNsaWVudDogdCxcbiAgc29jaWFsTGF5b3V0OiBsID0gXCJ2ZXJ0aWNhbFwiLFxuICBwcm92aWRlcnM6IG4sXG4gIHByb3ZpZGVyU2NvcGVzOiByLFxuICBxdWVyeVBhcmFtczogbyxcbiAgdmlldzogdiA9IFwic2lnbl9pblwiLFxuICByZWRpcmVjdFRvOiBFLFxuICBvbmx5VGhpcmRQYXJ0eVByb3ZpZGVyczogQyA9ICExLFxuICBtYWdpY0xpbms6IHcgPSAhMSxcbiAgc2hvd0xpbmtzOiBkID0gITAsXG4gIGFwcGVhcmFuY2U6IGksXG4gIHRoZW1lOiBtID0gXCJkZWZhdWx0XCIsXG4gIGxvY2FsaXphdGlvbjogYyA9IHsgdmFyaWFibGVzOiB7fSB9LFxuICBvdHBUeXBlOiB5ID0gXCJlbWFpbFwiLFxuICBhZGRpdGlvbmFsRGF0YTogeCxcbiAgY2hpbGRyZW46IGFcbn0pIHtcbiAgY29uc3QgXyA9IFcoYTEsIGMudmFyaWFibGVzID8/IHt9KSwgW2gsIGddID0gdSh2KSwgW3MsIE1dID0gdShcIlwiKSwgW3AsIEJdID0gdShcIlwiKSwgUCA9IGggPT09IFwic2lnbl9pblwiIHx8IGggPT09IFwic2lnbl91cFwiIHx8IGggPT09IFwibWFnaWNfbGlua1wiO1xuICBSKCgpID0+IHtcbiAgICB2YXIgeiwgZjtcbiAgICBuMSh7XG4gICAgICB0aGVtZTogVyhcbiAgICAgICAgKCh6ID0gaSA9PSBudWxsID8gdm9pZCAwIDogaS50aGVtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IHouZGVmYXVsdCkgPz8ge30sXG4gICAgICAgICgoZiA9IGkgPT0gbnVsbCA/IHZvaWQgMCA6IGkudmFyaWFibGVzKSA9PSBudWxsID8gdm9pZCAwIDogZi5kZWZhdWx0KSA/PyB7fVxuICAgICAgKVxuICAgIH0pO1xuICB9LCBbaV0pO1xuICBjb25zdCBBID0gKHsgY2hpbGRyZW46IHogfSkgPT4ge1xuICAgIHZhciBmO1xuICAgIHJldHVybiAoXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBtICE9PSBcImRlZmF1bHRcIiA/IHMxKFxuICAgICAgICAgICAgVyhcbiAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICBpID09IG51bGwgPyB2b2lkIDAgOiBpLnRoZW1lW21dLFxuICAgICAgICAgICAgICAoKGYgPSBpID09IG51bGwgPyB2b2lkIDAgOiBpLnZhcmlhYmxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IGZbbV0pID8/IHt9XG4gICAgICAgICAgICApXG4gICAgICAgICAgKSA6IFwiXCJcbiAgICAgICAgfSxcbiAgICAgICAgUCAmJiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIEExLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGFwcGVhcmFuY2U6IGksXG4gICAgICAgICAgICBzdXBhYmFzZUNsaWVudDogdCxcbiAgICAgICAgICAgIHByb3ZpZGVyczogbixcbiAgICAgICAgICAgIHByb3ZpZGVyU2NvcGVzOiByLFxuICAgICAgICAgICAgcXVlcnlQYXJhbXM6IG8sXG4gICAgICAgICAgICBzb2NpYWxMYXlvdXQ6IGwsXG4gICAgICAgICAgICByZWRpcmVjdFRvOiBFLFxuICAgICAgICAgICAgb25seVRoaXJkUGFydHlQcm92aWRlcnM6IEMsXG4gICAgICAgICAgICBpMThuOiBfLFxuICAgICAgICAgICAgdmlldzogaFxuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgIUMgJiYgelxuICAgICAgKVxuICAgICk7XG4gIH07XG4gIFIoKCkgPT4ge1xuICAgIGNvbnN0IHsgZGF0YTogeiB9ID0gdC5hdXRoLm9uQXV0aFN0YXRlQ2hhbmdlKFxuICAgICAgKGYpID0+IHtcbiAgICAgICAgZiA9PT0gXCJQQVNTV09SRF9SRUNPVkVSWVwiID8gZyhcInVwZGF0ZV9wYXNzd29yZFwiKSA6IGYgPT09IFwiVVNFUl9VUERBVEVEXCIgJiYgZyhcInNpZ25faW5cIik7XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gZyh2KSwgKCkgPT4gei5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfSwgW3ZdKTtcbiAgY29uc3QgTyA9IHtcbiAgICBzdXBhYmFzZUNsaWVudDogdCxcbiAgICBzZXRBdXRoVmlldzogZyxcbiAgICBkZWZhdWx0RW1haWw6IHMsXG4gICAgZGVmYXVsdFBhc3N3b3JkOiBwLFxuICAgIHNldERlZmF1bHRFbWFpbDogTSxcbiAgICBzZXREZWZhdWx0UGFzc3dvcmQ6IEIsXG4gICAgcmVkaXJlY3RUbzogRSxcbiAgICBtYWdpY0xpbms6IHcsXG4gICAgc2hvd0xpbmtzOiBkLFxuICAgIGkxOG46IF8sXG4gICAgYXBwZWFyYW5jZTogaVxuICB9O1xuICBzd2l0Y2ggKGgpIHtcbiAgICBjYXNlIGIuU0lHTl9JTjpcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KEEsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoUSwgeyAuLi5PLCBhdXRoVmlldzogXCJzaWduX2luXCIgfSkpO1xuICAgIGNhc2UgYi5TSUdOX1VQOlxuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoQSwgbnVsbCwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICAgICAgUSxcbiAgICAgICAge1xuICAgICAgICAgIGFwcGVhcmFuY2U6IGksXG4gICAgICAgICAgc3VwYWJhc2VDbGllbnQ6IHQsXG4gICAgICAgICAgYXV0aFZpZXc6IFwic2lnbl91cFwiLFxuICAgICAgICAgIHNldEF1dGhWaWV3OiBnLFxuICAgICAgICAgIGRlZmF1bHRFbWFpbDogcyxcbiAgICAgICAgICBkZWZhdWx0UGFzc3dvcmQ6IHAsXG4gICAgICAgICAgc2V0RGVmYXVsdEVtYWlsOiBNLFxuICAgICAgICAgIHNldERlZmF1bHRQYXNzd29yZDogQixcbiAgICAgICAgICByZWRpcmVjdFRvOiBFLFxuICAgICAgICAgIG1hZ2ljTGluazogdyxcbiAgICAgICAgICBzaG93TGlua3M6IGQsXG4gICAgICAgICAgaTE4bjogXyxcbiAgICAgICAgICBhZGRpdGlvbmFsRGF0YTogeCxcbiAgICAgICAgICBjaGlsZHJlbjogYVxuICAgICAgICB9XG4gICAgICApKTtcbiAgICBjYXNlIGIuRk9SR09UVEVOX1BBU1NXT1JEOlxuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoQSwgbnVsbCwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICAgICAgZTEsXG4gICAgICAgIHtcbiAgICAgICAgICBhcHBlYXJhbmNlOiBpLFxuICAgICAgICAgIHN1cGFiYXNlQ2xpZW50OiB0LFxuICAgICAgICAgIHNldEF1dGhWaWV3OiBnLFxuICAgICAgICAgIHJlZGlyZWN0VG86IEUsXG4gICAgICAgICAgc2hvd0xpbmtzOiBkLFxuICAgICAgICAgIGkxOG46IF9cbiAgICAgICAgfVxuICAgICAgKSk7XG4gICAgY2FzZSBiLk1BR0lDX0xJTks6XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChBLCBudWxsLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgICAgICBYLFxuICAgICAgICB7XG4gICAgICAgICAgYXBwZWFyYW5jZTogaSxcbiAgICAgICAgICBzdXBhYmFzZUNsaWVudDogdCxcbiAgICAgICAgICBzZXRBdXRoVmlldzogZyxcbiAgICAgICAgICByZWRpcmVjdFRvOiBFLFxuICAgICAgICAgIHNob3dMaW5rczogZCxcbiAgICAgICAgICBpMThuOiBfXG4gICAgICAgIH1cbiAgICAgICkpO1xuICAgIGNhc2UgYi5VUERBVEVfUEFTU1dPUkQ6XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICAgICAgdDEsXG4gICAgICAgIHtcbiAgICAgICAgICBhcHBlYXJhbmNlOiBpLFxuICAgICAgICAgIHN1cGFiYXNlQ2xpZW50OiB0LFxuICAgICAgICAgIGkxOG46IF9cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICBjYXNlIGIuVkVSSUZZX09UUDpcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgICAgICBVMSxcbiAgICAgICAge1xuICAgICAgICAgIGFwcGVhcmFuY2U6IGksXG4gICAgICAgICAgc3VwYWJhc2VDbGllbnQ6IHQsXG4gICAgICAgICAgb3RwVHlwZTogeSxcbiAgICAgICAgICBpMThuOiBfXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5TLkZvcmdvdHRlblBhc3N3b3JkID0gZTE7XG5TLlVwZGF0ZVBhc3N3b3JkID0gdDE7XG5TLk1hZ2ljTGluayA9IFg7XG5TLlVzZXJDb250ZXh0UHJvdmlkZXIgPSBSMTtcblMudXNlVXNlciA9IE8xO1xuY29uc3QgVzEgPSAkKHtcbiAgYm9yZGVyUmFkaXVzOiBcIjEycHhcIixcbiAgYm94U2hhZG93OiBcInJnYmEoMTAwLCAxMDAsIDExMSwgMC4yKSAwcHggN3B4IDI5cHggMHB4XCIsXG4gIHdpZHRoOiBcIjM2MHB4XCIsXG4gIHBhZGRpbmc6IFwiMjhweCAzMnB4XCJcbn0pLCBqMSA9ICh7XG4gIGNoaWxkcmVuOiB0LFxuICBhcHBlYXJhbmNlOiBsXG59KSA9PiB7XG4gIGNvbnN0IG4gPSBbXG4gICAgYCR7aTF9X3VpLWNhcmRgLFxuICAgIFcxKCksXG4gICAgbCA9PSBudWxsID8gdm9pZCAwIDogbC5jbGFzc05hbWVcbiAgXTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IG4uam9pbihcIiBcIikgfSwgdCk7XG59LCBxMSA9ICh0KSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICBTLFxuICB7XG4gICAgc2hvd0xpbmtzOiAhMSxcbiAgICAuLi50LFxuICAgIG9ubHlUaGlyZFBhcnR5UHJvdmlkZXJzOiAhMSxcbiAgICB2aWV3OiBcInNpZ25fdXBcIlxuICB9XG4pLCBLMSA9ICh0KSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICBTLFxuICB7XG4gICAgc2hvd0xpbmtzOiAhMSxcbiAgICAuLi50LFxuICAgIG9ubHlUaGlyZFBhcnR5UHJvdmlkZXJzOiAhMSxcbiAgICB2aWV3OiBcInNpZ25faW5cIlxuICB9XG4pLCBZMSA9ICh0KSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFMsIHsgLi4udCwgdmlldzogXCJtYWdpY19saW5rXCIsIHNob3dMaW5rczogITEgfSksIEoxID0gKHQpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gIFMsXG4gIHtcbiAgICAuLi50LFxuICAgIHZpZXc6IFwic2lnbl9pblwiLFxuICAgIHNob3dMaW5rczogITEsXG4gICAgb25seVRoaXJkUGFydHlQcm92aWRlcnM6ICEwXG4gIH1cbiksIFExID0gKHQpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoUywgeyBzaG93TGlua3M6ICExLCAuLi50LCB2aWV3OiBcImZvcmdvdHRlbl9wYXNzd29yZFwiIH0pLCBYMSA9ICh0KSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFMsIHsgLi4udCwgdmlldzogXCJ1cGRhdGVfcGFzc3dvcmRcIiB9KSwgZTAgPSAodCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChTLCB7IC4uLnQsIHZpZXc6IFwidmVyaWZ5X290cFwiIH0pO1xuZXhwb3J0IHtcbiAgUyBhcyBBdXRoLFxuICBqMSBhcyBBdXRoQ2FyZCxcbiAgUTEgYXMgRm9yZ290dGVuUGFzc3dvcmQsXG4gIFkxIGFzIE1hZ2ljTGluayxcbiAgSzEgYXMgU2lnbkluLFxuICBxMSBhcyBTaWduVXAsXG4gIEoxIGFzIFNvY2lhbEF1dGgsXG4gIFgxIGFzIFVwZGF0ZVBhc3N3b3JkLFxuICBlMCBhcyBWZXJpZnlPdHBcbn07XG4iXSwibmFtZXMiOlsiY3NzIiwiJCIsImNyZWF0ZVN0aXRjaGVzIiwibjEiLCJjcmVhdGVUaGVtZSIsInMxIiwiZ2VuZXJhdGVDbGFzc05hbWVzIiwiSSIsIlZJRVdTIiwiYiIsInRlbXBsYXRlIiwiYzEiLCJtZXJnZSIsIlciLCJlbiIsImExIiwiUFJFUEVOREVEX0NMQVNTX05BTUVTIiwiaTEiLCJlIiwidXNlU3RhdGUiLCJ1IiwidXNlUmVmIiwibTEiLCJ1c2VFZmZlY3QiLCJSIiwiY3JlYXRlQ29udGV4dCIsImQxIiwidXNlQ29udGV4dCIsInUxIiwiZzEiLCJmb250RmFtaWx5IiwiZm9udFNpemUiLCJtYXJnaW5Cb3R0b20iLCJjb2xvciIsImRpc3BsYXkiLCJ0ZXh0QWxpZ24iLCJ0ZXh0RGVjb3JhdGlvbiIsIlYiLCJjaGlsZHJlbiIsInQiLCJhcHBlYXJhbmNlIiwibCIsIm4iLCJvIiwiciIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZSIsImFuY2hvciIsImNsYXNzTmFtZSIsImpvaW4iLCJoMSIsImFsaWduSXRlbXMiLCJqdXN0aWZ5Q29udGVudCIsImdhcCIsImJvcmRlclJhZGl1cyIsInBhZGRpbmciLCJjdXJzb3IiLCJib3JkZXJXaWR0aCIsImJvcmRlclN0eWxlIiwid2lkdGgiLCJ0cmFuc2l0aW9uUHJvcGVydHkiLCJ0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24iLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJvcGFjaXR5IiwidmFyaWFudHMiLCJkZWZhdWx0IiwiYmFja2dyb3VuZENvbG9yIiwiYm9yZGVyQ29sb3IiLCJwcmltYXJ5IiwiVSIsImljb24iLCJsb2FkaW5nIiwidiIsIkMiLCJFIiwiYnV0dG9uIiwiZGlzYWJsZWQiLCJmMSIsImRpcmVjdGlvbiIsImhvcml6b250YWwiLCJncmlkVGVtcGxhdGVDb2x1bW5zIiwidmVydGljYWwiLCJmbGV4RGlyZWN0aW9uIiwibWFyZ2luIiwic21hbGwiLCJtZWRpdW0iLCJsYXJnZSIsIk4iLCJjb250YWluZXIiLCJFMSIsImJhY2tncm91bmQiLCJoZWlnaHQiLCJDMSIsImRpdmlkZXIiLCJ3MSIsImJveFNpemluZyIsIm91dGxpbmUiLCJsZXR0ZXJTcGFjaW5nIiwidHlwZSIsInBhc3N3b3JkIiwiRCIsImlucHV0IiwidjEiLCJIIiwibGFiZWwiLCJ4MSIsImxpbmVIZWlnaHQiLCJib3JkZXIiLCJkYW5nZXIiLCJGIiwibWVzc2FnZSIsIlgiLCJzZXRBdXRoVmlldyIsInN1cGFiYXNlQ2xpZW50IiwicmVkaXJlY3RUbyIsImkxOG4iLCJzaG93TGlua3MiLCJfIiwidyIsImQiLCJpIiwibSIsImMiLCJ5IiwieCIsImgiLCJzIiwiTSIsInByZXZlbnREZWZhdWx0IiwibGVuZ3RoIiwibWFnaWNfbGluayIsImVtcHR5X2VtYWlsX2FkZHJlc3MiLCJlcnJvciIsImciLCJhdXRoIiwic2lnbkluV2l0aE90cCIsImVtYWlsIiwib3B0aW9ucyIsImVtYWlsUmVkaXJlY3RUbyIsImNvbmZpcm1hdGlvbl90ZXh0IiwiYSIsImlkIiwib25TdWJtaXQiLCJodG1sRm9yIiwiZW1haWxfaW5wdXRfbGFiZWwiLCJuYW1lIiwiYXV0b0ZvY3VzIiwicGxhY2Vob2xkZXIiLCJlbWFpbF9pbnB1dF9wbGFjZWhvbGRlciIsIm9uQ2hhbmdlIiwidGFyZ2V0IiwidmFsdWUiLCJsb2FkaW5nX2J1dHRvbl9sYWJlbCIsImJ1dHRvbl9sYWJlbCIsImhyZWYiLCJvbkNsaWNrIiwiU0lHTl9JTiIsInNpZ25faW4iLCJsaW5rX3RleHQiLCJMIiwiXzEiLCJwcm92aWRlciIsInkxIiwiTDEiLCJiMSIsInAxIiwiazEiLCJNMSIsIlMxIiwiTjEiLCJGMSIsInoxIiwiJDEiLCJCMSIsIkQxIiwiSDEiLCJQMSIsIlYxIiwiSTEiLCJ4bWxucyIsInZpZXdCb3giLCJmaWxsIiwieDIiLCJ5MiIsImdyYWRpZW50VW5pdHMiLCJvZmZzZXQiLCJzdG9wQ29sb3IiLCJ0cmFuc2Zvcm0iLCJncmFkaWVudFRyYW5zZm9ybSIsInN0b3BPcGFjaXR5IiwiZmlsbFJ1bGUiLCJjbGlwUnVsZSIsIkExIiwic29jaWFsTGF5b3V0IiwicHJvdmlkZXJzIiwicHJvdmlkZXJTY29wZXMiLCJxdWVyeVBhcmFtcyIsIm9ubHlUaGlyZFBhcnR5UHJvdmlkZXJzIiwidmlldyIsInNpZ25JbldpdGhPQXV0aCIsInNjb3BlcyIsInRvTG93ZXJDYXNlIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzbGljZSIsIkZyYWdtZW50IiwibWFwIiwia2V5Iiwic29jaWFsX3Byb3ZpZGVyX3RleHQiLCJRIiwiYXV0aFZpZXciLCJkZWZhdWx0RW1haWwiLCJkZWZhdWx0UGFzc3dvcmQiLCJzZXREZWZhdWx0RW1haWwiLCJzZXREZWZhdWx0UGFzc3dvcmQiLCJhZGRpdGlvbmFsRGF0YSIsIm1hZ2ljTGluayIsIlQiLCJHIiwiWiIsImoiLCJwIiwiQiIsIlAiLCJBIiwiY3VycmVudCIsIk8iLCJrIiwicSIsIksiLCJzaWduSW5XaXRoUGFzc3dvcmQiLCJZIiwiZGF0YSIsInVzZXIiLCJyMSIsInNlc3Npb24iLCJvMSIsIkoiLCJzaWduVXAiLCJzaWduX3VwIiwieiIsImYiLCJhdXRvQ29tcGxldGUiLCJlbWFpbF9sYWJlbCIsImRlZmF1bHRWYWx1ZSIsInBhc3N3b3JkX2xhYmVsIiwicGFzc3dvcmRfaW5wdXRfcGxhY2Vob2xkZXIiLCJNQUdJQ19MSU5LIiwiRk9SR09UVEVOX1BBU1NXT1JEIiwiZm9yZ290dGVuX3Bhc3N3b3JkIiwiU0lHTl9VUCIsImUxIiwicmVzZXRQYXNzd29yZEZvckVtYWlsIiwidDEiLCJ1cGRhdGVVc2VyIiwidXBkYXRlX3Bhc3N3b3JkIiwiVTEiLCJvdHBUeXBlIiwidG9rZW4iLCJpbmNsdWRlcyIsInBob25lIiwidmVyaWZ5T3RwIiwidmVyaWZ5X290cCIsInBob25lX2lucHV0X2xhYmVsIiwicGhvbmVfaW5wdXRfcGxhY2Vob2xkZXIiLCJ0b2tlbl9pbnB1dF9sYWJlbCIsInRva2VuX2lucHV0X3BsYWNlaG9sZGVyIiwibDEiLCJSMSIsImdldFNlc3Npb24iLCJvbkF1dGhTdGF0ZUNoYW5nZSIsInN1YnNjcmlwdGlvbiIsInVuc3Vic2NyaWJlIiwiUHJvdmlkZXIiLCJPMSIsIkVycm9yIiwiUyIsInRoZW1lIiwibG9jYWxpemF0aW9uIiwidmFyaWFibGVzIiwiVVBEQVRFX1BBU1NXT1JEIiwiVkVSSUZZX09UUCIsIkZvcmdvdHRlblBhc3N3b3JkIiwiVXBkYXRlUGFzc3dvcmQiLCJNYWdpY0xpbmsiLCJVc2VyQ29udGV4dFByb3ZpZGVyIiwidXNlVXNlciIsIlcxIiwiYm94U2hhZG93IiwiajEiLCJxMSIsIksxIiwiWTEiLCJKMSIsIlExIiwiWDEiLCJlMCIsIkF1dGgiLCJBdXRoQ2FyZCIsIlNpZ25JbiIsIlNpZ25VcCIsIlNvY2lhbEF1dGgiLCJWZXJpZnlPdHAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-ui-react/dist/index.es.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-ui-shared/dist/index.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@supabase/auth-ui-shared/dist/index.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CLASS_NAMES: () => (/* binding */ CLASS_NAMES),\n/* harmony export */   PREPENDED_CLASS_NAMES: () => (/* binding */ PREPENDED_CLASS_NAMES),\n/* harmony export */   SocialLayouts: () => (/* binding */ SocialLayouts),\n/* harmony export */   ThemeMinimal: () => (/* binding */ ThemeMinimal),\n/* harmony export */   ThemeSupa: () => (/* binding */ ThemeSupa),\n/* harmony export */   VIEWS: () => (/* binding */ VIEWS),\n/* harmony export */   darkThemes: () => (/* binding */ darkThemes),\n/* harmony export */   en: () => (/* binding */ en_default),\n/* harmony export */   generateClassNames: () => (/* binding */ generateClassNames),\n/* harmony export */   merge: () => (/* binding */ merge),\n/* harmony export */   minimal: () => (/* binding */ minimal),\n/* harmony export */   supabase: () => (/* binding */ supabase),\n/* harmony export */   template: () => (/* binding */ template)\n/* harmony export */ });\n// src/theming/defaultThemes.ts\nvar ThemeSupa = {\n    default: {\n        colors: {\n            brand: \"hsl(153 60.0% 53.0%)\",\n            brandAccent: \"hsl(154 54.8% 45.1%)\",\n            brandButtonText: \"white\",\n            defaultButtonBackground: \"white\",\n            defaultButtonBackgroundHover: \"#eaeaea\",\n            defaultButtonBorder: \"lightgray\",\n            defaultButtonText: \"gray\",\n            dividerBackground: \"#eaeaea\",\n            inputBackground: \"transparent\",\n            inputBorder: \"lightgray\",\n            inputBorderHover: \"gray\",\n            inputBorderFocus: \"gray\",\n            inputText: \"black\",\n            inputLabelText: \"gray\",\n            inputPlaceholder: \"darkgray\",\n            messageText: \"#2b805a\",\n            messageBackground: \"#e7fcf1\",\n            messageBorder: \"#d0f3e1\",\n            messageTextDanger: \"#ff6369\",\n            messageBackgroundDanger: \"#fff8f8\",\n            messageBorderDanger: \"#822025\",\n            anchorTextColor: \"gray\",\n            anchorTextHoverColor: \"darkgray\"\n        },\n        space: {\n            spaceSmall: \"4px\",\n            spaceMedium: \"8px\",\n            spaceLarge: \"16px\",\n            labelBottomMargin: \"8px\",\n            anchorBottomMargin: \"4px\",\n            emailInputSpacing: \"4px\",\n            socialAuthSpacing: \"4px\",\n            buttonPadding: \"10px 15px\",\n            inputPadding: \"10px 15px\"\n        },\n        fontSizes: {\n            baseBodySize: \"13px\",\n            baseInputSize: \"14px\",\n            baseLabelSize: \"14px\",\n            baseButtonSize: \"14px\"\n        },\n        fonts: {\n            bodyFontFamily: `ui-sans-serif, sans-serif`,\n            buttonFontFamily: `ui-sans-serif, sans-serif`,\n            inputFontFamily: `ui-sans-serif, sans-serif`,\n            labelFontFamily: `ui-sans-serif, sans-serif`\n        },\n        // fontWeights: {},\n        // lineHeights: {},\n        // letterSpacings: {},\n        // sizes: {},\n        borderWidths: {\n            buttonBorderWidth: \"1px\",\n            inputBorderWidth: \"1px\"\n        },\n        // borderStyles: {},\n        radii: {\n            borderRadiusButton: \"4px\",\n            buttonBorderRadius: \"4px\",\n            inputBorderRadius: \"4px\"\n        }\n    },\n    dark: {\n        colors: {\n            brandButtonText: \"white\",\n            defaultButtonBackground: \"#2e2e2e\",\n            defaultButtonBackgroundHover: \"#3e3e3e\",\n            defaultButtonBorder: \"#3e3e3e\",\n            defaultButtonText: \"white\",\n            dividerBackground: \"#2e2e2e\",\n            inputBackground: \"#1e1e1e\",\n            inputBorder: \"#3e3e3e\",\n            inputBorderHover: \"gray\",\n            inputBorderFocus: \"gray\",\n            inputText: \"white\",\n            inputPlaceholder: \"darkgray\",\n            messageText: \"#85e0b7\",\n            messageBackground: \"#072719\",\n            messageBorder: \"#2b805a\",\n            messageBackgroundDanger: \"#1f1315\"\n        }\n    }\n};\nvar ThemeMinimal = {\n    default: {\n        colors: {\n            brand: \"black\",\n            brandAccent: \"#333333\",\n            brandButtonText: \"white\",\n            defaultButtonBackground: \"white\",\n            defaultButtonBorder: \"lightgray\",\n            defaultButtonText: \"gray\",\n            dividerBackground: \"#eaeaea\",\n            inputBackground: \"transparent\",\n            inputBorder: \"lightgray\",\n            inputText: \"black\",\n            inputPlaceholder: \"darkgray\",\n            messageText: \"#2b805a\",\n            messageBackground: \"#e7fcf1\",\n            messageBorder: \"#d0f3e1\",\n            messageTextDanger: \"#ff6369\",\n            messageBackgroundDanger: \"#fff8f8\",\n            messageBorderDanger: \"#822025\"\n        },\n        space: {\n            spaceSmall: \"4px\",\n            spaceMedium: \"8px\",\n            spaceLarge: \"16px\"\n        },\n        fontSizes: {\n            baseInputSize: \"14px\",\n            baseLabelSize: \"12px\"\n        },\n        fonts: {\n            bodyFontFamily: \"\",\n            inputFontFamily: \"\",\n            buttonFontFamily: \"\",\n            labelFontFamily: \"\"\n        },\n        // fontWeights: {},\n        // lineHeights: {},\n        // letterSpacings: {},\n        // sizes: {},\n        borderWidths: {},\n        // borderStyles: {},\n        radii: {}\n    },\n    dark: {\n        colors: {\n            brand: \"white\",\n            brandAccent: \"#afafaf\",\n            brandButtonText: \"black\",\n            defaultButtonBackground: \"#080808\",\n            defaultButtonBorder: \"black\",\n            defaultButtonText: \"white\",\n            dividerBackground: \"black\",\n            inputBackground: \"transparent\",\n            inputBorder: \"gray\",\n            inputText: \"black\",\n            inputPlaceholder: \"darkgray\",\n            messageText: \"#85e0b7\",\n            messageBackground: \"#072719\",\n            messageBorder: \"#2b805a\",\n            messageBackgroundDanger: \"#1f1315\"\n        }\n    }\n};\n// src/theming/Themes.ts\nvar supabase = {\n    colors: {\n        brand: \"hsl(153 60.0% 53.0%)\",\n        brandAccent: \"hsl(154 54.8% 45.1%)\",\n        brandButtonText: \"white\",\n        defaultButtonBackground: \"white\",\n        defaultButtonBackgroundHover: \"#eaeaea\",\n        defaultButtonBorder: \"lightgray\",\n        defaultButtonText: \"gray\",\n        dividerBackground: \"#eaeaea\",\n        inputBackground: \"transparent\",\n        inputBorder: \"lightgray\",\n        inputBorderHover: \"gray\",\n        inputBorderFocus: \"gray\",\n        inputText: \"black\",\n        inputLabelText: \"gray\",\n        inputPlaceholder: \"darkgray\",\n        messageText: \"gray\",\n        messageTextDanger: \"red\",\n        anchorTextColor: \"gray\",\n        anchorTextHoverColor: \"darkgray\"\n    },\n    space: {\n        spaceSmall: \"4px\",\n        spaceMedium: \"8px\",\n        spaceLarge: \"16px\",\n        labelBottomMargin: \"8px\",\n        anchorBottomMargin: \"4px\",\n        emailInputSpacing: \"4px\",\n        socialAuthSpacing: \"4px\",\n        buttonPadding: \"10px 15px\",\n        inputPadding: \"10px 15px\"\n    },\n    fontSizes: {\n        baseBodySize: \"13px\",\n        baseInputSize: \"14px\",\n        baseLabelSize: \"14px\",\n        baseButtonSize: \"14px\"\n    },\n    fonts: {\n        bodyFontFamily: `ui-sans-serif, sans-serif`,\n        buttonFontFamily: `ui-sans-serif, sans-serif`,\n        inputFontFamily: `ui-sans-serif, sans-serif`,\n        labelFontFamily: `ui-sans-serif, sans-serif`\n    },\n    // fontWeights: {},\n    // lineHeights: {},\n    // letterSpacings: {},\n    // sizes: {},\n    borderWidths: {\n        buttonBorderWidth: \"1px\",\n        inputBorderWidth: \"1px\"\n    },\n    // borderStyles: {},\n    radii: {\n        borderRadiusButton: \"4px\",\n        buttonBorderRadius: \"4px\",\n        inputBorderRadius: \"4px\"\n    }\n};\nvar defaultDarkTheme = {\n    colors: {\n        brandButtonText: \"white\",\n        defaultButtonBackground: \"#2e2e2e\",\n        defaultButtonBackgroundHover: \"#3e3e3e\",\n        defaultButtonBorder: \"#3e3e3e\",\n        defaultButtonText: \"white\",\n        dividerBackground: \"#2e2e2e\",\n        inputBackground: \"#1e1e1e\",\n        inputBorder: \"#3e3e3e\",\n        inputBorderHover: \"gray\",\n        inputBorderFocus: \"gray\",\n        inputText: \"white\",\n        inputPlaceholder: \"darkgray\"\n    }\n};\nvar minimal = {\n    colors: {\n        brand: \"black\",\n        brandAccent: \"#333333\",\n        brandButtonText: \"white\",\n        defaultButtonBackground: \"white\",\n        defaultButtonBorder: \"lightgray\",\n        defaultButtonText: \"gray\",\n        dividerBackground: \"#eaeaea\",\n        inputBackground: \"transparent\",\n        inputBorder: \"lightgray\",\n        inputText: \"black\",\n        inputPlaceholder: \"darkgray\"\n    },\n    space: {\n        spaceSmall: \"4px\",\n        spaceMedium: \"8px\",\n        spaceLarge: \"16px\"\n    },\n    fontSizes: {\n        baseInputSize: \"14px\",\n        baseLabelSize: \"12px\"\n    },\n    fonts: {\n        bodyFontFamily: \"\",\n        inputFontFamily: \"\",\n        buttonFontFamily: \"\",\n        labelFontFamily: \"\"\n    },\n    // fontWeights: {},\n    // lineHeights: {},\n    // letterSpacings: {},\n    // sizes: {},\n    borderWidths: {},\n    // borderStyles: {},\n    radii: {}\n};\nvar minimalDark = {\n    colors: {\n        brand: \"white\",\n        brandAccent: \"#afafaf\",\n        brandButtonText: \"black\",\n        defaultButtonBackground: \"#080808\",\n        defaultButtonBorder: \"black\",\n        defaultButtonText: \"white\",\n        dividerBackground: \"black\",\n        inputBackground: \"transparent\",\n        inputBorder: \"gray\",\n        inputText: \"black\",\n        inputPlaceholder: \"darkgray\"\n    }\n};\nvar darkThemes = {\n    supabase: defaultDarkTheme,\n    minimal: minimalDark\n};\n// src/constants.ts\nvar VIEWS = {\n    SIGN_IN: \"sign_in\",\n    SIGN_UP: \"sign_up\",\n    FORGOTTEN_PASSWORD: \"forgotten_password\",\n    MAGIC_LINK: \"magic_link\",\n    UPDATE_PASSWORD: \"update_password\",\n    VERIFY_OTP: \"verify_otp\"\n};\nvar PREPENDED_CLASS_NAMES = \"supabase-auth-ui\";\nvar CLASS_NAMES = {\n    // interfaces\n    ROOT: \"root\",\n    SIGN_IN: VIEWS.SIGN_IN,\n    SIGN_UP: VIEWS.SIGN_UP,\n    FORGOTTEN_PASSWORD: VIEWS.FORGOTTEN_PASSWORD,\n    MAGIC_LINK: VIEWS.MAGIC_LINK,\n    UPDATE_PASSWORD: VIEWS.UPDATE_PASSWORD,\n    // ui\n    anchor: \"ui-anchor\",\n    button: \"ui-button\",\n    container: \"ui-container\",\n    divider: \"ui-divider\",\n    input: \"ui-input\",\n    label: \"ui-label\",\n    loader: \"ui-loader\",\n    message: \"ui-message\"\n};\n// src/theming/utils.ts\nfunction generateClassNames(classNameKey, defaultStyles, appearance) {\n    var _a, _b;\n    const classNames = [];\n    const className = CLASS_NAMES[classNameKey];\n    classNames.push((appearance == null ? void 0 : appearance.prependedClassName) ? (appearance == null ? void 0 : appearance.prependedClassName) + \"_\" + className : PREPENDED_CLASS_NAMES + \"_\" + className);\n    if ((_a = appearance == null ? void 0 : appearance.className) == null ? void 0 : _a[classNameKey]) {\n        classNames.push((_b = appearance == null ? void 0 : appearance.className) == null ? void 0 : _b[classNameKey]);\n    }\n    if ((appearance == null ? void 0 : appearance.extend) === void 0 || (appearance == null ? void 0 : appearance.extend) === true) {\n        classNames.push(defaultStyles);\n    }\n    return classNames;\n}\n// src/types.ts\nvar SocialLayouts = /* @__PURE__ */ ((SocialLayouts2)=>{\n    SocialLayouts2[SocialLayouts2[\"horizontal\"] = 0] = \"horizontal\";\n    SocialLayouts2[SocialLayouts2[\"vertical\"] = 1] = \"vertical\";\n    return SocialLayouts2;\n})(SocialLayouts || {});\n// src/utils.ts\nfunction value(src, next) {\n    let k;\n    if (src && next && typeof src === \"object\" && typeof next === \"object\") {\n        if (Array.isArray(next)) {\n            for(k = 0; k < next.length; k++){\n                src[k] = value(src[k], next[k]);\n            }\n        } else {\n            for(k in next){\n                src[k] = value(src[k], next[k]);\n            }\n        }\n        return src;\n    }\n    return next;\n}\nfunction merge(target, ...args) {\n    let len = args.length;\n    for(let i = 0; i < len; i++){\n        target = value(target, args[i]);\n    }\n    return target;\n}\nfunction template(string, data) {\n    return string.replace(/{{(\\w+)}}/g, (placeholderWithDelimiters, placeholderWithoutDelimiters)=>data.hasOwnProperty(placeholderWithoutDelimiters) ? data[placeholderWithoutDelimiters] : placeholderWithDelimiters);\n}\n// src/localization/en.json\nvar en_default = {\n    sign_up: {\n        email_label: \"Email address\",\n        password_label: \"Create a Password\",\n        email_input_placeholder: \"Your email address\",\n        password_input_placeholder: \"Your password\",\n        button_label: \"Sign up\",\n        loading_button_label: \"Signing up ...\",\n        social_provider_text: \"Sign in with {{provider}}\",\n        link_text: \"Don't have an account? Sign up\",\n        confirmation_text: \"Check your email for the confirmation link\"\n    },\n    sign_in: {\n        email_label: \"Email address\",\n        password_label: \"Your Password\",\n        email_input_placeholder: \"Your email address\",\n        password_input_placeholder: \"Your password\",\n        button_label: \"Sign in\",\n        loading_button_label: \"Signing in ...\",\n        social_provider_text: \"Sign in with {{provider}}\",\n        link_text: \"Already have an account? Sign in\"\n    },\n    magic_link: {\n        email_input_label: \"Email address\",\n        email_input_placeholder: \"Your email address\",\n        button_label: \"Send Magic Link\",\n        loading_button_label: \"Sending Magic Link ...\",\n        link_text: \"Send a magic link email\",\n        confirmation_text: \"Check your email for the magic link\"\n    },\n    forgotten_password: {\n        email_label: \"Email address\",\n        password_label: \"Your Password\",\n        email_input_placeholder: \"Your email address\",\n        button_label: \"Send reset password instructions\",\n        loading_button_label: \"Sending reset instructions ...\",\n        link_text: \"Forgot your password?\",\n        confirmation_text: \"Check your email for the password reset link\"\n    },\n    update_password: {\n        password_label: \"New password\",\n        password_input_placeholder: \"Your new password\",\n        button_label: \"Update password\",\n        loading_button_label: \"Updating password ...\",\n        confirmation_text: \"Your password has been updated\"\n    },\n    verify_otp: {\n        email_input_label: \"Email address\",\n        email_input_placeholder: \"Your email address\",\n        phone_input_label: \"Phone number\",\n        phone_input_placeholder: \"Your phone number\",\n        token_input_label: \"Token\",\n        token_input_placeholder: \"Your Otp token\",\n        button_label: \"Verify token\",\n        loading_button_label: \"Signing in ...\"\n    }\n};\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtdWktc2hhcmVkL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwrQkFBK0I7QUFDL0IsSUFBSUEsWUFBWTtJQUNkQyxTQUFTO1FBQ1BDLFFBQVE7WUFDTkMsT0FBTztZQUNQQyxhQUFhO1lBQ2JDLGlCQUFpQjtZQUNqQkMseUJBQXlCO1lBQ3pCQyw4QkFBOEI7WUFDOUJDLHFCQUFxQjtZQUNyQkMsbUJBQW1CO1lBQ25CQyxtQkFBbUI7WUFDbkJDLGlCQUFpQjtZQUNqQkMsYUFBYTtZQUNiQyxrQkFBa0I7WUFDbEJDLGtCQUFrQjtZQUNsQkMsV0FBVztZQUNYQyxnQkFBZ0I7WUFDaEJDLGtCQUFrQjtZQUNsQkMsYUFBYTtZQUNiQyxtQkFBbUI7WUFDbkJDLGVBQWU7WUFDZkMsbUJBQW1CO1lBQ25CQyx5QkFBeUI7WUFDekJDLHFCQUFxQjtZQUNyQkMsaUJBQWlCO1lBQ2pCQyxzQkFBc0I7UUFDeEI7UUFDQUMsT0FBTztZQUNMQyxZQUFZO1lBQ1pDLGFBQWE7WUFDYkMsWUFBWTtZQUNaQyxtQkFBbUI7WUFDbkJDLG9CQUFvQjtZQUNwQkMsbUJBQW1CO1lBQ25CQyxtQkFBbUI7WUFDbkJDLGVBQWU7WUFDZkMsY0FBYztRQUNoQjtRQUNBQyxXQUFXO1lBQ1RDLGNBQWM7WUFDZEMsZUFBZTtZQUNmQyxlQUFlO1lBQ2ZDLGdCQUFnQjtRQUNsQjtRQUNBQyxPQUFPO1lBQ0xDLGdCQUFnQixDQUFDLHlCQUF5QixDQUFDO1lBQzNDQyxrQkFBa0IsQ0FBQyx5QkFBeUIsQ0FBQztZQUM3Q0MsaUJBQWlCLENBQUMseUJBQXlCLENBQUM7WUFDNUNDLGlCQUFpQixDQUFDLHlCQUF5QixDQUFDO1FBQzlDO1FBQ0EsbUJBQW1CO1FBQ25CLG1CQUFtQjtRQUNuQixzQkFBc0I7UUFDdEIsYUFBYTtRQUNiQyxjQUFjO1lBQ1pDLG1CQUFtQjtZQUNuQkMsa0JBQWtCO1FBQ3BCO1FBQ0Esb0JBQW9CO1FBQ3BCQyxPQUFPO1lBQ0xDLG9CQUFvQjtZQUNwQkMsb0JBQW9CO1lBQ3BCQyxtQkFBbUI7UUFDckI7SUFJRjtJQUNBQyxNQUFNO1FBQ0puRCxRQUFRO1lBQ05HLGlCQUFpQjtZQUNqQkMseUJBQXlCO1lBQ3pCQyw4QkFBOEI7WUFDOUJDLHFCQUFxQjtZQUNyQkMsbUJBQW1CO1lBQ25CQyxtQkFBbUI7WUFDbkJDLGlCQUFpQjtZQUNqQkMsYUFBYTtZQUNiQyxrQkFBa0I7WUFDbEJDLGtCQUFrQjtZQUNsQkMsV0FBVztZQUNYRSxrQkFBa0I7WUFDbEJDLGFBQWE7WUFDYkMsbUJBQW1CO1lBQ25CQyxlQUFlO1lBQ2ZFLHlCQUF5QjtRQUMzQjtJQUNGO0FBQ0Y7QUFDQSxJQUFJZ0MsZUFBZTtJQUNqQnJELFNBQVM7UUFDUEMsUUFBUTtZQUNOQyxPQUFPO1lBQ1BDLGFBQWE7WUFDYkMsaUJBQWlCO1lBQ2pCQyx5QkFBeUI7WUFDekJFLHFCQUFxQjtZQUNyQkMsbUJBQW1CO1lBQ25CQyxtQkFBbUI7WUFDbkJDLGlCQUFpQjtZQUNqQkMsYUFBYTtZQUNiRyxXQUFXO1lBQ1hFLGtCQUFrQjtZQUNsQkMsYUFBYTtZQUNiQyxtQkFBbUI7WUFDbkJDLGVBQWU7WUFDZkMsbUJBQW1CO1lBQ25CQyx5QkFBeUI7WUFDekJDLHFCQUFxQjtRQUN2QjtRQUNBRyxPQUFPO1lBQ0xDLFlBQVk7WUFDWkMsYUFBYTtZQUNiQyxZQUFZO1FBQ2Q7UUFDQU8sV0FBVztZQUNURSxlQUFlO1lBQ2ZDLGVBQWU7UUFDakI7UUFDQUUsT0FBTztZQUNMQyxnQkFBZ0I7WUFDaEJFLGlCQUFpQjtZQUNqQkQsa0JBQWtCO1lBQ2xCRSxpQkFBaUI7UUFFbkI7UUFDQSxtQkFBbUI7UUFDbkIsbUJBQW1CO1FBQ25CLHNCQUFzQjtRQUN0QixhQUFhO1FBQ2JDLGNBQWMsQ0FBQztRQUNmLG9CQUFvQjtRQUNwQkcsT0FBTyxDQUFDO0lBSVY7SUFDQUksTUFBTTtRQUNKbkQsUUFBUTtZQUNOQyxPQUFPO1lBQ1BDLGFBQWE7WUFDYkMsaUJBQWlCO1lBQ2pCQyx5QkFBeUI7WUFDekJFLHFCQUFxQjtZQUNyQkMsbUJBQW1CO1lBQ25CQyxtQkFBbUI7WUFDbkJDLGlCQUFpQjtZQUNqQkMsYUFBYTtZQUNiRyxXQUFXO1lBQ1hFLGtCQUFrQjtZQUNsQkMsYUFBYTtZQUNiQyxtQkFBbUI7WUFDbkJDLGVBQWU7WUFDZkUseUJBQXlCO1FBQzNCO0lBQ0Y7QUFDRjtBQUVBLHdCQUF3QjtBQUN4QixJQUFJaUMsV0FBVztJQUNickQsUUFBUTtRQUNOQyxPQUFPO1FBQ1BDLGFBQWE7UUFDYkMsaUJBQWlCO1FBQ2pCQyx5QkFBeUI7UUFDekJDLDhCQUE4QjtRQUM5QkMscUJBQXFCO1FBQ3JCQyxtQkFBbUI7UUFDbkJDLG1CQUFtQjtRQUNuQkMsaUJBQWlCO1FBQ2pCQyxhQUFhO1FBQ2JDLGtCQUFrQjtRQUNsQkMsa0JBQWtCO1FBQ2xCQyxXQUFXO1FBQ1hDLGdCQUFnQjtRQUNoQkMsa0JBQWtCO1FBQ2xCQyxhQUFhO1FBQ2JHLG1CQUFtQjtRQUNuQkcsaUJBQWlCO1FBQ2pCQyxzQkFBc0I7SUFDeEI7SUFDQUMsT0FBTztRQUNMQyxZQUFZO1FBQ1pDLGFBQWE7UUFDYkMsWUFBWTtRQUNaQyxtQkFBbUI7UUFDbkJDLG9CQUFvQjtRQUNwQkMsbUJBQW1CO1FBQ25CQyxtQkFBbUI7UUFDbkJDLGVBQWU7UUFDZkMsY0FBYztJQUNoQjtJQUNBQyxXQUFXO1FBQ1RDLGNBQWM7UUFDZEMsZUFBZTtRQUNmQyxlQUFlO1FBQ2ZDLGdCQUFnQjtJQUNsQjtJQUNBQyxPQUFPO1FBQ0xDLGdCQUFnQixDQUFDLHlCQUF5QixDQUFDO1FBQzNDQyxrQkFBa0IsQ0FBQyx5QkFBeUIsQ0FBQztRQUM3Q0MsaUJBQWlCLENBQUMseUJBQXlCLENBQUM7UUFDNUNDLGlCQUFpQixDQUFDLHlCQUF5QixDQUFDO0lBQzlDO0lBQ0EsbUJBQW1CO0lBQ25CLG1CQUFtQjtJQUNuQixzQkFBc0I7SUFDdEIsYUFBYTtJQUNiQyxjQUFjO1FBQ1pDLG1CQUFtQjtRQUNuQkMsa0JBQWtCO0lBQ3BCO0lBQ0Esb0JBQW9CO0lBQ3BCQyxPQUFPO1FBQ0xDLG9CQUFvQjtRQUNwQkMsb0JBQW9CO1FBQ3BCQyxtQkFBbUI7SUFDckI7QUFJRjtBQUNBLElBQUlJLG1CQUFtQjtJQUNyQnRELFFBQVE7UUFDTkcsaUJBQWlCO1FBQ2pCQyx5QkFBeUI7UUFDekJDLDhCQUE4QjtRQUM5QkMscUJBQXFCO1FBQ3JCQyxtQkFBbUI7UUFDbkJDLG1CQUFtQjtRQUNuQkMsaUJBQWlCO1FBQ2pCQyxhQUFhO1FBQ2JDLGtCQUFrQjtRQUNsQkMsa0JBQWtCO1FBQ2xCQyxXQUFXO1FBQ1hFLGtCQUFrQjtJQUNwQjtBQUNGO0FBQ0EsSUFBSXdDLFVBQVU7SUFDWnZELFFBQVE7UUFDTkMsT0FBTztRQUNQQyxhQUFhO1FBQ2JDLGlCQUFpQjtRQUNqQkMseUJBQXlCO1FBQ3pCRSxxQkFBcUI7UUFDckJDLG1CQUFtQjtRQUNuQkMsbUJBQW1CO1FBQ25CQyxpQkFBaUI7UUFDakJDLGFBQWE7UUFDYkcsV0FBVztRQUNYRSxrQkFBa0I7SUFDcEI7SUFDQVMsT0FBTztRQUNMQyxZQUFZO1FBQ1pDLGFBQWE7UUFDYkMsWUFBWTtJQUNkO0lBQ0FPLFdBQVc7UUFDVEUsZUFBZTtRQUNmQyxlQUFlO0lBQ2pCO0lBQ0FFLE9BQU87UUFDTEMsZ0JBQWdCO1FBQ2hCRSxpQkFBaUI7UUFDakJELGtCQUFrQjtRQUNsQkUsaUJBQWlCO0lBRW5CO0lBQ0EsbUJBQW1CO0lBQ25CLG1CQUFtQjtJQUNuQixzQkFBc0I7SUFDdEIsYUFBYTtJQUNiQyxjQUFjLENBQUM7SUFDZixvQkFBb0I7SUFDcEJHLE9BQU8sQ0FBQztBQUlWO0FBQ0EsSUFBSVMsY0FBYztJQUNoQnhELFFBQVE7UUFDTkMsT0FBTztRQUNQQyxhQUFhO1FBQ2JDLGlCQUFpQjtRQUNqQkMseUJBQXlCO1FBQ3pCRSxxQkFBcUI7UUFDckJDLG1CQUFtQjtRQUNuQkMsbUJBQW1CO1FBQ25CQyxpQkFBaUI7UUFDakJDLGFBQWE7UUFDYkcsV0FBVztRQUNYRSxrQkFBa0I7SUFDcEI7QUFDRjtBQUNBLElBQUkwQyxhQUFhO0lBQ2ZKLFVBQVVDO0lBQ1ZDLFNBQVNDO0FBQ1g7QUFFQSxtQkFBbUI7QUFDbkIsSUFBSUUsUUFBUTtJQUNWQyxTQUFTO0lBQ1RDLFNBQVM7SUFDVEMsb0JBQW9CO0lBQ3BCQyxZQUFZO0lBQ1pDLGlCQUFpQjtJQUNqQkMsWUFBWTtBQUNkO0FBQ0EsSUFBSUMsd0JBQXdCO0FBQzVCLElBQUlDLGNBQWM7SUFDaEIsYUFBYTtJQUNiQyxNQUFNO0lBQ05SLFNBQVNELE1BQU1DLE9BQU87SUFDdEJDLFNBQVNGLE1BQU1FLE9BQU87SUFDdEJDLG9CQUFvQkgsTUFBTUcsa0JBQWtCO0lBQzVDQyxZQUFZSixNQUFNSSxVQUFVO0lBQzVCQyxpQkFBaUJMLE1BQU1LLGVBQWU7SUFDdEMsS0FBSztJQUNMSyxRQUFRO0lBQ1JDLFFBQVE7SUFDUkMsV0FBVztJQUNYQyxTQUFTO0lBQ1RDLE9BQU87SUFDUEMsT0FBTztJQUNQQyxRQUFRO0lBQ1JDLFNBQVM7QUFDWDtBQUVBLHVCQUF1QjtBQUN2QixTQUFTQyxtQkFBbUJDLFlBQVksRUFBRUMsYUFBYSxFQUFFQyxVQUFVO0lBQ2pFLElBQUlDLElBQUlDO0lBQ1IsTUFBTUMsYUFBYSxFQUFFO0lBQ3JCLE1BQU1DLFlBQVlqQixXQUFXLENBQUNXLGFBQWE7SUFDM0NLLFdBQVdFLElBQUksQ0FDYixDQUFDTCxjQUFjLE9BQU8sS0FBSyxJQUFJQSxXQUFXTSxrQkFBa0IsSUFBSSxDQUFDTixjQUFjLE9BQU8sS0FBSyxJQUFJQSxXQUFXTSxrQkFBa0IsSUFBSSxNQUFNRixZQUFZbEIsd0JBQXdCLE1BQU1rQjtJQUVsTCxJQUFJLENBQUNILEtBQUtELGNBQWMsT0FBTyxLQUFLLElBQUlBLFdBQVdJLFNBQVMsS0FBSyxPQUFPLEtBQUssSUFBSUgsRUFBRSxDQUFDSCxhQUFhLEVBQUU7UUFDakdLLFdBQVdFLElBQUksQ0FBQyxDQUFDSCxLQUFLRixjQUFjLE9BQU8sS0FBSyxJQUFJQSxXQUFXSSxTQUFTLEtBQUssT0FBTyxLQUFLLElBQUlGLEVBQUUsQ0FBQ0osYUFBYTtJQUMvRztJQUNBLElBQUksQ0FBQ0UsY0FBYyxPQUFPLEtBQUssSUFBSUEsV0FBV08sTUFBTSxNQUFNLEtBQUssS0FBSyxDQUFDUCxjQUFjLE9BQU8sS0FBSyxJQUFJQSxXQUFXTyxNQUFNLE1BQU0sTUFBTTtRQUM5SEosV0FBV0UsSUFBSSxDQUFDTjtJQUNsQjtJQUNBLE9BQU9JO0FBQ1Q7QUFFQSxlQUFlO0FBQ2YsSUFBSUssZ0JBQWdDLGFBQUgsR0FBSSxFQUFDQztJQUNwQ0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsYUFBYSxHQUFHLEVBQUUsR0FBRztJQUNuREEsY0FBYyxDQUFDQSxjQUFjLENBQUMsV0FBVyxHQUFHLEVBQUUsR0FBRztJQUNqRCxPQUFPQTtBQUNULEdBQUdELGlCQUFpQixDQUFDO0FBRXJCLGVBQWU7QUFDZixTQUFTRSxNQUFNQyxHQUFHLEVBQUVDLElBQUk7SUFDdEIsSUFBSUM7SUFDSixJQUFJRixPQUFPQyxRQUFRLE9BQU9ELFFBQVEsWUFBWSxPQUFPQyxTQUFTLFVBQVU7UUFDdEUsSUFBSUUsTUFBTUMsT0FBTyxDQUFDSCxPQUFPO1lBQ3ZCLElBQUtDLElBQUksR0FBR0EsSUFBSUQsS0FBS0ksTUFBTSxFQUFFSCxJQUFLO2dCQUNoQ0YsR0FBRyxDQUFDRSxFQUFFLEdBQUdILE1BQU1DLEdBQUcsQ0FBQ0UsRUFBRSxFQUFFRCxJQUFJLENBQUNDLEVBQUU7WUFDaEM7UUFDRixPQUFPO1lBQ0wsSUFBS0EsS0FBS0QsS0FBTTtnQkFDZEQsR0FBRyxDQUFDRSxFQUFFLEdBQUdILE1BQU1DLEdBQUcsQ0FBQ0UsRUFBRSxFQUFFRCxJQUFJLENBQUNDLEVBQUU7WUFDaEM7UUFDRjtRQUNBLE9BQU9GO0lBQ1Q7SUFDQSxPQUFPQztBQUNUO0FBQ0EsU0FBU0ssTUFBTUMsTUFBTSxFQUFFLEdBQUdDLElBQUk7SUFDNUIsSUFBSUMsTUFBTUQsS0FBS0gsTUFBTTtJQUNyQixJQUFLLElBQUlLLElBQUksR0FBR0EsSUFBSUQsS0FBS0MsSUFBSztRQUM1QkgsU0FBU1IsTUFBTVEsUUFBUUMsSUFBSSxDQUFDRSxFQUFFO0lBQ2hDO0lBQ0EsT0FBT0g7QUFDVDtBQUNBLFNBQVNJLFNBQVNDLE1BQU0sRUFBRUMsSUFBSTtJQUM1QixPQUFPRCxPQUFPRSxPQUFPLENBQ25CLGNBQ0EsQ0FBQ0MsMkJBQTJCQywrQkFBaUNILEtBQUtJLGNBQWMsQ0FBQ0QsZ0NBQWdDSCxJQUFJLENBQUNHLDZCQUE2QixHQUFHRDtBQUUxSjtBQUVBLDJCQUEyQjtBQUMzQixJQUFJRyxhQUFhO0lBQ2ZDLFNBQVM7UUFDUEMsYUFBYTtRQUNiQyxnQkFBZ0I7UUFDaEJDLHlCQUF5QjtRQUN6QkMsNEJBQTRCO1FBQzVCQyxjQUFjO1FBQ2RDLHNCQUFzQjtRQUN0QkMsc0JBQXNCO1FBQ3RCQyxXQUFXO1FBQ1hDLG1CQUFtQjtJQUNyQjtJQUNBQyxTQUFTO1FBQ1BULGFBQWE7UUFDYkMsZ0JBQWdCO1FBQ2hCQyx5QkFBeUI7UUFDekJDLDRCQUE0QjtRQUM1QkMsY0FBYztRQUNkQyxzQkFBc0I7UUFDdEJDLHNCQUFzQjtRQUN0QkMsV0FBVztJQUNiO0lBQ0FHLFlBQVk7UUFDVkMsbUJBQW1CO1FBQ25CVCx5QkFBeUI7UUFDekJFLGNBQWM7UUFDZEMsc0JBQXNCO1FBQ3RCRSxXQUFXO1FBQ1hDLG1CQUFtQjtJQUNyQjtJQUNBSSxvQkFBb0I7UUFDbEJaLGFBQWE7UUFDYkMsZ0JBQWdCO1FBQ2hCQyx5QkFBeUI7UUFDekJFLGNBQWM7UUFDZEMsc0JBQXNCO1FBQ3RCRSxXQUFXO1FBQ1hDLG1CQUFtQjtJQUNyQjtJQUNBSyxpQkFBaUI7UUFDZlosZ0JBQWdCO1FBQ2hCRSw0QkFBNEI7UUFDNUJDLGNBQWM7UUFDZEMsc0JBQXNCO1FBQ3RCRyxtQkFBbUI7SUFDckI7SUFDQU0sWUFBWTtRQUNWSCxtQkFBbUI7UUFDbkJULHlCQUF5QjtRQUN6QmEsbUJBQW1CO1FBQ25CQyx5QkFBeUI7UUFDekJDLG1CQUFtQjtRQUNuQkMseUJBQXlCO1FBQ3pCZCxjQUFjO1FBQ2RDLHNCQUFzQjtJQUN4QjtBQUNGO0FBZUUsQ0FDRixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmNob3Itd29ya2Zsb3dzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLXVpLXNoYXJlZC9kaXN0L2luZGV4Lm1qcz8zYWRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy90aGVtaW5nL2RlZmF1bHRUaGVtZXMudHNcbnZhciBUaGVtZVN1cGEgPSB7XG4gIGRlZmF1bHQ6IHtcbiAgICBjb2xvcnM6IHtcbiAgICAgIGJyYW5kOiBcImhzbCgxNTMgNjAuMCUgNTMuMCUpXCIsXG4gICAgICBicmFuZEFjY2VudDogXCJoc2woMTU0IDU0LjglIDQ1LjElKVwiLFxuICAgICAgYnJhbmRCdXR0b25UZXh0OiBcIndoaXRlXCIsXG4gICAgICBkZWZhdWx0QnV0dG9uQmFja2dyb3VuZDogXCJ3aGl0ZVwiLFxuICAgICAgZGVmYXVsdEJ1dHRvbkJhY2tncm91bmRIb3ZlcjogXCIjZWFlYWVhXCIsXG4gICAgICBkZWZhdWx0QnV0dG9uQm9yZGVyOiBcImxpZ2h0Z3JheVwiLFxuICAgICAgZGVmYXVsdEJ1dHRvblRleHQ6IFwiZ3JheVwiLFxuICAgICAgZGl2aWRlckJhY2tncm91bmQ6IFwiI2VhZWFlYVwiLFxuICAgICAgaW5wdXRCYWNrZ3JvdW5kOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICBpbnB1dEJvcmRlcjogXCJsaWdodGdyYXlcIixcbiAgICAgIGlucHV0Qm9yZGVySG92ZXI6IFwiZ3JheVwiLFxuICAgICAgaW5wdXRCb3JkZXJGb2N1czogXCJncmF5XCIsXG4gICAgICBpbnB1dFRleHQ6IFwiYmxhY2tcIixcbiAgICAgIGlucHV0TGFiZWxUZXh0OiBcImdyYXlcIixcbiAgICAgIGlucHV0UGxhY2Vob2xkZXI6IFwiZGFya2dyYXlcIixcbiAgICAgIG1lc3NhZ2VUZXh0OiBcIiMyYjgwNWFcIixcbiAgICAgIG1lc3NhZ2VCYWNrZ3JvdW5kOiBcIiNlN2ZjZjFcIixcbiAgICAgIG1lc3NhZ2VCb3JkZXI6IFwiI2QwZjNlMVwiLFxuICAgICAgbWVzc2FnZVRleHREYW5nZXI6IFwiI2ZmNjM2OVwiLFxuICAgICAgbWVzc2FnZUJhY2tncm91bmREYW5nZXI6IFwiI2ZmZjhmOFwiLFxuICAgICAgbWVzc2FnZUJvcmRlckRhbmdlcjogXCIjODIyMDI1XCIsXG4gICAgICBhbmNob3JUZXh0Q29sb3I6IFwiZ3JheVwiLFxuICAgICAgYW5jaG9yVGV4dEhvdmVyQ29sb3I6IFwiZGFya2dyYXlcIlxuICAgIH0sXG4gICAgc3BhY2U6IHtcbiAgICAgIHNwYWNlU21hbGw6IFwiNHB4XCIsXG4gICAgICBzcGFjZU1lZGl1bTogXCI4cHhcIixcbiAgICAgIHNwYWNlTGFyZ2U6IFwiMTZweFwiLFxuICAgICAgbGFiZWxCb3R0b21NYXJnaW46IFwiOHB4XCIsXG4gICAgICBhbmNob3JCb3R0b21NYXJnaW46IFwiNHB4XCIsXG4gICAgICBlbWFpbElucHV0U3BhY2luZzogXCI0cHhcIixcbiAgICAgIHNvY2lhbEF1dGhTcGFjaW5nOiBcIjRweFwiLFxuICAgICAgYnV0dG9uUGFkZGluZzogXCIxMHB4IDE1cHhcIixcbiAgICAgIGlucHV0UGFkZGluZzogXCIxMHB4IDE1cHhcIlxuICAgIH0sXG4gICAgZm9udFNpemVzOiB7XG4gICAgICBiYXNlQm9keVNpemU6IFwiMTNweFwiLFxuICAgICAgYmFzZUlucHV0U2l6ZTogXCIxNHB4XCIsXG4gICAgICBiYXNlTGFiZWxTaXplOiBcIjE0cHhcIixcbiAgICAgIGJhc2VCdXR0b25TaXplOiBcIjE0cHhcIlxuICAgIH0sXG4gICAgZm9udHM6IHtcbiAgICAgIGJvZHlGb250RmFtaWx5OiBgdWktc2Fucy1zZXJpZiwgc2Fucy1zZXJpZmAsXG4gICAgICBidXR0b25Gb250RmFtaWx5OiBgdWktc2Fucy1zZXJpZiwgc2Fucy1zZXJpZmAsXG4gICAgICBpbnB1dEZvbnRGYW1pbHk6IGB1aS1zYW5zLXNlcmlmLCBzYW5zLXNlcmlmYCxcbiAgICAgIGxhYmVsRm9udEZhbWlseTogYHVpLXNhbnMtc2VyaWYsIHNhbnMtc2VyaWZgXG4gICAgfSxcbiAgICAvLyBmb250V2VpZ2h0czoge30sXG4gICAgLy8gbGluZUhlaWdodHM6IHt9LFxuICAgIC8vIGxldHRlclNwYWNpbmdzOiB7fSxcbiAgICAvLyBzaXplczoge30sXG4gICAgYm9yZGVyV2lkdGhzOiB7XG4gICAgICBidXR0b25Cb3JkZXJXaWR0aDogXCIxcHhcIixcbiAgICAgIGlucHV0Qm9yZGVyV2lkdGg6IFwiMXB4XCJcbiAgICB9LFxuICAgIC8vIGJvcmRlclN0eWxlczoge30sXG4gICAgcmFkaWk6IHtcbiAgICAgIGJvcmRlclJhZGl1c0J1dHRvbjogXCI0cHhcIixcbiAgICAgIGJ1dHRvbkJvcmRlclJhZGl1czogXCI0cHhcIixcbiAgICAgIGlucHV0Qm9yZGVyUmFkaXVzOiBcIjRweFwiXG4gICAgfVxuICAgIC8vIHNoYWRvd3M6IHt9LFxuICAgIC8vIHpJbmRpY2VzOiB7fSxcbiAgICAvLyB0cmFuc2l0aW9uczoge30sXG4gIH0sXG4gIGRhcms6IHtcbiAgICBjb2xvcnM6IHtcbiAgICAgIGJyYW5kQnV0dG9uVGV4dDogXCJ3aGl0ZVwiLFxuICAgICAgZGVmYXVsdEJ1dHRvbkJhY2tncm91bmQ6IFwiIzJlMmUyZVwiLFxuICAgICAgZGVmYXVsdEJ1dHRvbkJhY2tncm91bmRIb3ZlcjogXCIjM2UzZTNlXCIsXG4gICAgICBkZWZhdWx0QnV0dG9uQm9yZGVyOiBcIiMzZTNlM2VcIixcbiAgICAgIGRlZmF1bHRCdXR0b25UZXh0OiBcIndoaXRlXCIsXG4gICAgICBkaXZpZGVyQmFja2dyb3VuZDogXCIjMmUyZTJlXCIsXG4gICAgICBpbnB1dEJhY2tncm91bmQ6IFwiIzFlMWUxZVwiLFxuICAgICAgaW5wdXRCb3JkZXI6IFwiIzNlM2UzZVwiLFxuICAgICAgaW5wdXRCb3JkZXJIb3ZlcjogXCJncmF5XCIsXG4gICAgICBpbnB1dEJvcmRlckZvY3VzOiBcImdyYXlcIixcbiAgICAgIGlucHV0VGV4dDogXCJ3aGl0ZVwiLFxuICAgICAgaW5wdXRQbGFjZWhvbGRlcjogXCJkYXJrZ3JheVwiLFxuICAgICAgbWVzc2FnZVRleHQ6IFwiIzg1ZTBiN1wiLFxuICAgICAgbWVzc2FnZUJhY2tncm91bmQ6IFwiIzA3MjcxOVwiLFxuICAgICAgbWVzc2FnZUJvcmRlcjogXCIjMmI4MDVhXCIsXG4gICAgICBtZXNzYWdlQmFja2dyb3VuZERhbmdlcjogXCIjMWYxMzE1XCJcbiAgICB9XG4gIH1cbn07XG52YXIgVGhlbWVNaW5pbWFsID0ge1xuICBkZWZhdWx0OiB7XG4gICAgY29sb3JzOiB7XG4gICAgICBicmFuZDogXCJibGFja1wiLFxuICAgICAgYnJhbmRBY2NlbnQ6IFwiIzMzMzMzM1wiLFxuICAgICAgYnJhbmRCdXR0b25UZXh0OiBcIndoaXRlXCIsXG4gICAgICBkZWZhdWx0QnV0dG9uQmFja2dyb3VuZDogXCJ3aGl0ZVwiLFxuICAgICAgZGVmYXVsdEJ1dHRvbkJvcmRlcjogXCJsaWdodGdyYXlcIixcbiAgICAgIGRlZmF1bHRCdXR0b25UZXh0OiBcImdyYXlcIixcbiAgICAgIGRpdmlkZXJCYWNrZ3JvdW5kOiBcIiNlYWVhZWFcIixcbiAgICAgIGlucHV0QmFja2dyb3VuZDogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgaW5wdXRCb3JkZXI6IFwibGlnaHRncmF5XCIsXG4gICAgICBpbnB1dFRleHQ6IFwiYmxhY2tcIixcbiAgICAgIGlucHV0UGxhY2Vob2xkZXI6IFwiZGFya2dyYXlcIixcbiAgICAgIG1lc3NhZ2VUZXh0OiBcIiMyYjgwNWFcIixcbiAgICAgIG1lc3NhZ2VCYWNrZ3JvdW5kOiBcIiNlN2ZjZjFcIixcbiAgICAgIG1lc3NhZ2VCb3JkZXI6IFwiI2QwZjNlMVwiLFxuICAgICAgbWVzc2FnZVRleHREYW5nZXI6IFwiI2ZmNjM2OVwiLFxuICAgICAgbWVzc2FnZUJhY2tncm91bmREYW5nZXI6IFwiI2ZmZjhmOFwiLFxuICAgICAgbWVzc2FnZUJvcmRlckRhbmdlcjogXCIjODIyMDI1XCJcbiAgICB9LFxuICAgIHNwYWNlOiB7XG4gICAgICBzcGFjZVNtYWxsOiBcIjRweFwiLFxuICAgICAgc3BhY2VNZWRpdW06IFwiOHB4XCIsXG4gICAgICBzcGFjZUxhcmdlOiBcIjE2cHhcIlxuICAgIH0sXG4gICAgZm9udFNpemVzOiB7XG4gICAgICBiYXNlSW5wdXRTaXplOiBcIjE0cHhcIixcbiAgICAgIGJhc2VMYWJlbFNpemU6IFwiMTJweFwiXG4gICAgfSxcbiAgICBmb250czoge1xuICAgICAgYm9keUZvbnRGYW1pbHk6IFwiXCIsXG4gICAgICBpbnB1dEZvbnRGYW1pbHk6IFwiXCIsXG4gICAgICBidXR0b25Gb250RmFtaWx5OiBcIlwiLFxuICAgICAgbGFiZWxGb250RmFtaWx5OiBcIlwiXG4gICAgICAvLyBsaW5rRm9udEZhbWlseTogJycsXG4gICAgfSxcbiAgICAvLyBmb250V2VpZ2h0czoge30sXG4gICAgLy8gbGluZUhlaWdodHM6IHt9LFxuICAgIC8vIGxldHRlclNwYWNpbmdzOiB7fSxcbiAgICAvLyBzaXplczoge30sXG4gICAgYm9yZGVyV2lkdGhzOiB7fSxcbiAgICAvLyBib3JkZXJTdHlsZXM6IHt9LFxuICAgIHJhZGlpOiB7fVxuICAgIC8vIHNoYWRvd3M6IHt9LFxuICAgIC8vIHpJbmRpY2VzOiB7fSxcbiAgICAvLyB0cmFuc2l0aW9uczoge30sXG4gIH0sXG4gIGRhcms6IHtcbiAgICBjb2xvcnM6IHtcbiAgICAgIGJyYW5kOiBcIndoaXRlXCIsXG4gICAgICBicmFuZEFjY2VudDogXCIjYWZhZmFmXCIsXG4gICAgICBicmFuZEJ1dHRvblRleHQ6IFwiYmxhY2tcIixcbiAgICAgIGRlZmF1bHRCdXR0b25CYWNrZ3JvdW5kOiBcIiMwODA4MDhcIixcbiAgICAgIGRlZmF1bHRCdXR0b25Cb3JkZXI6IFwiYmxhY2tcIixcbiAgICAgIGRlZmF1bHRCdXR0b25UZXh0OiBcIndoaXRlXCIsXG4gICAgICBkaXZpZGVyQmFja2dyb3VuZDogXCJibGFja1wiLFxuICAgICAgaW5wdXRCYWNrZ3JvdW5kOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICBpbnB1dEJvcmRlcjogXCJncmF5XCIsXG4gICAgICBpbnB1dFRleHQ6IFwiYmxhY2tcIixcbiAgICAgIGlucHV0UGxhY2Vob2xkZXI6IFwiZGFya2dyYXlcIixcbiAgICAgIG1lc3NhZ2VUZXh0OiBcIiM4NWUwYjdcIixcbiAgICAgIG1lc3NhZ2VCYWNrZ3JvdW5kOiBcIiMwNzI3MTlcIixcbiAgICAgIG1lc3NhZ2VCb3JkZXI6IFwiIzJiODA1YVwiLFxuICAgICAgbWVzc2FnZUJhY2tncm91bmREYW5nZXI6IFwiIzFmMTMxNVwiXG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvdGhlbWluZy9UaGVtZXMudHNcbnZhciBzdXBhYmFzZSA9IHtcbiAgY29sb3JzOiB7XG4gICAgYnJhbmQ6IFwiaHNsKDE1MyA2MC4wJSA1My4wJSlcIixcbiAgICBicmFuZEFjY2VudDogXCJoc2woMTU0IDU0LjglIDQ1LjElKVwiLFxuICAgIGJyYW5kQnV0dG9uVGV4dDogXCJ3aGl0ZVwiLFxuICAgIGRlZmF1bHRCdXR0b25CYWNrZ3JvdW5kOiBcIndoaXRlXCIsXG4gICAgZGVmYXVsdEJ1dHRvbkJhY2tncm91bmRIb3ZlcjogXCIjZWFlYWVhXCIsXG4gICAgZGVmYXVsdEJ1dHRvbkJvcmRlcjogXCJsaWdodGdyYXlcIixcbiAgICBkZWZhdWx0QnV0dG9uVGV4dDogXCJncmF5XCIsXG4gICAgZGl2aWRlckJhY2tncm91bmQ6IFwiI2VhZWFlYVwiLFxuICAgIGlucHV0QmFja2dyb3VuZDogXCJ0cmFuc3BhcmVudFwiLFxuICAgIGlucHV0Qm9yZGVyOiBcImxpZ2h0Z3JheVwiLFxuICAgIGlucHV0Qm9yZGVySG92ZXI6IFwiZ3JheVwiLFxuICAgIGlucHV0Qm9yZGVyRm9jdXM6IFwiZ3JheVwiLFxuICAgIGlucHV0VGV4dDogXCJibGFja1wiLFxuICAgIGlucHV0TGFiZWxUZXh0OiBcImdyYXlcIixcbiAgICBpbnB1dFBsYWNlaG9sZGVyOiBcImRhcmtncmF5XCIsXG4gICAgbWVzc2FnZVRleHQ6IFwiZ3JheVwiLFxuICAgIG1lc3NhZ2VUZXh0RGFuZ2VyOiBcInJlZFwiLFxuICAgIGFuY2hvclRleHRDb2xvcjogXCJncmF5XCIsXG4gICAgYW5jaG9yVGV4dEhvdmVyQ29sb3I6IFwiZGFya2dyYXlcIlxuICB9LFxuICBzcGFjZToge1xuICAgIHNwYWNlU21hbGw6IFwiNHB4XCIsXG4gICAgc3BhY2VNZWRpdW06IFwiOHB4XCIsXG4gICAgc3BhY2VMYXJnZTogXCIxNnB4XCIsXG4gICAgbGFiZWxCb3R0b21NYXJnaW46IFwiOHB4XCIsXG4gICAgYW5jaG9yQm90dG9tTWFyZ2luOiBcIjRweFwiLFxuICAgIGVtYWlsSW5wdXRTcGFjaW5nOiBcIjRweFwiLFxuICAgIHNvY2lhbEF1dGhTcGFjaW5nOiBcIjRweFwiLFxuICAgIGJ1dHRvblBhZGRpbmc6IFwiMTBweCAxNXB4XCIsXG4gICAgaW5wdXRQYWRkaW5nOiBcIjEwcHggMTVweFwiXG4gIH0sXG4gIGZvbnRTaXplczoge1xuICAgIGJhc2VCb2R5U2l6ZTogXCIxM3B4XCIsXG4gICAgYmFzZUlucHV0U2l6ZTogXCIxNHB4XCIsXG4gICAgYmFzZUxhYmVsU2l6ZTogXCIxNHB4XCIsXG4gICAgYmFzZUJ1dHRvblNpemU6IFwiMTRweFwiXG4gIH0sXG4gIGZvbnRzOiB7XG4gICAgYm9keUZvbnRGYW1pbHk6IGB1aS1zYW5zLXNlcmlmLCBzYW5zLXNlcmlmYCxcbiAgICBidXR0b25Gb250RmFtaWx5OiBgdWktc2Fucy1zZXJpZiwgc2Fucy1zZXJpZmAsXG4gICAgaW5wdXRGb250RmFtaWx5OiBgdWktc2Fucy1zZXJpZiwgc2Fucy1zZXJpZmAsXG4gICAgbGFiZWxGb250RmFtaWx5OiBgdWktc2Fucy1zZXJpZiwgc2Fucy1zZXJpZmBcbiAgfSxcbiAgLy8gZm9udFdlaWdodHM6IHt9LFxuICAvLyBsaW5lSGVpZ2h0czoge30sXG4gIC8vIGxldHRlclNwYWNpbmdzOiB7fSxcbiAgLy8gc2l6ZXM6IHt9LFxuICBib3JkZXJXaWR0aHM6IHtcbiAgICBidXR0b25Cb3JkZXJXaWR0aDogXCIxcHhcIixcbiAgICBpbnB1dEJvcmRlcldpZHRoOiBcIjFweFwiXG4gIH0sXG4gIC8vIGJvcmRlclN0eWxlczoge30sXG4gIHJhZGlpOiB7XG4gICAgYm9yZGVyUmFkaXVzQnV0dG9uOiBcIjRweFwiLFxuICAgIGJ1dHRvbkJvcmRlclJhZGl1czogXCI0cHhcIixcbiAgICBpbnB1dEJvcmRlclJhZGl1czogXCI0cHhcIlxuICB9XG4gIC8vIHNoYWRvd3M6IHt9LFxuICAvLyB6SW5kaWNlczoge30sXG4gIC8vIHRyYW5zaXRpb25zOiB7fSxcbn07XG52YXIgZGVmYXVsdERhcmtUaGVtZSA9IHtcbiAgY29sb3JzOiB7XG4gICAgYnJhbmRCdXR0b25UZXh0OiBcIndoaXRlXCIsXG4gICAgZGVmYXVsdEJ1dHRvbkJhY2tncm91bmQ6IFwiIzJlMmUyZVwiLFxuICAgIGRlZmF1bHRCdXR0b25CYWNrZ3JvdW5kSG92ZXI6IFwiIzNlM2UzZVwiLFxuICAgIGRlZmF1bHRCdXR0b25Cb3JkZXI6IFwiIzNlM2UzZVwiLFxuICAgIGRlZmF1bHRCdXR0b25UZXh0OiBcIndoaXRlXCIsXG4gICAgZGl2aWRlckJhY2tncm91bmQ6IFwiIzJlMmUyZVwiLFxuICAgIGlucHV0QmFja2dyb3VuZDogXCIjMWUxZTFlXCIsXG4gICAgaW5wdXRCb3JkZXI6IFwiIzNlM2UzZVwiLFxuICAgIGlucHV0Qm9yZGVySG92ZXI6IFwiZ3JheVwiLFxuICAgIGlucHV0Qm9yZGVyRm9jdXM6IFwiZ3JheVwiLFxuICAgIGlucHV0VGV4dDogXCJ3aGl0ZVwiLFxuICAgIGlucHV0UGxhY2Vob2xkZXI6IFwiZGFya2dyYXlcIlxuICB9XG59O1xudmFyIG1pbmltYWwgPSB7XG4gIGNvbG9yczoge1xuICAgIGJyYW5kOiBcImJsYWNrXCIsXG4gICAgYnJhbmRBY2NlbnQ6IFwiIzMzMzMzM1wiLFxuICAgIGJyYW5kQnV0dG9uVGV4dDogXCJ3aGl0ZVwiLFxuICAgIGRlZmF1bHRCdXR0b25CYWNrZ3JvdW5kOiBcIndoaXRlXCIsXG4gICAgZGVmYXVsdEJ1dHRvbkJvcmRlcjogXCJsaWdodGdyYXlcIixcbiAgICBkZWZhdWx0QnV0dG9uVGV4dDogXCJncmF5XCIsXG4gICAgZGl2aWRlckJhY2tncm91bmQ6IFwiI2VhZWFlYVwiLFxuICAgIGlucHV0QmFja2dyb3VuZDogXCJ0cmFuc3BhcmVudFwiLFxuICAgIGlucHV0Qm9yZGVyOiBcImxpZ2h0Z3JheVwiLFxuICAgIGlucHV0VGV4dDogXCJibGFja1wiLFxuICAgIGlucHV0UGxhY2Vob2xkZXI6IFwiZGFya2dyYXlcIlxuICB9LFxuICBzcGFjZToge1xuICAgIHNwYWNlU21hbGw6IFwiNHB4XCIsXG4gICAgc3BhY2VNZWRpdW06IFwiOHB4XCIsXG4gICAgc3BhY2VMYXJnZTogXCIxNnB4XCJcbiAgfSxcbiAgZm9udFNpemVzOiB7XG4gICAgYmFzZUlucHV0U2l6ZTogXCIxNHB4XCIsXG4gICAgYmFzZUxhYmVsU2l6ZTogXCIxMnB4XCJcbiAgfSxcbiAgZm9udHM6IHtcbiAgICBib2R5Rm9udEZhbWlseTogXCJcIixcbiAgICBpbnB1dEZvbnRGYW1pbHk6IFwiXCIsXG4gICAgYnV0dG9uRm9udEZhbWlseTogXCJcIixcbiAgICBsYWJlbEZvbnRGYW1pbHk6IFwiXCJcbiAgICAvLyBsaW5rRm9udEZhbWlseTogJycsXG4gIH0sXG4gIC8vIGZvbnRXZWlnaHRzOiB7fSxcbiAgLy8gbGluZUhlaWdodHM6IHt9LFxuICAvLyBsZXR0ZXJTcGFjaW5nczoge30sXG4gIC8vIHNpemVzOiB7fSxcbiAgYm9yZGVyV2lkdGhzOiB7fSxcbiAgLy8gYm9yZGVyU3R5bGVzOiB7fSxcbiAgcmFkaWk6IHt9XG4gIC8vIHNoYWRvd3M6IHt9LFxuICAvLyB6SW5kaWNlczoge30sXG4gIC8vIHRyYW5zaXRpb25zOiB7fSxcbn07XG52YXIgbWluaW1hbERhcmsgPSB7XG4gIGNvbG9yczoge1xuICAgIGJyYW5kOiBcIndoaXRlXCIsXG4gICAgYnJhbmRBY2NlbnQ6IFwiI2FmYWZhZlwiLFxuICAgIGJyYW5kQnV0dG9uVGV4dDogXCJibGFja1wiLFxuICAgIGRlZmF1bHRCdXR0b25CYWNrZ3JvdW5kOiBcIiMwODA4MDhcIixcbiAgICBkZWZhdWx0QnV0dG9uQm9yZGVyOiBcImJsYWNrXCIsXG4gICAgZGVmYXVsdEJ1dHRvblRleHQ6IFwid2hpdGVcIixcbiAgICBkaXZpZGVyQmFja2dyb3VuZDogXCJibGFja1wiLFxuICAgIGlucHV0QmFja2dyb3VuZDogXCJ0cmFuc3BhcmVudFwiLFxuICAgIGlucHV0Qm9yZGVyOiBcImdyYXlcIixcbiAgICBpbnB1dFRleHQ6IFwiYmxhY2tcIixcbiAgICBpbnB1dFBsYWNlaG9sZGVyOiBcImRhcmtncmF5XCJcbiAgfVxufTtcbnZhciBkYXJrVGhlbWVzID0ge1xuICBzdXBhYmFzZTogZGVmYXVsdERhcmtUaGVtZSxcbiAgbWluaW1hbDogbWluaW1hbERhcmtcbn07XG5cbi8vIHNyYy9jb25zdGFudHMudHNcbnZhciBWSUVXUyA9IHtcbiAgU0lHTl9JTjogXCJzaWduX2luXCIsXG4gIFNJR05fVVA6IFwic2lnbl91cFwiLFxuICBGT1JHT1RURU5fUEFTU1dPUkQ6IFwiZm9yZ290dGVuX3Bhc3N3b3JkXCIsXG4gIE1BR0lDX0xJTks6IFwibWFnaWNfbGlua1wiLFxuICBVUERBVEVfUEFTU1dPUkQ6IFwidXBkYXRlX3Bhc3N3b3JkXCIsXG4gIFZFUklGWV9PVFA6IFwidmVyaWZ5X290cFwiXG59O1xudmFyIFBSRVBFTkRFRF9DTEFTU19OQU1FUyA9IFwic3VwYWJhc2UtYXV0aC11aVwiO1xudmFyIENMQVNTX05BTUVTID0ge1xuICAvLyBpbnRlcmZhY2VzXG4gIFJPT1Q6IFwicm9vdFwiLFxuICBTSUdOX0lOOiBWSUVXUy5TSUdOX0lOLFxuICBTSUdOX1VQOiBWSUVXUy5TSUdOX1VQLFxuICBGT1JHT1RURU5fUEFTU1dPUkQ6IFZJRVdTLkZPUkdPVFRFTl9QQVNTV09SRCxcbiAgTUFHSUNfTElOSzogVklFV1MuTUFHSUNfTElOSyxcbiAgVVBEQVRFX1BBU1NXT1JEOiBWSUVXUy5VUERBVEVfUEFTU1dPUkQsXG4gIC8vIHVpXG4gIGFuY2hvcjogXCJ1aS1hbmNob3JcIixcbiAgYnV0dG9uOiBcInVpLWJ1dHRvblwiLFxuICBjb250YWluZXI6IFwidWktY29udGFpbmVyXCIsXG4gIGRpdmlkZXI6IFwidWktZGl2aWRlclwiLFxuICBpbnB1dDogXCJ1aS1pbnB1dFwiLFxuICBsYWJlbDogXCJ1aS1sYWJlbFwiLFxuICBsb2FkZXI6IFwidWktbG9hZGVyXCIsXG4gIG1lc3NhZ2U6IFwidWktbWVzc2FnZVwiXG59O1xuXG4vLyBzcmMvdGhlbWluZy91dGlscy50c1xuZnVuY3Rpb24gZ2VuZXJhdGVDbGFzc05hbWVzKGNsYXNzTmFtZUtleSwgZGVmYXVsdFN0eWxlcywgYXBwZWFyYW5jZSkge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBjbGFzc05hbWVzID0gW107XG4gIGNvbnN0IGNsYXNzTmFtZSA9IENMQVNTX05BTUVTW2NsYXNzTmFtZUtleV07XG4gIGNsYXNzTmFtZXMucHVzaChcbiAgICAoYXBwZWFyYW5jZSA9PSBudWxsID8gdm9pZCAwIDogYXBwZWFyYW5jZS5wcmVwZW5kZWRDbGFzc05hbWUpID8gKGFwcGVhcmFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGFwcGVhcmFuY2UucHJlcGVuZGVkQ2xhc3NOYW1lKSArIFwiX1wiICsgY2xhc3NOYW1lIDogUFJFUEVOREVEX0NMQVNTX05BTUVTICsgXCJfXCIgKyBjbGFzc05hbWVcbiAgKTtcbiAgaWYgKChfYSA9IGFwcGVhcmFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGFwcGVhcmFuY2UuY2xhc3NOYW1lKSA9PSBudWxsID8gdm9pZCAwIDogX2FbY2xhc3NOYW1lS2V5XSkge1xuICAgIGNsYXNzTmFtZXMucHVzaCgoX2IgPSBhcHBlYXJhbmNlID09IG51bGwgPyB2b2lkIDAgOiBhcHBlYXJhbmNlLmNsYXNzTmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iW2NsYXNzTmFtZUtleV0pO1xuICB9XG4gIGlmICgoYXBwZWFyYW5jZSA9PSBudWxsID8gdm9pZCAwIDogYXBwZWFyYW5jZS5leHRlbmQpID09PSB2b2lkIDAgfHwgKGFwcGVhcmFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGFwcGVhcmFuY2UuZXh0ZW5kKSA9PT0gdHJ1ZSkge1xuICAgIGNsYXNzTmFtZXMucHVzaChkZWZhdWx0U3R5bGVzKTtcbiAgfVxuICByZXR1cm4gY2xhc3NOYW1lcztcbn1cblxuLy8gc3JjL3R5cGVzLnRzXG52YXIgU29jaWFsTGF5b3V0cyA9IC8qIEBfX1BVUkVfXyAqLyAoKFNvY2lhbExheW91dHMyKSA9PiB7XG4gIFNvY2lhbExheW91dHMyW1NvY2lhbExheW91dHMyW1wiaG9yaXpvbnRhbFwiXSA9IDBdID0gXCJob3Jpem9udGFsXCI7XG4gIFNvY2lhbExheW91dHMyW1NvY2lhbExheW91dHMyW1widmVydGljYWxcIl0gPSAxXSA9IFwidmVydGljYWxcIjtcbiAgcmV0dXJuIFNvY2lhbExheW91dHMyO1xufSkoU29jaWFsTGF5b3V0cyB8fCB7fSk7XG5cbi8vIHNyYy91dGlscy50c1xuZnVuY3Rpb24gdmFsdWUoc3JjLCBuZXh0KSB7XG4gIGxldCBrO1xuICBpZiAoc3JjICYmIG5leHQgJiYgdHlwZW9mIHNyYyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbmV4dCA9PT0gXCJvYmplY3RcIikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgICBmb3IgKGsgPSAwOyBrIDwgbmV4dC5sZW5ndGg7IGsrKykge1xuICAgICAgICBzcmNba10gPSB2YWx1ZShzcmNba10sIG5leHRba10pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGsgaW4gbmV4dCkge1xuICAgICAgICBzcmNba10gPSB2YWx1ZShzcmNba10sIG5leHRba10pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3JjO1xuICB9XG4gIHJldHVybiBuZXh0O1xufVxuZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCAuLi5hcmdzKSB7XG4gIGxldCBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHRhcmdldCA9IHZhbHVlKHRhcmdldCwgYXJnc1tpXSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHRlbXBsYXRlKHN0cmluZywgZGF0YSkge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoXG4gICAgL3t7KFxcdyspfX0vZyxcbiAgICAocGxhY2Vob2xkZXJXaXRoRGVsaW1pdGVycywgcGxhY2Vob2xkZXJXaXRob3V0RGVsaW1pdGVycykgPT4gZGF0YS5oYXNPd25Qcm9wZXJ0eShwbGFjZWhvbGRlcldpdGhvdXREZWxpbWl0ZXJzKSA/IGRhdGFbcGxhY2Vob2xkZXJXaXRob3V0RGVsaW1pdGVyc10gOiBwbGFjZWhvbGRlcldpdGhEZWxpbWl0ZXJzXG4gICk7XG59XG5cbi8vIHNyYy9sb2NhbGl6YXRpb24vZW4uanNvblxudmFyIGVuX2RlZmF1bHQgPSB7XG4gIHNpZ25fdXA6IHtcbiAgICBlbWFpbF9sYWJlbDogXCJFbWFpbCBhZGRyZXNzXCIsXG4gICAgcGFzc3dvcmRfbGFiZWw6IFwiQ3JlYXRlIGEgUGFzc3dvcmRcIixcbiAgICBlbWFpbF9pbnB1dF9wbGFjZWhvbGRlcjogXCJZb3VyIGVtYWlsIGFkZHJlc3NcIixcbiAgICBwYXNzd29yZF9pbnB1dF9wbGFjZWhvbGRlcjogXCJZb3VyIHBhc3N3b3JkXCIsXG4gICAgYnV0dG9uX2xhYmVsOiBcIlNpZ24gdXBcIixcbiAgICBsb2FkaW5nX2J1dHRvbl9sYWJlbDogXCJTaWduaW5nIHVwIC4uLlwiLFxuICAgIHNvY2lhbF9wcm92aWRlcl90ZXh0OiBcIlNpZ24gaW4gd2l0aCB7e3Byb3ZpZGVyfX1cIixcbiAgICBsaW5rX3RleHQ6IFwiRG9uJ3QgaGF2ZSBhbiBhY2NvdW50PyBTaWduIHVwXCIsXG4gICAgY29uZmlybWF0aW9uX3RleHQ6IFwiQ2hlY2sgeW91ciBlbWFpbCBmb3IgdGhlIGNvbmZpcm1hdGlvbiBsaW5rXCJcbiAgfSxcbiAgc2lnbl9pbjoge1xuICAgIGVtYWlsX2xhYmVsOiBcIkVtYWlsIGFkZHJlc3NcIixcbiAgICBwYXNzd29yZF9sYWJlbDogXCJZb3VyIFBhc3N3b3JkXCIsXG4gICAgZW1haWxfaW5wdXRfcGxhY2Vob2xkZXI6IFwiWW91ciBlbWFpbCBhZGRyZXNzXCIsXG4gICAgcGFzc3dvcmRfaW5wdXRfcGxhY2Vob2xkZXI6IFwiWW91ciBwYXNzd29yZFwiLFxuICAgIGJ1dHRvbl9sYWJlbDogXCJTaWduIGluXCIsXG4gICAgbG9hZGluZ19idXR0b25fbGFiZWw6IFwiU2lnbmluZyBpbiAuLi5cIixcbiAgICBzb2NpYWxfcHJvdmlkZXJfdGV4dDogXCJTaWduIGluIHdpdGgge3twcm92aWRlcn19XCIsXG4gICAgbGlua190ZXh0OiBcIkFscmVhZHkgaGF2ZSBhbiBhY2NvdW50PyBTaWduIGluXCJcbiAgfSxcbiAgbWFnaWNfbGluazoge1xuICAgIGVtYWlsX2lucHV0X2xhYmVsOiBcIkVtYWlsIGFkZHJlc3NcIixcbiAgICBlbWFpbF9pbnB1dF9wbGFjZWhvbGRlcjogXCJZb3VyIGVtYWlsIGFkZHJlc3NcIixcbiAgICBidXR0b25fbGFiZWw6IFwiU2VuZCBNYWdpYyBMaW5rXCIsXG4gICAgbG9hZGluZ19idXR0b25fbGFiZWw6IFwiU2VuZGluZyBNYWdpYyBMaW5rIC4uLlwiLFxuICAgIGxpbmtfdGV4dDogXCJTZW5kIGEgbWFnaWMgbGluayBlbWFpbFwiLFxuICAgIGNvbmZpcm1hdGlvbl90ZXh0OiBcIkNoZWNrIHlvdXIgZW1haWwgZm9yIHRoZSBtYWdpYyBsaW5rXCJcbiAgfSxcbiAgZm9yZ290dGVuX3Bhc3N3b3JkOiB7XG4gICAgZW1haWxfbGFiZWw6IFwiRW1haWwgYWRkcmVzc1wiLFxuICAgIHBhc3N3b3JkX2xhYmVsOiBcIllvdXIgUGFzc3dvcmRcIixcbiAgICBlbWFpbF9pbnB1dF9wbGFjZWhvbGRlcjogXCJZb3VyIGVtYWlsIGFkZHJlc3NcIixcbiAgICBidXR0b25fbGFiZWw6IFwiU2VuZCByZXNldCBwYXNzd29yZCBpbnN0cnVjdGlvbnNcIixcbiAgICBsb2FkaW5nX2J1dHRvbl9sYWJlbDogXCJTZW5kaW5nIHJlc2V0IGluc3RydWN0aW9ucyAuLi5cIixcbiAgICBsaW5rX3RleHQ6IFwiRm9yZ290IHlvdXIgcGFzc3dvcmQ/XCIsXG4gICAgY29uZmlybWF0aW9uX3RleHQ6IFwiQ2hlY2sgeW91ciBlbWFpbCBmb3IgdGhlIHBhc3N3b3JkIHJlc2V0IGxpbmtcIlxuICB9LFxuICB1cGRhdGVfcGFzc3dvcmQ6IHtcbiAgICBwYXNzd29yZF9sYWJlbDogXCJOZXcgcGFzc3dvcmRcIixcbiAgICBwYXNzd29yZF9pbnB1dF9wbGFjZWhvbGRlcjogXCJZb3VyIG5ldyBwYXNzd29yZFwiLFxuICAgIGJ1dHRvbl9sYWJlbDogXCJVcGRhdGUgcGFzc3dvcmRcIixcbiAgICBsb2FkaW5nX2J1dHRvbl9sYWJlbDogXCJVcGRhdGluZyBwYXNzd29yZCAuLi5cIixcbiAgICBjb25maXJtYXRpb25fdGV4dDogXCJZb3VyIHBhc3N3b3JkIGhhcyBiZWVuIHVwZGF0ZWRcIlxuICB9LFxuICB2ZXJpZnlfb3RwOiB7XG4gICAgZW1haWxfaW5wdXRfbGFiZWw6IFwiRW1haWwgYWRkcmVzc1wiLFxuICAgIGVtYWlsX2lucHV0X3BsYWNlaG9sZGVyOiBcIllvdXIgZW1haWwgYWRkcmVzc1wiLFxuICAgIHBob25lX2lucHV0X2xhYmVsOiBcIlBob25lIG51bWJlclwiLFxuICAgIHBob25lX2lucHV0X3BsYWNlaG9sZGVyOiBcIllvdXIgcGhvbmUgbnVtYmVyXCIsXG4gICAgdG9rZW5faW5wdXRfbGFiZWw6IFwiVG9rZW5cIixcbiAgICB0b2tlbl9pbnB1dF9wbGFjZWhvbGRlcjogXCJZb3VyIE90cCB0b2tlblwiLFxuICAgIGJ1dHRvbl9sYWJlbDogXCJWZXJpZnkgdG9rZW5cIixcbiAgICBsb2FkaW5nX2J1dHRvbl9sYWJlbDogXCJTaWduaW5nIGluIC4uLlwiXG4gIH1cbn07XG5leHBvcnQge1xuICBDTEFTU19OQU1FUyxcbiAgUFJFUEVOREVEX0NMQVNTX05BTUVTLFxuICBTb2NpYWxMYXlvdXRzLFxuICBUaGVtZU1pbmltYWwsXG4gIFRoZW1lU3VwYSxcbiAgVklFV1MsXG4gIGRhcmtUaGVtZXMsXG4gIGVuX2RlZmF1bHQgYXMgZW4sXG4gIGdlbmVyYXRlQ2xhc3NOYW1lcyxcbiAgbWVyZ2UsXG4gIG1pbmltYWwsXG4gIHN1cGFiYXNlLFxuICB0ZW1wbGF0ZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsiVGhlbWVTdXBhIiwiZGVmYXVsdCIsImNvbG9ycyIsImJyYW5kIiwiYnJhbmRBY2NlbnQiLCJicmFuZEJ1dHRvblRleHQiLCJkZWZhdWx0QnV0dG9uQmFja2dyb3VuZCIsImRlZmF1bHRCdXR0b25CYWNrZ3JvdW5kSG92ZXIiLCJkZWZhdWx0QnV0dG9uQm9yZGVyIiwiZGVmYXVsdEJ1dHRvblRleHQiLCJkaXZpZGVyQmFja2dyb3VuZCIsImlucHV0QmFja2dyb3VuZCIsImlucHV0Qm9yZGVyIiwiaW5wdXRCb3JkZXJIb3ZlciIsImlucHV0Qm9yZGVyRm9jdXMiLCJpbnB1dFRleHQiLCJpbnB1dExhYmVsVGV4dCIsImlucHV0UGxhY2Vob2xkZXIiLCJtZXNzYWdlVGV4dCIsIm1lc3NhZ2VCYWNrZ3JvdW5kIiwibWVzc2FnZUJvcmRlciIsIm1lc3NhZ2VUZXh0RGFuZ2VyIiwibWVzc2FnZUJhY2tncm91bmREYW5nZXIiLCJtZXNzYWdlQm9yZGVyRGFuZ2VyIiwiYW5jaG9yVGV4dENvbG9yIiwiYW5jaG9yVGV4dEhvdmVyQ29sb3IiLCJzcGFjZSIsInNwYWNlU21hbGwiLCJzcGFjZU1lZGl1bSIsInNwYWNlTGFyZ2UiLCJsYWJlbEJvdHRvbU1hcmdpbiIsImFuY2hvckJvdHRvbU1hcmdpbiIsImVtYWlsSW5wdXRTcGFjaW5nIiwic29jaWFsQXV0aFNwYWNpbmciLCJidXR0b25QYWRkaW5nIiwiaW5wdXRQYWRkaW5nIiwiZm9udFNpemVzIiwiYmFzZUJvZHlTaXplIiwiYmFzZUlucHV0U2l6ZSIsImJhc2VMYWJlbFNpemUiLCJiYXNlQnV0dG9uU2l6ZSIsImZvbnRzIiwiYm9keUZvbnRGYW1pbHkiLCJidXR0b25Gb250RmFtaWx5IiwiaW5wdXRGb250RmFtaWx5IiwibGFiZWxGb250RmFtaWx5IiwiYm9yZGVyV2lkdGhzIiwiYnV0dG9uQm9yZGVyV2lkdGgiLCJpbnB1dEJvcmRlcldpZHRoIiwicmFkaWkiLCJib3JkZXJSYWRpdXNCdXR0b24iLCJidXR0b25Cb3JkZXJSYWRpdXMiLCJpbnB1dEJvcmRlclJhZGl1cyIsImRhcmsiLCJUaGVtZU1pbmltYWwiLCJzdXBhYmFzZSIsImRlZmF1bHREYXJrVGhlbWUiLCJtaW5pbWFsIiwibWluaW1hbERhcmsiLCJkYXJrVGhlbWVzIiwiVklFV1MiLCJTSUdOX0lOIiwiU0lHTl9VUCIsIkZPUkdPVFRFTl9QQVNTV09SRCIsIk1BR0lDX0xJTksiLCJVUERBVEVfUEFTU1dPUkQiLCJWRVJJRllfT1RQIiwiUFJFUEVOREVEX0NMQVNTX05BTUVTIiwiQ0xBU1NfTkFNRVMiLCJST09UIiwiYW5jaG9yIiwiYnV0dG9uIiwiY29udGFpbmVyIiwiZGl2aWRlciIsImlucHV0IiwibGFiZWwiLCJsb2FkZXIiLCJtZXNzYWdlIiwiZ2VuZXJhdGVDbGFzc05hbWVzIiwiY2xhc3NOYW1lS2V5IiwiZGVmYXVsdFN0eWxlcyIsImFwcGVhcmFuY2UiLCJfYSIsIl9iIiwiY2xhc3NOYW1lcyIsImNsYXNzTmFtZSIsInB1c2giLCJwcmVwZW5kZWRDbGFzc05hbWUiLCJleHRlbmQiLCJTb2NpYWxMYXlvdXRzIiwiU29jaWFsTGF5b3V0czIiLCJ2YWx1ZSIsInNyYyIsIm5leHQiLCJrIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwibWVyZ2UiLCJ0YXJnZXQiLCJhcmdzIiwibGVuIiwiaSIsInRlbXBsYXRlIiwic3RyaW5nIiwiZGF0YSIsInJlcGxhY2UiLCJwbGFjZWhvbGRlcldpdGhEZWxpbWl0ZXJzIiwicGxhY2Vob2xkZXJXaXRob3V0RGVsaW1pdGVycyIsImhhc093blByb3BlcnR5IiwiZW5fZGVmYXVsdCIsInNpZ25fdXAiLCJlbWFpbF9sYWJlbCIsInBhc3N3b3JkX2xhYmVsIiwiZW1haWxfaW5wdXRfcGxhY2Vob2xkZXIiLCJwYXNzd29yZF9pbnB1dF9wbGFjZWhvbGRlciIsImJ1dHRvbl9sYWJlbCIsImxvYWRpbmdfYnV0dG9uX2xhYmVsIiwic29jaWFsX3Byb3ZpZGVyX3RleHQiLCJsaW5rX3RleHQiLCJjb25maXJtYXRpb25fdGV4dCIsInNpZ25faW4iLCJtYWdpY19saW5rIiwiZW1haWxfaW5wdXRfbGFiZWwiLCJmb3Jnb3R0ZW5fcGFzc3dvcmQiLCJ1cGRhdGVfcGFzc3dvcmQiLCJ2ZXJpZnlfb3RwIiwicGhvbmVfaW5wdXRfbGFiZWwiLCJwaG9uZV9pbnB1dF9wbGFjZWhvbGRlciIsInRva2VuX2lucHV0X2xhYmVsIiwidG9rZW5faW5wdXRfcGxhY2Vob2xkZXIiLCJlbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-ui-shared/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/postgrest-js/dist/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PostgrestBuilder: () => (/* binding */ PostgrestBuilder),\n/* harmony export */   PostgrestClient: () => (/* binding */ PostgrestClient),\n/* harmony export */   PostgrestError: () => (/* binding */ PostgrestError),\n/* harmony export */   PostgrestFilterBuilder: () => (/* binding */ PostgrestFilterBuilder),\n/* harmony export */   PostgrestQueryBuilder: () => (/* binding */ PostgrestQueryBuilder),\n/* harmony export */   PostgrestTransformBuilder: () => (/* binding */ PostgrestTransformBuilder),\n/* harmony export */   \"default\": () => (/* binding */ src_default)\n/* harmony export */ });\n//#region src/PostgrestError.ts\n/**\n* Error format\n*\n* {@link https://postgrest.org/en/stable/api.html?highlight=options#errors-and-http-status-codes}\n*/ var PostgrestError = class extends Error {\n    /**\n\t* @example\n\t* ```ts\n\t* import PostgrestError from '@supabase/postgrest-js'\n\t*\n\t* throw new PostgrestError({\n\t*   message: 'Row level security prevented the request',\n\t*   details: 'RLS denied the insert',\n\t*   hint: 'Check your policies',\n\t*   code: 'PGRST301',\n\t* })\n\t* ```\n\t*/ constructor(context){\n        super(context.message);\n        this.name = \"PostgrestError\";\n        this.details = context.details;\n        this.hint = context.hint;\n        this.code = context.code;\n    }\n};\n//#endregion\n//#region src/PostgrestBuilder.ts\nvar PostgrestBuilder = class {\n    /**\n\t* Creates a builder configured for a specific PostgREST request.\n\t*\n\t* @example\n\t* ```ts\n\t* import PostgrestQueryBuilder from '@supabase/postgrest-js'\n\t*\n\t* const builder = new PostgrestQueryBuilder(\n\t*   new URL('https://xyzcompany.supabase.co/rest/v1/users'),\n\t*   { headers: new Headers({ apikey: 'public-anon-key' }) }\n\t* )\n\t* ```\n\t*/ constructor(builder){\n        var _builder$shouldThrowO, _builder$isMaybeSingl, _builder$urlLengthLim;\n        this.shouldThrowOnError = false;\n        this.method = builder.method;\n        this.url = builder.url;\n        this.headers = new Headers(builder.headers);\n        this.schema = builder.schema;\n        this.body = builder.body;\n        this.shouldThrowOnError = (_builder$shouldThrowO = builder.shouldThrowOnError) !== null && _builder$shouldThrowO !== void 0 ? _builder$shouldThrowO : false;\n        this.signal = builder.signal;\n        this.isMaybeSingle = (_builder$isMaybeSingl = builder.isMaybeSingle) !== null && _builder$isMaybeSingl !== void 0 ? _builder$isMaybeSingl : false;\n        this.urlLengthLimit = (_builder$urlLengthLim = builder.urlLengthLimit) !== null && _builder$urlLengthLim !== void 0 ? _builder$urlLengthLim : 8e3;\n        if (builder.fetch) this.fetch = builder.fetch;\n        else this.fetch = fetch;\n    }\n    /**\n\t* If there's an error with the query, throwOnError will reject the promise by\n\t* throwing the error instead of returning it as part of a successful response.\n\t*\n\t* {@link https://github.com/supabase/supabase-js/issues/92}\n\t*/ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n\t* Set an HTTP header for the request.\n\t*/ setHeader(name, value) {\n        this.headers = new Headers(this.headers);\n        this.headers.set(name, value);\n        return this;\n    }\n    then(onfulfilled, onrejected) {\n        var _this = this;\n        if (this.schema === void 0) {} else if ([\n            \"GET\",\n            \"HEAD\"\n        ].includes(this.method)) this.headers.set(\"Accept-Profile\", this.schema);\n        else this.headers.set(\"Content-Profile\", this.schema);\n        if (this.method !== \"GET\" && this.method !== \"HEAD\") this.headers.set(\"Content-Type\", \"application/json\");\n        const _fetch = this.fetch;\n        let res = _fetch(this.url.toString(), {\n            method: this.method,\n            headers: this.headers,\n            body: JSON.stringify(this.body),\n            signal: this.signal\n        }).then(async (res$1)=>{\n            let error = null;\n            let data = null;\n            let count = null;\n            let status = res$1.status;\n            let statusText = res$1.statusText;\n            if (res$1.ok) {\n                var _this$headers$get2, _res$headers$get;\n                if (_this.method !== \"HEAD\") {\n                    var _this$headers$get;\n                    const body = await res$1.text();\n                    if (body === \"\") {} else if (_this.headers.get(\"Accept\") === \"text/csv\") data = body;\n                    else if (_this.headers.get(\"Accept\") && ((_this$headers$get = _this.headers.get(\"Accept\")) === null || _this$headers$get === void 0 ? void 0 : _this$headers$get.includes(\"application/vnd.pgrst.plan+text\"))) data = body;\n                    else data = JSON.parse(body);\n                }\n                const countHeader = (_this$headers$get2 = _this.headers.get(\"Prefer\")) === null || _this$headers$get2 === void 0 ? void 0 : _this$headers$get2.match(/count=(exact|planned|estimated)/);\n                const contentRange = (_res$headers$get = res$1.headers.get(\"content-range\")) === null || _res$headers$get === void 0 ? void 0 : _res$headers$get.split(\"/\");\n                if (countHeader && contentRange && contentRange.length > 1) count = parseInt(contentRange[1]);\n                if (_this.isMaybeSingle && _this.method === \"GET\" && Array.isArray(data)) if (data.length > 1) {\n                    error = {\n                        code: \"PGRST116\",\n                        details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,\n                        hint: null,\n                        message: \"JSON object requested, multiple (or no) rows returned\"\n                    };\n                    data = null;\n                    count = null;\n                    status = 406;\n                    statusText = \"Not Acceptable\";\n                } else if (data.length === 1) data = data[0];\n                else data = null;\n            } else {\n                var _error$details;\n                const body = await res$1.text();\n                try {\n                    error = JSON.parse(body);\n                    if (Array.isArray(error) && res$1.status === 404) {\n                        data = [];\n                        error = null;\n                        status = 200;\n                        statusText = \"OK\";\n                    }\n                } catch (_unused) {\n                    if (res$1.status === 404 && body === \"\") {\n                        status = 204;\n                        statusText = \"No Content\";\n                    } else error = {\n                        message: body\n                    };\n                }\n                if (error && _this.isMaybeSingle && (error === null || error === void 0 || (_error$details = error.details) === null || _error$details === void 0 ? void 0 : _error$details.includes(\"0 rows\"))) {\n                    error = null;\n                    status = 200;\n                    statusText = \"OK\";\n                }\n                if (error && _this.shouldThrowOnError) throw new PostgrestError(error);\n            }\n            return {\n                error,\n                data,\n                count,\n                status,\n                statusText\n            };\n        });\n        if (!this.shouldThrowOnError) res = res.catch((fetchError)=>{\n            var _fetchError$name2;\n            let errorDetails = \"\";\n            let hint = \"\";\n            let code = \"\";\n            const cause = fetchError === null || fetchError === void 0 ? void 0 : fetchError.cause;\n            if (cause) {\n                var _cause$message, _cause$code, _fetchError$name, _cause$name;\n                const causeMessage = (_cause$message = cause === null || cause === void 0 ? void 0 : cause.message) !== null && _cause$message !== void 0 ? _cause$message : \"\";\n                const causeCode = (_cause$code = cause === null || cause === void 0 ? void 0 : cause.code) !== null && _cause$code !== void 0 ? _cause$code : \"\";\n                errorDetails = `${(_fetchError$name = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _fetchError$name !== void 0 ? _fetchError$name : \"FetchError\"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`;\n                errorDetails += `\\n\\nCaused by: ${(_cause$name = cause === null || cause === void 0 ? void 0 : cause.name) !== null && _cause$name !== void 0 ? _cause$name : \"Error\"}: ${causeMessage}`;\n                if (causeCode) errorDetails += ` (${causeCode})`;\n                if (cause === null || cause === void 0 ? void 0 : cause.stack) errorDetails += `\\n${cause.stack}`;\n            } else {\n                var _fetchError$stack;\n                errorDetails = (_fetchError$stack = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _fetchError$stack !== void 0 ? _fetchError$stack : \"\";\n            }\n            const urlLength = this.url.toString().length;\n            if ((fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) === \"AbortError\" || (fetchError === null || fetchError === void 0 ? void 0 : fetchError.code) === \"ABORT_ERR\") {\n                code = \"\";\n                hint = \"Request was aborted (timeout or manual cancellation)\";\n                if (urlLength > this.urlLengthLimit) hint += `. Note: Your request URL is ${urlLength} characters, which may exceed server limits. If selecting many fields, consider using views. If filtering with large arrays (e.g., .in('id', [many IDs])), consider using an RPC function to pass values server-side.`;\n            } else if ((cause === null || cause === void 0 ? void 0 : cause.name) === \"HeadersOverflowError\" || (cause === null || cause === void 0 ? void 0 : cause.code) === \"UND_ERR_HEADERS_OVERFLOW\") {\n                code = \"\";\n                hint = \"HTTP headers exceeded server limits (typically 16KB)\";\n                if (urlLength > this.urlLengthLimit) hint += `. Your request URL is ${urlLength} characters. If selecting many fields, consider using views. If filtering with large arrays (e.g., .in('id', [200+ IDs])), consider using an RPC function instead.`;\n            }\n            return {\n                error: {\n                    message: `${(_fetchError$name2 = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _fetchError$name2 !== void 0 ? _fetchError$name2 : \"FetchError\"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`,\n                    details: errorDetails,\n                    hint,\n                    code\n                },\n                data: null,\n                count: null,\n                status: 0,\n                statusText: \"\"\n            };\n        });\n        return res.then(onfulfilled, onrejected);\n    }\n    /**\n\t* Override the type of the returned `data`.\n\t*\n\t* @typeParam NewResult - The new result type to override with\n\t* @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n\t*/ returns() {\n        /* istanbul ignore next */ return this;\n    }\n    /**\n\t* Override the type of the returned `data` field in the response.\n\t*\n\t* @typeParam NewResult - The new type to cast the response data to\n\t* @typeParam Options - Optional type configuration (defaults to { merge: true })\n\t* @typeParam Options.merge - When true, merges the new type with existing return type. When false, replaces the existing types entirely (defaults to true)\n\t* @example\n\t* ```typescript\n\t* // Merge with existing types (default behavior)\n\t* const query = supabase\n\t*   .from('users')\n\t*   .select()\n\t*   .overrideTypes<{ custom_field: string }>()\n\t*\n\t* // Replace existing types completely\n\t* const replaceQuery = supabase\n\t*   .from('users')\n\t*   .select()\n\t*   .overrideTypes<{ id: number; name: string }, { merge: false }>()\n\t* ```\n\t* @returns A PostgrestBuilder instance with the new type\n\t*/ overrideTypes() {\n        return this;\n    }\n};\n//#endregion\n//#region src/PostgrestTransformBuilder.ts\nvar PostgrestTransformBuilder = class extends PostgrestBuilder {\n    /**\n\t* Perform a SELECT on the query result.\n\t*\n\t* By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not\n\t* return modified rows. By calling this method, modified rows are returned in\n\t* `data`.\n\t*\n\t* @param columns - The columns to retrieve, separated by commas\n\t*/ select(columns) {\n        let quoted = false;\n        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : \"*\").split(\"\").map((c)=>{\n            if (/\\s/.test(c) && !quoted) return \"\";\n            if (c === '\"') quoted = !quoted;\n            return c;\n        }).join(\"\");\n        this.url.searchParams.set(\"select\", cleanedColumns);\n        this.headers.append(\"Prefer\", \"return=representation\");\n        return this;\n    }\n    /**\n\t* Order the query result by `column`.\n\t*\n\t* You can call this method multiple times to order by multiple columns.\n\t*\n\t* You can order referenced tables, but it only affects the ordering of the\n\t* parent table if you use `!inner` in the query.\n\t*\n\t* @param column - The column to order by\n\t* @param options - Named parameters\n\t* @param options.ascending - If `true`, the result will be in ascending order\n\t* @param options.nullsFirst - If `true`, `null`s appear first. If `false`,\n\t* `null`s appear last.\n\t* @param options.referencedTable - Set this to order a referenced table by\n\t* its columns\n\t* @param options.foreignTable - Deprecated, use `options.referencedTable`\n\t* instead\n\t*/ order(column, { ascending = true, nullsFirst, foreignTable, referencedTable = foreignTable } = {}) {\n        const key = referencedTable ? `${referencedTable}.order` : \"order\";\n        const existingOrder = this.url.searchParams.get(key);\n        this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : \"\"}${column}.${ascending ? \"asc\" : \"desc\"}${nullsFirst === void 0 ? \"\" : nullsFirst ? \".nullsfirst\" : \".nullslast\"}`);\n        return this;\n    }\n    /**\n\t* Limit the query result by `count`.\n\t*\n\t* @param count - The maximum number of rows to return\n\t* @param options - Named parameters\n\t* @param options.referencedTable - Set this to limit rows of referenced\n\t* tables instead of the parent table\n\t* @param options.foreignTable - Deprecated, use `options.referencedTable`\n\t* instead\n\t*/ limit(count, { foreignTable, referencedTable = foreignTable } = {}) {\n        const key = typeof referencedTable === \"undefined\" ? \"limit\" : `${referencedTable}.limit`;\n        this.url.searchParams.set(key, `${count}`);\n        return this;\n    }\n    /**\n\t* Limit the query result by starting at an offset `from` and ending at the offset `to`.\n\t* Only records within this range are returned.\n\t* This respects the query order and if there is no order clause the range could behave unexpectedly.\n\t* The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third\n\t* and fourth rows of the query.\n\t*\n\t* @param from - The starting index from which to limit the result\n\t* @param to - The last index to which to limit the result\n\t* @param options - Named parameters\n\t* @param options.referencedTable - Set this to limit rows of referenced\n\t* tables instead of the parent table\n\t* @param options.foreignTable - Deprecated, use `options.referencedTable`\n\t* instead\n\t*/ range(from, to, { foreignTable, referencedTable = foreignTable } = {}) {\n        const keyOffset = typeof referencedTable === \"undefined\" ? \"offset\" : `${referencedTable}.offset`;\n        const keyLimit = typeof referencedTable === \"undefined\" ? \"limit\" : `${referencedTable}.limit`;\n        this.url.searchParams.set(keyOffset, `${from}`);\n        this.url.searchParams.set(keyLimit, `${to - from + 1}`);\n        return this;\n    }\n    /**\n\t* Set the AbortSignal for the fetch request.\n\t*\n\t* @param signal - The AbortSignal to use for the fetch request\n\t*/ abortSignal(signal) {\n        this.signal = signal;\n        return this;\n    }\n    /**\n\t* Return `data` as a single object instead of an array of objects.\n\t*\n\t* Query result must be one row (e.g. using `.limit(1)`), otherwise this\n\t* returns an error.\n\t*/ single() {\n        this.headers.set(\"Accept\", \"application/vnd.pgrst.object+json\");\n        return this;\n    }\n    /**\n\t* Return `data` as a single object instead of an array of objects.\n\t*\n\t* Query result must be zero or one row (e.g. using `.limit(1)`), otherwise\n\t* this returns an error.\n\t*/ maybeSingle() {\n        if (this.method === \"GET\") this.headers.set(\"Accept\", \"application/json\");\n        else this.headers.set(\"Accept\", \"application/vnd.pgrst.object+json\");\n        this.isMaybeSingle = true;\n        return this;\n    }\n    /**\n\t* Return `data` as a string in CSV format.\n\t*/ csv() {\n        this.headers.set(\"Accept\", \"text/csv\");\n        return this;\n    }\n    /**\n\t* Return `data` as an object in [GeoJSON](https://geojson.org) format.\n\t*/ geojson() {\n        this.headers.set(\"Accept\", \"application/geo+json\");\n        return this;\n    }\n    /**\n\t* Return `data` as the EXPLAIN plan for the query.\n\t*\n\t* You need to enable the\n\t* [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)\n\t* setting before using this method.\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.analyze - If `true`, the query will be executed and the\n\t* actual run time will be returned\n\t*\n\t* @param options.verbose - If `true`, the query identifier will be returned\n\t* and `data` will include the output columns of the query\n\t*\n\t* @param options.settings - If `true`, include information on configuration\n\t* parameters that affect query planning\n\t*\n\t* @param options.buffers - If `true`, include information on buffer usage\n\t*\n\t* @param options.wal - If `true`, include information on WAL record generation\n\t*\n\t* @param options.format - The format of the output, can be `\"text\"` (default)\n\t* or `\"json\"`\n\t*/ explain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = \"text\" } = {}) {\n        var _this$headers$get;\n        const options = [\n            analyze ? \"analyze\" : null,\n            verbose ? \"verbose\" : null,\n            settings ? \"settings\" : null,\n            buffers ? \"buffers\" : null,\n            wal ? \"wal\" : null\n        ].filter(Boolean).join(\"|\");\n        const forMediatype = (_this$headers$get = this.headers.get(\"Accept\")) !== null && _this$headers$get !== void 0 ? _this$headers$get : \"application/json\";\n        this.headers.set(\"Accept\", `application/vnd.pgrst.plan+${format}; for=\"${forMediatype}\"; options=${options};`);\n        if (format === \"json\") return this;\n        else return this;\n    }\n    /**\n\t* Rollback the query.\n\t*\n\t* `data` will still be returned, but the query is not committed.\n\t*/ rollback() {\n        this.headers.append(\"Prefer\", \"tx=rollback\");\n        return this;\n    }\n    /**\n\t* Override the type of the returned `data`.\n\t*\n\t* @typeParam NewResult - The new result type to override with\n\t* @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n\t*/ returns() {\n        return this;\n    }\n    /**\n\t* Set the maximum number of rows that can be affected by the query.\n\t* Only available in PostgREST v13+ and only works with PATCH and DELETE methods.\n\t*\n\t* @param value - The maximum number of rows that can be affected\n\t*/ maxAffected(value) {\n        this.headers.append(\"Prefer\", \"handling=strict\");\n        this.headers.append(\"Prefer\", `max-affected=${value}`);\n        return this;\n    }\n};\n//#endregion\n//#region src/PostgrestFilterBuilder.ts\nconst PostgrestReservedCharsRegexp = /* @__PURE__ */ new RegExp(\"[,()]\");\nvar PostgrestFilterBuilder = class extends PostgrestTransformBuilder {\n    /**\n\t* Match only rows where `column` is equal to `value`.\n\t*\n\t* To check if the value of `column` is NULL, you should use `.is()` instead.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ eq(column, value) {\n        this.url.searchParams.append(column, `eq.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is not equal to `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ neq(column, value) {\n        this.url.searchParams.append(column, `neq.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is greater than `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ gt(column, value) {\n        this.url.searchParams.append(column, `gt.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is greater than or equal to `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ gte(column, value) {\n        this.url.searchParams.append(column, `gte.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is less than `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ lt(column, value) {\n        this.url.searchParams.append(column, `lt.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is less than or equal to `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ lte(column, value) {\n        this.url.searchParams.append(column, `lte.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches `pattern` case-sensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param pattern - The pattern to match with\n\t*/ like(column, pattern) {\n        this.url.searchParams.append(column, `like.${pattern}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches all of `patterns` case-sensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param patterns - The patterns to match with\n\t*/ likeAllOf(column, patterns) {\n        this.url.searchParams.append(column, `like(all).{${patterns.join(\",\")}}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches any of `patterns` case-sensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param patterns - The patterns to match with\n\t*/ likeAnyOf(column, patterns) {\n        this.url.searchParams.append(column, `like(any).{${patterns.join(\",\")}}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches `pattern` case-insensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param pattern - The pattern to match with\n\t*/ ilike(column, pattern) {\n        this.url.searchParams.append(column, `ilike.${pattern}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches all of `patterns` case-insensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param patterns - The patterns to match with\n\t*/ ilikeAllOf(column, patterns) {\n        this.url.searchParams.append(column, `ilike(all).{${patterns.join(\",\")}}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches any of `patterns` case-insensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param patterns - The patterns to match with\n\t*/ ilikeAnyOf(column, patterns) {\n        this.url.searchParams.append(column, `ilike(any).{${patterns.join(\",\")}}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches the PostgreSQL regex `pattern`\n\t* case-sensitively (using the `~` operator).\n\t*\n\t* @param column - The column to filter on\n\t* @param pattern - The PostgreSQL regular expression pattern to match with\n\t*/ regexMatch(column, pattern) {\n        this.url.searchParams.append(column, `match.${pattern}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches the PostgreSQL regex `pattern`\n\t* case-insensitively (using the `~*` operator).\n\t*\n\t* @param column - The column to filter on\n\t* @param pattern - The PostgreSQL regular expression pattern to match with\n\t*/ regexIMatch(column, pattern) {\n        this.url.searchParams.append(column, `imatch.${pattern}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` IS `value`.\n\t*\n\t* For non-boolean columns, this is only relevant for checking if the value of\n\t* `column` is NULL by setting `value` to `null`.\n\t*\n\t* For boolean columns, you can also set `value` to `true` or `false` and it\n\t* will behave the same way as `.eq()`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ is(column, value) {\n        this.url.searchParams.append(column, `is.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` IS DISTINCT FROM `value`.\n\t*\n\t* Unlike `.neq()`, this treats `NULL` as a comparable value. Two `NULL` values\n\t* are considered equal (not distinct), and comparing `NULL` with any non-NULL\n\t* value returns true (distinct).\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ isDistinct(column, value) {\n        this.url.searchParams.append(column, `isdistinct.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is included in the `values` array.\n\t*\n\t* @param column - The column to filter on\n\t* @param values - The values array to filter with\n\t*/ in(column, values) {\n        const cleanedValues = Array.from(new Set(values)).map((s)=>{\n            if (typeof s === \"string\" && PostgrestReservedCharsRegexp.test(s)) return `\"${s}\"`;\n            else return `${s}`;\n        }).join(\",\");\n        this.url.searchParams.append(column, `in.(${cleanedValues})`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is NOT included in the `values` array.\n\t*\n\t* @param column - The column to filter on\n\t* @param values - The values array to filter with\n\t*/ notIn(column, values) {\n        const cleanedValues = Array.from(new Set(values)).map((s)=>{\n            if (typeof s === \"string\" && PostgrestReservedCharsRegexp.test(s)) return `\"${s}\"`;\n            else return `${s}`;\n        }).join(\",\");\n        this.url.searchParams.append(column, `not.in.(${cleanedValues})`);\n        return this;\n    }\n    /**\n\t* Only relevant for jsonb, array, and range columns. Match only rows where\n\t* `column` contains every element appearing in `value`.\n\t*\n\t* @param column - The jsonb, array, or range column to filter on\n\t* @param value - The jsonb, array, or range value to filter with\n\t*/ contains(column, value) {\n        if (typeof value === \"string\") this.url.searchParams.append(column, `cs.${value}`);\n        else if (Array.isArray(value)) this.url.searchParams.append(column, `cs.{${value.join(\",\")}}`);\n        else this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);\n        return this;\n    }\n    /**\n\t* Only relevant for jsonb, array, and range columns. Match only rows where\n\t* every element appearing in `column` is contained by `value`.\n\t*\n\t* @param column - The jsonb, array, or range column to filter on\n\t* @param value - The jsonb, array, or range value to filter with\n\t*/ containedBy(column, value) {\n        if (typeof value === \"string\") this.url.searchParams.append(column, `cd.${value}`);\n        else if (Array.isArray(value)) this.url.searchParams.append(column, `cd.{${value.join(\",\")}}`);\n        else this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);\n        return this;\n    }\n    /**\n\t* Only relevant for range columns. Match only rows where every element in\n\t* `column` is greater than any element in `range`.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/ rangeGt(column, range) {\n        this.url.searchParams.append(column, `sr.${range}`);\n        return this;\n    }\n    /**\n\t* Only relevant for range columns. Match only rows where every element in\n\t* `column` is either contained in `range` or greater than any element in\n\t* `range`.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/ rangeGte(column, range) {\n        this.url.searchParams.append(column, `nxl.${range}`);\n        return this;\n    }\n    /**\n\t* Only relevant for range columns. Match only rows where every element in\n\t* `column` is less than any element in `range`.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/ rangeLt(column, range) {\n        this.url.searchParams.append(column, `sl.${range}`);\n        return this;\n    }\n    /**\n\t* Only relevant for range columns. Match only rows where every element in\n\t* `column` is either contained in `range` or less than any element in\n\t* `range`.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/ rangeLte(column, range) {\n        this.url.searchParams.append(column, `nxr.${range}`);\n        return this;\n    }\n    /**\n\t* Only relevant for range columns. Match only rows where `column` is\n\t* mutually exclusive to `range` and there can be no element between the two\n\t* ranges.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/ rangeAdjacent(column, range) {\n        this.url.searchParams.append(column, `adj.${range}`);\n        return this;\n    }\n    /**\n\t* Only relevant for array and range columns. Match only rows where\n\t* `column` and `value` have an element in common.\n\t*\n\t* @param column - The array or range column to filter on\n\t* @param value - The array or range value to filter with\n\t*/ overlaps(column, value) {\n        if (typeof value === \"string\") this.url.searchParams.append(column, `ov.${value}`);\n        else this.url.searchParams.append(column, `ov.{${value.join(\",\")}}`);\n        return this;\n    }\n    /**\n\t* Only relevant for text and tsvector columns. Match only rows where\n\t* `column` matches the query string in `query`.\n\t*\n\t* @param column - The text or tsvector column to filter on\n\t* @param query - The query text to match with\n\t* @param options - Named parameters\n\t* @param options.config - The text search configuration to use\n\t* @param options.type - Change how the `query` text is interpreted\n\t*/ textSearch(column, query, { config, type } = {}) {\n        let typePart = \"\";\n        if (type === \"plain\") typePart = \"pl\";\n        else if (type === \"phrase\") typePart = \"ph\";\n        else if (type === \"websearch\") typePart = \"w\";\n        const configPart = config === void 0 ? \"\" : `(${config})`;\n        this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);\n        return this;\n    }\n    /**\n\t* Match only rows where each column in `query` keys is equal to its\n\t* associated value. Shorthand for multiple `.eq()`s.\n\t*\n\t* @param query - The object to filter with, with column names as keys mapped\n\t* to their filter values\n\t*/ match(query) {\n        Object.entries(query).forEach(([column, value])=>{\n            this.url.searchParams.append(column, `eq.${value}`);\n        });\n        return this;\n    }\n    /**\n\t* Match only rows which doesn't satisfy the filter.\n\t*\n\t* Unlike most filters, `opearator` and `value` are used as-is and need to\n\t* follow [PostgREST\n\t* syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n\t* to make sure they are properly sanitized.\n\t*\n\t* @param column - The column to filter on\n\t* @param operator - The operator to be negated to filter with, following\n\t* PostgREST syntax\n\t* @param value - The value to filter with, following PostgREST syntax\n\t*/ not(column, operator, value) {\n        this.url.searchParams.append(column, `not.${operator}.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows which satisfy at least one of the filters.\n\t*\n\t* Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\n\t* syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n\t* to make sure it's properly sanitized.\n\t*\n\t* It's currently not possible to do an `.or()` filter across multiple tables.\n\t*\n\t* @param filters - The filters to use, following PostgREST syntax\n\t* @param options - Named parameters\n\t* @param options.referencedTable - Set this to filter on referenced tables\n\t* instead of the parent table\n\t* @param options.foreignTable - Deprecated, use `referencedTable` instead\n\t*/ or(filters, { foreignTable, referencedTable = foreignTable } = {}) {\n        const key = referencedTable ? `${referencedTable}.or` : \"or\";\n        this.url.searchParams.append(key, `(${filters})`);\n        return this;\n    }\n    /**\n\t* Match only rows which satisfy the filter. This is an escape hatch - you\n\t* should use the specific filter methods wherever possible.\n\t*\n\t* Unlike most filters, `opearator` and `value` are used as-is and need to\n\t* follow [PostgREST\n\t* syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n\t* to make sure they are properly sanitized.\n\t*\n\t* @param column - The column to filter on\n\t* @param operator - The operator to filter with, following PostgREST syntax\n\t* @param value - The value to filter with, following PostgREST syntax\n\t*/ filter(column, operator, value) {\n        this.url.searchParams.append(column, `${operator}.${value}`);\n        return this;\n    }\n};\n//#endregion\n//#region src/PostgrestQueryBuilder.ts\nvar PostgrestQueryBuilder = class {\n    /**\n\t* Creates a query builder scoped to a Postgres table or view.\n\t*\n\t* @example\n\t* ```ts\n\t* import PostgrestQueryBuilder from '@supabase/postgrest-js'\n\t*\n\t* const query = new PostgrestQueryBuilder(\n\t*   new URL('https://xyzcompany.supabase.co/rest/v1/users'),\n\t*   { headers: { apikey: 'public-anon-key' } }\n\t* )\n\t* ```\n\t*/ constructor(url, { headers = {}, schema, fetch: fetch$1, urlLengthLimit = 8e3 }){\n        this.url = url;\n        this.headers = new Headers(headers);\n        this.schema = schema;\n        this.fetch = fetch$1;\n        this.urlLengthLimit = urlLengthLimit;\n    }\n    /**\n\t* Clone URL and headers to prevent shared state between operations.\n\t*/ cloneRequestState() {\n        return {\n            url: new URL(this.url.toString()),\n            headers: new Headers(this.headers)\n        };\n    }\n    /**\n\t* Perform a SELECT query on the table or view.\n\t*\n\t* @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.head - When set to `true`, `data` will not be returned.\n\t* Useful if you only need the count.\n\t*\n\t* @param options.count - Count algorithm to use to count rows in the table or view.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*\n\t* @remarks\n\t* When using `count` with `.range()` or `.limit()`, the returned `count` is the total number of rows\n\t* that match your filters, not the number of rows in the current page. Use this to build pagination UI.\n\t*/ select(columns, options) {\n        const { head = false, count } = options !== null && options !== void 0 ? options : {};\n        const method = head ? \"HEAD\" : \"GET\";\n        let quoted = false;\n        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : \"*\").split(\"\").map((c)=>{\n            if (/\\s/.test(c) && !quoted) return \"\";\n            if (c === '\"') quoted = !quoted;\n            return c;\n        }).join(\"\");\n        const { url, headers } = this.cloneRequestState();\n        url.searchParams.set(\"select\", cleanedColumns);\n        if (count) headers.append(\"Prefer\", `count=${count}`);\n        return new PostgrestFilterBuilder({\n            method,\n            url,\n            headers,\n            schema: this.schema,\n            fetch: this.fetch,\n            urlLengthLimit: this.urlLengthLimit\n        });\n    }\n    /**\n\t* Perform an INSERT into the table or view.\n\t*\n\t* By default, inserted rows are not returned. To return it, chain the call\n\t* with `.select()`.\n\t*\n\t* @param values - The values to insert. Pass an object to insert a single row\n\t* or an array to insert multiple rows.\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.count - Count algorithm to use to count inserted rows.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*\n\t* @param options.defaultToNull - Make missing fields default to `null`.\n\t* Otherwise, use the default value for the column. Only applies for bulk\n\t* inserts.\n\t*/ insert(values, { count, defaultToNull = true } = {}) {\n        var _this$fetch;\n        const method = \"POST\";\n        const { url, headers } = this.cloneRequestState();\n        if (count) headers.append(\"Prefer\", `count=${count}`);\n        if (!defaultToNull) headers.append(\"Prefer\", `missing=default`);\n        if (Array.isArray(values)) {\n            const columns = values.reduce((acc, x)=>acc.concat(Object.keys(x)), []);\n            if (columns.length > 0) {\n                const uniqueColumns = [\n                    ...new Set(columns)\n                ].map((column)=>`\"${column}\"`);\n                url.searchParams.set(\"columns\", uniqueColumns.join(\",\"));\n            }\n        }\n        return new PostgrestFilterBuilder({\n            method,\n            url,\n            headers,\n            schema: this.schema,\n            body: values,\n            fetch: (_this$fetch = this.fetch) !== null && _this$fetch !== void 0 ? _this$fetch : fetch,\n            urlLengthLimit: this.urlLengthLimit\n        });\n    }\n    /**\n\t* Perform an UPSERT on the table or view. Depending on the column(s) passed\n\t* to `onConflict`, `.upsert()` allows you to perform the equivalent of\n\t* `.insert()` if a row with the corresponding `onConflict` columns doesn't\n\t* exist, or if it does exist, perform an alternative action depending on\n\t* `ignoreDuplicates`.\n\t*\n\t* By default, upserted rows are not returned. To return it, chain the call\n\t* with `.select()`.\n\t*\n\t* @param values - The values to upsert with. Pass an object to upsert a\n\t* single row or an array to upsert multiple rows.\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n\t* duplicate rows are determined. Two rows are duplicates if all the\n\t* `onConflict` columns are equal.\n\t*\n\t* @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n\t* `false`, duplicate rows are merged with existing rows.\n\t*\n\t* @param options.count - Count algorithm to use to count upserted rows.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*\n\t* @param options.defaultToNull - Make missing fields default to `null`.\n\t* Otherwise, use the default value for the column. This only applies when\n\t* inserting new rows, not when merging with existing rows under\n\t* `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\n\t*\n\t* @example Upsert a single row using a unique key\n\t* ```ts\n\t* // Upserting a single row, overwriting based on the 'username' unique column\n\t* const { data, error } = await supabase\n\t*   .from('users')\n\t*   .upsert({ username: 'supabot' }, { onConflict: 'username' })\n\t*\n\t* // Example response:\n\t* // {\n\t* //   data: [\n\t* //     { id: 4, message: 'bar', username: 'supabot' }\n\t* //   ],\n\t* //   error: null\n\t* // }\n\t* ```\n\t*\n\t* @example Upsert with conflict resolution and exact row counting\n\t* ```ts\n\t* // Upserting and returning exact count\n\t* const { data, error, count } = await supabase\n\t*   .from('users')\n\t*   .upsert(\n\t*     {\n\t*       id: 3,\n\t*       message: 'foo',\n\t*       username: 'supabot'\n\t*     },\n\t*     {\n\t*       onConflict: 'username',\n\t*       count: 'exact'\n\t*     }\n\t*   )\n\t*\n\t* // Example response:\n\t* // {\n\t* //   data: [\n\t* //     {\n\t* //       id: 42,\n\t* //       handle: \"saoirse\",\n\t* //       display_name: \"Saoirse\"\n\t* //     }\n\t* //   ],\n\t* //   count: 1,\n\t* //   error: null\n\t* // }\n\t* ```\n\t*/ upsert(values, { onConflict, ignoreDuplicates = false, count, defaultToNull = true } = {}) {\n        var _this$fetch2;\n        const method = \"POST\";\n        const { url, headers } = this.cloneRequestState();\n        headers.append(\"Prefer\", `resolution=${ignoreDuplicates ? \"ignore\" : \"merge\"}-duplicates`);\n        if (onConflict !== void 0) url.searchParams.set(\"on_conflict\", onConflict);\n        if (count) headers.append(\"Prefer\", `count=${count}`);\n        if (!defaultToNull) headers.append(\"Prefer\", \"missing=default\");\n        if (Array.isArray(values)) {\n            const columns = values.reduce((acc, x)=>acc.concat(Object.keys(x)), []);\n            if (columns.length > 0) {\n                const uniqueColumns = [\n                    ...new Set(columns)\n                ].map((column)=>`\"${column}\"`);\n                url.searchParams.set(\"columns\", uniqueColumns.join(\",\"));\n            }\n        }\n        return new PostgrestFilterBuilder({\n            method,\n            url,\n            headers,\n            schema: this.schema,\n            body: values,\n            fetch: (_this$fetch2 = this.fetch) !== null && _this$fetch2 !== void 0 ? _this$fetch2 : fetch,\n            urlLengthLimit: this.urlLengthLimit\n        });\n    }\n    /**\n\t* Perform an UPDATE on the table or view.\n\t*\n\t* By default, updated rows are not returned. To return it, chain the call\n\t* with `.select()` after filters.\n\t*\n\t* @param values - The values to update with\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.count - Count algorithm to use to count updated rows.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*/ update(values, { count } = {}) {\n        var _this$fetch3;\n        const method = \"PATCH\";\n        const { url, headers } = this.cloneRequestState();\n        if (count) headers.append(\"Prefer\", `count=${count}`);\n        return new PostgrestFilterBuilder({\n            method,\n            url,\n            headers,\n            schema: this.schema,\n            body: values,\n            fetch: (_this$fetch3 = this.fetch) !== null && _this$fetch3 !== void 0 ? _this$fetch3 : fetch,\n            urlLengthLimit: this.urlLengthLimit\n        });\n    }\n    /**\n\t* Perform a DELETE on the table or view.\n\t*\n\t* By default, deleted rows are not returned. To return it, chain the call\n\t* with `.select()` after filters.\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.count - Count algorithm to use to count deleted rows.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*/ delete({ count } = {}) {\n        var _this$fetch4;\n        const method = \"DELETE\";\n        const { url, headers } = this.cloneRequestState();\n        if (count) headers.append(\"Prefer\", `count=${count}`);\n        return new PostgrestFilterBuilder({\n            method,\n            url,\n            headers,\n            schema: this.schema,\n            fetch: (_this$fetch4 = this.fetch) !== null && _this$fetch4 !== void 0 ? _this$fetch4 : fetch,\n            urlLengthLimit: this.urlLengthLimit\n        });\n    }\n};\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/typeof.js\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o$1) {\n        return typeof o$1;\n    } : function(o$1) {\n        return o$1 && \"function\" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? \"symbol\" : typeof o$1;\n    }, _typeof(o);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPrimitive.js\nfunction toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPropertyKey.js\nfunction toPropertyKey(t) {\n    var i = toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/defineProperty.js\nfunction _defineProperty(e, r, t) {\n    return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/objectSpread2.js\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r$1) {\n            return Object.getOwnPropertyDescriptor(e, r$1).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread2(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r$1) {\n            _defineProperty(e, r$1, t[r$1]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {\n            Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));\n        });\n    }\n    return e;\n}\n//#endregion\n//#region src/PostgrestClient.ts\n/**\n* PostgREST client.\n*\n* @typeParam Database - Types for the schema from the [type\n* generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\n*\n* @typeParam SchemaName - Postgres schema to switch to. Must be a string\n* literal, the same one passed to the constructor. If the schema is not\n* `\"public\"`, this must be supplied manually.\n*/ var PostgrestClient = class PostgrestClient {\n    /**\n\t* Creates a PostgREST client.\n\t*\n\t* @param url - URL of the PostgREST endpoint\n\t* @param options - Named parameters\n\t* @param options.headers - Custom headers\n\t* @param options.schema - Postgres schema to switch to\n\t* @param options.fetch - Custom fetch\n\t* @param options.timeout - Optional timeout in milliseconds for all requests. When set, requests will automatically abort after this duration to prevent indefinite hangs.\n\t* @param options.urlLengthLimit - Maximum URL length in characters before warnings/errors are triggered. Defaults to 8000.\n\t* @example\n\t* ```ts\n\t* import PostgrestClient from '@supabase/postgrest-js'\n\t*\n\t* const postgrest = new PostgrestClient('https://xyzcompany.supabase.co/rest/v1', {\n\t*   headers: { apikey: 'public-anon-key' },\n\t*   schema: 'public',\n\t*   timeout: 30000, // 30 second timeout\n\t* })\n\t* ```\n\t*/ constructor(url, { headers = {}, schema, fetch: fetch$1, timeout, urlLengthLimit = 8e3 } = {}){\n        this.url = url;\n        this.headers = new Headers(headers);\n        this.schemaName = schema;\n        this.urlLengthLimit = urlLengthLimit;\n        const originalFetch = fetch$1 !== null && fetch$1 !== void 0 ? fetch$1 : globalThis.fetch;\n        if (timeout !== void 0 && timeout > 0) this.fetch = (input, init)=>{\n            const controller = new AbortController();\n            const timeoutId = setTimeout(()=>controller.abort(), timeout);\n            const existingSignal = init === null || init === void 0 ? void 0 : init.signal;\n            if (existingSignal) {\n                if (existingSignal.aborted) {\n                    clearTimeout(timeoutId);\n                    return originalFetch(input, init);\n                }\n                const abortHandler = ()=>{\n                    clearTimeout(timeoutId);\n                    controller.abort();\n                };\n                existingSignal.addEventListener(\"abort\", abortHandler, {\n                    once: true\n                });\n                return originalFetch(input, _objectSpread2(_objectSpread2({}, init), {}, {\n                    signal: controller.signal\n                })).finally(()=>{\n                    clearTimeout(timeoutId);\n                    existingSignal.removeEventListener(\"abort\", abortHandler);\n                });\n            }\n            return originalFetch(input, _objectSpread2(_objectSpread2({}, init), {}, {\n                signal: controller.signal\n            })).finally(()=>clearTimeout(timeoutId));\n        };\n        else this.fetch = originalFetch;\n    }\n    /**\n\t* Perform a query on a table or a view.\n\t*\n\t* @param relation - The table or view name to query\n\t*/ from(relation) {\n        if (!relation || typeof relation !== \"string\" || relation.trim() === \"\") throw new Error(\"Invalid relation name: relation must be a non-empty string.\");\n        return new PostgrestQueryBuilder(new URL(`${this.url}/${relation}`), {\n            headers: new Headers(this.headers),\n            schema: this.schemaName,\n            fetch: this.fetch,\n            urlLengthLimit: this.urlLengthLimit\n        });\n    }\n    /**\n\t* Select a schema to query or perform an function (rpc) call.\n\t*\n\t* The schema needs to be on the list of exposed schemas inside Supabase.\n\t*\n\t* @param schema - The schema to query\n\t*/ schema(schema) {\n        return new PostgrestClient(this.url, {\n            headers: this.headers,\n            schema,\n            fetch: this.fetch,\n            urlLengthLimit: this.urlLengthLimit\n        });\n    }\n    /**\n\t* Perform a function call.\n\t*\n\t* @param fn - The function name to call\n\t* @param args - The arguments to pass to the function call\n\t* @param options - Named parameters\n\t* @param options.head - When set to `true`, `data` will not be returned.\n\t* Useful if you only need the count.\n\t* @param options.get - When set to `true`, the function will be called with\n\t* read-only access mode.\n\t* @param options.count - Count algorithm to use to count rows returned by the\n\t* function. Only applicable for [set-returning\n\t* functions](https://www.postgresql.org/docs/current/functions-srf.html).\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*\n\t* @example\n\t* ```ts\n\t* // For cross-schema functions where type inference fails, use overrideTypes:\n\t* const { data } = await supabase\n\t*   .schema('schema_b')\n\t*   .rpc('function_a', {})\n\t*   .overrideTypes<{ id: string; user_id: string }[]>()\n\t* ```\n\t*/ rpc(fn, args = {}, { head = false, get = false, count } = {}) {\n        var _this$fetch;\n        let method;\n        const url = new URL(`${this.url}/rpc/${fn}`);\n        let body;\n        const _isObject = (v)=>v !== null && typeof v === \"object\" && (!Array.isArray(v) || v.some(_isObject));\n        const _hasObjectArg = head && Object.values(args).some(_isObject);\n        if (_hasObjectArg) {\n            method = \"POST\";\n            body = args;\n        } else if (head || get) {\n            method = head ? \"HEAD\" : \"GET\";\n            Object.entries(args).filter(([_, value])=>value !== void 0).map(([name, value])=>[\n                    name,\n                    Array.isArray(value) ? `{${value.join(\",\")}}` : `${value}`\n                ]).forEach(([name, value])=>{\n                url.searchParams.append(name, value);\n            });\n        } else {\n            method = \"POST\";\n            body = args;\n        }\n        const headers = new Headers(this.headers);\n        if (_hasObjectArg) headers.set(\"Prefer\", count ? `count=${count},return=minimal` : \"return=minimal\");\n        else if (count) headers.set(\"Prefer\", `count=${count}`);\n        return new PostgrestFilterBuilder({\n            method,\n            url,\n            headers,\n            schema: this.schemaName,\n            body,\n            fetch: (_this$fetch = this.fetch) !== null && _this$fetch !== void 0 ? _this$fetch : fetch,\n            urlLengthLimit: this.urlLengthLimit\n        });\n    }\n};\n//#endregion\n//#region src/index.ts\nvar src_default = {\n    PostgrestClient,\n    PostgrestQueryBuilder,\n    PostgrestFilterBuilder,\n    PostgrestTransformBuilder,\n    PostgrestBuilder,\n    PostgrestError\n};\n//#endregion\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsK0JBQStCO0FBQy9COzs7O0FBSUEsR0FDQSxJQUFJQSxpQkFBaUIsY0FBY0M7SUFDbEM7Ozs7Ozs7Ozs7OztDQVlBLEdBQ0FDLFlBQVlDLE9BQU8sQ0FBRTtRQUNwQixLQUFLLENBQUNBLFFBQVFDLE9BQU87UUFDckIsSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLE9BQU8sR0FBR0gsUUFBUUcsT0FBTztRQUM5QixJQUFJLENBQUNDLElBQUksR0FBR0osUUFBUUksSUFBSTtRQUN4QixJQUFJLENBQUNDLElBQUksR0FBR0wsUUFBUUssSUFBSTtJQUN6QjtBQUNEO0FBRUEsWUFBWTtBQUNaLGlDQUFpQztBQUNqQyxJQUFJQyxtQkFBbUI7SUFDdEI7Ozs7Ozs7Ozs7OztDQVlBLEdBQ0FQLFlBQVlRLE9BQU8sQ0FBRTtRQUNwQixJQUFJQyx1QkFBdUJDLHVCQUF1QkM7UUFDbEQsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRztRQUMxQixJQUFJLENBQUNDLE1BQU0sR0FBR0wsUUFBUUssTUFBTTtRQUM1QixJQUFJLENBQUNDLEdBQUcsR0FBR04sUUFBUU0sR0FBRztRQUN0QixJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJQyxRQUFRUixRQUFRTyxPQUFPO1FBQzFDLElBQUksQ0FBQ0UsTUFBTSxHQUFHVCxRQUFRUyxNQUFNO1FBQzVCLElBQUksQ0FBQ0MsSUFBSSxHQUFHVixRQUFRVSxJQUFJO1FBQ3hCLElBQUksQ0FBQ04sa0JBQWtCLEdBQUcsQ0FBQ0gsd0JBQXdCRCxRQUFRSSxrQkFBa0IsTUFBTSxRQUFRSCwwQkFBMEIsS0FBSyxJQUFJQSx3QkFBd0I7UUFDdEosSUFBSSxDQUFDVSxNQUFNLEdBQUdYLFFBQVFXLE1BQU07UUFDNUIsSUFBSSxDQUFDQyxhQUFhLEdBQUcsQ0FBQ1Ysd0JBQXdCRixR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QUFJeU8sZUFBZXpPLFFBQVFXLEdBQUcsQ0FBQyxVQUFVYyxRQUFRLENBQUMsTUFBTSxFQUFFQSxNQUFNLGVBQWUsQ0FBQyxHQUFHO2FBQzlFLElBQUlBLE9BQU96QixRQUFRVyxHQUFHLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRWMsTUFBTSxDQUFDO1FBQ3RELE9BQU8sSUFBSWlGLHVCQUF1QjtZQUNqQzVHO1lBQ0FDO1lBQ0FDO1lBQ0FFLFFBQVEsSUFBSSxDQUFDNk0sVUFBVTtZQUN2QjVNO1lBQ0FJLE9BQU8sQ0FBQ3dKLGNBQWMsSUFBSSxDQUFDeEosS0FBSyxNQUFNLFFBQVF3SixnQkFBZ0IsS0FBSyxJQUFJQSxjQUFjeEo7WUFDckZELGdCQUFnQixJQUFJLENBQUNBLGNBQWM7UUFDcEM7SUFDRDtBQUNEO0FBRUEsWUFBWTtBQUNaLHNCQUFzQjtBQUN0QixJQUFJcU8sY0FBYztJQUNqQjlCO0lBQ0FyRDtJQUNBOUM7SUFDQTdDO0lBQ0FyRTtJQUNBVDtBQUNEO0FBRUEsWUFBWTtBQUNtSixDQUMvSixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmNob3Itd29ya2Zsb3dzLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvZGlzdC9pbmRleC5tanM/N2FjMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyNyZWdpb24gc3JjL1Bvc3RncmVzdEVycm9yLnRzXG4vKipcbiogRXJyb3IgZm9ybWF0XG4qXG4qIHtAbGluayBodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sP2hpZ2hsaWdodD1vcHRpb25zI2Vycm9ycy1hbmQtaHR0cC1zdGF0dXMtY29kZXN9XG4qL1xudmFyIFBvc3RncmVzdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG5cdC8qKlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHNcblx0KiBpbXBvcnQgUG9zdGdyZXN0RXJyb3IgZnJvbSAnQHN1cGFiYXNlL3Bvc3RncmVzdC1qcydcblx0KlxuXHQqIHRocm93IG5ldyBQb3N0Z3Jlc3RFcnJvcih7XG5cdCogICBtZXNzYWdlOiAnUm93IGxldmVsIHNlY3VyaXR5IHByZXZlbnRlZCB0aGUgcmVxdWVzdCcsXG5cdCogICBkZXRhaWxzOiAnUkxTIGRlbmllZCB0aGUgaW5zZXJ0Jyxcblx0KiAgIGhpbnQ6ICdDaGVjayB5b3VyIHBvbGljaWVzJyxcblx0KiAgIGNvZGU6ICdQR1JTVDMwMScsXG5cdCogfSlcblx0KiBgYGBcblx0Ki9cblx0Y29uc3RydWN0b3IoY29udGV4dCkge1xuXHRcdHN1cGVyKGNvbnRleHQubWVzc2FnZSk7XG5cdFx0dGhpcy5uYW1lID0gXCJQb3N0Z3Jlc3RFcnJvclwiO1xuXHRcdHRoaXMuZGV0YWlscyA9IGNvbnRleHQuZGV0YWlscztcblx0XHR0aGlzLmhpbnQgPSBjb250ZXh0LmhpbnQ7XG5cdFx0dGhpcy5jb2RlID0gY29udGV4dC5jb2RlO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvUG9zdGdyZXN0QnVpbGRlci50c1xudmFyIFBvc3RncmVzdEJ1aWxkZXIgPSBjbGFzcyB7XG5cdC8qKlxuXHQqIENyZWF0ZXMgYSBidWlsZGVyIGNvbmZpZ3VyZWQgZm9yIGEgc3BlY2lmaWMgUG9zdGdSRVNUIHJlcXVlc3QuXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHRzXG5cdCogaW1wb3J0IFBvc3RncmVzdFF1ZXJ5QnVpbGRlciBmcm9tICdAc3VwYWJhc2UvcG9zdGdyZXN0LWpzJ1xuXHQqXG5cdCogY29uc3QgYnVpbGRlciA9IG5ldyBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIoXG5cdCogICBuZXcgVVJMKCdodHRwczovL3h5emNvbXBhbnkuc3VwYWJhc2UuY28vcmVzdC92MS91c2VycycpLFxuXHQqICAgeyBoZWFkZXJzOiBuZXcgSGVhZGVycyh7IGFwaWtleTogJ3B1YmxpYy1hbm9uLWtleScgfSkgfVxuXHQqIClcblx0KiBgYGBcblx0Ki9cblx0Y29uc3RydWN0b3IoYnVpbGRlcikge1xuXHRcdHZhciBfYnVpbGRlciRzaG91bGRUaHJvd08sIF9idWlsZGVyJGlzTWF5YmVTaW5nbCwgX2J1aWxkZXIkdXJsTGVuZ3RoTGltO1xuXHRcdHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gZmFsc2U7XG5cdFx0dGhpcy5tZXRob2QgPSBidWlsZGVyLm1ldGhvZDtcblx0XHR0aGlzLnVybCA9IGJ1aWxkZXIudXJsO1xuXHRcdHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGJ1aWxkZXIuaGVhZGVycyk7XG5cdFx0dGhpcy5zY2hlbWEgPSBidWlsZGVyLnNjaGVtYTtcblx0XHR0aGlzLmJvZHkgPSBidWlsZGVyLmJvZHk7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSAoX2J1aWxkZXIkc2hvdWxkVGhyb3dPID0gYnVpbGRlci5zaG91bGRUaHJvd09uRXJyb3IpICE9PSBudWxsICYmIF9idWlsZGVyJHNob3VsZFRocm93TyAhPT0gdm9pZCAwID8gX2J1aWxkZXIkc2hvdWxkVGhyb3dPIDogZmFsc2U7XG5cdFx0dGhpcy5zaWduYWwgPSBidWlsZGVyLnNpZ25hbDtcblx0XHR0aGlzLmlzTWF5YmVTaW5nbGUgPSAoX2J1aWxkZXIkaXNNYXliZVNpbmdsID0gYnVpbGRlci5pc01heWJlU2luZ2xlKSAhPT0gbnVsbCAmJiBfYnVpbGRlciRpc01heWJlU2luZ2wgIT09IHZvaWQgMCA/IF9idWlsZGVyJGlzTWF5YmVTaW5nbCA6IGZhbHNlO1xuXHRcdHRoaXMudXJsTGVuZ3RoTGltaXQgPSAoX2J1aWxkZXIkdXJsTGVuZ3RoTGltID0gYnVpbGRlci51cmxMZW5ndGhMaW1pdCkgIT09IG51bGwgJiYgX2J1aWxkZXIkdXJsTGVuZ3RoTGltICE9PSB2b2lkIDAgPyBfYnVpbGRlciR1cmxMZW5ndGhMaW0gOiA4ZTM7XG5cdFx0aWYgKGJ1aWxkZXIuZmV0Y2gpIHRoaXMuZmV0Y2ggPSBidWlsZGVyLmZldGNoO1xuXHRcdGVsc2UgdGhpcy5mZXRjaCA9IGZldGNoO1xuXHR9XG5cdC8qKlxuXHQqIElmIHRoZXJlJ3MgYW4gZXJyb3Igd2l0aCB0aGUgcXVlcnksIHRocm93T25FcnJvciB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZSBieVxuXHQqIHRocm93aW5nIHRoZSBlcnJvciBpbnN0ZWFkIG9mIHJldHVybmluZyBpdCBhcyBwYXJ0IG9mIGEgc3VjY2Vzc2Z1bCByZXNwb25zZS5cblx0KlxuXHQqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2Uvc3VwYWJhc2UtanMvaXNzdWVzLzkyfVxuXHQqL1xuXHR0aHJvd09uRXJyb3IoKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSB0cnVlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIFNldCBhbiBIVFRQIGhlYWRlciBmb3IgdGhlIHJlcXVlc3QuXG5cdCovXG5cdHNldEhlYWRlcihuYW1lLCB2YWx1ZSkge1xuXHRcdHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyk7XG5cdFx0dGhpcy5oZWFkZXJzLnNldChuYW1lLCB2YWx1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0dGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCkge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0aWYgKHRoaXMuc2NoZW1hID09PSB2b2lkIDApIHt9IGVsc2UgaWYgKFtcIkdFVFwiLCBcIkhFQURcIl0uaW5jbHVkZXModGhpcy5tZXRob2QpKSB0aGlzLmhlYWRlcnMuc2V0KFwiQWNjZXB0LVByb2ZpbGVcIiwgdGhpcy5zY2hlbWEpO1xuXHRcdGVsc2UgdGhpcy5oZWFkZXJzLnNldChcIkNvbnRlbnQtUHJvZmlsZVwiLCB0aGlzLnNjaGVtYSk7XG5cdFx0aWYgKHRoaXMubWV0aG9kICE9PSBcIkdFVFwiICYmIHRoaXMubWV0aG9kICE9PSBcIkhFQURcIikgdGhpcy5oZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG5cdFx0Y29uc3QgX2ZldGNoID0gdGhpcy5mZXRjaDtcblx0XHRsZXQgcmVzID0gX2ZldGNoKHRoaXMudXJsLnRvU3RyaW5nKCksIHtcblx0XHRcdG1ldGhvZDogdGhpcy5tZXRob2QsXG5cdFx0XHRoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG5cdFx0XHRib2R5OiBKU09OLnN0cmluZ2lmeSh0aGlzLmJvZHkpLFxuXHRcdFx0c2lnbmFsOiB0aGlzLnNpZ25hbFxuXHRcdH0pLnRoZW4oYXN5bmMgKHJlcyQxKSA9PiB7XG5cdFx0XHRsZXQgZXJyb3IgPSBudWxsO1xuXHRcdFx0bGV0IGRhdGEgPSBudWxsO1xuXHRcdFx0bGV0IGNvdW50ID0gbnVsbDtcblx0XHRcdGxldCBzdGF0dXMgPSByZXMkMS5zdGF0dXM7XG5cdFx0XHRsZXQgc3RhdHVzVGV4dCA9IHJlcyQxLnN0YXR1c1RleHQ7XG5cdFx0XHRpZiAocmVzJDEub2spIHtcblx0XHRcdFx0dmFyIF90aGlzJGhlYWRlcnMkZ2V0MiwgX3JlcyRoZWFkZXJzJGdldDtcblx0XHRcdFx0aWYgKF90aGlzLm1ldGhvZCAhPT0gXCJIRUFEXCIpIHtcblx0XHRcdFx0XHR2YXIgX3RoaXMkaGVhZGVycyRnZXQ7XG5cdFx0XHRcdFx0Y29uc3QgYm9keSA9IGF3YWl0IHJlcyQxLnRleHQoKTtcblx0XHRcdFx0XHRpZiAoYm9keSA9PT0gXCJcIikge30gZWxzZSBpZiAoX3RoaXMuaGVhZGVycy5nZXQoXCJBY2NlcHRcIikgPT09IFwidGV4dC9jc3ZcIikgZGF0YSA9IGJvZHk7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoX3RoaXMuaGVhZGVycy5nZXQoXCJBY2NlcHRcIikgJiYgKChfdGhpcyRoZWFkZXJzJGdldCA9IF90aGlzLmhlYWRlcnMuZ2V0KFwiQWNjZXB0XCIpKSA9PT0gbnVsbCB8fCBfdGhpcyRoZWFkZXJzJGdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkaGVhZGVycyRnZXQuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi92bmQucGdyc3QucGxhbit0ZXh0XCIpKSkgZGF0YSA9IGJvZHk7XG5cdFx0XHRcdFx0ZWxzZSBkYXRhID0gSlNPTi5wYXJzZShib2R5KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zdCBjb3VudEhlYWRlciA9IChfdGhpcyRoZWFkZXJzJGdldDIgPSBfdGhpcy5oZWFkZXJzLmdldChcIlByZWZlclwiKSkgPT09IG51bGwgfHwgX3RoaXMkaGVhZGVycyRnZXQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRoZWFkZXJzJGdldDIubWF0Y2goL2NvdW50PShleGFjdHxwbGFubmVkfGVzdGltYXRlZCkvKTtcblx0XHRcdFx0Y29uc3QgY29udGVudFJhbmdlID0gKF9yZXMkaGVhZGVycyRnZXQgPSByZXMkMS5oZWFkZXJzLmdldChcImNvbnRlbnQtcmFuZ2VcIikpID09PSBudWxsIHx8IF9yZXMkaGVhZGVycyRnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZXMkaGVhZGVycyRnZXQuc3BsaXQoXCIvXCIpO1xuXHRcdFx0XHRpZiAoY291bnRIZWFkZXIgJiYgY29udGVudFJhbmdlICYmIGNvbnRlbnRSYW5nZS5sZW5ndGggPiAxKSBjb3VudCA9IHBhcnNlSW50KGNvbnRlbnRSYW5nZVsxXSk7XG5cdFx0XHRcdGlmIChfdGhpcy5pc01heWJlU2luZ2xlICYmIF90aGlzLm1ldGhvZCA9PT0gXCJHRVRcIiAmJiBBcnJheS5pc0FycmF5KGRhdGEpKSBpZiAoZGF0YS5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0ZXJyb3IgPSB7XG5cdFx0XHRcdFx0XHRjb2RlOiBcIlBHUlNUMTE2XCIsXG5cdFx0XHRcdFx0XHRkZXRhaWxzOiBgUmVzdWx0cyBjb250YWluICR7ZGF0YS5sZW5ndGh9IHJvd3MsIGFwcGxpY2F0aW9uL3ZuZC5wZ3JzdC5vYmplY3QranNvbiByZXF1aXJlcyAxIHJvd2AsXG5cdFx0XHRcdFx0XHRoaW50OiBudWxsLFxuXHRcdFx0XHRcdFx0bWVzc2FnZTogXCJKU09OIG9iamVjdCByZXF1ZXN0ZWQsIG11bHRpcGxlIChvciBubykgcm93cyByZXR1cm5lZFwiXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRkYXRhID0gbnVsbDtcblx0XHRcdFx0XHRjb3VudCA9IG51bGw7XG5cdFx0XHRcdFx0c3RhdHVzID0gNDA2O1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIk5vdCBBY2NlcHRhYmxlXCI7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZGF0YS5sZW5ndGggPT09IDEpIGRhdGEgPSBkYXRhWzBdO1xuXHRcdFx0XHRlbHNlIGRhdGEgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIF9lcnJvciRkZXRhaWxzO1xuXHRcdFx0XHRjb25zdCBib2R5ID0gYXdhaXQgcmVzJDEudGV4dCgpO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGVycm9yID0gSlNPTi5wYXJzZShib2R5KTtcblx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShlcnJvcikgJiYgcmVzJDEuc3RhdHVzID09PSA0MDQpIHtcblx0XHRcdFx0XHRcdGRhdGEgPSBbXTtcblx0XHRcdFx0XHRcdGVycm9yID0gbnVsbDtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDIwMDtcblx0XHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIk9LXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGNhdGNoIChfdW51c2VkKSB7XG5cdFx0XHRcdFx0aWYgKHJlcyQxLnN0YXR1cyA9PT0gNDA0ICYmIGJvZHkgPT09IFwiXCIpIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDIwNDtcblx0XHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIk5vIENvbnRlbnRcIjtcblx0XHRcdFx0XHR9IGVsc2UgZXJyb3IgPSB7IG1lc3NhZ2U6IGJvZHkgfTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZXJyb3IgJiYgX3RoaXMuaXNNYXliZVNpbmdsZSAmJiAoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCB8fCAoX2Vycm9yJGRldGFpbHMgPSBlcnJvci5kZXRhaWxzKSA9PT0gbnVsbCB8fCBfZXJyb3IkZGV0YWlscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Vycm9yJGRldGFpbHMuaW5jbHVkZXMoXCIwIHJvd3NcIikpKSB7XG5cdFx0XHRcdFx0ZXJyb3IgPSBudWxsO1xuXHRcdFx0XHRcdHN0YXR1cyA9IDIwMDtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJPS1wiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChlcnJvciAmJiBfdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IG5ldyBQb3N0Z3Jlc3RFcnJvcihlcnJvcik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRlcnJvcixcblx0XHRcdFx0ZGF0YSxcblx0XHRcdFx0Y291bnQsXG5cdFx0XHRcdHN0YXR1cyxcblx0XHRcdFx0c3RhdHVzVGV4dFxuXHRcdFx0fTtcblx0XHR9KTtcblx0XHRpZiAoIXRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSByZXMgPSByZXMuY2F0Y2goKGZldGNoRXJyb3IpID0+IHtcblx0XHRcdHZhciBfZmV0Y2hFcnJvciRuYW1lMjtcblx0XHRcdGxldCBlcnJvckRldGFpbHMgPSBcIlwiO1xuXHRcdFx0bGV0IGhpbnQgPSBcIlwiO1xuXHRcdFx0bGV0IGNvZGUgPSBcIlwiO1xuXHRcdFx0Y29uc3QgY2F1c2UgPSBmZXRjaEVycm9yID09PSBudWxsIHx8IGZldGNoRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZldGNoRXJyb3IuY2F1c2U7XG5cdFx0XHRpZiAoY2F1c2UpIHtcblx0XHRcdFx0dmFyIF9jYXVzZSRtZXNzYWdlLCBfY2F1c2UkY29kZSwgX2ZldGNoRXJyb3IkbmFtZSwgX2NhdXNlJG5hbWU7XG5cdFx0XHRcdGNvbnN0IGNhdXNlTWVzc2FnZSA9IChfY2F1c2UkbWVzc2FnZSA9IGNhdXNlID09PSBudWxsIHx8IGNhdXNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYXVzZS5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfY2F1c2UkbWVzc2FnZSAhPT0gdm9pZCAwID8gX2NhdXNlJG1lc3NhZ2UgOiBcIlwiO1xuXHRcdFx0XHRjb25zdCBjYXVzZUNvZGUgPSAoX2NhdXNlJGNvZGUgPSBjYXVzZSA9PT0gbnVsbCB8fCBjYXVzZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2F1c2UuY29kZSkgIT09IG51bGwgJiYgX2NhdXNlJGNvZGUgIT09IHZvaWQgMCA/IF9jYXVzZSRjb2RlIDogXCJcIjtcblx0XHRcdFx0ZXJyb3JEZXRhaWxzID0gYCR7KF9mZXRjaEVycm9yJG5hbWUgPSBmZXRjaEVycm9yID09PSBudWxsIHx8IGZldGNoRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZldGNoRXJyb3IubmFtZSkgIT09IG51bGwgJiYgX2ZldGNoRXJyb3IkbmFtZSAhPT0gdm9pZCAwID8gX2ZldGNoRXJyb3IkbmFtZSA6IFwiRmV0Y2hFcnJvclwifTogJHtmZXRjaEVycm9yID09PSBudWxsIHx8IGZldGNoRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZldGNoRXJyb3IubWVzc2FnZX1gO1xuXHRcdFx0XHRlcnJvckRldGFpbHMgKz0gYFxcblxcbkNhdXNlZCBieTogJHsoX2NhdXNlJG5hbWUgPSBjYXVzZSA9PT0gbnVsbCB8fCBjYXVzZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2F1c2UubmFtZSkgIT09IG51bGwgJiYgX2NhdXNlJG5hbWUgIT09IHZvaWQgMCA/IF9jYXVzZSRuYW1lIDogXCJFcnJvclwifTogJHtjYXVzZU1lc3NhZ2V9YDtcblx0XHRcdFx0aWYgKGNhdXNlQ29kZSkgZXJyb3JEZXRhaWxzICs9IGAgKCR7Y2F1c2VDb2RlfSlgO1xuXHRcdFx0XHRpZiAoY2F1c2UgPT09IG51bGwgfHwgY2F1c2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhdXNlLnN0YWNrKSBlcnJvckRldGFpbHMgKz0gYFxcbiR7Y2F1c2Uuc3RhY2t9YDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBfZmV0Y2hFcnJvciRzdGFjaztcblx0XHRcdFx0ZXJyb3JEZXRhaWxzID0gKF9mZXRjaEVycm9yJHN0YWNrID0gZmV0Y2hFcnJvciA9PT0gbnVsbCB8fCBmZXRjaEVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZXRjaEVycm9yLnN0YWNrKSAhPT0gbnVsbCAmJiBfZmV0Y2hFcnJvciRzdGFjayAhPT0gdm9pZCAwID8gX2ZldGNoRXJyb3Ikc3RhY2sgOiBcIlwiO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgdXJsTGVuZ3RoID0gdGhpcy51cmwudG9TdHJpbmcoKS5sZW5ndGg7XG5cdFx0XHRpZiAoKGZldGNoRXJyb3IgPT09IG51bGwgfHwgZmV0Y2hFcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmV0Y2hFcnJvci5uYW1lKSA9PT0gXCJBYm9ydEVycm9yXCIgfHwgKGZldGNoRXJyb3IgPT09IG51bGwgfHwgZmV0Y2hFcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmV0Y2hFcnJvci5jb2RlKSA9PT0gXCJBQk9SVF9FUlJcIikge1xuXHRcdFx0XHRjb2RlID0gXCJcIjtcblx0XHRcdFx0aGludCA9IFwiUmVxdWVzdCB3YXMgYWJvcnRlZCAodGltZW91dCBvciBtYW51YWwgY2FuY2VsbGF0aW9uKVwiO1xuXHRcdFx0XHRpZiAodXJsTGVuZ3RoID4gdGhpcy51cmxMZW5ndGhMaW1pdCkgaGludCArPSBgLiBOb3RlOiBZb3VyIHJlcXVlc3QgVVJMIGlzICR7dXJsTGVuZ3RofSBjaGFyYWN0ZXJzLCB3aGljaCBtYXkgZXhjZWVkIHNlcnZlciBsaW1pdHMuIElmIHNlbGVjdGluZyBtYW55IGZpZWxkcywgY29uc2lkZXIgdXNpbmcgdmlld3MuIElmIGZpbHRlcmluZyB3aXRoIGxhcmdlIGFycmF5cyAoZS5nLiwgLmluKCdpZCcsIFttYW55IElEc10pKSwgY29uc2lkZXIgdXNpbmcgYW4gUlBDIGZ1bmN0aW9uIHRvIHBhc3MgdmFsdWVzIHNlcnZlci1zaWRlLmA7XG5cdFx0XHR9IGVsc2UgaWYgKChjYXVzZSA9PT0gbnVsbCB8fCBjYXVzZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2F1c2UubmFtZSkgPT09IFwiSGVhZGVyc092ZXJmbG93RXJyb3JcIiB8fCAoY2F1c2UgPT09IG51bGwgfHwgY2F1c2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhdXNlLmNvZGUpID09PSBcIlVORF9FUlJfSEVBREVSU19PVkVSRkxPV1wiKSB7XG5cdFx0XHRcdGNvZGUgPSBcIlwiO1xuXHRcdFx0XHRoaW50ID0gXCJIVFRQIGhlYWRlcnMgZXhjZWVkZWQgc2VydmVyIGxpbWl0cyAodHlwaWNhbGx5IDE2S0IpXCI7XG5cdFx0XHRcdGlmICh1cmxMZW5ndGggPiB0aGlzLnVybExlbmd0aExpbWl0KSBoaW50ICs9IGAuIFlvdXIgcmVxdWVzdCBVUkwgaXMgJHt1cmxMZW5ndGh9IGNoYXJhY3RlcnMuIElmIHNlbGVjdGluZyBtYW55IGZpZWxkcywgY29uc2lkZXIgdXNpbmcgdmlld3MuIElmIGZpbHRlcmluZyB3aXRoIGxhcmdlIGFycmF5cyAoZS5nLiwgLmluKCdpZCcsIFsyMDArIElEc10pKSwgY29uc2lkZXIgdXNpbmcgYW4gUlBDIGZ1bmN0aW9uIGluc3RlYWQuYDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGVycm9yOiB7XG5cdFx0XHRcdFx0bWVzc2FnZTogYCR7KF9mZXRjaEVycm9yJG5hbWUyID0gZmV0Y2hFcnJvciA9PT0gbnVsbCB8fCBmZXRjaEVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZXRjaEVycm9yLm5hbWUpICE9PSBudWxsICYmIF9mZXRjaEVycm9yJG5hbWUyICE9PSB2b2lkIDAgPyBfZmV0Y2hFcnJvciRuYW1lMiA6IFwiRmV0Y2hFcnJvclwifTogJHtmZXRjaEVycm9yID09PSBudWxsIHx8IGZldGNoRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZldGNoRXJyb3IubWVzc2FnZX1gLFxuXHRcdFx0XHRcdGRldGFpbHM6IGVycm9yRGV0YWlscyxcblx0XHRcdFx0XHRoaW50LFxuXHRcdFx0XHRcdGNvZGVcblx0XHRcdFx0fSxcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0Y291bnQ6IG51bGwsXG5cdFx0XHRcdHN0YXR1czogMCxcblx0XHRcdFx0c3RhdHVzVGV4dDogXCJcIlxuXHRcdFx0fTtcblx0XHR9KTtcblx0XHRyZXR1cm4gcmVzLnRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpO1xuXHR9XG5cdC8qKlxuXHQqIE92ZXJyaWRlIHRoZSB0eXBlIG9mIHRoZSByZXR1cm5lZCBgZGF0YWAuXG5cdCpcblx0KiBAdHlwZVBhcmFtIE5ld1Jlc3VsdCAtIFRoZSBuZXcgcmVzdWx0IHR5cGUgdG8gb3ZlcnJpZGUgd2l0aFxuXHQqIEBkZXByZWNhdGVkIFVzZSBvdmVycmlkZVR5cGVzPHlvdXJUeXBlLCB7IG1lcmdlOiBmYWxzZSB9PigpIG1ldGhvZCBhdCB0aGUgZW5kIG9mIHlvdXIgY2FsbCBjaGFpbiBpbnN0ZWFkXG5cdCovXG5cdHJldHVybnMoKSB7XG5cdFx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBPdmVycmlkZSB0aGUgdHlwZSBvZiB0aGUgcmV0dXJuZWQgYGRhdGFgIGZpZWxkIGluIHRoZSByZXNwb25zZS5cblx0KlxuXHQqIEB0eXBlUGFyYW0gTmV3UmVzdWx0IC0gVGhlIG5ldyB0eXBlIHRvIGNhc3QgdGhlIHJlc3BvbnNlIGRhdGEgdG9cblx0KiBAdHlwZVBhcmFtIE9wdGlvbnMgLSBPcHRpb25hbCB0eXBlIGNvbmZpZ3VyYXRpb24gKGRlZmF1bHRzIHRvIHsgbWVyZ2U6IHRydWUgfSlcblx0KiBAdHlwZVBhcmFtIE9wdGlvbnMubWVyZ2UgLSBXaGVuIHRydWUsIG1lcmdlcyB0aGUgbmV3IHR5cGUgd2l0aCBleGlzdGluZyByZXR1cm4gdHlwZS4gV2hlbiBmYWxzZSwgcmVwbGFjZXMgdGhlIGV4aXN0aW5nIHR5cGVzIGVudGlyZWx5IChkZWZhdWx0cyB0byB0cnVlKVxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIC8vIE1lcmdlIHdpdGggZXhpc3RpbmcgdHlwZXMgKGRlZmF1bHQgYmVoYXZpb3IpXG5cdCogY29uc3QgcXVlcnkgPSBzdXBhYmFzZVxuXHQqICAgLmZyb20oJ3VzZXJzJylcblx0KiAgIC5zZWxlY3QoKVxuXHQqICAgLm92ZXJyaWRlVHlwZXM8eyBjdXN0b21fZmllbGQ6IHN0cmluZyB9PigpXG5cdCpcblx0KiAvLyBSZXBsYWNlIGV4aXN0aW5nIHR5cGVzIGNvbXBsZXRlbHlcblx0KiBjb25zdCByZXBsYWNlUXVlcnkgPSBzdXBhYmFzZVxuXHQqICAgLmZyb20oJ3VzZXJzJylcblx0KiAgIC5zZWxlY3QoKVxuXHQqICAgLm92ZXJyaWRlVHlwZXM8eyBpZDogbnVtYmVyOyBuYW1lOiBzdHJpbmcgfSwgeyBtZXJnZTogZmFsc2UgfT4oKVxuXHQqIGBgYFxuXHQqIEByZXR1cm5zIEEgUG9zdGdyZXN0QnVpbGRlciBpbnN0YW5jZSB3aXRoIHRoZSBuZXcgdHlwZVxuXHQqL1xuXHRvdmVycmlkZVR5cGVzKCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlci50c1xudmFyIFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFBvc3RncmVzdEJ1aWxkZXIge1xuXHQvKipcblx0KiBQZXJmb3JtIGEgU0VMRUNUIG9uIHRoZSBxdWVyeSByZXN1bHQuXG5cdCpcblx0KiBCeSBkZWZhdWx0LCBgLmluc2VydCgpYCwgYC51cGRhdGUoKWAsIGAudXBzZXJ0KClgLCBhbmQgYC5kZWxldGUoKWAgZG8gbm90XG5cdCogcmV0dXJuIG1vZGlmaWVkIHJvd3MuIEJ5IGNhbGxpbmcgdGhpcyBtZXRob2QsIG1vZGlmaWVkIHJvd3MgYXJlIHJldHVybmVkIGluXG5cdCogYGRhdGFgLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbnMgLSBUaGUgY29sdW1ucyB0byByZXRyaWV2ZSwgc2VwYXJhdGVkIGJ5IGNvbW1hc1xuXHQqL1xuXHRzZWxlY3QoY29sdW1ucykge1xuXHRcdGxldCBxdW90ZWQgPSBmYWxzZTtcblx0XHRjb25zdCBjbGVhbmVkQ29sdW1ucyA9IChjb2x1bW5zICE9PSBudWxsICYmIGNvbHVtbnMgIT09IHZvaWQgMCA/IGNvbHVtbnMgOiBcIipcIikuc3BsaXQoXCJcIikubWFwKChjKSA9PiB7XG5cdFx0XHRpZiAoL1xccy8udGVzdChjKSAmJiAhcXVvdGVkKSByZXR1cm4gXCJcIjtcblx0XHRcdGlmIChjID09PSBcIlxcXCJcIikgcXVvdGVkID0gIXF1b3RlZDtcblx0XHRcdHJldHVybiBjO1xuXHRcdH0pLmpvaW4oXCJcIik7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChcInNlbGVjdFwiLCBjbGVhbmVkQ29sdW1ucyk7XG5cdFx0dGhpcy5oZWFkZXJzLmFwcGVuZChcIlByZWZlclwiLCBcInJldHVybj1yZXByZXNlbnRhdGlvblwiKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBPcmRlciB0aGUgcXVlcnkgcmVzdWx0IGJ5IGBjb2x1bW5gLlxuXHQqXG5cdCogWW91IGNhbiBjYWxsIHRoaXMgbWV0aG9kIG11bHRpcGxlIHRpbWVzIHRvIG9yZGVyIGJ5IG11bHRpcGxlIGNvbHVtbnMuXG5cdCpcblx0KiBZb3UgY2FuIG9yZGVyIHJlZmVyZW5jZWQgdGFibGVzLCBidXQgaXQgb25seSBhZmZlY3RzIHRoZSBvcmRlcmluZyBvZiB0aGVcblx0KiBwYXJlbnQgdGFibGUgaWYgeW91IHVzZSBgIWlubmVyYCBpbiB0aGUgcXVlcnkuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBvcmRlciBieVxuXHQqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuXHQqIEBwYXJhbSBvcHRpb25zLmFzY2VuZGluZyAtIElmIGB0cnVlYCwgdGhlIHJlc3VsdCB3aWxsIGJlIGluIGFzY2VuZGluZyBvcmRlclxuXHQqIEBwYXJhbSBvcHRpb25zLm51bGxzRmlyc3QgLSBJZiBgdHJ1ZWAsIGBudWxsYHMgYXBwZWFyIGZpcnN0LiBJZiBgZmFsc2VgLFxuXHQqIGBudWxsYHMgYXBwZWFyIGxhc3QuXG5cdCogQHBhcmFtIG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlIC0gU2V0IHRoaXMgdG8gb3JkZXIgYSByZWZlcmVuY2VkIHRhYmxlIGJ5XG5cdCogaXRzIGNvbHVtbnNcblx0KiBAcGFyYW0gb3B0aW9ucy5mb3JlaWduVGFibGUgLSBEZXByZWNhdGVkLCB1c2UgYG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlYFxuXHQqIGluc3RlYWRcblx0Ki9cblx0b3JkZXIoY29sdW1uLCB7IGFzY2VuZGluZyA9IHRydWUsIG51bGxzRmlyc3QsIGZvcmVpZ25UYWJsZSwgcmVmZXJlbmNlZFRhYmxlID0gZm9yZWlnblRhYmxlIH0gPSB7fSkge1xuXHRcdGNvbnN0IGtleSA9IHJlZmVyZW5jZWRUYWJsZSA/IGAke3JlZmVyZW5jZWRUYWJsZX0ub3JkZXJgIDogXCJvcmRlclwiO1xuXHRcdGNvbnN0IGV4aXN0aW5nT3JkZXIgPSB0aGlzLnVybC5zZWFyY2hQYXJhbXMuZ2V0KGtleSk7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIGAke2V4aXN0aW5nT3JkZXIgPyBgJHtleGlzdGluZ09yZGVyfSxgIDogXCJcIn0ke2NvbHVtbn0uJHthc2NlbmRpbmcgPyBcImFzY1wiIDogXCJkZXNjXCJ9JHtudWxsc0ZpcnN0ID09PSB2b2lkIDAgPyBcIlwiIDogbnVsbHNGaXJzdCA/IFwiLm51bGxzZmlyc3RcIiA6IFwiLm51bGxzbGFzdFwifWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIExpbWl0IHRoZSBxdWVyeSByZXN1bHQgYnkgYGNvdW50YC5cblx0KlxuXHQqIEBwYXJhbSBjb3VudCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiByb3dzIHRvIHJldHVyblxuXHQqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuXHQqIEBwYXJhbSBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZSAtIFNldCB0aGlzIHRvIGxpbWl0IHJvd3Mgb2YgcmVmZXJlbmNlZFxuXHQqIHRhYmxlcyBpbnN0ZWFkIG9mIHRoZSBwYXJlbnQgdGFibGVcblx0KiBAcGFyYW0gb3B0aW9ucy5mb3JlaWduVGFibGUgLSBEZXByZWNhdGVkLCB1c2UgYG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlYFxuXHQqIGluc3RlYWRcblx0Ki9cblx0bGltaXQoY291bnQsIHsgZm9yZWlnblRhYmxlLCByZWZlcmVuY2VkVGFibGUgPSBmb3JlaWduVGFibGUgfSA9IHt9KSB7XG5cdFx0Y29uc3Qga2V5ID0gdHlwZW9mIHJlZmVyZW5jZWRUYWJsZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwibGltaXRcIiA6IGAke3JlZmVyZW5jZWRUYWJsZX0ubGltaXRgO1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCBgJHtjb3VudH1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBMaW1pdCB0aGUgcXVlcnkgcmVzdWx0IGJ5IHN0YXJ0aW5nIGF0IGFuIG9mZnNldCBgZnJvbWAgYW5kIGVuZGluZyBhdCB0aGUgb2Zmc2V0IGB0b2AuXG5cdCogT25seSByZWNvcmRzIHdpdGhpbiB0aGlzIHJhbmdlIGFyZSByZXR1cm5lZC5cblx0KiBUaGlzIHJlc3BlY3RzIHRoZSBxdWVyeSBvcmRlciBhbmQgaWYgdGhlcmUgaXMgbm8gb3JkZXIgY2xhdXNlIHRoZSByYW5nZSBjb3VsZCBiZWhhdmUgdW5leHBlY3RlZGx5LlxuXHQqIFRoZSBgZnJvbWAgYW5kIGB0b2AgdmFsdWVzIGFyZSAwLWJhc2VkIGFuZCBpbmNsdXNpdmU6IGByYW5nZSgxLCAzKWAgd2lsbCBpbmNsdWRlIHRoZSBzZWNvbmQsIHRoaXJkXG5cdCogYW5kIGZvdXJ0aCByb3dzIG9mIHRoZSBxdWVyeS5cblx0KlxuXHQqIEBwYXJhbSBmcm9tIC0gVGhlIHN0YXJ0aW5nIGluZGV4IGZyb20gd2hpY2ggdG8gbGltaXQgdGhlIHJlc3VsdFxuXHQqIEBwYXJhbSB0byAtIFRoZSBsYXN0IGluZGV4IHRvIHdoaWNoIHRvIGxpbWl0IHRoZSByZXN1bHRcblx0KiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcblx0KiBAcGFyYW0gb3B0aW9ucy5yZWZlcmVuY2VkVGFibGUgLSBTZXQgdGhpcyB0byBsaW1pdCByb3dzIG9mIHJlZmVyZW5jZWRcblx0KiB0YWJsZXMgaW5zdGVhZCBvZiB0aGUgcGFyZW50IHRhYmxlXG5cdCogQHBhcmFtIG9wdGlvbnMuZm9yZWlnblRhYmxlIC0gRGVwcmVjYXRlZCwgdXNlIGBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZWBcblx0KiBpbnN0ZWFkXG5cdCovXG5cdHJhbmdlKGZyb20sIHRvLCB7IGZvcmVpZ25UYWJsZSwgcmVmZXJlbmNlZFRhYmxlID0gZm9yZWlnblRhYmxlIH0gPSB7fSkge1xuXHRcdGNvbnN0IGtleU9mZnNldCA9IHR5cGVvZiByZWZlcmVuY2VkVGFibGUgPT09IFwidW5kZWZpbmVkXCIgPyBcIm9mZnNldFwiIDogYCR7cmVmZXJlbmNlZFRhYmxlfS5vZmZzZXRgO1xuXHRcdGNvbnN0IGtleUxpbWl0ID0gdHlwZW9mIHJlZmVyZW5jZWRUYWJsZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwibGltaXRcIiA6IGAke3JlZmVyZW5jZWRUYWJsZX0ubGltaXRgO1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5T2Zmc2V0LCBgJHtmcm9tfWApO1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5TGltaXQsIGAke3RvIC0gZnJvbSArIDF9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogU2V0IHRoZSBBYm9ydFNpZ25hbCBmb3IgdGhlIGZldGNoIHJlcXVlc3QuXG5cdCpcblx0KiBAcGFyYW0gc2lnbmFsIC0gVGhlIEFib3J0U2lnbmFsIHRvIHVzZSBmb3IgdGhlIGZldGNoIHJlcXVlc3Rcblx0Ki9cblx0YWJvcnRTaWduYWwoc2lnbmFsKSB7XG5cdFx0dGhpcy5zaWduYWwgPSBzaWduYWw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogUmV0dXJuIGBkYXRhYCBhcyBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheSBvZiBvYmplY3RzLlxuXHQqXG5cdCogUXVlcnkgcmVzdWx0IG11c3QgYmUgb25lIHJvdyAoZS5nLiB1c2luZyBgLmxpbWl0KDEpYCksIG90aGVyd2lzZSB0aGlzXG5cdCogcmV0dXJucyBhbiBlcnJvci5cblx0Ki9cblx0c2luZ2xlKCkge1xuXHRcdHRoaXMuaGVhZGVycy5zZXQoXCJBY2NlcHRcIiwgXCJhcHBsaWNhdGlvbi92bmQucGdyc3Qub2JqZWN0K2pzb25cIik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogUmV0dXJuIGBkYXRhYCBhcyBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheSBvZiBvYmplY3RzLlxuXHQqXG5cdCogUXVlcnkgcmVzdWx0IG11c3QgYmUgemVybyBvciBvbmUgcm93IChlLmcuIHVzaW5nIGAubGltaXQoMSlgKSwgb3RoZXJ3aXNlXG5cdCogdGhpcyByZXR1cm5zIGFuIGVycm9yLlxuXHQqL1xuXHRtYXliZVNpbmdsZSgpIHtcblx0XHRpZiAodGhpcy5tZXRob2QgPT09IFwiR0VUXCIpIHRoaXMuaGVhZGVycy5zZXQoXCJBY2NlcHRcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuXHRcdGVsc2UgdGhpcy5oZWFkZXJzLnNldChcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL3ZuZC5wZ3JzdC5vYmplY3QranNvblwiKTtcblx0XHR0aGlzLmlzTWF5YmVTaW5nbGUgPSB0cnVlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIFJldHVybiBgZGF0YWAgYXMgYSBzdHJpbmcgaW4gQ1NWIGZvcm1hdC5cblx0Ki9cblx0Y3N2KCkge1xuXHRcdHRoaXMuaGVhZGVycy5zZXQoXCJBY2NlcHRcIiwgXCJ0ZXh0L2NzdlwiKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBSZXR1cm4gYGRhdGFgIGFzIGFuIG9iamVjdCBpbiBbR2VvSlNPTl0oaHR0cHM6Ly9nZW9qc29uLm9yZykgZm9ybWF0LlxuXHQqL1xuXHRnZW9qc29uKCkge1xuXHRcdHRoaXMuaGVhZGVycy5zZXQoXCJBY2NlcHRcIiwgXCJhcHBsaWNhdGlvbi9nZW8ranNvblwiKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBSZXR1cm4gYGRhdGFgIGFzIHRoZSBFWFBMQUlOIHBsYW4gZm9yIHRoZSBxdWVyeS5cblx0KlxuXHQqIFlvdSBuZWVkIHRvIGVuYWJsZSB0aGVcblx0KiBbZGJfcGxhbl9lbmFibGVkXShodHRwczovL3N1cGFiYXNlLmNvbS9kb2NzL2d1aWRlcy9kYXRhYmFzZS9kZWJ1Z2dpbmctcGVyZm9ybWFuY2UjZW5hYmxpbmctZXhwbGFpbilcblx0KiBzZXR0aW5nIGJlZm9yZSB1c2luZyB0aGlzIG1ldGhvZC5cblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMuYW5hbHl6ZSAtIElmIGB0cnVlYCwgdGhlIHF1ZXJ5IHdpbGwgYmUgZXhlY3V0ZWQgYW5kIHRoZVxuXHQqIGFjdHVhbCBydW4gdGltZSB3aWxsIGJlIHJldHVybmVkXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy52ZXJib3NlIC0gSWYgYHRydWVgLCB0aGUgcXVlcnkgaWRlbnRpZmllciB3aWxsIGJlIHJldHVybmVkXG5cdCogYW5kIGBkYXRhYCB3aWxsIGluY2x1ZGUgdGhlIG91dHB1dCBjb2x1bW5zIG9mIHRoZSBxdWVyeVxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMuc2V0dGluZ3MgLSBJZiBgdHJ1ZWAsIGluY2x1ZGUgaW5mb3JtYXRpb24gb24gY29uZmlndXJhdGlvblxuXHQqIHBhcmFtZXRlcnMgdGhhdCBhZmZlY3QgcXVlcnkgcGxhbm5pbmdcblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zLmJ1ZmZlcnMgLSBJZiBgdHJ1ZWAsIGluY2x1ZGUgaW5mb3JtYXRpb24gb24gYnVmZmVyIHVzYWdlXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy53YWwgLSBJZiBgdHJ1ZWAsIGluY2x1ZGUgaW5mb3JtYXRpb24gb24gV0FMIHJlY29yZCBnZW5lcmF0aW9uXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy5mb3JtYXQgLSBUaGUgZm9ybWF0IG9mIHRoZSBvdXRwdXQsIGNhbiBiZSBgXCJ0ZXh0XCJgIChkZWZhdWx0KVxuXHQqIG9yIGBcImpzb25cImBcblx0Ki9cblx0ZXhwbGFpbih7IGFuYWx5emUgPSBmYWxzZSwgdmVyYm9zZSA9IGZhbHNlLCBzZXR0aW5ncyA9IGZhbHNlLCBidWZmZXJzID0gZmFsc2UsIHdhbCA9IGZhbHNlLCBmb3JtYXQgPSBcInRleHRcIiB9ID0ge30pIHtcblx0XHR2YXIgX3RoaXMkaGVhZGVycyRnZXQ7XG5cdFx0Y29uc3Qgb3B0aW9ucyA9IFtcblx0XHRcdGFuYWx5emUgPyBcImFuYWx5emVcIiA6IG51bGwsXG5cdFx0XHR2ZXJib3NlID8gXCJ2ZXJib3NlXCIgOiBudWxsLFxuXHRcdFx0c2V0dGluZ3MgPyBcInNldHRpbmdzXCIgOiBudWxsLFxuXHRcdFx0YnVmZmVycyA/IFwiYnVmZmVyc1wiIDogbnVsbCxcblx0XHRcdHdhbCA/IFwid2FsXCIgOiBudWxsXG5cdFx0XS5maWx0ZXIoQm9vbGVhbikuam9pbihcInxcIik7XG5cdFx0Y29uc3QgZm9yTWVkaWF0eXBlID0gKF90aGlzJGhlYWRlcnMkZ2V0ID0gdGhpcy5oZWFkZXJzLmdldChcIkFjY2VwdFwiKSkgIT09IG51bGwgJiYgX3RoaXMkaGVhZGVycyRnZXQgIT09IHZvaWQgMCA/IF90aGlzJGhlYWRlcnMkZ2V0IDogXCJhcHBsaWNhdGlvbi9qc29uXCI7XG5cdFx0dGhpcy5oZWFkZXJzLnNldChcIkFjY2VwdFwiLCBgYXBwbGljYXRpb24vdm5kLnBncnN0LnBsYW4rJHtmb3JtYXR9OyBmb3I9XCIke2Zvck1lZGlhdHlwZX1cIjsgb3B0aW9ucz0ke29wdGlvbnN9O2ApO1xuXHRcdGlmIChmb3JtYXQgPT09IFwianNvblwiKSByZXR1cm4gdGhpcztcblx0XHRlbHNlIHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIFJvbGxiYWNrIHRoZSBxdWVyeS5cblx0KlxuXHQqIGBkYXRhYCB3aWxsIHN0aWxsIGJlIHJldHVybmVkLCBidXQgdGhlIHF1ZXJ5IGlzIG5vdCBjb21taXR0ZWQuXG5cdCovXG5cdHJvbGxiYWNrKCkge1xuXHRcdHRoaXMuaGVhZGVycy5hcHBlbmQoXCJQcmVmZXJcIiwgXCJ0eD1yb2xsYmFja1wiKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBPdmVycmlkZSB0aGUgdHlwZSBvZiB0aGUgcmV0dXJuZWQgYGRhdGFgLlxuXHQqXG5cdCogQHR5cGVQYXJhbSBOZXdSZXN1bHQgLSBUaGUgbmV3IHJlc3VsdCB0eXBlIHRvIG92ZXJyaWRlIHdpdGhcblx0KiBAZGVwcmVjYXRlZCBVc2Ugb3ZlcnJpZGVUeXBlczx5b3VyVHlwZSwgeyBtZXJnZTogZmFsc2UgfT4oKSBtZXRob2QgYXQgdGhlIGVuZCBvZiB5b3VyIGNhbGwgY2hhaW4gaW5zdGVhZFxuXHQqL1xuXHRyZXR1cm5zKCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIFNldCB0aGUgbWF4aW11bSBudW1iZXIgb2Ygcm93cyB0aGF0IGNhbiBiZSBhZmZlY3RlZCBieSB0aGUgcXVlcnkuXG5cdCogT25seSBhdmFpbGFibGUgaW4gUG9zdGdSRVNUIHYxMysgYW5kIG9ubHkgd29ya3Mgd2l0aCBQQVRDSCBhbmQgREVMRVRFIG1ldGhvZHMuXG5cdCpcblx0KiBAcGFyYW0gdmFsdWUgLSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygcm93cyB0aGF0IGNhbiBiZSBhZmZlY3RlZFxuXHQqL1xuXHRtYXhBZmZlY3RlZCh2YWx1ZSkge1xuXHRcdHRoaXMuaGVhZGVycy5hcHBlbmQoXCJQcmVmZXJcIiwgXCJoYW5kbGluZz1zdHJpY3RcIik7XG5cdFx0dGhpcy5oZWFkZXJzLmFwcGVuZChcIlByZWZlclwiLCBgbWF4LWFmZmVjdGVkPSR7dmFsdWV9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9Qb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLnRzXG5jb25zdCBQb3N0Z3Jlc3RSZXNlcnZlZENoYXJzUmVnZXhwID0gLyogQF9fUFVSRV9fICovIG5ldyBSZWdFeHAoXCJbLCgpXVwiKTtcbnZhciBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyIHtcblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGVxdWFsIHRvIGB2YWx1ZWAuXG5cdCpcblx0KiBUbyBjaGVjayBpZiB0aGUgdmFsdWUgb2YgYGNvbHVtbmAgaXMgTlVMTCwgeW91IHNob3VsZCB1c2UgYC5pcygpYCBpbnN0ZWFkLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdGVxKGNvbHVtbiwgdmFsdWUpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGVxLiR7dmFsdWV9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIG5vdCBlcXVhbCB0byBgdmFsdWVgLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdG5lcShjb2x1bW4sIHZhbHVlKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBuZXEuJHt2YWx1ZX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgZ3JlYXRlciB0aGFuIGB2YWx1ZWAuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0Z3QoY29sdW1uLCB2YWx1ZSkge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgZ3QuJHt2YWx1ZX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGB2YWx1ZWAuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0Z3RlKGNvbHVtbiwgdmFsdWUpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGd0ZS4ke3ZhbHVlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBsZXNzIHRoYW4gYHZhbHVlYC5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRsdChjb2x1bW4sIHZhbHVlKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBsdC4ke3ZhbHVlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYHZhbHVlYC5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRsdGUoY29sdW1uLCB2YWx1ZSkge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbHRlLiR7dmFsdWV9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYHBhdHRlcm5gIGNhc2Utc2Vuc2l0aXZlbHkuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gcGF0dGVybiAtIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIHdpdGhcblx0Ki9cblx0bGlrZShjb2x1bW4sIHBhdHRlcm4pIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGxpa2UuJHtwYXR0ZXJufWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGFsbCBvZiBgcGF0dGVybnNgIGNhc2Utc2Vuc2l0aXZlbHkuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gcGF0dGVybnMgLSBUaGUgcGF0dGVybnMgdG8gbWF0Y2ggd2l0aFxuXHQqL1xuXHRsaWtlQWxsT2YoY29sdW1uLCBwYXR0ZXJucykge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbGlrZShhbGwpLnske3BhdHRlcm5zLmpvaW4oXCIsXCIpfX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBhbnkgb2YgYHBhdHRlcm5zYCBjYXNlLXNlbnNpdGl2ZWx5LlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHBhdHRlcm5zIC0gVGhlIHBhdHRlcm5zIHRvIG1hdGNoIHdpdGhcblx0Ki9cblx0bGlrZUFueU9mKGNvbHVtbiwgcGF0dGVybnMpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGxpa2UoYW55KS57JHtwYXR0ZXJucy5qb2luKFwiLFwiKX19YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYHBhdHRlcm5gIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSBwYXR0ZXJuIC0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd2l0aFxuXHQqL1xuXHRpbGlrZShjb2x1bW4sIHBhdHRlcm4pIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGlsaWtlLiR7cGF0dGVybn1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBhbGwgb2YgYHBhdHRlcm5zYCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gcGF0dGVybnMgLSBUaGUgcGF0dGVybnMgdG8gbWF0Y2ggd2l0aFxuXHQqL1xuXHRpbGlrZUFsbE9mKGNvbHVtbiwgcGF0dGVybnMpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGlsaWtlKGFsbCkueyR7cGF0dGVybnMuam9pbihcIixcIil9fWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGFueSBvZiBgcGF0dGVybnNgIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSBwYXR0ZXJucyAtIFRoZSBwYXR0ZXJucyB0byBtYXRjaCB3aXRoXG5cdCovXG5cdGlsaWtlQW55T2YoY29sdW1uLCBwYXR0ZXJucykge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaWxpa2UoYW55KS57JHtwYXR0ZXJucy5qb2luKFwiLFwiKX19YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgdGhlIFBvc3RncmVTUUwgcmVnZXggYHBhdHRlcm5gXG5cdCogY2FzZS1zZW5zaXRpdmVseSAodXNpbmcgdGhlIGB+YCBvcGVyYXRvcikuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gcGF0dGVybiAtIFRoZSBQb3N0Z3JlU1FMIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuIHRvIG1hdGNoIHdpdGhcblx0Ki9cblx0cmVnZXhNYXRjaChjb2x1bW4sIHBhdHRlcm4pIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG1hdGNoLiR7cGF0dGVybn1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyB0aGUgUG9zdGdyZVNRTCByZWdleCBgcGF0dGVybmBcblx0KiBjYXNlLWluc2Vuc2l0aXZlbHkgKHVzaW5nIHRoZSBgfipgIG9wZXJhdG9yKS5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSBwYXR0ZXJuIC0gVGhlIFBvc3RncmVTUUwgcmVndWxhciBleHByZXNzaW9uIHBhdHRlcm4gdG8gbWF0Y2ggd2l0aFxuXHQqL1xuXHRyZWdleElNYXRjaChjb2x1bW4sIHBhdHRlcm4pIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGltYXRjaC4ke3BhdHRlcm59YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIElTIGB2YWx1ZWAuXG5cdCpcblx0KiBGb3Igbm9uLWJvb2xlYW4gY29sdW1ucywgdGhpcyBpcyBvbmx5IHJlbGV2YW50IGZvciBjaGVja2luZyBpZiB0aGUgdmFsdWUgb2Zcblx0KiBgY29sdW1uYCBpcyBOVUxMIGJ5IHNldHRpbmcgYHZhbHVlYCB0byBgbnVsbGAuXG5cdCpcblx0KiBGb3IgYm9vbGVhbiBjb2x1bW5zLCB5b3UgY2FuIGFsc28gc2V0IGB2YWx1ZWAgdG8gYHRydWVgIG9yIGBmYWxzZWAgYW5kIGl0XG5cdCogd2lsbCBiZWhhdmUgdGhlIHNhbWUgd2F5IGFzIGAuZXEoKWAuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0aXMoY29sdW1uLCB2YWx1ZSkge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaXMuJHt2YWx1ZX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgSVMgRElTVElOQ1QgRlJPTSBgdmFsdWVgLlxuXHQqXG5cdCogVW5saWtlIGAubmVxKClgLCB0aGlzIHRyZWF0cyBgTlVMTGAgYXMgYSBjb21wYXJhYmxlIHZhbHVlLiBUd28gYE5VTExgIHZhbHVlc1xuXHQqIGFyZSBjb25zaWRlcmVkIGVxdWFsIChub3QgZGlzdGluY3QpLCBhbmQgY29tcGFyaW5nIGBOVUxMYCB3aXRoIGFueSBub24tTlVMTFxuXHQqIHZhbHVlIHJldHVybnMgdHJ1ZSAoZGlzdGluY3QpLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdGlzRGlzdGluY3QoY29sdW1uLCB2YWx1ZSkge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaXNkaXN0aW5jdC4ke3ZhbHVlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBpbmNsdWRlZCBpbiB0aGUgYHZhbHVlc2AgYXJyYXkuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyBhcnJheSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRpbihjb2x1bW4sIHZhbHVlcykge1xuXHRcdGNvbnN0IGNsZWFuZWRWYWx1ZXMgPSBBcnJheS5mcm9tKG5ldyBTZXQodmFsdWVzKSkubWFwKChzKSA9PiB7XG5cdFx0XHRpZiAodHlwZW9mIHMgPT09IFwic3RyaW5nXCIgJiYgUG9zdGdyZXN0UmVzZXJ2ZWRDaGFyc1JlZ2V4cC50ZXN0KHMpKSByZXR1cm4gYFwiJHtzfVwiYDtcblx0XHRcdGVsc2UgcmV0dXJuIGAke3N9YDtcblx0XHR9KS5qb2luKFwiLFwiKTtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGluLigke2NsZWFuZWRWYWx1ZXN9KWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBOT1QgaW5jbHVkZWQgaW4gdGhlIGB2YWx1ZXNgIGFycmF5LlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgYXJyYXkgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0bm90SW4oY29sdW1uLCB2YWx1ZXMpIHtcblx0XHRjb25zdCBjbGVhbmVkVmFsdWVzID0gQXJyYXkuZnJvbShuZXcgU2V0KHZhbHVlcykpLm1hcCgocykgPT4ge1xuXHRcdFx0aWYgKHR5cGVvZiBzID09PSBcInN0cmluZ1wiICYmIFBvc3RncmVzdFJlc2VydmVkQ2hhcnNSZWdleHAudGVzdChzKSkgcmV0dXJuIGBcIiR7c31cImA7XG5cdFx0XHRlbHNlIHJldHVybiBgJHtzfWA7XG5cdFx0fSkuam9pbihcIixcIik7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBub3QuaW4uKCR7Y2xlYW5lZFZhbHVlc30pYCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogT25seSByZWxldmFudCBmb3IganNvbmIsIGFycmF5LCBhbmQgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlXG5cdCogYGNvbHVtbmAgY29udGFpbnMgZXZlcnkgZWxlbWVudCBhcHBlYXJpbmcgaW4gYHZhbHVlYC5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUganNvbmIsIGFycmF5LCBvciByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHZhbHVlIC0gVGhlIGpzb25iLCBhcnJheSwgb3IgcmFuZ2UgdmFsdWUgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0Y29udGFpbnMoY29sdW1uLCB2YWx1ZSkge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY3MuJHt2YWx1ZX1gKTtcblx0XHRlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjcy57JHt2YWx1ZS5qb2luKFwiLFwiKX19YCk7XG5cdFx0ZWxzZSB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNzLiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE9ubHkgcmVsZXZhbnQgZm9yIGpzb25iLCBhcnJheSwgYW5kIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZVxuXHQqIGV2ZXJ5IGVsZW1lbnQgYXBwZWFyaW5nIGluIGBjb2x1bW5gIGlzIGNvbnRhaW5lZCBieSBgdmFsdWVgLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBqc29uYiwgYXJyYXksIG9yIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gdmFsdWUgLSBUaGUganNvbmIsIGFycmF5LCBvciByYW5nZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRjb250YWluZWRCeShjb2x1bW4sIHZhbHVlKSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjZC4ke3ZhbHVlfWApO1xuXHRcdGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNkLnske3ZhbHVlLmpvaW4oXCIsXCIpfX1gKTtcblx0XHRlbHNlIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY2QuJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGV2ZXJ5IGVsZW1lbnQgaW5cblx0KiBgY29sdW1uYCBpcyBncmVhdGVyIHRoYW4gYW55IGVsZW1lbnQgaW4gYHJhbmdlYC5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRyYW5nZUd0KGNvbHVtbiwgcmFuZ2UpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYHNyLiR7cmFuZ2V9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGV2ZXJ5IGVsZW1lbnQgaW5cblx0KiBgY29sdW1uYCBpcyBlaXRoZXIgY29udGFpbmVkIGluIGByYW5nZWAgb3IgZ3JlYXRlciB0aGFuIGFueSBlbGVtZW50IGluXG5cdCogYHJhbmdlYC5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRyYW5nZUd0ZShjb2x1bW4sIHJhbmdlKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBueGwuJHtyYW5nZX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZXZlcnkgZWxlbWVudCBpblxuXHQqIGBjb2x1bW5gIGlzIGxlc3MgdGhhbiBhbnkgZWxlbWVudCBpbiBgcmFuZ2VgLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdHJhbmdlTHQoY29sdW1uLCByYW5nZSkge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgc2wuJHtyYW5nZX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZXZlcnkgZWxlbWVudCBpblxuXHQqIGBjb2x1bW5gIGlzIGVpdGhlciBjb250YWluZWQgaW4gYHJhbmdlYCBvciBsZXNzIHRoYW4gYW55IGVsZW1lbnQgaW5cblx0KiBgcmFuZ2VgLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdHJhbmdlTHRlKGNvbHVtbiwgcmFuZ2UpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG54ci4ke3JhbmdlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE9ubHkgcmVsZXZhbnQgZm9yIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpc1xuXHQqIG11dHVhbGx5IGV4Y2x1c2l2ZSB0byBgcmFuZ2VgIGFuZCB0aGVyZSBjYW4gYmUgbm8gZWxlbWVudCBiZXR3ZWVuIHRoZSB0d29cblx0KiByYW5nZXMuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0cmFuZ2VBZGphY2VudChjb2x1bW4sIHJhbmdlKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBhZGouJHtyYW5nZX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBPbmx5IHJlbGV2YW50IGZvciBhcnJheSBhbmQgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlXG5cdCogYGNvbHVtbmAgYW5kIGB2YWx1ZWAgaGF2ZSBhbiBlbGVtZW50IGluIGNvbW1vbi5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgYXJyYXkgb3IgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSB2YWx1ZSAtIFRoZSBhcnJheSBvciByYW5nZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRvdmVybGFwcyhjb2x1bW4sIHZhbHVlKSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBvdi4ke3ZhbHVlfWApO1xuXHRcdGVsc2UgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBvdi57JHt2YWx1ZS5qb2luKFwiLFwiKX19YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogT25seSByZWxldmFudCBmb3IgdGV4dCBhbmQgdHN2ZWN0b3IgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlXG5cdCogYGNvbHVtbmAgbWF0Y2hlcyB0aGUgcXVlcnkgc3RyaW5nIGluIGBxdWVyeWAuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIHRleHQgb3IgdHN2ZWN0b3IgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeSB0ZXh0IHRvIG1hdGNoIHdpdGhcblx0KiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcblx0KiBAcGFyYW0gb3B0aW9ucy5jb25maWcgLSBUaGUgdGV4dCBzZWFyY2ggY29uZmlndXJhdGlvbiB0byB1c2Vcblx0KiBAcGFyYW0gb3B0aW9ucy50eXBlIC0gQ2hhbmdlIGhvdyB0aGUgYHF1ZXJ5YCB0ZXh0IGlzIGludGVycHJldGVkXG5cdCovXG5cdHRleHRTZWFyY2goY29sdW1uLCBxdWVyeSwgeyBjb25maWcsIHR5cGUgfSA9IHt9KSB7XG5cdFx0bGV0IHR5cGVQYXJ0ID0gXCJcIjtcblx0XHRpZiAodHlwZSA9PT0gXCJwbGFpblwiKSB0eXBlUGFydCA9IFwicGxcIjtcblx0XHRlbHNlIGlmICh0eXBlID09PSBcInBocmFzZVwiKSB0eXBlUGFydCA9IFwicGhcIjtcblx0XHRlbHNlIGlmICh0eXBlID09PSBcIndlYnNlYXJjaFwiKSB0eXBlUGFydCA9IFwid1wiO1xuXHRcdGNvbnN0IGNvbmZpZ1BhcnQgPSBjb25maWcgPT09IHZvaWQgMCA/IFwiXCIgOiBgKCR7Y29uZmlnfSlgO1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgJHt0eXBlUGFydH1mdHMke2NvbmZpZ1BhcnR9LiR7cXVlcnl9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGVhY2ggY29sdW1uIGluIGBxdWVyeWAga2V5cyBpcyBlcXVhbCB0byBpdHNcblx0KiBhc3NvY2lhdGVkIHZhbHVlLiBTaG9ydGhhbmQgZm9yIG11bHRpcGxlIGAuZXEoKWBzLlxuXHQqXG5cdCogQHBhcmFtIHF1ZXJ5IC0gVGhlIG9iamVjdCB0byBmaWx0ZXIgd2l0aCwgd2l0aCBjb2x1bW4gbmFtZXMgYXMga2V5cyBtYXBwZWRcblx0KiB0byB0aGVpciBmaWx0ZXIgdmFsdWVzXG5cdCovXG5cdG1hdGNoKHF1ZXJ5KSB7XG5cdFx0T2JqZWN0LmVudHJpZXMocXVlcnkpLmZvckVhY2goKFtjb2x1bW4sIHZhbHVlXSkgPT4ge1xuXHRcdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBlcS4ke3ZhbHVlfWApO1xuXHRcdH0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGljaCBkb2Vzbid0IHNhdGlzZnkgdGhlIGZpbHRlci5cblx0KlxuXHQqIFVubGlrZSBtb3N0IGZpbHRlcnMsIGBvcGVhcmF0b3JgIGFuZCBgdmFsdWVgIGFyZSB1c2VkIGFzLWlzIGFuZCBuZWVkIHRvXG5cdCogZm9sbG93IFtQb3N0Z1JFU1Rcblx0KiBzeW50YXhdKGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi9zdGFibGUvYXBpLmh0bWwjb3BlcmF0b3JzKS4gWW91IGFsc28gbmVlZFxuXHQqIHRvIG1ha2Ugc3VyZSB0aGV5IGFyZSBwcm9wZXJseSBzYW5pdGl6ZWQuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gb3BlcmF0b3IgLSBUaGUgb3BlcmF0b3IgdG8gYmUgbmVnYXRlZCB0byBmaWx0ZXIgd2l0aCwgZm9sbG93aW5nXG5cdCogUG9zdGdSRVNUIHN5bnRheFxuXHQqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aCwgZm9sbG93aW5nIFBvc3RnUkVTVCBzeW50YXhcblx0Ki9cblx0bm90KGNvbHVtbiwgb3BlcmF0b3IsIHZhbHVlKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBub3QuJHtvcGVyYXRvcn0uJHt2YWx1ZX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hpY2ggc2F0aXNmeSBhdCBsZWFzdCBvbmUgb2YgdGhlIGZpbHRlcnMuXG5cdCpcblx0KiBVbmxpa2UgbW9zdCBmaWx0ZXJzLCBgZmlsdGVyc2AgaXMgdXNlZCBhcy1pcyBhbmQgbmVlZHMgdG8gZm9sbG93IFtQb3N0Z1JFU1Rcblx0KiBzeW50YXhdKGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi9zdGFibGUvYXBpLmh0bWwjb3BlcmF0b3JzKS4gWW91IGFsc28gbmVlZFxuXHQqIHRvIG1ha2Ugc3VyZSBpdCdzIHByb3Blcmx5IHNhbml0aXplZC5cblx0KlxuXHQqIEl0J3MgY3VycmVudGx5IG5vdCBwb3NzaWJsZSB0byBkbyBhbiBgLm9yKClgIGZpbHRlciBhY3Jvc3MgbXVsdGlwbGUgdGFibGVzLlxuXHQqXG5cdCogQHBhcmFtIGZpbHRlcnMgLSBUaGUgZmlsdGVycyB0byB1c2UsIGZvbGxvd2luZyBQb3N0Z1JFU1Qgc3ludGF4XG5cdCogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG5cdCogQHBhcmFtIG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlIC0gU2V0IHRoaXMgdG8gZmlsdGVyIG9uIHJlZmVyZW5jZWQgdGFibGVzXG5cdCogaW5zdGVhZCBvZiB0aGUgcGFyZW50IHRhYmxlXG5cdCogQHBhcmFtIG9wdGlvbnMuZm9yZWlnblRhYmxlIC0gRGVwcmVjYXRlZCwgdXNlIGByZWZlcmVuY2VkVGFibGVgIGluc3RlYWRcblx0Ki9cblx0b3IoZmlsdGVycywgeyBmb3JlaWduVGFibGUsIHJlZmVyZW5jZWRUYWJsZSA9IGZvcmVpZ25UYWJsZSB9ID0ge30pIHtcblx0XHRjb25zdCBrZXkgPSByZWZlcmVuY2VkVGFibGUgPyBgJHtyZWZlcmVuY2VkVGFibGV9Lm9yYCA6IFwib3JcIjtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgYCgke2ZpbHRlcnN9KWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGljaCBzYXRpc2Z5IHRoZSBmaWx0ZXIuIFRoaXMgaXMgYW4gZXNjYXBlIGhhdGNoIC0geW91XG5cdCogc2hvdWxkIHVzZSB0aGUgc3BlY2lmaWMgZmlsdGVyIG1ldGhvZHMgd2hlcmV2ZXIgcG9zc2libGUuXG5cdCpcblx0KiBVbmxpa2UgbW9zdCBmaWx0ZXJzLCBgb3BlYXJhdG9yYCBhbmQgYHZhbHVlYCBhcmUgdXNlZCBhcy1pcyBhbmQgbmVlZCB0b1xuXHQqIGZvbGxvdyBbUG9zdGdSRVNUXG5cdCogc3ludGF4XShodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sI29wZXJhdG9ycykuIFlvdSBhbHNvIG5lZWRcblx0KiB0byBtYWtlIHN1cmUgdGhleSBhcmUgcHJvcGVybHkgc2FuaXRpemVkLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIG9wZXJhdG9yIC0gVGhlIG9wZXJhdG9yIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuXHQqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aCwgZm9sbG93aW5nIFBvc3RnUkVTVCBzeW50YXhcblx0Ki9cblx0ZmlsdGVyKGNvbHVtbiwgb3BlcmF0b3IsIHZhbHVlKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGAke29wZXJhdG9yfS4ke3ZhbHVlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvUG9zdGdyZXN0UXVlcnlCdWlsZGVyLnRzXG52YXIgUG9zdGdyZXN0UXVlcnlCdWlsZGVyID0gY2xhc3Mge1xuXHQvKipcblx0KiBDcmVhdGVzIGEgcXVlcnkgYnVpbGRlciBzY29wZWQgdG8gYSBQb3N0Z3JlcyB0YWJsZSBvciB2aWV3LlxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0c1xuXHQqIGltcG9ydCBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIgZnJvbSAnQHN1cGFiYXNlL3Bvc3RncmVzdC1qcydcblx0KlxuXHQqIGNvbnN0IHF1ZXJ5ID0gbmV3IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcihcblx0KiAgIG5ldyBVUkwoJ2h0dHBzOi8veHl6Y29tcGFueS5zdXBhYmFzZS5jby9yZXN0L3YxL3VzZXJzJyksXG5cdCogICB7IGhlYWRlcnM6IHsgYXBpa2V5OiAncHVibGljLWFub24ta2V5JyB9IH1cblx0KiApXG5cdCogYGBgXG5cdCovXG5cdGNvbnN0cnVjdG9yKHVybCwgeyBoZWFkZXJzID0ge30sIHNjaGVtYSwgZmV0Y2g6IGZldGNoJDEsIHVybExlbmd0aExpbWl0ID0gOGUzIH0pIHtcblx0XHR0aGlzLnVybCA9IHVybDtcblx0XHR0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhoZWFkZXJzKTtcblx0XHR0aGlzLnNjaGVtYSA9IHNjaGVtYTtcblx0XHR0aGlzLmZldGNoID0gZmV0Y2gkMTtcblx0XHR0aGlzLnVybExlbmd0aExpbWl0ID0gdXJsTGVuZ3RoTGltaXQ7XG5cdH1cblx0LyoqXG5cdCogQ2xvbmUgVVJMIGFuZCBoZWFkZXJzIHRvIHByZXZlbnQgc2hhcmVkIHN0YXRlIGJldHdlZW4gb3BlcmF0aW9ucy5cblx0Ki9cblx0Y2xvbmVSZXF1ZXN0U3RhdGUoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHVybDogbmV3IFVSTCh0aGlzLnVybC50b1N0cmluZygpKSxcblx0XHRcdGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycylcblx0XHR9O1xuXHR9XG5cdC8qKlxuXHQqIFBlcmZvcm0gYSBTRUxFQ1QgcXVlcnkgb24gdGhlIHRhYmxlIG9yIHZpZXcuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1ucyAtIFRoZSBjb2x1bW5zIHRvIHJldHJpZXZlLCBzZXBhcmF0ZWQgYnkgY29tbWFzLiBDb2x1bW5zIGNhbiBiZSByZW5hbWVkIHdoZW4gcmV0dXJuZWQgd2l0aCBgY3VzdG9tTmFtZTpjb2x1bW5OYW1lYFxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy5oZWFkIC0gV2hlbiBzZXQgdG8gYHRydWVgLCBgZGF0YWAgd2lsbCBub3QgYmUgcmV0dXJuZWQuXG5cdCogVXNlZnVsIGlmIHlvdSBvbmx5IG5lZWQgdGhlIGNvdW50LlxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHJvd3MgaW4gdGhlIHRhYmxlIG9yIHZpZXcuXG5cdCpcblx0KiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG5cdCogaG9vZC5cblx0KlxuXHQqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG5cdCogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cblx0KlxuXHQqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcblx0KiBudW1iZXJzLlxuXHQqXG5cdCogQHJlbWFya3Ncblx0KiBXaGVuIHVzaW5nIGBjb3VudGAgd2l0aCBgLnJhbmdlKClgIG9yIGAubGltaXQoKWAsIHRoZSByZXR1cm5lZCBgY291bnRgIGlzIHRoZSB0b3RhbCBudW1iZXIgb2Ygcm93c1xuXHQqIHRoYXQgbWF0Y2ggeW91ciBmaWx0ZXJzLCBub3QgdGhlIG51bWJlciBvZiByb3dzIGluIHRoZSBjdXJyZW50IHBhZ2UuIFVzZSB0aGlzIHRvIGJ1aWxkIHBhZ2luYXRpb24gVUkuXG5cdCovXG5cdHNlbGVjdChjb2x1bW5zLCBvcHRpb25zKSB7XG5cdFx0Y29uc3QgeyBoZWFkID0gZmFsc2UsIGNvdW50IH0gPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcblx0XHRjb25zdCBtZXRob2QgPSBoZWFkID8gXCJIRUFEXCIgOiBcIkdFVFwiO1xuXHRcdGxldCBxdW90ZWQgPSBmYWxzZTtcblx0XHRjb25zdCBjbGVhbmVkQ29sdW1ucyA9IChjb2x1bW5zICE9PSBudWxsICYmIGNvbHVtbnMgIT09IHZvaWQgMCA/IGNvbHVtbnMgOiBcIipcIikuc3BsaXQoXCJcIikubWFwKChjKSA9PiB7XG5cdFx0XHRpZiAoL1xccy8udGVzdChjKSAmJiAhcXVvdGVkKSByZXR1cm4gXCJcIjtcblx0XHRcdGlmIChjID09PSBcIlxcXCJcIikgcXVvdGVkID0gIXF1b3RlZDtcblx0XHRcdHJldHVybiBjO1xuXHRcdH0pLmpvaW4oXCJcIik7XG5cdFx0Y29uc3QgeyB1cmwsIGhlYWRlcnMgfSA9IHRoaXMuY2xvbmVSZXF1ZXN0U3RhdGUoKTtcblx0XHR1cmwuc2VhcmNoUGFyYW1zLnNldChcInNlbGVjdFwiLCBjbGVhbmVkQ29sdW1ucyk7XG5cdFx0aWYgKGNvdW50KSBoZWFkZXJzLmFwcGVuZChcIlByZWZlclwiLCBgY291bnQ9JHtjb3VudH1gKTtcblx0XHRyZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXIoe1xuXHRcdFx0bWV0aG9kLFxuXHRcdFx0dXJsLFxuXHRcdFx0aGVhZGVycyxcblx0XHRcdHNjaGVtYTogdGhpcy5zY2hlbWEsXG5cdFx0XHRmZXRjaDogdGhpcy5mZXRjaCxcblx0XHRcdHVybExlbmd0aExpbWl0OiB0aGlzLnVybExlbmd0aExpbWl0XG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogUGVyZm9ybSBhbiBJTlNFUlQgaW50byB0aGUgdGFibGUgb3Igdmlldy5cblx0KlxuXHQqIEJ5IGRlZmF1bHQsIGluc2VydGVkIHJvd3MgYXJlIG5vdCByZXR1cm5lZC4gVG8gcmV0dXJuIGl0LCBjaGFpbiB0aGUgY2FsbFxuXHQqIHdpdGggYC5zZWxlY3QoKWAuXG5cdCpcblx0KiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byBpbnNlcnQuIFBhc3MgYW4gb2JqZWN0IHRvIGluc2VydCBhIHNpbmdsZSByb3dcblx0KiBvciBhbiBhcnJheSB0byBpbnNlcnQgbXVsdGlwbGUgcm93cy5cblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IGluc2VydGVkIHJvd3MuXG5cdCpcblx0KiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG5cdCogaG9vZC5cblx0KlxuXHQqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG5cdCogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cblx0KlxuXHQqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcblx0KiBudW1iZXJzLlxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMuZGVmYXVsdFRvTnVsbCAtIE1ha2UgbWlzc2luZyBmaWVsZHMgZGVmYXVsdCB0byBgbnVsbGAuXG5cdCogT3RoZXJ3aXNlLCB1c2UgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBjb2x1bW4uIE9ubHkgYXBwbGllcyBmb3IgYnVsa1xuXHQqIGluc2VydHMuXG5cdCovXG5cdGluc2VydCh2YWx1ZXMsIHsgY291bnQsIGRlZmF1bHRUb051bGwgPSB0cnVlIH0gPSB7fSkge1xuXHRcdHZhciBfdGhpcyRmZXRjaDtcblx0XHRjb25zdCBtZXRob2QgPSBcIlBPU1RcIjtcblx0XHRjb25zdCB7IHVybCwgaGVhZGVycyB9ID0gdGhpcy5jbG9uZVJlcXVlc3RTdGF0ZSgpO1xuXHRcdGlmIChjb3VudCkgaGVhZGVycy5hcHBlbmQoXCJQcmVmZXJcIiwgYGNvdW50PSR7Y291bnR9YCk7XG5cdFx0aWYgKCFkZWZhdWx0VG9OdWxsKSBoZWFkZXJzLmFwcGVuZChcIlByZWZlclwiLCBgbWlzc2luZz1kZWZhdWx0YCk7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuXHRcdFx0Y29uc3QgY29sdW1ucyA9IHZhbHVlcy5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjLmNvbmNhdChPYmplY3Qua2V5cyh4KSksIFtdKTtcblx0XHRcdGlmIChjb2x1bW5zLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Y29uc3QgdW5pcXVlQ29sdW1ucyA9IFsuLi5uZXcgU2V0KGNvbHVtbnMpXS5tYXAoKGNvbHVtbikgPT4gYFwiJHtjb2x1bW59XCJgKTtcblx0XHRcdFx0dXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJjb2x1bW5zXCIsIHVuaXF1ZUNvbHVtbnMuam9pbihcIixcIikpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXIoe1xuXHRcdFx0bWV0aG9kLFxuXHRcdFx0dXJsLFxuXHRcdFx0aGVhZGVycyxcblx0XHRcdHNjaGVtYTogdGhpcy5zY2hlbWEsXG5cdFx0XHRib2R5OiB2YWx1ZXMsXG5cdFx0XHRmZXRjaDogKF90aGlzJGZldGNoID0gdGhpcy5mZXRjaCkgIT09IG51bGwgJiYgX3RoaXMkZmV0Y2ggIT09IHZvaWQgMCA/IF90aGlzJGZldGNoIDogZmV0Y2gsXG5cdFx0XHR1cmxMZW5ndGhMaW1pdDogdGhpcy51cmxMZW5ndGhMaW1pdFxuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqIFBlcmZvcm0gYW4gVVBTRVJUIG9uIHRoZSB0YWJsZSBvciB2aWV3LiBEZXBlbmRpbmcgb24gdGhlIGNvbHVtbihzKSBwYXNzZWRcblx0KiB0byBgb25Db25mbGljdGAsIGAudXBzZXJ0KClgIGFsbG93cyB5b3UgdG8gcGVyZm9ybSB0aGUgZXF1aXZhbGVudCBvZlxuXHQqIGAuaW5zZXJ0KClgIGlmIGEgcm93IHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgYG9uQ29uZmxpY3RgIGNvbHVtbnMgZG9lc24ndFxuXHQqIGV4aXN0LCBvciBpZiBpdCBkb2VzIGV4aXN0LCBwZXJmb3JtIGFuIGFsdGVybmF0aXZlIGFjdGlvbiBkZXBlbmRpbmcgb25cblx0KiBgaWdub3JlRHVwbGljYXRlc2AuXG5cdCpcblx0KiBCeSBkZWZhdWx0LCB1cHNlcnRlZCByb3dzIGFyZSBub3QgcmV0dXJuZWQuIFRvIHJldHVybiBpdCwgY2hhaW4gdGhlIGNhbGxcblx0KiB3aXRoIGAuc2VsZWN0KClgLlxuXHQqXG5cdCogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgdG8gdXBzZXJ0IHdpdGguIFBhc3MgYW4gb2JqZWN0IHRvIHVwc2VydCBhXG5cdCogc2luZ2xlIHJvdyBvciBhbiBhcnJheSB0byB1cHNlcnQgbXVsdGlwbGUgcm93cy5cblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMub25Db25mbGljdCAtIENvbW1hLXNlcGFyYXRlZCBVTklRVUUgY29sdW1uKHMpIHRvIHNwZWNpZnkgaG93XG5cdCogZHVwbGljYXRlIHJvd3MgYXJlIGRldGVybWluZWQuIFR3byByb3dzIGFyZSBkdXBsaWNhdGVzIGlmIGFsbCB0aGVcblx0KiBgb25Db25mbGljdGAgY29sdW1ucyBhcmUgZXF1YWwuXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy5pZ25vcmVEdXBsaWNhdGVzIC0gSWYgYHRydWVgLCBkdXBsaWNhdGUgcm93cyBhcmUgaWdub3JlZC4gSWZcblx0KiBgZmFsc2VgLCBkdXBsaWNhdGUgcm93cyBhcmUgbWVyZ2VkIHdpdGggZXhpc3Rpbmcgcm93cy5cblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCB1cHNlcnRlZCByb3dzLlxuXHQqXG5cdCogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuXHQqIGhvb2QuXG5cdCpcblx0KiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuXHQqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG5cdCpcblx0KiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG5cdCogbnVtYmVycy5cblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zLmRlZmF1bHRUb051bGwgLSBNYWtlIG1pc3NpbmcgZmllbGRzIGRlZmF1bHQgdG8gYG51bGxgLlxuXHQqIE90aGVyd2lzZSwgdXNlIHRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgY29sdW1uLiBUaGlzIG9ubHkgYXBwbGllcyB3aGVuXG5cdCogaW5zZXJ0aW5nIG5ldyByb3dzLCBub3Qgd2hlbiBtZXJnaW5nIHdpdGggZXhpc3Rpbmcgcm93cyB1bmRlclxuXHQqIGBpZ25vcmVEdXBsaWNhdGVzOiBmYWxzZWAuIFRoaXMgYWxzbyBvbmx5IGFwcGxpZXMgd2hlbiBkb2luZyBidWxrIHVwc2VydHMuXG5cdCpcblx0KiBAZXhhbXBsZSBVcHNlcnQgYSBzaW5nbGUgcm93IHVzaW5nIGEgdW5pcXVlIGtleVxuXHQqIGBgYHRzXG5cdCogLy8gVXBzZXJ0aW5nIGEgc2luZ2xlIHJvdywgb3ZlcndyaXRpbmcgYmFzZWQgb24gdGhlICd1c2VybmFtZScgdW5pcXVlIGNvbHVtblxuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuZnJvbSgndXNlcnMnKVxuXHQqICAgLnVwc2VydCh7IHVzZXJuYW1lOiAnc3VwYWJvdCcgfSwgeyBvbkNvbmZsaWN0OiAndXNlcm5hbWUnIH0pXG5cdCpcblx0KiAvLyBFeGFtcGxlIHJlc3BvbnNlOlxuXHQqIC8vIHtcblx0KiAvLyAgIGRhdGE6IFtcblx0KiAvLyAgICAgeyBpZDogNCwgbWVzc2FnZTogJ2JhcicsIHVzZXJuYW1lOiAnc3VwYWJvdCcgfVxuXHQqIC8vICAgXSxcblx0KiAvLyAgIGVycm9yOiBudWxsXG5cdCogLy8gfVxuXHQqIGBgYFxuXHQqXG5cdCogQGV4YW1wbGUgVXBzZXJ0IHdpdGggY29uZmxpY3QgcmVzb2x1dGlvbiBhbmQgZXhhY3Qgcm93IGNvdW50aW5nXG5cdCogYGBgdHNcblx0KiAvLyBVcHNlcnRpbmcgYW5kIHJldHVybmluZyBleGFjdCBjb3VudFxuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IsIGNvdW50IH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLmZyb20oJ3VzZXJzJylcblx0KiAgIC51cHNlcnQoXG5cdCogICAgIHtcblx0KiAgICAgICBpZDogMyxcblx0KiAgICAgICBtZXNzYWdlOiAnZm9vJyxcblx0KiAgICAgICB1c2VybmFtZTogJ3N1cGFib3QnXG5cdCogICAgIH0sXG5cdCogICAgIHtcblx0KiAgICAgICBvbkNvbmZsaWN0OiAndXNlcm5hbWUnLFxuXHQqICAgICAgIGNvdW50OiAnZXhhY3QnXG5cdCogICAgIH1cblx0KiAgIClcblx0KlxuXHQqIC8vIEV4YW1wbGUgcmVzcG9uc2U6XG5cdCogLy8ge1xuXHQqIC8vICAgZGF0YTogW1xuXHQqIC8vICAgICB7XG5cdCogLy8gICAgICAgaWQ6IDQyLFxuXHQqIC8vICAgICAgIGhhbmRsZTogXCJzYW9pcnNlXCIsXG5cdCogLy8gICAgICAgZGlzcGxheV9uYW1lOiBcIlNhb2lyc2VcIlxuXHQqIC8vICAgICB9XG5cdCogLy8gICBdLFxuXHQqIC8vICAgY291bnQ6IDEsXG5cdCogLy8gICBlcnJvcjogbnVsbFxuXHQqIC8vIH1cblx0KiBgYGBcblx0Ki9cblx0dXBzZXJ0KHZhbHVlcywgeyBvbkNvbmZsaWN0LCBpZ25vcmVEdXBsaWNhdGVzID0gZmFsc2UsIGNvdW50LCBkZWZhdWx0VG9OdWxsID0gdHJ1ZSB9ID0ge30pIHtcblx0XHR2YXIgX3RoaXMkZmV0Y2gyO1xuXHRcdGNvbnN0IG1ldGhvZCA9IFwiUE9TVFwiO1xuXHRcdGNvbnN0IHsgdXJsLCBoZWFkZXJzIH0gPSB0aGlzLmNsb25lUmVxdWVzdFN0YXRlKCk7XG5cdFx0aGVhZGVycy5hcHBlbmQoXCJQcmVmZXJcIiwgYHJlc29sdXRpb249JHtpZ25vcmVEdXBsaWNhdGVzID8gXCJpZ25vcmVcIiA6IFwibWVyZ2VcIn0tZHVwbGljYXRlc2ApO1xuXHRcdGlmIChvbkNvbmZsaWN0ICE9PSB2b2lkIDApIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwib25fY29uZmxpY3RcIiwgb25Db25mbGljdCk7XG5cdFx0aWYgKGNvdW50KSBoZWFkZXJzLmFwcGVuZChcIlByZWZlclwiLCBgY291bnQ9JHtjb3VudH1gKTtcblx0XHRpZiAoIWRlZmF1bHRUb051bGwpIGhlYWRlcnMuYXBwZW5kKFwiUHJlZmVyXCIsIFwibWlzc2luZz1kZWZhdWx0XCIpO1xuXHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcblx0XHRcdGNvbnN0IGNvbHVtbnMgPSB2YWx1ZXMucmVkdWNlKChhY2MsIHgpID0+IGFjYy5jb25jYXQoT2JqZWN0LmtleXMoeCkpLCBbXSk7XG5cdFx0XHRpZiAoY29sdW1ucy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGNvbnN0IHVuaXF1ZUNvbHVtbnMgPSBbLi4ubmV3IFNldChjb2x1bW5zKV0ubWFwKChjb2x1bW4pID0+IGBcIiR7Y29sdW1ufVwiYCk7XG5cdFx0XHRcdHVybC5zZWFyY2hQYXJhbXMuc2V0KFwiY29sdW1uc1wiLCB1bmlxdWVDb2x1bW5zLmpvaW4oXCIsXCIpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyKHtcblx0XHRcdG1ldGhvZCxcblx0XHRcdHVybCxcblx0XHRcdGhlYWRlcnMsXG5cdFx0XHRzY2hlbWE6IHRoaXMuc2NoZW1hLFxuXHRcdFx0Ym9keTogdmFsdWVzLFxuXHRcdFx0ZmV0Y2g6IChfdGhpcyRmZXRjaDIgPSB0aGlzLmZldGNoKSAhPT0gbnVsbCAmJiBfdGhpcyRmZXRjaDIgIT09IHZvaWQgMCA/IF90aGlzJGZldGNoMiA6IGZldGNoLFxuXHRcdFx0dXJsTGVuZ3RoTGltaXQ6IHRoaXMudXJsTGVuZ3RoTGltaXRcblx0XHR9KTtcblx0fVxuXHQvKipcblx0KiBQZXJmb3JtIGFuIFVQREFURSBvbiB0aGUgdGFibGUgb3Igdmlldy5cblx0KlxuXHQqIEJ5IGRlZmF1bHQsIHVwZGF0ZWQgcm93cyBhcmUgbm90IHJldHVybmVkLiBUbyByZXR1cm4gaXQsIGNoYWluIHRoZSBjYWxsXG5cdCogd2l0aCBgLnNlbGVjdCgpYCBhZnRlciBmaWx0ZXJzLlxuXHQqXG5cdCogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgdG8gdXBkYXRlIHdpdGhcblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHVwZGF0ZWQgcm93cy5cblx0KlxuXHQqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcblx0KiBob29kLlxuXHQqXG5cdCogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcblx0KiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuXHQqXG5cdCogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuXHQqIG51bWJlcnMuXG5cdCovXG5cdHVwZGF0ZSh2YWx1ZXMsIHsgY291bnQgfSA9IHt9KSB7XG5cdFx0dmFyIF90aGlzJGZldGNoMztcblx0XHRjb25zdCBtZXRob2QgPSBcIlBBVENIXCI7XG5cdFx0Y29uc3QgeyB1cmwsIGhlYWRlcnMgfSA9IHRoaXMuY2xvbmVSZXF1ZXN0U3RhdGUoKTtcblx0XHRpZiAoY291bnQpIGhlYWRlcnMuYXBwZW5kKFwiUHJlZmVyXCIsIGBjb3VudD0ke2NvdW50fWApO1xuXHRcdHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcih7XG5cdFx0XHRtZXRob2QsXG5cdFx0XHR1cmwsXG5cdFx0XHRoZWFkZXJzLFxuXHRcdFx0c2NoZW1hOiB0aGlzLnNjaGVtYSxcblx0XHRcdGJvZHk6IHZhbHVlcyxcblx0XHRcdGZldGNoOiAoX3RoaXMkZmV0Y2gzID0gdGhpcy5mZXRjaCkgIT09IG51bGwgJiYgX3RoaXMkZmV0Y2gzICE9PSB2b2lkIDAgPyBfdGhpcyRmZXRjaDMgOiBmZXRjaCxcblx0XHRcdHVybExlbmd0aExpbWl0OiB0aGlzLnVybExlbmd0aExpbWl0XG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogUGVyZm9ybSBhIERFTEVURSBvbiB0aGUgdGFibGUgb3Igdmlldy5cblx0KlxuXHQqIEJ5IGRlZmF1bHQsIGRlbGV0ZWQgcm93cyBhcmUgbm90IHJldHVybmVkLiBUbyByZXR1cm4gaXQsIGNoYWluIHRoZSBjYWxsXG5cdCogd2l0aCBgLnNlbGVjdCgpYCBhZnRlciBmaWx0ZXJzLlxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgZGVsZXRlZCByb3dzLlxuXHQqXG5cdCogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuXHQqIGhvb2QuXG5cdCpcblx0KiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuXHQqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG5cdCpcblx0KiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG5cdCogbnVtYmVycy5cblx0Ki9cblx0ZGVsZXRlKHsgY291bnQgfSA9IHt9KSB7XG5cdFx0dmFyIF90aGlzJGZldGNoNDtcblx0XHRjb25zdCBtZXRob2QgPSBcIkRFTEVURVwiO1xuXHRcdGNvbnN0IHsgdXJsLCBoZWFkZXJzIH0gPSB0aGlzLmNsb25lUmVxdWVzdFN0YXRlKCk7XG5cdFx0aWYgKGNvdW50KSBoZWFkZXJzLmFwcGVuZChcIlByZWZlclwiLCBgY291bnQ9JHtjb3VudH1gKTtcblx0XHRyZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXIoe1xuXHRcdFx0bWV0aG9kLFxuXHRcdFx0dXJsLFxuXHRcdFx0aGVhZGVycyxcblx0XHRcdHNjaGVtYTogdGhpcy5zY2hlbWEsXG5cdFx0XHRmZXRjaDogKF90aGlzJGZldGNoNCA9IHRoaXMuZmV0Y2gpICE9PSBudWxsICYmIF90aGlzJGZldGNoNCAhPT0gdm9pZCAwID8gX3RoaXMkZmV0Y2g0IDogZmV0Y2gsXG5cdFx0XHR1cmxMZW5ndGhMaW1pdDogdGhpcy51cmxMZW5ndGhMaW1pdFxuXHRcdH0pO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBcXDBAb3hjLXByb2plY3QrcnVudGltZUAwLjEwMS4wL2hlbHBlcnMvdHlwZW9mLmpzXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHtcblx0XCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXHRyZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uKG8kMSkge1xuXHRcdHJldHVybiB0eXBlb2YgbyQxO1xuXHR9IDogZnVuY3Rpb24obyQxKSB7XG5cdFx0cmV0dXJuIG8kMSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvJDEuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvJDEgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG8kMTtcblx0fSwgX3R5cGVvZihvKTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gXFwwQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC4xMDEuMC9oZWxwZXJzL3RvUHJpbWl0aXZlLmpzXG5mdW5jdGlvbiB0b1ByaW1pdGl2ZSh0LCByKSB7XG5cdGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0O1xuXHR2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcblx0aWYgKHZvaWQgMCAhPT0gZSkge1xuXHRcdHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuXHRcdGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpO1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcblx0fVxuXHRyZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBcXDBAb3hjLXByb2plY3QrcnVudGltZUAwLjEwMS4wL2hlbHBlcnMvdG9Qcm9wZXJ0eUtleS5qc1xuZnVuY3Rpb24gdG9Qcm9wZXJ0eUtleSh0KSB7XG5cdHZhciBpID0gdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG5cdHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIFxcMEBveGMtcHJvamVjdCtydW50aW1lQDAuMTAxLjAvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qc1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHtcblx0cmV0dXJuIChyID0gdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7XG5cdFx0dmFsdWU6IHQsXG5cdFx0ZW51bWVyYWJsZTogITAsXG5cdFx0Y29uZmlndXJhYmxlOiAhMCxcblx0XHR3cml0YWJsZTogITBcblx0fSkgOiBlW3JdID0gdCwgZTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gXFwwQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC4xMDEuMC9oZWxwZXJzL29iamVjdFNwcmVhZDIuanNcbmZ1bmN0aW9uIG93bktleXMoZSwgcikge1xuXHR2YXIgdCA9IE9iamVjdC5rZXlzKGUpO1xuXHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcblx0XHRyICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24ociQxKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByJDEpLmVudW1lcmFibGU7XG5cdFx0fSkpLCB0LnB1c2guYXBwbHkodCwgbyk7XG5cdH1cblx0cmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMihlKSB7XG5cdGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7XG5cdFx0dmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9O1xuXHRcdHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uKHIkMSkge1xuXHRcdFx0X2RlZmluZVByb3BlcnR5KGUsIHIkMSwgdFtyJDFdKTtcblx0XHR9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24ociQxKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciQxLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIkMSkpO1xuXHRcdH0pO1xuXHR9XG5cdHJldHVybiBlO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvUG9zdGdyZXN0Q2xpZW50LnRzXG4vKipcbiogUG9zdGdSRVNUIGNsaWVudC5cbipcbiogQHR5cGVQYXJhbSBEYXRhYmFzZSAtIFR5cGVzIGZvciB0aGUgc2NoZW1hIGZyb20gdGhlIFt0eXBlXG4qIGdlbmVyYXRvcl0oaHR0cHM6Ly9zdXBhYmFzZS5jb20vZG9jcy9yZWZlcmVuY2UvamF2YXNjcmlwdC9uZXh0L3R5cGVzY3JpcHQtc3VwcG9ydClcbipcbiogQHR5cGVQYXJhbSBTY2hlbWFOYW1lIC0gUG9zdGdyZXMgc2NoZW1hIHRvIHN3aXRjaCB0by4gTXVzdCBiZSBhIHN0cmluZ1xuKiBsaXRlcmFsLCB0aGUgc2FtZSBvbmUgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci4gSWYgdGhlIHNjaGVtYSBpcyBub3RcbiogYFwicHVibGljXCJgLCB0aGlzIG11c3QgYmUgc3VwcGxpZWQgbWFudWFsbHkuXG4qL1xudmFyIFBvc3RncmVzdENsaWVudCA9IGNsYXNzIFBvc3RncmVzdENsaWVudCB7XG5cdC8qKlxuXHQqIENyZWF0ZXMgYSBQb3N0Z1JFU1QgY2xpZW50LlxuXHQqXG5cdCogQHBhcmFtIHVybCAtIFVSTCBvZiB0aGUgUG9zdGdSRVNUIGVuZHBvaW50XG5cdCogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG5cdCogQHBhcmFtIG9wdGlvbnMuaGVhZGVycyAtIEN1c3RvbSBoZWFkZXJzXG5cdCogQHBhcmFtIG9wdGlvbnMuc2NoZW1hIC0gUG9zdGdyZXMgc2NoZW1hIHRvIHN3aXRjaCB0b1xuXHQqIEBwYXJhbSBvcHRpb25zLmZldGNoIC0gQ3VzdG9tIGZldGNoXG5cdCogQHBhcmFtIG9wdGlvbnMudGltZW91dCAtIE9wdGlvbmFsIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciBhbGwgcmVxdWVzdHMuIFdoZW4gc2V0LCByZXF1ZXN0cyB3aWxsIGF1dG9tYXRpY2FsbHkgYWJvcnQgYWZ0ZXIgdGhpcyBkdXJhdGlvbiB0byBwcmV2ZW50IGluZGVmaW5pdGUgaGFuZ3MuXG5cdCogQHBhcmFtIG9wdGlvbnMudXJsTGVuZ3RoTGltaXQgLSBNYXhpbXVtIFVSTCBsZW5ndGggaW4gY2hhcmFjdGVycyBiZWZvcmUgd2FybmluZ3MvZXJyb3JzIGFyZSB0cmlnZ2VyZWQuIERlZmF1bHRzIHRvIDgwMDAuXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0c1xuXHQqIGltcG9ydCBQb3N0Z3Jlc3RDbGllbnQgZnJvbSAnQHN1cGFiYXNlL3Bvc3RncmVzdC1qcydcblx0KlxuXHQqIGNvbnN0IHBvc3RncmVzdCA9IG5ldyBQb3N0Z3Jlc3RDbGllbnQoJ2h0dHBzOi8veHl6Y29tcGFueS5zdXBhYmFzZS5jby9yZXN0L3YxJywge1xuXHQqICAgaGVhZGVyczogeyBhcGlrZXk6ICdwdWJsaWMtYW5vbi1rZXknIH0sXG5cdCogICBzY2hlbWE6ICdwdWJsaWMnLFxuXHQqICAgdGltZW91dDogMzAwMDAsIC8vIDMwIHNlY29uZCB0aW1lb3V0XG5cdCogfSlcblx0KiBgYGBcblx0Ki9cblx0Y29uc3RydWN0b3IodXJsLCB7IGhlYWRlcnMgPSB7fSwgc2NoZW1hLCBmZXRjaDogZmV0Y2gkMSwgdGltZW91dCwgdXJsTGVuZ3RoTGltaXQgPSA4ZTMgfSA9IHt9KSB7XG5cdFx0dGhpcy51cmwgPSB1cmw7XG5cdFx0dGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaGVhZGVycyk7XG5cdFx0dGhpcy5zY2hlbWFOYW1lID0gc2NoZW1hO1xuXHRcdHRoaXMudXJsTGVuZ3RoTGltaXQgPSB1cmxMZW5ndGhMaW1pdDtcblx0XHRjb25zdCBvcmlnaW5hbEZldGNoID0gZmV0Y2gkMSAhPT0gbnVsbCAmJiBmZXRjaCQxICE9PSB2b2lkIDAgPyBmZXRjaCQxIDogZ2xvYmFsVGhpcy5mZXRjaDtcblx0XHRpZiAodGltZW91dCAhPT0gdm9pZCAwICYmIHRpbWVvdXQgPiAwKSB0aGlzLmZldGNoID0gKGlucHV0LCBpbml0KSA9PiB7XG5cdFx0XHRjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuXHRcdFx0Y29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIHRpbWVvdXQpO1xuXHRcdFx0Y29uc3QgZXhpc3RpbmdTaWduYWwgPSBpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQuc2lnbmFsO1xuXHRcdFx0aWYgKGV4aXN0aW5nU2lnbmFsKSB7XG5cdFx0XHRcdGlmIChleGlzdGluZ1NpZ25hbC5hYm9ydGVkKSB7XG5cdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG5cdFx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsRmV0Y2goaW5wdXQsIGluaXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0IGFib3J0SGFuZGxlciA9ICgpID0+IHtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQodGltZW91dElkKTtcblx0XHRcdFx0XHRjb250cm9sbGVyLmFib3J0KCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdGV4aXN0aW5nU2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydEhhbmRsZXIsIHsgb25jZTogdHJ1ZSB9KTtcblx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsRmV0Y2goaW5wdXQsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBpbml0KSwge30sIHsgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCB9KSkuZmluYWxseSgoKSA9PiB7XG5cdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG5cdFx0XHRcdFx0ZXhpc3RpbmdTaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0SGFuZGxlcik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9yaWdpbmFsRmV0Y2goaW5wdXQsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBpbml0KSwge30sIHsgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCB9KSkuZmluYWxseSgoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dElkKSk7XG5cdFx0fTtcblx0XHRlbHNlIHRoaXMuZmV0Y2ggPSBvcmlnaW5hbEZldGNoO1xuXHR9XG5cdC8qKlxuXHQqIFBlcmZvcm0gYSBxdWVyeSBvbiBhIHRhYmxlIG9yIGEgdmlldy5cblx0KlxuXHQqIEBwYXJhbSByZWxhdGlvbiAtIFRoZSB0YWJsZSBvciB2aWV3IG5hbWUgdG8gcXVlcnlcblx0Ki9cblx0ZnJvbShyZWxhdGlvbikge1xuXHRcdGlmICghcmVsYXRpb24gfHwgdHlwZW9mIHJlbGF0aW9uICE9PSBcInN0cmluZ1wiIHx8IHJlbGF0aW9uLnRyaW0oKSA9PT0gXCJcIikgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZWxhdGlvbiBuYW1lOiByZWxhdGlvbiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZy5cIik7XG5cdFx0cmV0dXJuIG5ldyBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIobmV3IFVSTChgJHt0aGlzLnVybH0vJHtyZWxhdGlvbn1gKSwge1xuXHRcdFx0aGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcblx0XHRcdHNjaGVtYTogdGhpcy5zY2hlbWFOYW1lLFxuXHRcdFx0ZmV0Y2g6IHRoaXMuZmV0Y2gsXG5cdFx0XHR1cmxMZW5ndGhMaW1pdDogdGhpcy51cmxMZW5ndGhMaW1pdFxuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqIFNlbGVjdCBhIHNjaGVtYSB0byBxdWVyeSBvciBwZXJmb3JtIGFuIGZ1bmN0aW9uIChycGMpIGNhbGwuXG5cdCpcblx0KiBUaGUgc2NoZW1hIG5lZWRzIHRvIGJlIG9uIHRoZSBsaXN0IG9mIGV4cG9zZWQgc2NoZW1hcyBpbnNpZGUgU3VwYWJhc2UuXG5cdCpcblx0KiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSB0byBxdWVyeVxuXHQqL1xuXHRzY2hlbWEoc2NoZW1hKSB7XG5cdFx0cmV0dXJuIG5ldyBQb3N0Z3Jlc3RDbGllbnQodGhpcy51cmwsIHtcblx0XHRcdGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcblx0XHRcdHNjaGVtYSxcblx0XHRcdGZldGNoOiB0aGlzLmZldGNoLFxuXHRcdFx0dXJsTGVuZ3RoTGltaXQ6IHRoaXMudXJsTGVuZ3RoTGltaXRcblx0XHR9KTtcblx0fVxuXHQvKipcblx0KiBQZXJmb3JtIGEgZnVuY3Rpb24gY2FsbC5cblx0KlxuXHQqIEBwYXJhbSBmbiAtIFRoZSBmdW5jdGlvbiBuYW1lIHRvIGNhbGxcblx0KiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgZnVuY3Rpb24gY2FsbFxuXHQqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuXHQqIEBwYXJhbSBvcHRpb25zLmhlYWQgLSBXaGVuIHNldCB0byBgdHJ1ZWAsIGBkYXRhYCB3aWxsIG5vdCBiZSByZXR1cm5lZC5cblx0KiBVc2VmdWwgaWYgeW91IG9ubHkgbmVlZCB0aGUgY291bnQuXG5cdCogQHBhcmFtIG9wdGlvbnMuZ2V0IC0gV2hlbiBzZXQgdG8gYHRydWVgLCB0aGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aFxuXHQqIHJlYWQtb25seSBhY2Nlc3MgbW9kZS5cblx0KiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgcm93cyByZXR1cm5lZCBieSB0aGVcblx0KiBmdW5jdGlvbi4gT25seSBhcHBsaWNhYmxlIGZvciBbc2V0LXJldHVybmluZ1xuXHQqIGZ1bmN0aW9uc10oaHR0cHM6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy9jdXJyZW50L2Z1bmN0aW9ucy1zcmYuaHRtbCkuXG5cdCpcblx0KiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG5cdCogaG9vZC5cblx0KlxuXHQqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG5cdCogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cblx0KlxuXHQqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcblx0KiBudW1iZXJzLlxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0c1xuXHQqIC8vIEZvciBjcm9zcy1zY2hlbWEgZnVuY3Rpb25zIHdoZXJlIHR5cGUgaW5mZXJlbmNlIGZhaWxzLCB1c2Ugb3ZlcnJpZGVUeXBlczpcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc2NoZW1hKCdzY2hlbWFfYicpXG5cdCogICAucnBjKCdmdW5jdGlvbl9hJywge30pXG5cdCogICAub3ZlcnJpZGVUeXBlczx7IGlkOiBzdHJpbmc7IHVzZXJfaWQ6IHN0cmluZyB9W10+KClcblx0KiBgYGBcblx0Ki9cblx0cnBjKGZuLCBhcmdzID0ge30sIHsgaGVhZCA9IGZhbHNlLCBnZXQgPSBmYWxzZSwgY291bnQgfSA9IHt9KSB7XG5cdFx0dmFyIF90aGlzJGZldGNoO1xuXHRcdGxldCBtZXRob2Q7XG5cdFx0Y29uc3QgdXJsID0gbmV3IFVSTChgJHt0aGlzLnVybH0vcnBjLyR7Zm59YCk7XG5cdFx0bGV0IGJvZHk7XG5cdFx0Y29uc3QgX2lzT2JqZWN0ID0gKHYpID0+IHYgIT09IG51bGwgJiYgdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgKCFBcnJheS5pc0FycmF5KHYpIHx8IHYuc29tZShfaXNPYmplY3QpKTtcblx0XHRjb25zdCBfaGFzT2JqZWN0QXJnID0gaGVhZCAmJiBPYmplY3QudmFsdWVzKGFyZ3MpLnNvbWUoX2lzT2JqZWN0KTtcblx0XHRpZiAoX2hhc09iamVjdEFyZykge1xuXHRcdFx0bWV0aG9kID0gXCJQT1NUXCI7XG5cdFx0XHRib2R5ID0gYXJncztcblx0XHR9IGVsc2UgaWYgKGhlYWQgfHwgZ2V0KSB7XG5cdFx0XHRtZXRob2QgPSBoZWFkID8gXCJIRUFEXCIgOiBcIkdFVFwiO1xuXHRcdFx0T2JqZWN0LmVudHJpZXMoYXJncykuZmlsdGVyKChbXywgdmFsdWVdKSA9PiB2YWx1ZSAhPT0gdm9pZCAwKS5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+IFtuYW1lLCBBcnJheS5pc0FycmF5KHZhbHVlKSA/IGB7JHt2YWx1ZS5qb2luKFwiLFwiKX19YCA6IGAke3ZhbHVlfWBdKS5mb3JFYWNoKChbbmFtZSwgdmFsdWVdKSA9PiB7XG5cdFx0XHRcdHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKG5hbWUsIHZhbHVlKTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZXRob2QgPSBcIlBPU1RcIjtcblx0XHRcdGJvZHkgPSBhcmdzO1xuXHRcdH1cblx0XHRjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKTtcblx0XHRpZiAoX2hhc09iamVjdEFyZykgaGVhZGVycy5zZXQoXCJQcmVmZXJcIiwgY291bnQgPyBgY291bnQ9JHtjb3VudH0scmV0dXJuPW1pbmltYWxgIDogXCJyZXR1cm49bWluaW1hbFwiKTtcblx0XHRlbHNlIGlmIChjb3VudCkgaGVhZGVycy5zZXQoXCJQcmVmZXJcIiwgYGNvdW50PSR7Y291bnR9YCk7XG5cdFx0cmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyKHtcblx0XHRcdG1ldGhvZCxcblx0XHRcdHVybCxcblx0XHRcdGhlYWRlcnMsXG5cdFx0XHRzY2hlbWE6IHRoaXMuc2NoZW1hTmFtZSxcblx0XHRcdGJvZHksXG5cdFx0XHRmZXRjaDogKF90aGlzJGZldGNoID0gdGhpcy5mZXRjaCkgIT09IG51bGwgJiYgX3RoaXMkZmV0Y2ggIT09IHZvaWQgMCA/IF90aGlzJGZldGNoIDogZmV0Y2gsXG5cdFx0XHR1cmxMZW5ndGhMaW1pdDogdGhpcy51cmxMZW5ndGhMaW1pdFxuXHRcdH0pO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvaW5kZXgudHNcbnZhciBzcmNfZGVmYXVsdCA9IHtcblx0UG9zdGdyZXN0Q2xpZW50LFxuXHRQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIsXG5cdFBvc3RncmVzdEZpbHRlckJ1aWxkZXIsXG5cdFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIsXG5cdFBvc3RncmVzdEJ1aWxkZXIsXG5cdFBvc3RncmVzdEVycm9yXG59O1xuXG4vLyNlbmRyZWdpb25cbmV4cG9ydCB7IFBvc3RncmVzdEJ1aWxkZXIsIFBvc3RncmVzdENsaWVudCwgUG9zdGdyZXN0RXJyb3IsIFBvc3RncmVzdEZpbHRlckJ1aWxkZXIsIFBvc3RncmVzdFF1ZXJ5QnVpbGRlciwgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciwgc3JjX2RlZmF1bHQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6WyJQb3N0Z3Jlc3RFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJjb250ZXh0IiwibWVzc2FnZSIsIm5hbWUiLCJkZXRhaWxzIiwiaGludCIsImNvZGUiLCJQb3N0Z3Jlc3RCdWlsZGVyIiwiYnVpbGRlciIsIl9idWlsZGVyJHNob3VsZFRocm93TyIsIl9idWlsZGVyJGlzTWF5YmVTaW5nbCIsIl9idWlsZGVyJHVybExlbmd0aExpbSIsInNob3VsZFRocm93T25FcnJvciIsIm1ldGhvZCIsInVybCIsImhlYWRlcnMiLCJIZWFkZXJzIiwic2NoZW1hIiwiYm9keSIsInNpZ25hbCIsImlzTWF5YmVTaW5nbGUiLCJ1cmxMZW5ndGhMaW1pdCIsImZldGNoIiwidGhyb3dPbkVycm9yIiwic2V0SGVhZGVyIiwidmFsdWUiLCJzZXQiLCJ0aGVuIiwib25mdWxmaWxsZWQiLCJvbnJlamVjdGVkIiwiX3RoaXMiLCJpbmNsdWRlcyIsIl9mZXRjaCIsInJlcyIsInRvU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlcyQxIiwiZXJyb3IiLCJkYXRhIiwiY291bnQiLCJzdGF0dXMiLCJzdGF0dXNUZXh0Iiwib2siLCJfdGhpcyRoZWFkZXJzJGdldDIiLCJfcmVzJGhlYWRlcnMkZ2V0IiwiX3RoaXMkaGVhZGVycyRnZXQiLCJ0ZXh0IiwiZ2V0IiwicGFyc2UiLCJjb3VudEhlYWRlciIsIm1hdGNoIiwiY29udGVudFJhbmdlIiwic3BsaXQiLCJsZW5ndGgiLCJwYXJzZUludCIsIkFycmF5IiwiaXNBcnJheSIsIl9lcnJvciRkZXRhaWxzIiwiX3VudXNlZCIsImNhdGNoIiwiZmV0Y2hFcnJvciIsIl9mZXRjaEVycm9yJG5hbWUyIiwiZXJyb3JEZXRhaWxzIiwiY2F1c2UiLCJfY2F1c2UkbWVzc2FnZSIsIl9jYXVzZSRjb2RlIiwiX2ZldGNoRXJyb3IkbmFtZSIsIl9jYXVzZSRuYW1lIiwiY2F1c2VNZXNzYWdlIiwiY2F1c2VDb2RlIiwic3RhY2siLCJfZmV0Y2hFcnJvciRzdGFjayIsInVybExlbmd0aCIsInJldHVybnMiLCJvdmVycmlkZVR5cGVzIiwiUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciIsInNlbGVjdCIsImNvbHVtbnMiLCJxdW90ZWQiLCJjbGVhbmVkQ29sdW1ucyIsIm1hcCIsImMiLCJ0ZXN0Iiwiam9pbiIsInNlYXJjaFBhcmFtcyIsImFwcGVuZCIsIm9yZGVyIiwiY29sdW1uIiwiYXNjZW5kaW5nIiwibnVsbHNGaXJzdCIsImZvcmVpZ25UYWJsZSIsInJlZmVyZW5jZWRUYWJsZSIsImtleSIsImV4aXN0aW5nT3JkZXIiLCJsaW1pdCIsInJhbmdlIiwiZnJvbSIsInRvIiwia2V5T2Zmc2V0Iiwia2V5TGltaXQiLCJhYm9ydFNpZ25hbCIsInNpbmdsZSIsIm1heWJlU2luZ2xlIiwiY3N2IiwiZ2VvanNvbiIsImV4cGxhaW4iLCJhbmFseXplIiwidmVyYm9zZSIsInNldHRpbmdzIiwiYnVmZmVycyIsIndhbCIsImZvcm1hdCIsIm9wdGlvbnMiLCJmaWx0ZXIiLCJCb29sZWFuIiwiZm9yTWVkaWF0eXBlIiwicm9sbGJhY2siLCJtYXhBZmZlY3RlZCIsIlBvc3RncmVzdFJlc2VydmVkQ2hhcnNSZWdleHAiLCJSZWdFeHAiLCJQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyIiwiZXEiLCJuZXEiLCJndCIsImd0ZSIsImx0IiwibHRlIiwibGlrZSIsInBhdHRlcm4iLCJsaWtlQWxsT2YiLCJwYXR0ZXJucyIsImxpa2VBbnlPZiIsImlsaWtlIiwiaWxpa2VBbGxPZiIsImlsaWtlQW55T2YiLCJyZWdleE1hdGNoIiwicmVnZXhJTWF0Y2giLCJpcyIsImlzRGlzdGluY3QiLCJpbiIsInZhbHVlcyIsImNsZWFuZWRWYWx1ZXMiLCJTZXQiLCJzIiwibm90SW4iLCJjb250YWlucyIsImNvbnRhaW5lZEJ5IiwicmFuZ2VHdCIsInJhbmdlR3RlIiwicmFuZ2VMdCIsInJhbmdlTHRlIiwicmFuZ2VBZGphY2VudCIsIm92ZXJsYXBzIiwidGV4dFNlYXJjaCIsInF1ZXJ5IiwiY29uZmlnIiwidHlwZSIsInR5cGVQYXJ0IiwiY29uZmlnUGFydCIsIk9iamVjdCIsImVudHJpZXMiLCJmb3JFYWNoIiwibm90Iiwib3BlcmF0b3IiLCJvciIsImZpbHRlcnMiLCJQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIiLCJmZXRjaCQxIiwiY2xvbmVSZXF1ZXN0U3RhdGUiLCJVUkwiLCJoZWFkIiwiaW5zZXJ0IiwiZGVmYXVsdFRvTnVsbCIsIl90aGlzJGZldGNoIiwicmVkdWNlIiwiYWNjIiwieCIsImNvbmNhdCIsImtleXMiLCJ1bmlxdWVDb2x1bW5zIiwidXBzZXJ0Iiwib25Db25mbGljdCIsImlnbm9yZUR1cGxpY2F0ZXMiLCJfdGhpcyRmZXRjaDIiLCJ1cGRhdGUiLCJfdGhpcyRmZXRjaDMiLCJkZWxldGUiLCJfdGhpcyRmZXRjaDQiLCJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwibyQxIiwicHJvdG90eXBlIiwidG9QcmltaXRpdmUiLCJ0IiwiciIsImUiLCJpIiwiY2FsbCIsIlR5cGVFcnJvciIsIlN0cmluZyIsIk51bWJlciIsInRvUHJvcGVydHlLZXkiLCJfZGVmaW5lUHJvcGVydHkiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIm93bktleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJyJDEiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkMiIsImFyZ3VtZW50cyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiUG9zdGdyZXN0Q2xpZW50IiwidGltZW91dCIsInNjaGVtYU5hbWUiLCJvcmlnaW5hbEZldGNoIiwiZ2xvYmFsVGhpcyIsImlucHV0IiwiaW5pdCIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJ0aW1lb3V0SWQiLCJzZXRUaW1lb3V0IiwiYWJvcnQiLCJleGlzdGluZ1NpZ25hbCIsImFib3J0ZWQiLCJjbGVhclRpbWVvdXQiLCJhYm9ydEhhbmRsZXIiLCJhZGRFdmVudExpc3RlbmVyIiwib25jZSIsImZpbmFsbHkiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVsYXRpb24iLCJ0cmltIiwicnBjIiwiZm4iLCJhcmdzIiwiX2lzT2JqZWN0IiwidiIsInNvbWUiLCJfaGFzT2JqZWN0QXJnIiwiXyIsInNyY19kZWZhdWx0IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/postgrest-js/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/index.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/index.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageAnalyticsClient: () => (/* binding */ StorageAnalyticsClient),\n/* harmony export */   StorageApiError: () => (/* binding */ StorageApiError),\n/* harmony export */   StorageClient: () => (/* binding */ StorageClient),\n/* harmony export */   StorageError: () => (/* binding */ StorageError),\n/* harmony export */   StorageUnknownError: () => (/* binding */ StorageUnknownError),\n/* harmony export */   StorageVectorsApiError: () => (/* binding */ StorageVectorsApiError),\n/* harmony export */   StorageVectorsClient: () => (/* binding */ StorageVectorsClient),\n/* harmony export */   StorageVectorsError: () => (/* binding */ StorageVectorsError),\n/* harmony export */   StorageVectorsErrorCode: () => (/* binding */ StorageVectorsErrorCode),\n/* harmony export */   StorageVectorsUnknownError: () => (/* binding */ StorageVectorsUnknownError),\n/* harmony export */   VectorBucketApi: () => (/* binding */ VectorBucketApi),\n/* harmony export */   VectorBucketScope: () => (/* binding */ VectorBucketScope),\n/* harmony export */   VectorDataApi: () => (/* binding */ VectorDataApi),\n/* harmony export */   VectorIndexApi: () => (/* binding */ VectorIndexApi),\n/* harmony export */   VectorIndexScope: () => (/* binding */ VectorIndexScope),\n/* harmony export */   isStorageError: () => (/* binding */ isStorageError),\n/* harmony export */   isStorageVectorsError: () => (/* binding */ isStorageVectorsError)\n/* harmony export */ });\n/* harmony import */ var iceberg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! iceberg-js */ \"(ssr)/./node_modules/iceberg-js/dist/index.mjs\");\n\n//#region src/lib/common/errors.ts\n/**\n* Base error class for all Storage errors\n* Supports both 'storage' and 'vectors' namespaces\n*/ var StorageError = class extends Error {\n    constructor(message, namespace = \"storage\", status, statusCode){\n        super(message);\n        this.__isStorageError = true;\n        this.namespace = namespace;\n        this.name = namespace === \"vectors\" ? \"StorageVectorsError\" : \"StorageError\";\n        this.status = status;\n        this.statusCode = statusCode;\n    }\n};\n/**\n* Type guard to check if an error is a StorageError\n* @param error - The error to check\n* @returns True if the error is a StorageError\n*/ function isStorageError(error) {\n    return typeof error === \"object\" && error !== null && \"__isStorageError\" in error;\n}\n/**\n* API error returned from Storage service\n* Includes HTTP status code and service-specific error code\n*/ var StorageApiError = class extends StorageError {\n    constructor(message, status, statusCode, namespace = \"storage\"){\n        super(message, namespace, status, statusCode);\n        this.name = namespace === \"vectors\" ? \"StorageVectorsApiError\" : \"StorageApiError\";\n        this.status = status;\n        this.statusCode = statusCode;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            statusCode: this.statusCode\n        };\n    }\n};\n/**\n* Unknown error that doesn't match expected error patterns\n* Wraps the original error for debugging\n*/ var StorageUnknownError = class extends StorageError {\n    constructor(message, originalError, namespace = \"storage\"){\n        super(message, namespace);\n        this.name = namespace === \"vectors\" ? \"StorageVectorsUnknownError\" : \"StorageUnknownError\";\n        this.originalError = originalError;\n    }\n};\n/**\n* @deprecated Use StorageError with namespace='vectors' instead\n* Alias for backward compatibility with existing vector storage code\n*/ var StorageVectorsError = class extends StorageError {\n    constructor(message){\n        super(message, \"vectors\");\n    }\n};\n/**\n* Type guard to check if an error is a StorageVectorsError\n* @param error - The error to check\n* @returns True if the error is a StorageVectorsError\n*/ function isStorageVectorsError(error) {\n    return isStorageError(error) && error[\"namespace\"] === \"vectors\";\n}\n/**\n* @deprecated Use StorageApiError with namespace='vectors' instead\n* Alias for backward compatibility with existing vector storage code\n*/ var StorageVectorsApiError = class extends StorageApiError {\n    constructor(message, status, statusCode){\n        super(message, status, statusCode, \"vectors\");\n    }\n};\n/**\n* @deprecated Use StorageUnknownError with namespace='vectors' instead\n* Alias for backward compatibility with existing vector storage code\n*/ var StorageVectorsUnknownError = class extends StorageUnknownError {\n    constructor(message, originalError){\n        super(message, originalError, \"vectors\");\n    }\n};\n/**\n* Error codes specific to S3 Vectors API\n* Maps AWS service errors to application-friendly error codes\n*/ let StorageVectorsErrorCode = /* @__PURE__ */ function(StorageVectorsErrorCode$1) {\n    /** Internal server fault (HTTP 500) */ StorageVectorsErrorCode$1[\"InternalError\"] = \"InternalError\";\n    /** Resource already exists / conflict (HTTP 409) */ StorageVectorsErrorCode$1[\"S3VectorConflictException\"] = \"S3VectorConflictException\";\n    /** Resource not found (HTTP 404) */ StorageVectorsErrorCode$1[\"S3VectorNotFoundException\"] = \"S3VectorNotFoundException\";\n    /** Delete bucket while not empty (HTTP 400) */ StorageVectorsErrorCode$1[\"S3VectorBucketNotEmpty\"] = \"S3VectorBucketNotEmpty\";\n    /** Exceeds bucket quota/limit (HTTP 400) */ StorageVectorsErrorCode$1[\"S3VectorMaxBucketsExceeded\"] = \"S3VectorMaxBucketsExceeded\";\n    /** Exceeds index quota/limit (HTTP 400) */ StorageVectorsErrorCode$1[\"S3VectorMaxIndexesExceeded\"] = \"S3VectorMaxIndexesExceeded\";\n    return StorageVectorsErrorCode$1;\n}({});\n//#endregion\n//#region src/lib/common/helpers.ts\n/**\n* Resolves the fetch implementation to use\n* Uses custom fetch if provided, otherwise uses native fetch\n*\n* @param customFetch - Optional custom fetch implementation\n* @returns Resolved fetch function\n*/ const resolveFetch = (customFetch)=>{\n    if (customFetch) return (...args)=>customFetch(...args);\n    return (...args)=>fetch(...args);\n};\n/**\n* Determine if input is a plain object\n* An object is plain if it's created by either {}, new Object(), or Object.create(null)\n*\n* @param value - Value to check\n* @returns True if value is a plain object\n* @source https://github.com/sindresorhus/is-plain-obj\n*/ const isPlainObject = (value)=>{\n    if (typeof value !== \"object\" || value === null) return false;\n    const prototype = Object.getPrototypeOf(value);\n    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n};\n/**\n* Recursively converts object keys from snake_case to camelCase\n* Used for normalizing API responses\n*\n* @param item - Object to convert\n* @returns Converted object with camelCase keys\n*/ const recursiveToCamel = (item)=>{\n    if (Array.isArray(item)) return item.map((el)=>recursiveToCamel(el));\n    else if (typeof item === \"function\" || item !== Object(item)) return item;\n    const result = {};\n    Object.entries(item).forEach(([key, value])=>{\n        const newKey = key.replace(/([-_][a-z])/gi, (c)=>c.toUpperCase().replace(/[-_]/g, \"\"));\n        result[newKey] = recursiveToCamel(value);\n    });\n    return result;\n};\n/**\n* Validates if a given bucket name is valid according to Supabase Storage API rules\n* Mirrors backend validation from: storage/src/storage/limits.ts:isValidBucketName()\n*\n* Rules:\n* - Length: 1-100 characters\n* - Allowed characters: alphanumeric (a-z, A-Z, 0-9), underscore (_), and safe special characters\n* - Safe special characters: ! - . * ' ( ) space & $ @ = ; : + , ?\n* - Forbidden: path separators (/, \\), path traversal (..), leading/trailing whitespace\n*\n* AWS S3 Reference: https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html\n*\n* @param bucketName - The bucket name to validate\n* @returns true if valid, false otherwise\n*/ const isValidBucketName = (bucketName)=>{\n    if (!bucketName || typeof bucketName !== \"string\") return false;\n    if (bucketName.length === 0 || bucketName.length > 100) return false;\n    if (bucketName.trim() !== bucketName) return false;\n    if (bucketName.includes(\"/\") || bucketName.includes(\"\\\\\")) return false;\n    return /^[\\w!.\\*'() &$@=;:+,?-]+$/.test(bucketName);\n};\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/typeof.js\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o$1) {\n        return typeof o$1;\n    } : function(o$1) {\n        return o$1 && \"function\" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? \"symbol\" : typeof o$1;\n    }, _typeof(o);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPrimitive.js\nfunction toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPropertyKey.js\nfunction toPropertyKey(t) {\n    var i = toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/defineProperty.js\nfunction _defineProperty(e, r, t) {\n    return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/objectSpread2.js\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r$1) {\n            return Object.getOwnPropertyDescriptor(e, r$1).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread2(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r$1) {\n            _defineProperty(e, r$1, t[r$1]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {\n            Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));\n        });\n    }\n    return e;\n}\n//#endregion\n//#region src/lib/common/fetch.ts\n/**\n* Extracts error message from various error response formats\n* @param err - Error object from API\n* @returns Human-readable error message\n*/ const _getErrorMessage = (err)=>{\n    var _err$error;\n    return err.msg || err.message || err.error_description || (typeof err.error === \"string\" ? err.error : (_err$error = err.error) === null || _err$error === void 0 ? void 0 : _err$error.message) || JSON.stringify(err);\n};\n/**\n* Handles fetch errors and converts them to Storage error types\n* @param error - The error caught from fetch\n* @param reject - Promise rejection function\n* @param options - Fetch options that may affect error handling\n* @param namespace - Error namespace ('storage' or 'vectors')\n*/ const handleError = async (error, reject, options, namespace)=>{\n    if (error && typeof error === \"object\" && \"status\" in error && \"ok\" in error && typeof error.status === \"number\" && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {\n        const responseError = error;\n        const status = responseError.status || 500;\n        if (typeof responseError.json === \"function\") responseError.json().then((err)=>{\n            const statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || (err === null || err === void 0 ? void 0 : err.code) || status + \"\";\n            reject(new StorageApiError(_getErrorMessage(err), status, statusCode, namespace));\n        }).catch(()=>{\n            if (namespace === \"vectors\") {\n                const statusCode = status + \"\";\n                reject(new StorageApiError(responseError.statusText || `HTTP ${status} error`, status, statusCode, namespace));\n            } else {\n                const statusCode = status + \"\";\n                reject(new StorageApiError(responseError.statusText || `HTTP ${status} error`, status, statusCode, namespace));\n            }\n        });\n        else {\n            const statusCode = status + \"\";\n            reject(new StorageApiError(responseError.statusText || `HTTP ${status} error`, status, statusCode, namespace));\n        }\n    } else reject(new StorageUnknownError(_getErrorMessage(error), error, namespace));\n};\n/**\n* Builds request parameters for fetch calls\n* @param method - HTTP method\n* @param options - Custom fetch options\n* @param parameters - Additional fetch parameters like AbortSignal\n* @param body - Request body (will be JSON stringified if plain object)\n* @returns Complete fetch request parameters\n*/ const _getRequestParams = (method, options, parameters, body)=>{\n    const params = {\n        method,\n        headers: (options === null || options === void 0 ? void 0 : options.headers) || {}\n    };\n    if (method === \"GET\" || method === \"HEAD\" || !body) return _objectSpread2(_objectSpread2({}, params), parameters);\n    if (isPlainObject(body)) {\n        params.headers = _objectSpread2({\n            \"Content-Type\": \"application/json\"\n        }, options === null || options === void 0 ? void 0 : options.headers);\n        params.body = JSON.stringify(body);\n    } else params.body = body;\n    if (options === null || options === void 0 ? void 0 : options.duplex) params.duplex = options.duplex;\n    return _objectSpread2(_objectSpread2({}, params), parameters);\n};\n/**\n* Internal request handler that wraps fetch with error handling\n* @param fetcher - Fetch function to use\n* @param method - HTTP method\n* @param url - Request URL\n* @param options - Custom fetch options\n* @param parameters - Additional fetch parameters\n* @param body - Request body\n* @param namespace - Error namespace ('storage' or 'vectors')\n* @returns Promise with parsed response or error\n*/ async function _handleRequest(fetcher, method, url, options, parameters, body, namespace) {\n    return new Promise((resolve, reject)=>{\n        fetcher(url, _getRequestParams(method, options, parameters, body)).then((result)=>{\n            if (!result.ok) throw result;\n            if (options === null || options === void 0 ? void 0 : options.noResolveJson) return result;\n            if (namespace === \"vectors\") {\n                const contentType = result.headers.get(\"content-type\");\n                if (result.headers.get(\"content-length\") === \"0\" || result.status === 204) return {};\n                if (!contentType || !contentType.includes(\"application/json\")) return {};\n            }\n            return result.json();\n        }).then((data)=>resolve(data)).catch((error)=>handleError(error, reject, options, namespace));\n    });\n}\n/**\n* Creates a fetch API with the specified namespace\n* @param namespace - Error namespace ('storage' or 'vectors')\n* @returns Object with HTTP method functions\n*/ function createFetchApi(namespace = \"storage\") {\n    return {\n        get: async (fetcher, url, options, parameters)=>{\n            return _handleRequest(fetcher, \"GET\", url, options, parameters, void 0, namespace);\n        },\n        post: async (fetcher, url, body, options, parameters)=>{\n            return _handleRequest(fetcher, \"POST\", url, options, parameters, body, namespace);\n        },\n        put: async (fetcher, url, body, options, parameters)=>{\n            return _handleRequest(fetcher, \"PUT\", url, options, parameters, body, namespace);\n        },\n        head: async (fetcher, url, options, parameters)=>{\n            return _handleRequest(fetcher, \"HEAD\", url, _objectSpread2(_objectSpread2({}, options), {}, {\n                noResolveJson: true\n            }), parameters, void 0, namespace);\n        },\n        remove: async (fetcher, url, body, options, parameters)=>{\n            return _handleRequest(fetcher, \"DELETE\", url, options, parameters, body, namespace);\n        }\n    };\n}\nconst defaultApi = createFetchApi(\"storage\");\nconst { get, post, put, head, remove } = defaultApi;\nconst vectorsApi = createFetchApi(\"vectors\");\n//#endregion\n//#region src/lib/common/BaseApiClient.ts\n/**\n* @ignore\n* Base API client class for all Storage API classes\n* Provides common infrastructure for error handling and configuration\n*\n* @typeParam TError - The error type (StorageError or subclass)\n*/ var BaseApiClient = class {\n    /**\n\t* Creates a new BaseApiClient instance\n\t* @param url - Base URL for API requests\n\t* @param headers - Default headers for API requests\n\t* @param fetch - Optional custom fetch implementation\n\t* @param namespace - Error namespace ('storage' or 'vectors')\n\t*/ constructor(url, headers = {}, fetch$1, namespace = \"storage\"){\n        this.shouldThrowOnError = false;\n        this.url = url;\n        this.headers = headers;\n        this.fetch = resolveFetch(fetch$1);\n        this.namespace = namespace;\n    }\n    /**\n\t* Enable throwing errors instead of returning them.\n\t* When enabled, errors are thrown instead of returned in { data, error } format.\n\t*\n\t* @returns this - For method chaining\n\t*/ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n\t* Set an HTTP header for the request.\n\t* Creates a shallow copy of headers to avoid mutating shared state.\n\t*\n\t* @param name - Header name\n\t* @param value - Header value\n\t* @returns this - For method chaining\n\t*/ setHeader(name, value) {\n        this.headers = _objectSpread2(_objectSpread2({}, this.headers), {}, {\n            [name]: value\n        });\n        return this;\n    }\n    /**\n\t* Handles API operation with standardized error handling\n\t* Eliminates repetitive try-catch blocks across all API methods\n\t*\n\t* This wrapper:\n\t* 1. Executes the operation\n\t* 2. Returns { data, error: null } on success\n\t* 3. Returns { data: null, error } on failure (if shouldThrowOnError is false)\n\t* 4. Throws error on failure (if shouldThrowOnError is true)\n\t*\n\t* @typeParam T - The expected data type from the operation\n\t* @param operation - Async function that performs the API call\n\t* @returns Promise with { data, error } tuple\n\t*\n\t* @example\n\t* ```typescript\n\t* async listBuckets() {\n\t*   return this.handleOperation(async () => {\n\t*     return await get(this.fetch, `${this.url}/bucket`, {\n\t*       headers: this.headers,\n\t*     })\n\t*   })\n\t* }\n\t* ```\n\t*/ async handleOperation(operation) {\n        var _this = this;\n        try {\n            return {\n                data: await operation(),\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/packages/StreamDownloadBuilder.ts\nvar StreamDownloadBuilder = class {\n    constructor(downloadFn, shouldThrowOnError){\n        this.downloadFn = downloadFn;\n        this.shouldThrowOnError = shouldThrowOnError;\n    }\n    then(onfulfilled, onrejected) {\n        return this.execute().then(onfulfilled, onrejected);\n    }\n    async execute() {\n        var _this = this;\n        try {\n            return {\n                data: (await _this.downloadFn()).body,\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/packages/BlobDownloadBuilder.ts\nlet _Symbol$toStringTag;\n_Symbol$toStringTag = Symbol.toStringTag;\nvar BlobDownloadBuilder = class {\n    constructor(downloadFn, shouldThrowOnError){\n        this.downloadFn = downloadFn;\n        this.shouldThrowOnError = shouldThrowOnError;\n        this[_Symbol$toStringTag] = \"BlobDownloadBuilder\";\n        this.promise = null;\n    }\n    asStream() {\n        return new StreamDownloadBuilder(this.downloadFn, this.shouldThrowOnError);\n    }\n    then(onfulfilled, onrejected) {\n        return this.getPromise().then(onfulfilled, onrejected);\n    }\n    catch(onrejected) {\n        return this.getPromise().catch(onrejected);\n    }\n    finally(onfinally) {\n        return this.getPromise().finally(onfinally);\n    }\n    getPromise() {\n        if (!this.promise) this.promise = this.execute();\n        return this.promise;\n    }\n    async execute() {\n        var _this = this;\n        try {\n            return {\n                data: await (await _this.downloadFn()).blob(),\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/packages/StorageFileApi.ts\nconst DEFAULT_SEARCH_OPTIONS = {\n    limit: 100,\n    offset: 0,\n    sortBy: {\n        column: \"name\",\n        order: \"asc\"\n    }\n};\nconst DEFAULT_FILE_OPTIONS = {\n    cacheControl: \"3600\",\n    contentType: \"text/plain;charset=UTF-8\",\n    upsert: false\n};\nvar StorageFileApi = class extends BaseApiClient {\n    constructor(url, headers = {}, bucketId, fetch$1){\n        super(url, headers, fetch$1, \"storage\");\n        this.bucketId = bucketId;\n    }\n    /**\n\t* Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.\n\t*\n\t* @param method HTTP method.\n\t* @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t*/ async uploadOrUpdate(method, path, fileBody, fileOptions) {\n        var _this = this;\n        return _this.handleOperation(async ()=>{\n            let body;\n            const options = _objectSpread2(_objectSpread2({}, DEFAULT_FILE_OPTIONS), fileOptions);\n            let headers = _objectSpread2(_objectSpread2({}, _this.headers), method === \"POST\" && {\n                \"x-upsert\": String(options.upsert)\n            });\n            const metadata = options.metadata;\n            if (typeof Blob !== \"undefined\" && fileBody instanceof Blob) {\n                body = new FormData();\n                body.append(\"cacheControl\", options.cacheControl);\n                if (metadata) body.append(\"metadata\", _this.encodeMetadata(metadata));\n                body.append(\"\", fileBody);\n            } else if (typeof FormData !== \"undefined\" && fileBody instanceof FormData) {\n                body = fileBody;\n                if (!body.has(\"cacheControl\")) body.append(\"cacheControl\", options.cacheControl);\n                if (metadata && !body.has(\"metadata\")) body.append(\"metadata\", _this.encodeMetadata(metadata));\n            } else {\n                body = fileBody;\n                headers[\"cache-control\"] = `max-age=${options.cacheControl}`;\n                headers[\"content-type\"] = options.contentType;\n                if (metadata) headers[\"x-metadata\"] = _this.toBase64(_this.encodeMetadata(metadata));\n                if ((typeof ReadableStream !== \"undefined\" && body instanceof ReadableStream || body && typeof body === \"object\" && \"pipe\" in body && typeof body.pipe === \"function\") && !options.duplex) options.duplex = \"half\";\n            }\n            if (fileOptions === null || fileOptions === void 0 ? void 0 : fileOptions.headers) headers = _objectSpread2(_objectSpread2({}, headers), fileOptions.headers);\n            const cleanPath = _this._removeEmptyFolders(path);\n            const _path = _this._getFinalPath(cleanPath);\n            const data = await (method == \"PUT\" ? put : post)(_this.fetch, `${_this.url}/object/${_path}`, body, _objectSpread2({\n                headers\n            }, (options === null || options === void 0 ? void 0 : options.duplex) ? {\n                duplex: options.duplex\n            } : {}));\n            return {\n                path: cleanPath,\n                id: data.Id,\n                fullPath: data.Key\n            };\n        });\n    }\n    /**\n\t* Uploads a file to an existing bucket.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t* @param fileOptions Optional file upload options including cacheControl, contentType, upsert, and metadata.\n\t* @returns Promise with response containing file path, id, and fullPath or error\n\t*\n\t* @example Upload file\n\t* ```js\n\t* const avatarFile = event.target.files[0]\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .upload('public/avatar1.png', avatarFile, {\n\t*     cacheControl: '3600',\n\t*     upsert: false\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"public/avatar1.png\",\n\t*     \"fullPath\": \"avatars/public/avatar1.png\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Upload file using `ArrayBuffer` from base64 file data\n\t* ```js\n\t* import { decode } from 'base64-arraybuffer'\n\t*\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .upload('public/avatar1.png', decode('base64FileData'), {\n\t*     contentType: 'image/png'\n\t*   })\n\t* ```\n\t*/ async upload(path, fileBody, fileOptions) {\n        return this.uploadOrUpdate(\"POST\", path, fileBody, fileOptions);\n    }\n    /**\n\t* Upload a file with a token generated from `createSignedUploadUrl`.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n\t* @param token The token generated from `createSignedUploadUrl`\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t* @param fileOptions HTTP headers (cacheControl, contentType, etc.).\n\t* **Note:** The `upsert` option has no effect here. To enable upsert behavior,\n\t* pass `{ upsert: true }` when calling `createSignedUploadUrl()` instead.\n\t* @returns Promise with response containing file path and fullPath or error\n\t*\n\t* @example Upload to a signed URL\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .uploadToSignedUrl('folder/cat.jpg', 'token-from-createSignedUploadUrl', file)\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"folder/cat.jpg\",\n\t*     \"fullPath\": \"avatars/folder/cat.jpg\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async uploadToSignedUrl(path, token, fileBody, fileOptions) {\n        var _this3 = this;\n        const cleanPath = _this3._removeEmptyFolders(path);\n        const _path = _this3._getFinalPath(cleanPath);\n        const url = new URL(_this3.url + `/object/upload/sign/${_path}`);\n        url.searchParams.set(\"token\", token);\n        return _this3.handleOperation(async ()=>{\n            let body;\n            const options = _objectSpread2({\n                upsert: DEFAULT_FILE_OPTIONS.upsert\n            }, fileOptions);\n            const headers = _objectSpread2(_objectSpread2({}, _this3.headers), {\n                \"x-upsert\": String(options.upsert)\n            });\n            if (typeof Blob !== \"undefined\" && fileBody instanceof Blob) {\n                body = new FormData();\n                body.append(\"cacheControl\", options.cacheControl);\n                body.append(\"\", fileBody);\n            } else if (typeof FormData !== \"undefined\" && fileBody instanceof FormData) {\n                body = fileBody;\n                body.append(\"cacheControl\", options.cacheControl);\n            } else {\n                body = fileBody;\n                headers[\"cache-control\"] = `max-age=${options.cacheControl}`;\n                headers[\"content-type\"] = options.contentType;\n            }\n            return {\n                path: cleanPath,\n                fullPath: (await put(_this3.fetch, url.toString(), body, {\n                    headers\n                })).Key\n            };\n        });\n    }\n    /**\n\t* Creates a signed upload URL.\n\t* Signed upload URLs can be used to upload files to the bucket without further authentication.\n\t* They are valid for 2 hours.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the current file name. For example `folder/image.png`.\n\t* @param options.upsert If set to true, allows the file to be overwritten if it already exists.\n\t* @returns Promise with response containing signed upload URL, token, and path or error\n\t*\n\t* @example Create Signed Upload URL\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUploadUrl('folder/cat.jpg')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"signedUrl\": \"https://example.supabase.co/storage/v1/object/upload/sign/avatars/folder/cat.jpg?token=<TOKEN>\",\n\t*     \"path\": \"folder/cat.jpg\",\n\t*     \"token\": \"<TOKEN>\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createSignedUploadUrl(path, options) {\n        var _this4 = this;\n        return _this4.handleOperation(async ()=>{\n            let _path = _this4._getFinalPath(path);\n            const headers = _objectSpread2({}, _this4.headers);\n            if (options === null || options === void 0 ? void 0 : options.upsert) headers[\"x-upsert\"] = \"true\";\n            const data = await post(_this4.fetch, `${_this4.url}/object/upload/sign/${_path}`, {}, {\n                headers\n            });\n            const url = new URL(_this4.url + data.url);\n            const token = url.searchParams.get(\"token\");\n            if (!token) throw new StorageError(\"No token returned by API\");\n            return {\n                signedUrl: url.toString(),\n                path,\n                token\n            };\n        });\n    }\n    /**\n\t* Replaces an existing file at the specified path with a new one.\n\t*\n\t* @category File Buckets\n\t* @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t* @param fileOptions Optional file upload options including cacheControl, contentType, upsert, and metadata.\n\t* @returns Promise with response containing file path, id, and fullPath or error\n\t*\n\t* @example Update file\n\t* ```js\n\t* const avatarFile = event.target.files[0]\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .update('public/avatar1.png', avatarFile, {\n\t*     cacheControl: '3600',\n\t*     upsert: true\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"public/avatar1.png\",\n\t*     \"fullPath\": \"avatars/public/avatar1.png\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Update file using `ArrayBuffer` from base64 file data\n\t* ```js\n\t* import {decode} from 'base64-arraybuffer'\n\t*\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .update('public/avatar1.png', decode('base64FileData'), {\n\t*     contentType: 'image/png'\n\t*   })\n\t* ```\n\t*/ async update(path, fileBody, fileOptions) {\n        return this.uploadOrUpdate(\"PUT\", path, fileBody, fileOptions);\n    }\n    /**\n\t* Moves an existing file to a new path in the same bucket.\n\t*\n\t* @category File Buckets\n\t* @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n\t* @param toPath The new file path, including the new file name. For example `folder/image-new.png`.\n\t* @param options The destination options.\n\t* @returns Promise with response containing success message or error\n\t*\n\t* @example Move file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .move('public/avatar1.png', 'private/avatar2.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully moved\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async move(fromPath, toPath, options) {\n        var _this6 = this;\n        return _this6.handleOperation(async ()=>{\n            return await post(_this6.fetch, `${_this6.url}/object/move`, {\n                bucketId: _this6.bucketId,\n                sourceKey: fromPath,\n                destinationKey: toPath,\n                destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket\n            }, {\n                headers: _this6.headers\n            });\n        });\n    }\n    /**\n\t* Copies an existing file to a new path in the same bucket.\n\t*\n\t* @category File Buckets\n\t* @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n\t* @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.\n\t* @param options The destination options.\n\t* @returns Promise with response containing copied file path or error\n\t*\n\t* @example Copy file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .copy('public/avatar1.png', 'private/avatar2.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"avatars/private/avatar2.png\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async copy(fromPath, toPath, options) {\n        var _this7 = this;\n        return _this7.handleOperation(async ()=>{\n            return {\n                path: (await post(_this7.fetch, `${_this7.url}/object/copy`, {\n                    bucketId: _this7.bucketId,\n                    sourceKey: fromPath,\n                    destinationKey: toPath,\n                    destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket\n                }, {\n                    headers: _this7.headers\n                })).Key\n            };\n        });\n    }\n    /**\n\t* Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the current file name. For example `folder/image.png`.\n\t* @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.\n\t* @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n\t* @param options.transform Transform the asset before serving it to the client.\n\t* @returns Promise with response containing signed URL or error\n\t*\n\t* @example Create Signed URL\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrl('folder/avatar1.png', 60)\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"signedUrl\": \"https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar1.png?token=<TOKEN>\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Create a signed URL for an asset with transformations\n\t* ```js\n\t* const { data } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrl('folder/avatar1.png', 60, {\n\t*     transform: {\n\t*       width: 100,\n\t*       height: 100,\n\t*     }\n\t*   })\n\t* ```\n\t*\n\t* @example Create a signed URL which triggers the download of the asset\n\t* ```js\n\t* const { data } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrl('folder/avatar1.png', 60, {\n\t*     download: true,\n\t*   })\n\t* ```\n\t*/ async createSignedUrl(path, expiresIn, options) {\n        var _this8 = this;\n        return _this8.handleOperation(async ()=>{\n            let _path = _this8._getFinalPath(path);\n            let data = await post(_this8.fetch, `${_this8.url}/object/sign/${_path}`, _objectSpread2({\n                expiresIn\n            }, (options === null || options === void 0 ? void 0 : options.transform) ? {\n                transform: options.transform\n            } : {}), {\n                headers: _this8.headers\n            });\n            const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? \"\" : options.download}` : \"\";\n            return {\n                signedUrl: encodeURI(`${_this8.url}${data.signedURL}${downloadQueryParam}`)\n            };\n        });\n    }\n    /**\n\t* Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.\n\t*\n\t* @category File Buckets\n\t* @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.\n\t* @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.\n\t* @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n\t* @returns Promise with response containing array of objects with signedUrl, path, and error or error\n\t*\n\t* @example Create Signed URLs\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrls(['folder/avatar1.png', 'folder/avatar2.png'], 60)\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [\n\t*     {\n\t*       \"error\": null,\n\t*       \"path\": \"folder/avatar1.png\",\n\t*       \"signedURL\": \"/object/sign/avatars/folder/avatar1.png?token=<TOKEN>\",\n\t*       \"signedUrl\": \"https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar1.png?token=<TOKEN>\"\n\t*     },\n\t*     {\n\t*       \"error\": null,\n\t*       \"path\": \"folder/avatar2.png\",\n\t*       \"signedURL\": \"/object/sign/avatars/folder/avatar2.png?token=<TOKEN>\",\n\t*       \"signedUrl\": \"https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar2.png?token=<TOKEN>\"\n\t*     }\n\t*   ],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createSignedUrls(paths, expiresIn, options) {\n        var _this9 = this;\n        return _this9.handleOperation(async ()=>{\n            const data = await post(_this9.fetch, `${_this9.url}/object/sign/${_this9.bucketId}`, {\n                expiresIn,\n                paths\n            }, {\n                headers: _this9.headers\n            });\n            const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? \"\" : options.download}` : \"\";\n            return data.map((datum)=>_objectSpread2(_objectSpread2({}, datum), {}, {\n                    signedUrl: datum.signedURL ? encodeURI(`${_this9.url}${datum.signedURL}${downloadQueryParam}`) : null\n                }));\n        });\n    }\n    /**\n\t* Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.\n\t*\n\t* @category File Buckets\n\t* @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.\n\t* @param options.transform Transform the asset before serving it to the client.\n\t* @param parameters Additional fetch parameters like signal for cancellation. Supports standard fetch options including cache control.\n\t* @returns BlobDownloadBuilder instance for downloading the file\n\t*\n\t* @example Download file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .download('folder/avatar1.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": <BLOB>,\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Download file with transformations\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .download('folder/avatar1.png', {\n\t*     transform: {\n\t*       width: 100,\n\t*       height: 100,\n\t*       quality: 80\n\t*     }\n\t*   })\n\t* ```\n\t*\n\t* @example Download with cache control (useful in Edge Functions)\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .download('folder/avatar1.png', {}, { cache: 'no-store' })\n\t* ```\n\t*\n\t* @example Download with abort signal\n\t* ```js\n\t* const controller = new AbortController()\n\t* setTimeout(() => controller.abort(), 5000)\n\t*\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .download('folder/avatar1.png', {}, { signal: controller.signal })\n\t* ```\n\t*/ download(path, options, parameters) {\n        const renderPath = typeof (options === null || options === void 0 ? void 0 : options.transform) !== \"undefined\" ? \"render/image/authenticated\" : \"object\";\n        const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});\n        const queryString = transformationQuery ? `?${transformationQuery}` : \"\";\n        const _path = this._getFinalPath(path);\n        const downloadFn = ()=>get(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {\n                headers: this.headers,\n                noResolveJson: true\n            }, parameters);\n        return new BlobDownloadBuilder(downloadFn, this.shouldThrowOnError);\n    }\n    /**\n\t* Retrieves the details of an existing file.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. For example `folder/image.png`.\n\t* @returns Promise with response containing file metadata or error\n\t*\n\t* @example Get file info\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .info('folder/avatar1.png')\n\t* ```\n\t*/ async info(path) {\n        var _this10 = this;\n        const _path = _this10._getFinalPath(path);\n        return _this10.handleOperation(async ()=>{\n            return recursiveToCamel(await get(_this10.fetch, `${_this10.url}/object/info/${_path}`, {\n                headers: _this10.headers\n            }));\n        });\n    }\n    /**\n\t* Checks the existence of a file.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. For example `folder/image.png`.\n\t* @returns Promise with response containing boolean indicating file existence or error\n\t*\n\t* @example Check file existence\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .exists('folder/avatar1.png')\n\t* ```\n\t*/ async exists(path) {\n        var _this11 = this;\n        const _path = _this11._getFinalPath(path);\n        try {\n            await head(_this11.fetch, `${_this11.url}/object/${_path}`, {\n                headers: _this11.headers\n            });\n            return {\n                data: true,\n                error: null\n            };\n        } catch (error) {\n            if (_this11.shouldThrowOnError) throw error;\n            if (isStorageError(error) && error instanceof StorageUnknownError) {\n                const originalError = error.originalError;\n                if ([\n                    400,\n                    404\n                ].includes(originalError === null || originalError === void 0 ? void 0 : originalError.status)) return {\n                    data: false,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n\t* A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.\n\t* This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.\n\t*\n\t* @category File Buckets\n\t* @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.\n\t* @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n\t* @param options.transform Transform the asset before serving it to the client.\n\t* @returns Object with public URL\n\t*\n\t* @example Returns the URL for an asset in a public bucket\n\t* ```js\n\t* const { data } = supabase\n\t*   .storage\n\t*   .from('public-bucket')\n\t*   .getPublicUrl('folder/avatar1.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"publicUrl\": \"https://example.supabase.co/storage/v1/object/public/public-bucket/folder/avatar1.png\"\n\t*   }\n\t* }\n\t* ```\n\t*\n\t* @example Returns the URL for an asset in a public bucket with transformations\n\t* ```js\n\t* const { data } = supabase\n\t*   .storage\n\t*   .from('public-bucket')\n\t*   .getPublicUrl('folder/avatar1.png', {\n\t*     transform: {\n\t*       width: 100,\n\t*       height: 100,\n\t*     }\n\t*   })\n\t* ```\n\t*\n\t* @example Returns the URL which triggers the download of an asset in a public bucket\n\t* ```js\n\t* const { data } = supabase\n\t*   .storage\n\t*   .from('public-bucket')\n\t*   .getPublicUrl('folder/avatar1.png', {\n\t*     download: true,\n\t*   })\n\t* ```\n\t*/ getPublicUrl(path, options) {\n        const _path = this._getFinalPath(path);\n        const _queryString = [];\n        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `download=${options.download === true ? \"\" : options.download}` : \"\";\n        if (downloadQueryParam !== \"\") _queryString.push(downloadQueryParam);\n        const renderPath = typeof (options === null || options === void 0 ? void 0 : options.transform) !== \"undefined\" ? \"render/image\" : \"object\";\n        const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});\n        if (transformationQuery !== \"\") _queryString.push(transformationQuery);\n        let queryString = _queryString.join(\"&\");\n        if (queryString !== \"\") queryString = `?${queryString}`;\n        return {\n            data: {\n                publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`)\n            }\n        };\n    }\n    /**\n\t* Deletes files within the same bucket\n\t*\n\t* @category File Buckets\n\t* @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].\n\t* @returns Promise with response containing array of deleted file objects or error\n\t*\n\t* @example Delete file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .remove(['folder/avatar1.png'])\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async remove(paths) {\n        var _this12 = this;\n        return _this12.handleOperation(async ()=>{\n            return await remove(_this12.fetch, `${_this12.url}/object/${_this12.bucketId}`, {\n                prefixes: paths\n            }, {\n                headers: _this12.headers\n            });\n        });\n    }\n    /**\n\t* Get file metadata\n\t* @param id the file id to retrieve metadata\n\t*/ /**\n\t* Update file metadata\n\t* @param id the file id to update metadata\n\t* @param meta the new file metadata\n\t*/ /**\n\t* Lists all the files and folders within a path of the bucket.\n\t*\n\t* @category File Buckets\n\t* @param path The folder path.\n\t* @param options Search options including limit (defaults to 100), offset, sortBy, and search\n\t* @param parameters Optional fetch parameters including signal for cancellation\n\t* @returns Promise with response containing array of files or error\n\t*\n\t* @example List files in a bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .list('folder', {\n\t*     limit: 100,\n\t*     offset: 0,\n\t*     sortBy: { column: 'name', order: 'asc' },\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [\n\t*     {\n\t*       \"name\": \"avatar1.png\",\n\t*       \"id\": \"e668cf7f-821b-4a2f-9dce-7dfa5dd1cfd2\",\n\t*       \"updated_at\": \"2024-05-22T23:06:05.580Z\",\n\t*       \"created_at\": \"2024-05-22T23:04:34.443Z\",\n\t*       \"last_accessed_at\": \"2024-05-22T23:04:34.443Z\",\n\t*       \"metadata\": {\n\t*         \"eTag\": \"\\\"c5e8c553235d9af30ef4f6e280790b92\\\"\",\n\t*         \"size\": 32175,\n\t*         \"mimetype\": \"image/png\",\n\t*         \"cacheControl\": \"max-age=3600\",\n\t*         \"lastModified\": \"2024-05-22T23:06:05.574Z\",\n\t*         \"contentLength\": 32175,\n\t*         \"httpStatusCode\": 200\n\t*       }\n\t*     }\n\t*   ],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Search files in a bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .list('folder', {\n\t*     limit: 100,\n\t*     offset: 0,\n\t*     sortBy: { column: 'name', order: 'asc' },\n\t*     search: 'jon'\n\t*   })\n\t* ```\n\t*/ async list(path, options, parameters) {\n        var _this13 = this;\n        return _this13.handleOperation(async ()=>{\n            const body = _objectSpread2(_objectSpread2(_objectSpread2({}, DEFAULT_SEARCH_OPTIONS), options), {}, {\n                prefix: path || \"\"\n            });\n            return await post(_this13.fetch, `${_this13.url}/object/list/${_this13.bucketId}`, body, {\n                headers: _this13.headers\n            }, parameters);\n        });\n    }\n    /**\n\t* @experimental this method signature might change in the future\n\t*\n\t* @category File Buckets\n\t* @param options search options\n\t* @param parameters\n\t*/ async listV2(options, parameters) {\n        var _this14 = this;\n        return _this14.handleOperation(async ()=>{\n            const body = _objectSpread2({}, options);\n            return await post(_this14.fetch, `${_this14.url}/object/list-v2/${_this14.bucketId}`, body, {\n                headers: _this14.headers\n            }, parameters);\n        });\n    }\n    encodeMetadata(metadata) {\n        return JSON.stringify(metadata);\n    }\n    toBase64(data) {\n        if (typeof Buffer !== \"undefined\") return Buffer.from(data).toString(\"base64\");\n        return btoa(data);\n    }\n    _getFinalPath(path) {\n        return `${this.bucketId}/${path.replace(/^\\/+/, \"\")}`;\n    }\n    _removeEmptyFolders(path) {\n        return path.replace(/^\\/|\\/$/g, \"\").replace(/\\/+/g, \"/\");\n    }\n    transformOptsToQueryString(transform) {\n        const params = [];\n        if (transform.width) params.push(`width=${transform.width}`);\n        if (transform.height) params.push(`height=${transform.height}`);\n        if (transform.resize) params.push(`resize=${transform.resize}`);\n        if (transform.format) params.push(`format=${transform.format}`);\n        if (transform.quality) params.push(`quality=${transform.quality}`);\n        return params.join(\"&\");\n    }\n};\n//#endregion\n//#region src/lib/version.ts\nconst version = \"2.97.0\";\n//#endregion\n//#region src/lib/constants.ts\nconst DEFAULT_HEADERS = {\n    \"X-Client-Info\": `storage-js/${version}`\n};\n//#endregion\n//#region src/packages/StorageBucketApi.ts\nvar StorageBucketApi = class extends BaseApiClient {\n    constructor(url, headers = {}, fetch$1, opts){\n        const baseUrl = new URL(url);\n        if (opts === null || opts === void 0 ? void 0 : opts.useNewHostname) {\n            if (/supabase\\.(co|in|red)$/.test(baseUrl.hostname) && !baseUrl.hostname.includes(\"storage.supabase.\")) baseUrl.hostname = baseUrl.hostname.replace(\"supabase.\", \"storage.supabase.\");\n        }\n        const finalUrl = baseUrl.href.replace(/\\/$/, \"\");\n        const finalHeaders = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), headers);\n        super(finalUrl, finalHeaders, fetch$1, \"storage\");\n    }\n    /**\n\t* Retrieves the details of all Storage buckets within an existing project.\n\t*\n\t* @category File Buckets\n\t* @param options Query parameters for listing buckets\n\t* @param options.limit Maximum number of buckets to return\n\t* @param options.offset Number of buckets to skip\n\t* @param options.sortColumn Column to sort by ('id', 'name', 'created_at', 'updated_at')\n\t* @param options.sortOrder Sort order ('asc' or 'desc')\n\t* @param options.search Search term to filter bucket names\n\t* @returns Promise with response containing array of buckets or error\n\t*\n\t* @example List buckets\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .listBuckets()\n\t* ```\n\t*\n\t* @example List buckets with options\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .listBuckets({\n\t*     limit: 10,\n\t*     offset: 0,\n\t*     sortColumn: 'created_at',\n\t*     sortOrder: 'desc',\n\t*     search: 'prod'\n\t*   })\n\t* ```\n\t*/ async listBuckets(options) {\n        var _this = this;\n        return _this.handleOperation(async ()=>{\n            const queryString = _this.listBucketOptionsToQueryString(options);\n            return await get(_this.fetch, `${_this.url}/bucket${queryString}`, {\n                headers: _this.headers\n            });\n        });\n    }\n    /**\n\t* Retrieves the details of an existing Storage bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The unique identifier of the bucket you would like to retrieve.\n\t* @returns Promise with response containing bucket details or error\n\t*\n\t* @example Get bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .getBucket('avatars')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"id\": \"avatars\",\n\t*     \"name\": \"avatars\",\n\t*     \"owner\": \"\",\n\t*     \"public\": false,\n\t*     \"file_size_limit\": 1024,\n\t*     \"allowed_mime_types\": [\n\t*       \"image/png\"\n\t*     ],\n\t*     \"created_at\": \"2024-05-22T22:26:05.100Z\",\n\t*     \"updated_at\": \"2024-05-22T22:26:05.100Z\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async getBucket(id) {\n        var _this2 = this;\n        return _this2.handleOperation(async ()=>{\n            return await get(_this2.fetch, `${_this2.url}/bucket/${id}`, {\n                headers: _this2.headers\n            });\n        });\n    }\n    /**\n\t* Creates a new Storage bucket\n\t*\n\t* @category File Buckets\n\t* @param id A unique identifier for the bucket you are creating.\n\t* @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.\n\t* @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n\t* The global file size limit takes precedence over this value.\n\t* The default value is null, which doesn't set a per bucket file size limit.\n\t* @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n\t* The default value is null, which allows files with all mime types to be uploaded.\n\t* Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n\t* @param options.type (private-beta) specifies the bucket type. see `BucketType` for more details.\n\t*   - default bucket type is `STANDARD`\n\t* @returns Promise with response containing newly created bucket name or error\n\t*\n\t* @example Create bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .createBucket('avatars', {\n\t*     public: false,\n\t*     allowedMimeTypes: ['image/png'],\n\t*     fileSizeLimit: 1024\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"name\": \"avatars\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createBucket(id, options = {\n        public: false\n    }) {\n        var _this3 = this;\n        return _this3.handleOperation(async ()=>{\n            return await post(_this3.fetch, `${_this3.url}/bucket`, {\n                id,\n                name: id,\n                type: options.type,\n                public: options.public,\n                file_size_limit: options.fileSizeLimit,\n                allowed_mime_types: options.allowedMimeTypes\n            }, {\n                headers: _this3.headers\n            });\n        });\n    }\n    /**\n\t* Updates a Storage bucket\n\t*\n\t* @category File Buckets\n\t* @param id A unique identifier for the bucket you are updating.\n\t* @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.\n\t* @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n\t* The global file size limit takes precedence over this value.\n\t* The default value is null, which doesn't set a per bucket file size limit.\n\t* @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n\t* The default value is null, which allows files with all mime types to be uploaded.\n\t* Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n\t* @returns Promise with response containing success message or error\n\t*\n\t* @example Update bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .updateBucket('avatars', {\n\t*     public: false,\n\t*     allowedMimeTypes: ['image/png'],\n\t*     fileSizeLimit: 1024\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully updated\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async updateBucket(id, options) {\n        var _this4 = this;\n        return _this4.handleOperation(async ()=>{\n            return await put(_this4.fetch, `${_this4.url}/bucket/${id}`, {\n                id,\n                name: id,\n                public: options.public,\n                file_size_limit: options.fileSizeLimit,\n                allowed_mime_types: options.allowedMimeTypes\n            }, {\n                headers: _this4.headers\n            });\n        });\n    }\n    /**\n\t* Removes all objects inside a single bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The unique identifier of the bucket you would like to empty.\n\t* @returns Promise with success message or error\n\t*\n\t* @example Empty bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .emptyBucket('avatars')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully emptied\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async emptyBucket(id) {\n        var _this5 = this;\n        return _this5.handleOperation(async ()=>{\n            return await post(_this5.fetch, `${_this5.url}/bucket/${id}/empty`, {}, {\n                headers: _this5.headers\n            });\n        });\n    }\n    /**\n\t* Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.\n\t* You must first `empty()` the bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The unique identifier of the bucket you would like to delete.\n\t* @returns Promise with success message or error\n\t*\n\t* @example Delete bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .deleteBucket('avatars')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully deleted\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async deleteBucket(id) {\n        var _this6 = this;\n        return _this6.handleOperation(async ()=>{\n            return await remove(_this6.fetch, `${_this6.url}/bucket/${id}`, {}, {\n                headers: _this6.headers\n            });\n        });\n    }\n    listBucketOptionsToQueryString(options) {\n        const params = {};\n        if (options) {\n            if (\"limit\" in options) params.limit = String(options.limit);\n            if (\"offset\" in options) params.offset = String(options.offset);\n            if (options.search) params.search = options.search;\n            if (options.sortColumn) params.sortColumn = options.sortColumn;\n            if (options.sortOrder) params.sortOrder = options.sortOrder;\n        }\n        return Object.keys(params).length > 0 ? \"?\" + new URLSearchParams(params).toString() : \"\";\n    }\n};\n//#endregion\n//#region src/packages/StorageAnalyticsClient.ts\n/**\n* Client class for managing Analytics Buckets using Iceberg tables\n* Provides methods for creating, listing, and deleting analytics buckets\n*/ var StorageAnalyticsClient = class extends BaseApiClient {\n    /**\n\t* @alpha\n\t*\n\t* Creates a new StorageAnalyticsClient instance\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param url - The base URL for the storage API\n\t* @param headers - HTTP headers to include in requests\n\t* @param fetch - Optional custom fetch implementation\n\t*\n\t* @example\n\t* ```typescript\n\t* const client = new StorageAnalyticsClient(url, headers)\n\t* ```\n\t*/ constructor(url, headers = {}, fetch$1){\n        const finalUrl = url.replace(/\\/$/, \"\");\n        const finalHeaders = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), headers);\n        super(finalUrl, finalHeaders, fetch$1, \"storage\");\n    }\n    /**\n\t* @alpha\n\t*\n\t* Creates a new analytics bucket using Iceberg tables\n\t* Analytics buckets are optimized for analytical queries and data processing\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param name A unique name for the bucket you are creating\n\t* @returns Promise with response containing newly created analytics bucket or error\n\t*\n\t* @example Create analytics bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .createBucket('analytics-data')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"name\": \"analytics-data\",\n\t*     \"type\": \"ANALYTICS\",\n\t*     \"format\": \"iceberg\",\n\t*     \"created_at\": \"2024-05-22T22:26:05.100Z\",\n\t*     \"updated_at\": \"2024-05-22T22:26:05.100Z\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createBucket(name) {\n        var _this = this;\n        return _this.handleOperation(async ()=>{\n            return await post(_this.fetch, `${_this.url}/bucket`, {\n                name\n            }, {\n                headers: _this.headers\n            });\n        });\n    }\n    /**\n\t* @alpha\n\t*\n\t* Retrieves the details of all Analytics Storage buckets within an existing project\n\t* Only returns buckets of type 'ANALYTICS'\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param options Query parameters for listing buckets\n\t* @param options.limit Maximum number of buckets to return\n\t* @param options.offset Number of buckets to skip\n\t* @param options.sortColumn Column to sort by ('name', 'created_at', 'updated_at')\n\t* @param options.sortOrder Sort order ('asc' or 'desc')\n\t* @param options.search Search term to filter bucket names\n\t* @returns Promise with response containing array of analytics buckets or error\n\t*\n\t* @example List analytics buckets\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .listBuckets({\n\t*     limit: 10,\n\t*     offset: 0,\n\t*     sortColumn: 'created_at',\n\t*     sortOrder: 'desc'\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [\n\t*     {\n\t*       \"name\": \"analytics-data\",\n\t*       \"type\": \"ANALYTICS\",\n\t*       \"format\": \"iceberg\",\n\t*       \"created_at\": \"2024-05-22T22:26:05.100Z\",\n\t*       \"updated_at\": \"2024-05-22T22:26:05.100Z\"\n\t*     }\n\t*   ],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async listBuckets(options) {\n        var _this2 = this;\n        return _this2.handleOperation(async ()=>{\n            const queryParams = new URLSearchParams();\n            if ((options === null || options === void 0 ? void 0 : options.limit) !== void 0) queryParams.set(\"limit\", options.limit.toString());\n            if ((options === null || options === void 0 ? void 0 : options.offset) !== void 0) queryParams.set(\"offset\", options.offset.toString());\n            if (options === null || options === void 0 ? void 0 : options.sortColumn) queryParams.set(\"sortColumn\", options.sortColumn);\n            if (options === null || options === void 0 ? void 0 : options.sortOrder) queryParams.set(\"sortOrder\", options.sortOrder);\n            if (options === null || options === void 0 ? void 0 : options.search) queryParams.set(\"search\", options.search);\n            const queryString = queryParams.toString();\n            const url = queryString ? `${_this2.url}/bucket?${queryString}` : `${_this2.url}/bucket`;\n            return await get(_this2.fetch, url, {\n                headers: _this2.headers\n            });\n        });\n    }\n    /**\n\t* @alpha\n\t*\n\t* Deletes an existing analytics bucket\n\t* A bucket can't be deleted with existing objects inside it\n\t* You must first empty the bucket before deletion\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param bucketName The unique identifier of the bucket you would like to delete\n\t* @returns Promise with response containing success message or error\n\t*\n\t* @example Delete analytics bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .deleteBucket('analytics-data')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully deleted\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async deleteBucket(bucketName) {\n        var _this3 = this;\n        return _this3.handleOperation(async ()=>{\n            return await remove(_this3.fetch, `${_this3.url}/bucket/${bucketName}`, {}, {\n                headers: _this3.headers\n            });\n        });\n    }\n    /**\n\t* @alpha\n\t*\n\t* Get an Iceberg REST Catalog client configured for a specific analytics bucket\n\t* Use this to perform advanced table and namespace operations within the bucket\n\t* The returned client provides full access to the Apache Iceberg REST Catalog API\n\t* with the Supabase `{ data, error }` pattern for consistent error handling on all operations.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param bucketName - The name of the analytics bucket (warehouse) to connect to\n\t* @returns The wrapped Iceberg catalog client\n\t* @throws {StorageError} If the bucket name is invalid\n\t*\n\t* @example Get catalog and create table\n\t* ```js\n\t* // First, create an analytics bucket\n\t* const { data: bucket, error: bucketError } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .createBucket('analytics-data')\n\t*\n\t* // Get the Iceberg catalog for that bucket\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // Create a namespace\n\t* const { error: nsError } = await catalog.createNamespace({ namespace: ['default'] })\n\t*\n\t* // Create a table with schema\n\t* const { data: tableMetadata, error: tableError } = await catalog.createTable(\n\t*   { namespace: ['default'] },\n\t*   {\n\t*     name: 'events',\n\t*     schema: {\n\t*       type: 'struct',\n\t*       fields: [\n\t*         { id: 1, name: 'id', type: 'long', required: true },\n\t*         { id: 2, name: 'timestamp', type: 'timestamp', required: true },\n\t*         { id: 3, name: 'user_id', type: 'string', required: false }\n\t*       ],\n\t*       'schema-id': 0,\n\t*       'identifier-field-ids': [1]\n\t*     },\n\t*     'partition-spec': {\n\t*       'spec-id': 0,\n\t*       fields: []\n\t*     },\n\t*     'write-order': {\n\t*       'order-id': 0,\n\t*       fields: []\n\t*     },\n\t*     properties: {\n\t*       'write.format.default': 'parquet'\n\t*     }\n\t*   }\n\t* )\n\t* ```\n\t*\n\t* @example List tables in namespace\n\t* ```js\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // List all tables in the default namespace\n\t* const { data: tables, error: listError } = await catalog.listTables({ namespace: ['default'] })\n\t* if (listError) {\n\t*   if (listError.isNotFound()) {\n\t*     console.log('Namespace not found')\n\t*   }\n\t*   return\n\t* }\n\t* console.log(tables) // [{ namespace: ['default'], name: 'events' }]\n\t* ```\n\t*\n\t* @example Working with namespaces\n\t* ```js\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // List all namespaces\n\t* const { data: namespaces } = await catalog.listNamespaces()\n\t*\n\t* // Create namespace with properties\n\t* await catalog.createNamespace(\n\t*   { namespace: ['production'] },\n\t*   { properties: { owner: 'data-team', env: 'prod' } }\n\t* )\n\t* ```\n\t*\n\t* @example Cleanup operations\n\t* ```js\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // Drop table with purge option (removes all data)\n\t* const { error: dropError } = await catalog.dropTable(\n\t*   { namespace: ['default'], name: 'events' },\n\t*   { purge: true }\n\t* )\n\t*\n\t* if (dropError?.isNotFound()) {\n\t*   console.log('Table does not exist')\n\t* }\n\t*\n\t* // Drop namespace (must be empty)\n\t* await catalog.dropNamespace({ namespace: ['default'] })\n\t* ```\n\t*\n\t* @remarks\n\t* This method provides a bridge between Supabase's bucket management and the standard\n\t* Apache Iceberg REST Catalog API. The bucket name maps to the Iceberg warehouse parameter.\n\t* All authentication and configuration is handled automatically using your Supabase credentials.\n\t*\n\t* **Error Handling**: Invalid bucket names throw immediately. All catalog\n\t* operations return `{ data, error }` where errors are `IcebergError` instances from iceberg-js.\n\t* Use helper methods like `error.isNotFound()` or check `error.status` for specific error handling.\n\t* Use `.throwOnError()` on the analytics client if you prefer exceptions for catalog operations.\n\t*\n\t* **Cleanup Operations**: When using `dropTable`, the `purge: true` option permanently\n\t* deletes all table data. Without it, the table is marked as deleted but data remains.\n\t*\n\t* **Library Dependency**: The returned catalog wraps `IcebergRestCatalog` from iceberg-js.\n\t* For complete API documentation and advanced usage, refer to the\n\t* [iceberg-js documentation](https://supabase.github.io/iceberg-js/).\n\t*/ from(bucketName) {\n        var _this4 = this;\n        if (!isValidBucketName(bucketName)) throw new StorageError(\"Invalid bucket name: File, folder, and bucket names must follow AWS object key naming guidelines and should avoid the use of any other characters.\");\n        const catalog = new iceberg_js__WEBPACK_IMPORTED_MODULE_0__.IcebergRestCatalog({\n            baseUrl: this.url,\n            catalogName: bucketName,\n            auth: {\n                type: \"custom\",\n                getHeaders: async ()=>_this4.headers\n            },\n            fetch: this.fetch\n        });\n        const shouldThrowOnError = this.shouldThrowOnError;\n        return new Proxy(catalog, {\n            get (target, prop) {\n                const value = target[prop];\n                if (typeof value !== \"function\") return value;\n                return async (...args)=>{\n                    try {\n                        return {\n                            data: await value.apply(target, args),\n                            error: null\n                        };\n                    } catch (error) {\n                        if (shouldThrowOnError) throw error;\n                        return {\n                            data: null,\n                            error\n                        };\n                    }\n                };\n            }\n        });\n    }\n};\n//#endregion\n//#region src/packages/VectorIndexApi.ts\n/**\n* @hidden\n* Base implementation for vector index operations.\n* Use {@link VectorBucketScope} via `supabase.storage.vectors.from('bucket')` instead.\n*/ var VectorIndexApi = class extends BaseApiClient {\n    /** Creates a new VectorIndexApi instance */ constructor(url, headers = {}, fetch$1){\n        const finalUrl = url.replace(/\\/$/, \"\");\n        const finalHeaders = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), {}, {\n            \"Content-Type\": \"application/json\"\n        }, headers);\n        super(finalUrl, finalHeaders, fetch$1, \"vectors\");\n    }\n    /** Creates a new vector index within a bucket */ async createIndex(options) {\n        var _this = this;\n        return _this.handleOperation(async ()=>{\n            return await vectorsApi.post(_this.fetch, `${_this.url}/CreateIndex`, options, {\n                headers: _this.headers\n            }) || {};\n        });\n    }\n    /** Retrieves metadata for a specific vector index */ async getIndex(vectorBucketName, indexName) {\n        var _this2 = this;\n        return _this2.handleOperation(async ()=>{\n            return await vectorsApi.post(_this2.fetch, `${_this2.url}/GetIndex`, {\n                vectorBucketName,\n                indexName\n            }, {\n                headers: _this2.headers\n            });\n        });\n    }\n    /** Lists vector indexes within a bucket with optional filtering and pagination */ async listIndexes(options) {\n        var _this3 = this;\n        return _this3.handleOperation(async ()=>{\n            return await vectorsApi.post(_this3.fetch, `${_this3.url}/ListIndexes`, options, {\n                headers: _this3.headers\n            });\n        });\n    }\n    /** Deletes a vector index and all its data */ async deleteIndex(vectorBucketName, indexName) {\n        var _this4 = this;\n        return _this4.handleOperation(async ()=>{\n            return await vectorsApi.post(_this4.fetch, `${_this4.url}/DeleteIndex`, {\n                vectorBucketName,\n                indexName\n            }, {\n                headers: _this4.headers\n            }) || {};\n        });\n    }\n};\n//#endregion\n//#region src/packages/VectorDataApi.ts\n/**\n* @hidden\n* Base implementation for vector data operations.\n* Use {@link VectorIndexScope} via `supabase.storage.vectors.from('bucket').index('idx')` instead.\n*/ var VectorDataApi = class extends BaseApiClient {\n    /** Creates a new VectorDataApi instance */ constructor(url, headers = {}, fetch$1){\n        const finalUrl = url.replace(/\\/$/, \"\");\n        const finalHeaders = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), {}, {\n            \"Content-Type\": \"application/json\"\n        }, headers);\n        super(finalUrl, finalHeaders, fetch$1, \"vectors\");\n    }\n    /** Inserts or updates vectors in batch (1-500 per request) */ async putVectors(options) {\n        var _this = this;\n        if (options.vectors.length < 1 || options.vectors.length > 500) throw new Error(\"Vector batch size must be between 1 and 500 items\");\n        return _this.handleOperation(async ()=>{\n            return await vectorsApi.post(_this.fetch, `${_this.url}/PutVectors`, options, {\n                headers: _this.headers\n            }) || {};\n        });\n    }\n    /** Retrieves vectors by their keys in batch */ async getVectors(options) {\n        var _this2 = this;\n        return _this2.handleOperation(async ()=>{\n            return await vectorsApi.post(_this2.fetch, `${_this2.url}/GetVectors`, options, {\n                headers: _this2.headers\n            });\n        });\n    }\n    /** Lists vectors in an index with pagination */ async listVectors(options) {\n        var _this3 = this;\n        if (options.segmentCount !== void 0) {\n            if (options.segmentCount < 1 || options.segmentCount > 16) throw new Error(\"segmentCount must be between 1 and 16\");\n            if (options.segmentIndex !== void 0) {\n                if (options.segmentIndex < 0 || options.segmentIndex >= options.segmentCount) throw new Error(`segmentIndex must be between 0 and ${options.segmentCount - 1}`);\n            }\n        }\n        return _this3.handleOperation(async ()=>{\n            return await vectorsApi.post(_this3.fetch, `${_this3.url}/ListVectors`, options, {\n                headers: _this3.headers\n            });\n        });\n    }\n    /** Queries for similar vectors using approximate nearest neighbor search */ async queryVectors(options) {\n        var _this4 = this;\n        return _this4.handleOperation(async ()=>{\n            return await vectorsApi.post(_this4.fetch, `${_this4.url}/QueryVectors`, options, {\n                headers: _this4.headers\n            });\n        });\n    }\n    /** Deletes vectors by their keys in batch (1-500 per request) */ async deleteVectors(options) {\n        var _this5 = this;\n        if (options.keys.length < 1 || options.keys.length > 500) throw new Error(\"Keys batch size must be between 1 and 500 items\");\n        return _this5.handleOperation(async ()=>{\n            return await vectorsApi.post(_this5.fetch, `${_this5.url}/DeleteVectors`, options, {\n                headers: _this5.headers\n            }) || {};\n        });\n    }\n};\n//#endregion\n//#region src/packages/VectorBucketApi.ts\n/**\n* @hidden\n* Base implementation for vector bucket operations.\n* Use {@link StorageVectorsClient} via `supabase.storage.vectors` instead.\n*/ var VectorBucketApi = class extends BaseApiClient {\n    /** Creates a new VectorBucketApi instance */ constructor(url, headers = {}, fetch$1){\n        const finalUrl = url.replace(/\\/$/, \"\");\n        const finalHeaders = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), {}, {\n            \"Content-Type\": \"application/json\"\n        }, headers);\n        super(finalUrl, finalHeaders, fetch$1, \"vectors\");\n    }\n    /** Creates a new vector bucket */ async createBucket(vectorBucketName) {\n        var _this = this;\n        return _this.handleOperation(async ()=>{\n            return await vectorsApi.post(_this.fetch, `${_this.url}/CreateVectorBucket`, {\n                vectorBucketName\n            }, {\n                headers: _this.headers\n            }) || {};\n        });\n    }\n    /** Retrieves metadata for a specific vector bucket */ async getBucket(vectorBucketName) {\n        var _this2 = this;\n        return _this2.handleOperation(async ()=>{\n            return await vectorsApi.post(_this2.fetch, `${_this2.url}/GetVectorBucket`, {\n                vectorBucketName\n            }, {\n                headers: _this2.headers\n            });\n        });\n    }\n    /** Lists vector buckets with optional filtering and pagination */ async listBuckets(options = {}) {\n        var _this3 = this;\n        return _this3.handleOperation(async ()=>{\n            return await vectorsApi.post(_this3.fetch, `${_this3.url}/ListVectorBuckets`, options, {\n                headers: _this3.headers\n            });\n        });\n    }\n    /** Deletes a vector bucket (must be empty first) */ async deleteBucket(vectorBucketName) {\n        var _this4 = this;\n        return _this4.handleOperation(async ()=>{\n            return await vectorsApi.post(_this4.fetch, `${_this4.url}/DeleteVectorBucket`, {\n                vectorBucketName\n            }, {\n                headers: _this4.headers\n            }) || {};\n        });\n    }\n};\n//#endregion\n//#region src/packages/StorageVectorsClient.ts\n/**\n*\n* @alpha\n*\n* Main client for interacting with S3 Vectors API\n* Provides access to bucket, index, and vector data operations\n*\n* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n*\n* **Usage Patterns:**\n*\n* ```typescript\n* const { data, error } = await supabase\n*  .storage\n*  .vectors\n*  .createBucket('embeddings-prod')\n*\n* // Access index operations via buckets\n* const bucket = supabase.storage.vectors.from('embeddings-prod')\n* await bucket.createIndex({\n*   indexName: 'documents',\n*   dataType: 'float32',\n*   dimension: 1536,\n*   distanceMetric: 'cosine'\n* })\n*\n* // Access vector operations via index\n* const index = bucket.index('documents')\n* await index.putVectors({\n*   vectors: [\n*     { key: 'doc-1', data: { float32: [...] }, metadata: { title: 'Intro' } }\n*   ]\n* })\n*\n* // Query similar vectors\n* const { data } = await index.queryVectors({\n*   queryVector: { float32: [...] },\n*   topK: 5,\n*   returnDistance: true\n* })\n* ```\n*/ var StorageVectorsClient = class extends VectorBucketApi {\n    /**\n\t* @alpha\n\t*\n\t* Creates a StorageVectorsClient that can manage buckets, indexes, and vectors.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param url - Base URL of the Storage Vectors REST API.\n\t* @param options.headers - Optional headers (for example `Authorization`) applied to every request.\n\t* @param options.fetch - Optional custom `fetch` implementation for non-browser runtimes.\n\t*\n\t* @example\n\t* ```typescript\n\t* const client = new StorageVectorsClient(url, options)\n\t* ```\n\t*/ constructor(url, options = {}){\n        super(url, options.headers || {}, options.fetch);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access operations for a specific vector bucket\n\t* Returns a scoped client for index and vector operations within the bucket\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Name of the vector bucket\n\t* @returns Bucket-scoped client with index and vector operations\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* ```\n\t*/ from(vectorBucketName) {\n        return new VectorBucketScope(this.url, this.headers, vectorBucketName, this.fetch);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Creates a new vector bucket\n\t* Vector buckets are containers for vector indexes and their data\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Unique name for the vector bucket\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .createBucket('embeddings-prod')\n\t* ```\n\t*/ async createBucket(vectorBucketName) {\n        var _superprop_getCreateBucket = ()=>super.createBucket, _this = this;\n        return _superprop_getCreateBucket().call(_this, vectorBucketName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Retrieves metadata for a specific vector bucket\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Name of the vector bucket\n\t* @returns Promise with bucket metadata or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .getBucket('embeddings-prod')\n\t*\n\t* console.log('Bucket created:', data?.vectorBucket.creationTime)\n\t* ```\n\t*/ async getBucket(vectorBucketName) {\n        var _superprop_getGetBucket = ()=>super.getBucket, _this2 = this;\n        return _superprop_getGetBucket().call(_this2, vectorBucketName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Lists all vector buckets with optional filtering and pagination\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Optional filters (prefix, maxResults, nextToken)\n\t* @returns Promise with list of buckets or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .listBuckets({ prefix: 'embeddings-' })\n\t*\n\t* data?.vectorBuckets.forEach(bucket => {\n\t*   console.log(bucket.vectorBucketName)\n\t* })\n\t* ```\n\t*/ async listBuckets(options = {}) {\n        var _superprop_getListBuckets = ()=>super.listBuckets, _this3 = this;\n        return _superprop_getListBuckets().call(_this3, options);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Deletes a vector bucket (bucket must be empty)\n\t* All indexes must be deleted before deleting the bucket\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Name of the vector bucket to delete\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .deleteBucket('embeddings-old')\n\t* ```\n\t*/ async deleteBucket(vectorBucketName) {\n        var _superprop_getDeleteBucket = ()=>super.deleteBucket, _this4 = this;\n        return _superprop_getDeleteBucket().call(_this4, vectorBucketName);\n    }\n};\n/**\n*\n* @alpha\n*\n* Scoped client for operations within a specific vector bucket\n* Provides index management and access to vector operations\n*\n* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n*/ var VectorBucketScope = class extends VectorIndexApi {\n    /**\n\t* @alpha\n\t*\n\t* Creates a helper that automatically scopes all index operations to the provided bucket.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* ```\n\t*/ constructor(url, headers, vectorBucketName, fetch$1){\n        super(url, headers, fetch$1);\n        this.vectorBucketName = vectorBucketName;\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Creates a new vector index in this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Index configuration (vectorBucketName is automatically set)\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* await bucket.createIndex({\n\t*   indexName: 'documents-openai',\n\t*   dataType: 'float32',\n\t*   dimension: 1536,\n\t*   distanceMetric: 'cosine',\n\t*   metadataConfiguration: {\n\t*     nonFilterableMetadataKeys: ['raw_text']\n\t*   }\n\t* })\n\t* ```\n\t*/ async createIndex(options) {\n        var _superprop_getCreateIndex = ()=>super.createIndex, _this5 = this;\n        return _superprop_getCreateIndex().call(_this5, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this5.vectorBucketName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Lists indexes in this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Listing options (vectorBucketName is automatically set)\n\t* @returns Promise with response containing indexes array and pagination token or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* const { data } = await bucket.listIndexes({ prefix: 'documents-' })\n\t* ```\n\t*/ async listIndexes(options = {}) {\n        var _superprop_getListIndexes = ()=>super.listIndexes, _this6 = this;\n        return _superprop_getListIndexes().call(_this6, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this6.vectorBucketName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Retrieves metadata for a specific index in this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param indexName - Name of the index to retrieve\n\t* @returns Promise with index metadata or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* const { data } = await bucket.getIndex('documents-openai')\n\t* console.log('Dimension:', data?.index.dimension)\n\t* ```\n\t*/ async getIndex(indexName) {\n        var _superprop_getGetIndex = ()=>super.getIndex, _this7 = this;\n        return _superprop_getGetIndex().call(_this7, _this7.vectorBucketName, indexName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Deletes an index from this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param indexName - Name of the index to delete\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* await bucket.deleteIndex('old-index')\n\t* ```\n\t*/ async deleteIndex(indexName) {\n        var _superprop_getDeleteIndex = ()=>super.deleteIndex, _this8 = this;\n        return _superprop_getDeleteIndex().call(_this8, _this8.vectorBucketName, indexName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access operations for a specific index within this bucket\n\t* Returns a scoped client for vector data operations\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param indexName - Name of the index\n\t* @returns Index-scoped client with vector data operations\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t*\n\t* // Insert vectors\n\t* await index.putVectors({\n\t*   vectors: [\n\t*     { key: 'doc-1', data: { float32: [...] }, metadata: { title: 'Intro' } }\n\t*   ]\n\t* })\n\t*\n\t* // Query similar vectors\n\t* const { data } = await index.queryVectors({\n\t*   queryVector: { float32: [...] },\n\t*   topK: 5\n\t* })\n\t* ```\n\t*/ index(indexName) {\n        return new VectorIndexScope(this.url, this.headers, this.vectorBucketName, indexName, this.fetch);\n    }\n};\n/**\n*\n* @alpha\n*\n* Scoped client for operations within a specific vector index\n* Provides vector data operations (put, get, list, query, delete)\n*\n* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n*/ var VectorIndexScope = class extends VectorDataApi {\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Creates a helper that automatically scopes all vector operations to the provided bucket/index names.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* ```\n\t*/ constructor(url, headers, vectorBucketName, indexName, fetch$1){\n        super(url, headers, fetch$1);\n        this.vectorBucketName = vectorBucketName;\n        this.indexName = indexName;\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Inserts or updates vectors in this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Vector insertion options (bucket and index names automatically set)\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* await index.putVectors({\n\t*   vectors: [\n\t*     {\n\t*       key: 'doc-1',\n\t*       data: { float32: [0.1, 0.2, ...] },\n\t*       metadata: { title: 'Introduction', page: 1 }\n\t*     }\n\t*   ]\n\t* })\n\t* ```\n\t*/ async putVectors(options) {\n        var _superprop_getPutVectors = ()=>super.putVectors, _this9 = this;\n        return _superprop_getPutVectors().call(_this9, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this9.vectorBucketName,\n            indexName: _this9.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Retrieves vectors by keys from this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Vector retrieval options (bucket and index names automatically set)\n\t* @returns Promise with response containing vectors array or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* const { data } = await index.getVectors({\n\t*   keys: ['doc-1', 'doc-2'],\n\t*   returnMetadata: true\n\t* })\n\t* ```\n\t*/ async getVectors(options) {\n        var _superprop_getGetVectors = ()=>super.getVectors, _this10 = this;\n        return _superprop_getGetVectors().call(_this10, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this10.vectorBucketName,\n            indexName: _this10.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Lists vectors in this index with pagination\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Listing options (bucket and index names automatically set)\n\t* @returns Promise with response containing vectors array and pagination token or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* const { data } = await index.listVectors({\n\t*   maxResults: 500,\n\t*   returnMetadata: true\n\t* })\n\t* ```\n\t*/ async listVectors(options = {}) {\n        var _superprop_getListVectors = ()=>super.listVectors, _this11 = this;\n        return _superprop_getListVectors().call(_this11, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this11.vectorBucketName,\n            indexName: _this11.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Queries for similar vectors in this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Query options (bucket and index names automatically set)\n\t* @returns Promise with response containing matches array of similar vectors ordered by distance or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* const { data } = await index.queryVectors({\n\t*   queryVector: { float32: [0.1, 0.2, ...] },\n\t*   topK: 5,\n\t*   filter: { category: 'technical' },\n\t*   returnDistance: true,\n\t*   returnMetadata: true\n\t* })\n\t* ```\n\t*/ async queryVectors(options) {\n        var _superprop_getQueryVectors = ()=>super.queryVectors, _this12 = this;\n        return _superprop_getQueryVectors().call(_this12, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this12.vectorBucketName,\n            indexName: _this12.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Deletes vectors by keys from this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Deletion options (bucket and index names automatically set)\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* await index.deleteVectors({\n\t*   keys: ['doc-1', 'doc-2', 'doc-3']\n\t* })\n\t* ```\n\t*/ async deleteVectors(options) {\n        var _superprop_getDeleteVectors = ()=>super.deleteVectors, _this13 = this;\n        return _superprop_getDeleteVectors().call(_this13, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this13.vectorBucketName,\n            indexName: _this13.indexName\n        }));\n    }\n};\n//#endregion\n//#region src/StorageClient.ts\nvar StorageClient = class extends StorageBucketApi {\n    /**\n\t* Creates a client for Storage buckets, files, analytics, and vectors.\n\t*\n\t* @category File Buckets\n\t* @example\n\t* ```ts\n\t* import { StorageClient } from '@supabase/storage-js'\n\t*\n\t* const storage = new StorageClient('https://xyzcompany.supabase.co/storage/v1', {\n\t*   apikey: 'public-anon-key',\n\t* })\n\t* const avatars = storage.from('avatars')\n\t* ```\n\t*/ constructor(url, headers = {}, fetch$1, opts){\n        super(url, headers, fetch$1, opts);\n    }\n    /**\n\t* Perform file operation in a bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The bucket id to operate on.\n\t*\n\t* @example\n\t* ```typescript\n\t* const avatars = supabase.storage.from('avatars')\n\t* ```\n\t*/ from(id) {\n        return new StorageFileApi(this.url, this.headers, id, this.fetch);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access vector storage operations.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @returns A StorageVectorsClient instance configured with the current storage settings.\n\t*/ get vectors() {\n        return new StorageVectorsClient(this.url + \"/vector\", {\n            headers: this.headers,\n            fetch: this.fetch\n        });\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access analytics storage operations using Iceberg tables.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @returns A StorageAnalyticsClient instance configured with the current storage settings.\n\t*/ get analytics() {\n        return new StorageAnalyticsClient(this.url + \"/iceberg\", this.headers, this.fetch);\n    }\n};\n//#endregion\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdEO0FBRWhELGtDQUFrQztBQUNsQzs7O0FBR0EsR0FDQSxJQUFJQyxlQUFlLGNBQWNDO0lBQ2hDQyxZQUFZQyxPQUFPLEVBQUVDLFlBQVksU0FBUyxFQUFFQyxNQUFNLEVBQUVDLFVBQVUsQ0FBRTtRQUMvRCxLQUFLLENBQUNIO1FBQ04sSUFBSSxDQUFDSSxnQkFBZ0IsR0FBRztRQUN4QixJQUFJLENBQUNILFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDSSxJQUFJLEdBQUdKLGNBQWMsWUFBWSx3QkFBd0I7UUFDOUQsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxVQUFVLEdBQUdBO0lBQ25CO0FBQ0Q7QUFDQTs7OztBQUlBLEdBQ0EsU0FBU0csZUFBZUMsS0FBSztJQUM1QixPQUFPLE9BQU9BLFVBQVUsWUFBWUEsVUFBVSxRQUFRLHNCQUFzQkE7QUFDN0U7QUFDQTs7O0FBR0EsR0FDQSxJQUFJQyxrQkFBa0IsY0FBY1g7SUFDbkNFLFlBQVlDLE9BQU8sRUFBRUUsTUFBTSxFQUFFQyxVQUFVLEVBQUVGLFlBQVksU0FBUyxDQUFFO1FBQy9ELEtBQUssQ0FBQ0QsU0FBU0MsV0FBV0MsUUFBUUM7UUFDbEMsSUFBSSxDQUFDRSxJQUFJLEdBQUdKLGNBQWMsWUFBWSwyQkFBMkI7UUFDakUsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxVQUFVLEdBQUdBO0lBQ25CO0lBQ0FNLFNBQVM7UUFDUixPQUFPO1lBQ05KLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2ZMLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCRSxRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUNuQkMsWUFBWSxJQUFJLENBQUNBLFVBQVU7UUFDNUI7SUFDRDtBQUNEO0FBQ0E7OztBQUdBLEdBQ0Es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TSxLQUFLLENBQUNsQixlQUFlakUsVUFBVSxJQUFJO1FBQzNFLE9BQU9tRiw4QkFBOEJ0UCxJQUFJLENBQUNtSyxTQUFTakosZUFBZUEsZUFBZSxDQUFDLEdBQUdhLFVBQVUsQ0FBQyxHQUFHO1lBQ2xHeUwsa0JBQWtCckQsUUFBUXFELGdCQUFnQjtZQUMxQ0MsV0FBV3RELFFBQVFzRCxTQUFTO1FBQzdCO0lBQ0Q7QUFDRDtBQUVBLFlBQVk7QUFDWiw4QkFBOEI7QUFDOUIsSUFBSThCLGdCQUFnQixjQUFjdEU7SUFDakM7Ozs7Ozs7Ozs7Ozs7Q0FhQSxHQUNBNU8sWUFBWTJHLEdBQUcsRUFBRUosVUFBVSxDQUFDLENBQUMsRUFBRW1CLE9BQU8sRUFBRW1ILElBQUksQ0FBRTtRQUM3QyxLQUFLLENBQUNsSSxLQUFLSixTQUFTbUIsU0FBU21IO0lBQzlCO0lBQ0E7Ozs7Ozs7Ozs7Q0FVQSxHQUNBVixLQUFLekQsRUFBRSxFQUFFO1FBQ1IsT0FBTyxJQUFJbkIsZUFBZSxJQUFJLENBQUM1QyxHQUFHLEVBQUUsSUFBSSxDQUFDSixPQUFPLEVBQUVtRSxJQUFJLElBQUksQ0FBQ3BKLEtBQUs7SUFDakU7SUFDQTs7Ozs7Ozs7OztDQVVBLEdBQ0EsSUFBSW1RLFVBQVU7UUFDYixPQUFPLElBQUlRLHFCQUFxQixJQUFJLENBQUN0TCxHQUFHLEdBQUcsV0FBVztZQUNyREosU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckJqRixPQUFPLElBQUksQ0FBQ0EsS0FBSztRQUNsQjtJQUNEO0lBQ0E7Ozs7Ozs7Ozs7Q0FVQSxHQUNBLElBQUk2UixZQUFZO1FBQ2YsT0FBTyxJQUFJNUMsdUJBQXVCLElBQUksQ0FBQzVKLEdBQUcsR0FBRyxZQUFZLElBQUksQ0FBQ0osT0FBTyxFQUFFLElBQUksQ0FBQ2pGLEtBQUs7SUFDbEY7QUFDRDtBQUVBLFlBQVk7QUFDNlUsQ0FDelYsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5jaG9yLXdvcmtmbG93cy8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L2luZGV4Lm1qcz9lYjM0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEljZWJlcmdSZXN0Q2F0YWxvZyB9IGZyb20gXCJpY2ViZXJnLWpzXCI7XG5cbi8vI3JlZ2lvbiBzcmMvbGliL2NvbW1vbi9lcnJvcnMudHNcbi8qKlxuKiBCYXNlIGVycm9yIGNsYXNzIGZvciBhbGwgU3RvcmFnZSBlcnJvcnNcbiogU3VwcG9ydHMgYm90aCAnc3RvcmFnZScgYW5kICd2ZWN0b3JzJyBuYW1lc3BhY2VzXG4qL1xudmFyIFN0b3JhZ2VFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlLCBuYW1lc3BhY2UgPSBcInN0b3JhZ2VcIiwgc3RhdHVzLCBzdGF0dXNDb2RlKSB7XG5cdFx0c3VwZXIobWVzc2FnZSk7XG5cdFx0dGhpcy5fX2lzU3RvcmFnZUVycm9yID0gdHJ1ZTtcblx0XHR0aGlzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0XHR0aGlzLm5hbWUgPSBuYW1lc3BhY2UgPT09IFwidmVjdG9yc1wiID8gXCJTdG9yYWdlVmVjdG9yc0Vycm9yXCIgOiBcIlN0b3JhZ2VFcnJvclwiO1xuXHRcdHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuXHRcdHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG5cdH1cbn07XG4vKipcbiogVHlwZSBndWFyZCB0byBjaGVjayBpZiBhbiBlcnJvciBpcyBhIFN0b3JhZ2VFcnJvclxuKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3IgdG8gY2hlY2tcbiogQHJldHVybnMgVHJ1ZSBpZiB0aGUgZXJyb3IgaXMgYSBTdG9yYWdlRXJyb3JcbiovXG5mdW5jdGlvbiBpc1N0b3JhZ2VFcnJvcihlcnJvcikge1xuXHRyZXR1cm4gdHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmIGVycm9yICE9PSBudWxsICYmIFwiX19pc1N0b3JhZ2VFcnJvclwiIGluIGVycm9yO1xufVxuLyoqXG4qIEFQSSBlcnJvciByZXR1cm5lZCBmcm9tIFN0b3JhZ2Ugc2VydmljZVxuKiBJbmNsdWRlcyBIVFRQIHN0YXR1cyBjb2RlIGFuZCBzZXJ2aWNlLXNwZWNpZmljIGVycm9yIGNvZGVcbiovXG52YXIgU3RvcmFnZUFwaUVycm9yID0gY2xhc3MgZXh0ZW5kcyBTdG9yYWdlRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMsIHN0YXR1c0NvZGUsIG5hbWVzcGFjZSA9IFwic3RvcmFnZVwiKSB7XG5cdFx0c3VwZXIobWVzc2FnZSwgbmFtZXNwYWNlLCBzdGF0dXMsIHN0YXR1c0NvZGUpO1xuXHRcdHRoaXMubmFtZSA9IG5hbWVzcGFjZSA9PT0gXCJ2ZWN0b3JzXCIgPyBcIlN0b3JhZ2VWZWN0b3JzQXBpRXJyb3JcIiA6IFwiU3RvcmFnZUFwaUVycm9yXCI7XG5cdFx0dGhpcy5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0dGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcblx0fVxuXHR0b0pTT04oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdG5hbWU6IHRoaXMubmFtZSxcblx0XHRcdG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcblx0XHRcdHN0YXR1czogdGhpcy5zdGF0dXMsXG5cdFx0XHRzdGF0dXNDb2RlOiB0aGlzLnN0YXR1c0NvZGVcblx0XHR9O1xuXHR9XG59O1xuLyoqXG4qIFVua25vd24gZXJyb3IgdGhhdCBkb2Vzbid0IG1hdGNoIGV4cGVjdGVkIGVycm9yIHBhdHRlcm5zXG4qIFdyYXBzIHRoZSBvcmlnaW5hbCBlcnJvciBmb3IgZGVidWdnaW5nXG4qL1xudmFyIFN0b3JhZ2VVbmtub3duRXJyb3IgPSBjbGFzcyBleHRlbmRzIFN0b3JhZ2VFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9yaWdpbmFsRXJyb3IsIG5hbWVzcGFjZSA9IFwic3RvcmFnZVwiKSB7XG5cdFx0c3VwZXIobWVzc2FnZSwgbmFtZXNwYWNlKTtcblx0XHR0aGlzLm5hbWUgPSBuYW1lc3BhY2UgPT09IFwidmVjdG9yc1wiID8gXCJTdG9yYWdlVmVjdG9yc1Vua25vd25FcnJvclwiIDogXCJTdG9yYWdlVW5rbm93bkVycm9yXCI7XG5cdFx0dGhpcy5vcmlnaW5hbEVycm9yID0gb3JpZ2luYWxFcnJvcjtcblx0fVxufTtcbi8qKlxuKiBAZGVwcmVjYXRlZCBVc2UgU3RvcmFnZUVycm9yIHdpdGggbmFtZXNwYWNlPSd2ZWN0b3JzJyBpbnN0ZWFkXG4qIEFsaWFzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggZXhpc3RpbmcgdmVjdG9yIHN0b3JhZ2UgY29kZVxuKi9cbnZhciBTdG9yYWdlVmVjdG9yc0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBTdG9yYWdlRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG5cdFx0c3VwZXIobWVzc2FnZSwgXCJ2ZWN0b3JzXCIpO1xuXHR9XG59O1xuLyoqXG4qIFR5cGUgZ3VhcmQgdG8gY2hlY2sgaWYgYW4gZXJyb3IgaXMgYSBTdG9yYWdlVmVjdG9yc0Vycm9yXG4qIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciB0byBjaGVja1xuKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBlcnJvciBpcyBhIFN0b3JhZ2VWZWN0b3JzRXJyb3JcbiovXG5mdW5jdGlvbiBpc1N0b3JhZ2VWZWN0b3JzRXJyb3IoZXJyb3IpIHtcblx0cmV0dXJuIGlzU3RvcmFnZUVycm9yKGVycm9yKSAmJiBlcnJvcltcIm5hbWVzcGFjZVwiXSA9PT0gXCJ2ZWN0b3JzXCI7XG59XG4vKipcbiogQGRlcHJlY2F0ZWQgVXNlIFN0b3JhZ2VBcGlFcnJvciB3aXRoIG5hbWVzcGFjZT0ndmVjdG9ycycgaW5zdGVhZFxuKiBBbGlhcyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIGV4aXN0aW5nIHZlY3RvciBzdG9yYWdlIGNvZGVcbiovXG52YXIgU3RvcmFnZVZlY3RvcnNBcGlFcnJvciA9IGNsYXNzIGV4dGVuZHMgU3RvcmFnZUFwaUVycm9yIHtcblx0Y29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCBzdGF0dXNDb2RlKSB7XG5cdFx0c3VwZXIobWVzc2FnZSwgc3RhdHVzLCBzdGF0dXNDb2RlLCBcInZlY3RvcnNcIik7XG5cdH1cbn07XG4vKipcbiogQGRlcHJlY2F0ZWQgVXNlIFN0b3JhZ2VVbmtub3duRXJyb3Igd2l0aCBuYW1lc3BhY2U9J3ZlY3RvcnMnIGluc3RlYWRcbiogQWxpYXMgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBleGlzdGluZyB2ZWN0b3Igc3RvcmFnZSBjb2RlXG4qL1xudmFyIFN0b3JhZ2VWZWN0b3JzVW5rbm93bkVycm9yID0gY2xhc3MgZXh0ZW5kcyBTdG9yYWdlVW5rbm93bkVycm9yIHtcblx0Y29uc3RydWN0b3IobWVzc2FnZSwgb3JpZ2luYWxFcnJvcikge1xuXHRcdHN1cGVyKG1lc3NhZ2UsIG9yaWdpbmFsRXJyb3IsIFwidmVjdG9yc1wiKTtcblx0fVxufTtcbi8qKlxuKiBFcnJvciBjb2RlcyBzcGVjaWZpYyB0byBTMyBWZWN0b3JzIEFQSVxuKiBNYXBzIEFXUyBzZXJ2aWNlIGVycm9ycyB0byBhcHBsaWNhdGlvbi1mcmllbmRseSBlcnJvciBjb2Rlc1xuKi9cbmxldCBTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxKSB7XG5cdC8qKiBJbnRlcm5hbCBzZXJ2ZXIgZmF1bHQgKEhUVFAgNTAwKSAqL1xuXHRTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxW1wiSW50ZXJuYWxFcnJvclwiXSA9IFwiSW50ZXJuYWxFcnJvclwiO1xuXHQvKiogUmVzb3VyY2UgYWxyZWFkeSBleGlzdHMgLyBjb25mbGljdCAoSFRUUCA0MDkpICovXG5cdFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlJDFbXCJTM1ZlY3RvckNvbmZsaWN0RXhjZXB0aW9uXCJdID0gXCJTM1ZlY3RvckNvbmZsaWN0RXhjZXB0aW9uXCI7XG5cdC8qKiBSZXNvdXJjZSBub3QgZm91bmQgKEhUVFAgNDA0KSAqL1xuXHRTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxW1wiUzNWZWN0b3JOb3RGb3VuZEV4Y2VwdGlvblwiXSA9IFwiUzNWZWN0b3JOb3RGb3VuZEV4Y2VwdGlvblwiO1xuXHQvKiogRGVsZXRlIGJ1Y2tldCB3aGlsZSBub3QgZW1wdHkgKEhUVFAgNDAwKSAqL1xuXHRTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxW1wiUzNWZWN0b3JCdWNrZXROb3RFbXB0eVwiXSA9IFwiUzNWZWN0b3JCdWNrZXROb3RFbXB0eVwiO1xuXHQvKiogRXhjZWVkcyBidWNrZXQgcXVvdGEvbGltaXQgKEhUVFAgNDAwKSAqL1xuXHRTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxW1wiUzNWZWN0b3JNYXhCdWNrZXRzRXhjZWVkZWRcIl0gPSBcIlMzVmVjdG9yTWF4QnVja2V0c0V4Y2VlZGVkXCI7XG5cdC8qKiBFeGNlZWRzIGluZGV4IHF1b3RhL2xpbWl0IChIVFRQIDQwMCkgKi9cblx0U3RvcmFnZVZlY3RvcnNFcnJvckNvZGUkMVtcIlMzVmVjdG9yTWF4SW5kZXhlc0V4Y2VlZGVkXCJdID0gXCJTM1ZlY3Rvck1heEluZGV4ZXNFeGNlZWRlZFwiO1xuXHRyZXR1cm4gU3RvcmFnZVZlY3RvcnNFcnJvckNvZGUkMTtcbn0oe30pO1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL2NvbW1vbi9oZWxwZXJzLnRzXG4vKipcbiogUmVzb2x2ZXMgdGhlIGZldGNoIGltcGxlbWVudGF0aW9uIHRvIHVzZVxuKiBVc2VzIGN1c3RvbSBmZXRjaCBpZiBwcm92aWRlZCwgb3RoZXJ3aXNlIHVzZXMgbmF0aXZlIGZldGNoXG4qXG4qIEBwYXJhbSBjdXN0b21GZXRjaCAtIE9wdGlvbmFsIGN1c3RvbSBmZXRjaCBpbXBsZW1lbnRhdGlvblxuKiBAcmV0dXJucyBSZXNvbHZlZCBmZXRjaCBmdW5jdGlvblxuKi9cbmNvbnN0IHJlc29sdmVGZXRjaCA9IChjdXN0b21GZXRjaCkgPT4ge1xuXHRpZiAoY3VzdG9tRmV0Y2gpIHJldHVybiAoLi4uYXJncykgPT4gY3VzdG9tRmV0Y2goLi4uYXJncyk7XG5cdHJldHVybiAoLi4uYXJncykgPT4gZmV0Y2goLi4uYXJncyk7XG59O1xuLyoqXG4qIERldGVybWluZSBpZiBpbnB1dCBpcyBhIHBsYWluIG9iamVjdFxuKiBBbiBvYmplY3QgaXMgcGxhaW4gaWYgaXQncyBjcmVhdGVkIGJ5IGVpdGhlciB7fSwgbmV3IE9iamVjdCgpLCBvciBPYmplY3QuY3JlYXRlKG51bGwpXG4qXG4qIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrXG4qIEByZXR1cm5zIFRydWUgaWYgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3RcbiogQHNvdXJjZSBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2lzLXBsYWluLW9ialxuKi9cbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsdWUpID0+IHtcblx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuXHRyZXR1cm4gKHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGUgfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvdHlwZSkgPT09IG51bGwpICYmICEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSAmJiAhKFN5bWJvbC5pdGVyYXRvciBpbiB2YWx1ZSk7XG59O1xuLyoqXG4qIFJlY3Vyc2l2ZWx5IGNvbnZlcnRzIG9iamVjdCBrZXlzIGZyb20gc25ha2VfY2FzZSB0byBjYW1lbENhc2VcbiogVXNlZCBmb3Igbm9ybWFsaXppbmcgQVBJIHJlc3BvbnNlc1xuKlxuKiBAcGFyYW0gaXRlbSAtIE9iamVjdCB0byBjb252ZXJ0XG4qIEByZXR1cm5zIENvbnZlcnRlZCBvYmplY3Qgd2l0aCBjYW1lbENhc2Uga2V5c1xuKi9cbmNvbnN0IHJlY3Vyc2l2ZVRvQ2FtZWwgPSAoaXRlbSkgPT4ge1xuXHRpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkgcmV0dXJuIGl0ZW0ubWFwKChlbCkgPT4gcmVjdXJzaXZlVG9DYW1lbChlbCkpO1xuXHRlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJmdW5jdGlvblwiIHx8IGl0ZW0gIT09IE9iamVjdChpdGVtKSkgcmV0dXJuIGl0ZW07XG5cdGNvbnN0IHJlc3VsdCA9IHt9O1xuXHRPYmplY3QuZW50cmllcyhpdGVtKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcblx0XHRjb25zdCBuZXdLZXkgPSBrZXkucmVwbGFjZSgvKFstX11bYS16XSkvZ2ksIChjKSA9PiBjLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvWy1fXS9nLCBcIlwiKSk7XG5cdFx0cmVzdWx0W25ld0tleV0gPSByZWN1cnNpdmVUb0NhbWVsKHZhbHVlKTtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4qIFZhbGlkYXRlcyBpZiBhIGdpdmVuIGJ1Y2tldCBuYW1lIGlzIHZhbGlkIGFjY29yZGluZyB0byBTdXBhYmFzZSBTdG9yYWdlIEFQSSBydWxlc1xuKiBNaXJyb3JzIGJhY2tlbmQgdmFsaWRhdGlvbiBmcm9tOiBzdG9yYWdlL3NyYy9zdG9yYWdlL2xpbWl0cy50czppc1ZhbGlkQnVja2V0TmFtZSgpXG4qXG4qIFJ1bGVzOlxuKiAtIExlbmd0aDogMS0xMDAgY2hhcmFjdGVyc1xuKiAtIEFsbG93ZWQgY2hhcmFjdGVyczogYWxwaGFudW1lcmljIChhLXosIEEtWiwgMC05KSwgdW5kZXJzY29yZSAoXyksIGFuZCBzYWZlIHNwZWNpYWwgY2hhcmFjdGVyc1xuKiAtIFNhZmUgc3BlY2lhbCBjaGFyYWN0ZXJzOiAhIC0gLiAqICcgKCApIHNwYWNlICYgJCBAID0gOyA6ICsgLCA/XG4qIC0gRm9yYmlkZGVuOiBwYXRoIHNlcGFyYXRvcnMgKC8sIFxcKSwgcGF0aCB0cmF2ZXJzYWwgKC4uKSwgbGVhZGluZy90cmFpbGluZyB3aGl0ZXNwYWNlXG4qXG4qIEFXUyBTMyBSZWZlcmVuY2U6IGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BbWF6b25TMy9sYXRlc3QvdXNlcmd1aWRlL29iamVjdC1rZXlzLmh0bWxcbipcbiogQHBhcmFtIGJ1Y2tldE5hbWUgLSBUaGUgYnVja2V0IG5hbWUgdG8gdmFsaWRhdGVcbiogQHJldHVybnMgdHJ1ZSBpZiB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlXG4qL1xuY29uc3QgaXNWYWxpZEJ1Y2tldE5hbWUgPSAoYnVja2V0TmFtZSkgPT4ge1xuXHRpZiAoIWJ1Y2tldE5hbWUgfHwgdHlwZW9mIGJ1Y2tldE5hbWUgIT09IFwic3RyaW5nXCIpIHJldHVybiBmYWxzZTtcblx0aWYgKGJ1Y2tldE5hbWUubGVuZ3RoID09PSAwIHx8IGJ1Y2tldE5hbWUubGVuZ3RoID4gMTAwKSByZXR1cm4gZmFsc2U7XG5cdGlmIChidWNrZXROYW1lLnRyaW0oKSAhPT0gYnVja2V0TmFtZSkgcmV0dXJuIGZhbHNlO1xuXHRpZiAoYnVja2V0TmFtZS5pbmNsdWRlcyhcIi9cIikgfHwgYnVja2V0TmFtZS5pbmNsdWRlcyhcIlxcXFxcIikpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuIC9eW1xcdyEuXFwqJygpICYkQD07OissPy1dKyQvLnRlc3QoYnVja2V0TmFtZSk7XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBcXDBAb3hjLXByb2plY3QrcnVudGltZUAwLjEwMS4wL2hlbHBlcnMvdHlwZW9mLmpzXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHtcblx0XCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXHRyZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uKG8kMSkge1xuXHRcdHJldHVybiB0eXBlb2YgbyQxO1xuXHR9IDogZnVuY3Rpb24obyQxKSB7XG5cdFx0cmV0dXJuIG8kMSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvJDEuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvJDEgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG8kMTtcblx0fSwgX3R5cGVvZihvKTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gXFwwQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC4xMDEuMC9oZWxwZXJzL3RvUHJpbWl0aXZlLmpzXG5mdW5jdGlvbiB0b1ByaW1pdGl2ZSh0LCByKSB7XG5cdGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0O1xuXHR2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcblx0aWYgKHZvaWQgMCAhPT0gZSkge1xuXHRcdHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuXHRcdGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpO1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcblx0fVxuXHRyZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBcXDBAb3hjLXByb2plY3QrcnVudGltZUAwLjEwMS4wL2hlbHBlcnMvdG9Qcm9wZXJ0eUtleS5qc1xuZnVuY3Rpb24gdG9Qcm9wZXJ0eUtleSh0KSB7XG5cdHZhciBpID0gdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG5cdHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIFxcMEBveGMtcHJvamVjdCtydW50aW1lQDAuMTAxLjAvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qc1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHtcblx0cmV0dXJuIChyID0gdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7XG5cdFx0dmFsdWU6IHQsXG5cdFx0ZW51bWVyYWJsZTogITAsXG5cdFx0Y29uZmlndXJhYmxlOiAhMCxcblx0XHR3cml0YWJsZTogITBcblx0fSkgOiBlW3JdID0gdCwgZTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gXFwwQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC4xMDEuMC9oZWxwZXJzL29iamVjdFNwcmVhZDIuanNcbmZ1bmN0aW9uIG93bktleXMoZSwgcikge1xuXHR2YXIgdCA9IE9iamVjdC5rZXlzKGUpO1xuXHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcblx0XHRyICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24ociQxKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByJDEpLmVudW1lcmFibGU7XG5cdFx0fSkpLCB0LnB1c2guYXBwbHkodCwgbyk7XG5cdH1cblx0cmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMihlKSB7XG5cdGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7XG5cdFx0dmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9O1xuXHRcdHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uKHIkMSkge1xuXHRcdFx0X2RlZmluZVByb3BlcnR5KGUsIHIkMSwgdFtyJDFdKTtcblx0XHR9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24ociQxKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciQxLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIkMSkpO1xuXHRcdH0pO1xuXHR9XG5cdHJldHVybiBlO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL2NvbW1vbi9mZXRjaC50c1xuLyoqXG4qIEV4dHJhY3RzIGVycm9yIG1lc3NhZ2UgZnJvbSB2YXJpb3VzIGVycm9yIHJlc3BvbnNlIGZvcm1hdHNcbiogQHBhcmFtIGVyciAtIEVycm9yIG9iamVjdCBmcm9tIEFQSVxuKiBAcmV0dXJucyBIdW1hbi1yZWFkYWJsZSBlcnJvciBtZXNzYWdlXG4qL1xuY29uc3QgX2dldEVycm9yTWVzc2FnZSA9IChlcnIpID0+IHtcblx0dmFyIF9lcnIkZXJyb3I7XG5cdHJldHVybiBlcnIubXNnIHx8IGVyci5tZXNzYWdlIHx8IGVyci5lcnJvcl9kZXNjcmlwdGlvbiB8fCAodHlwZW9mIGVyci5lcnJvciA9PT0gXCJzdHJpbmdcIiA/IGVyci5lcnJvciA6IChfZXJyJGVycm9yID0gZXJyLmVycm9yKSA9PT0gbnVsbCB8fCBfZXJyJGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXJyJGVycm9yLm1lc3NhZ2UpIHx8IEpTT04uc3RyaW5naWZ5KGVycik7XG59O1xuLyoqXG4qIEhhbmRsZXMgZmV0Y2ggZXJyb3JzIGFuZCBjb252ZXJ0cyB0aGVtIHRvIFN0b3JhZ2UgZXJyb3IgdHlwZXNcbiogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIGNhdWdodCBmcm9tIGZldGNoXG4qIEBwYXJhbSByZWplY3QgLSBQcm9taXNlIHJlamVjdGlvbiBmdW5jdGlvblxuKiBAcGFyYW0gb3B0aW9ucyAtIEZldGNoIG9wdGlvbnMgdGhhdCBtYXkgYWZmZWN0IGVycm9yIGhhbmRsaW5nXG4qIEBwYXJhbSBuYW1lc3BhY2UgLSBFcnJvciBuYW1lc3BhY2UgKCdzdG9yYWdlJyBvciAndmVjdG9ycycpXG4qL1xuY29uc3QgaGFuZGxlRXJyb3IgPSBhc3luYyAoZXJyb3IsIHJlamVjdCwgb3B0aW9ucywgbmFtZXNwYWNlKSA9PiB7XG5cdGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgXCJzdGF0dXNcIiBpbiBlcnJvciAmJiBcIm9rXCIgaW4gZXJyb3IgJiYgdHlwZW9mIGVycm9yLnN0YXR1cyA9PT0gXCJudW1iZXJcIiAmJiAhKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ub1Jlc29sdmVKc29uKSkge1xuXHRcdGNvbnN0IHJlc3BvbnNlRXJyb3IgPSBlcnJvcjtcblx0XHRjb25zdCBzdGF0dXMgPSByZXNwb25zZUVycm9yLnN0YXR1cyB8fCA1MDA7XG5cdFx0aWYgKHR5cGVvZiByZXNwb25zZUVycm9yLmpzb24gPT09IFwiZnVuY3Rpb25cIikgcmVzcG9uc2VFcnJvci5qc29uKCkudGhlbigoZXJyKSA9PiB7XG5cdFx0XHRjb25zdCBzdGF0dXNDb2RlID0gKGVyciA9PT0gbnVsbCB8fCBlcnIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVyci5zdGF0dXNDb2RlKSB8fCAoZXJyID09PSBudWxsIHx8IGVyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyLmNvZGUpIHx8IHN0YXR1cyArIFwiXCI7XG5cdFx0XHRyZWplY3QobmV3IFN0b3JhZ2VBcGlFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGVyciksIHN0YXR1cywgc3RhdHVzQ29kZSwgbmFtZXNwYWNlKSk7XG5cdFx0fSkuY2F0Y2goKCkgPT4ge1xuXHRcdFx0aWYgKG5hbWVzcGFjZSA9PT0gXCJ2ZWN0b3JzXCIpIHtcblx0XHRcdFx0Y29uc3Qgc3RhdHVzQ29kZSA9IHN0YXR1cyArIFwiXCI7XG5cdFx0XHRcdHJlamVjdChuZXcgU3RvcmFnZUFwaUVycm9yKHJlc3BvbnNlRXJyb3Iuc3RhdHVzVGV4dCB8fCBgSFRUUCAke3N0YXR1c30gZXJyb3JgLCBzdGF0dXMsIHN0YXR1c0NvZGUsIG5hbWVzcGFjZSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3Qgc3RhdHVzQ29kZSA9IHN0YXR1cyArIFwiXCI7XG5cdFx0XHRcdHJlamVjdChuZXcgU3RvcmFnZUFwaUVycm9yKHJlc3BvbnNlRXJyb3Iuc3RhdHVzVGV4dCB8fCBgSFRUUCAke3N0YXR1c30gZXJyb3JgLCBzdGF0dXMsIHN0YXR1c0NvZGUsIG5hbWVzcGFjZSkpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGVsc2Uge1xuXHRcdFx0Y29uc3Qgc3RhdHVzQ29kZSA9IHN0YXR1cyArIFwiXCI7XG5cdFx0XHRyZWplY3QobmV3IFN0b3JhZ2VBcGlFcnJvcihyZXNwb25zZUVycm9yLnN0YXR1c1RleHQgfHwgYEhUVFAgJHtzdGF0dXN9IGVycm9yYCwgc3RhdHVzLCBzdGF0dXNDb2RlLCBuYW1lc3BhY2UpKTtcblx0XHR9XG5cdH0gZWxzZSByZWplY3QobmV3IFN0b3JhZ2VVbmtub3duRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnJvciksIGVycm9yLCBuYW1lc3BhY2UpKTtcbn07XG4vKipcbiogQnVpbGRzIHJlcXVlc3QgcGFyYW1ldGVycyBmb3IgZmV0Y2ggY2FsbHNcbiogQHBhcmFtIG1ldGhvZCAtIEhUVFAgbWV0aG9kXG4qIEBwYXJhbSBvcHRpb25zIC0gQ3VzdG9tIGZldGNoIG9wdGlvbnNcbiogQHBhcmFtIHBhcmFtZXRlcnMgLSBBZGRpdGlvbmFsIGZldGNoIHBhcmFtZXRlcnMgbGlrZSBBYm9ydFNpZ25hbFxuKiBAcGFyYW0gYm9keSAtIFJlcXVlc3QgYm9keSAod2lsbCBiZSBKU09OIHN0cmluZ2lmaWVkIGlmIHBsYWluIG9iamVjdClcbiogQHJldHVybnMgQ29tcGxldGUgZmV0Y2ggcmVxdWVzdCBwYXJhbWV0ZXJzXG4qL1xuY29uc3QgX2dldFJlcXVlc3RQYXJhbXMgPSAobWV0aG9kLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KSA9PiB7XG5cdGNvbnN0IHBhcmFtcyA9IHtcblx0XHRtZXRob2QsXG5cdFx0aGVhZGVyczogKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKSB8fCB7fVxuXHR9O1xuXHRpZiAobWV0aG9kID09PSBcIkdFVFwiIHx8IG1ldGhvZCA9PT0gXCJIRUFEXCIgfHwgIWJvZHkpIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgcGFyYW1zKSwgcGFyYW1ldGVycyk7XG5cdGlmIChpc1BsYWluT2JqZWN0KGJvZHkpKSB7XG5cdFx0cGFyYW1zLmhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkMih7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKTtcblx0XHRwYXJhbXMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuXHR9IGVsc2UgcGFyYW1zLmJvZHkgPSBib2R5O1xuXHRpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmR1cGxleCkgcGFyYW1zLmR1cGxleCA9IG9wdGlvbnMuZHVwbGV4O1xuXHRyZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHBhcmFtcyksIHBhcmFtZXRlcnMpO1xufTtcbi8qKlxuKiBJbnRlcm5hbCByZXF1ZXN0IGhhbmRsZXIgdGhhdCB3cmFwcyBmZXRjaCB3aXRoIGVycm9yIGhhbmRsaW5nXG4qIEBwYXJhbSBmZXRjaGVyIC0gRmV0Y2ggZnVuY3Rpb24gdG8gdXNlXG4qIEBwYXJhbSBtZXRob2QgLSBIVFRQIG1ldGhvZFxuKiBAcGFyYW0gdXJsIC0gUmVxdWVzdCBVUkxcbiogQHBhcmFtIG9wdGlvbnMgLSBDdXN0b20gZmV0Y2ggb3B0aW9uc1xuKiBAcGFyYW0gcGFyYW1ldGVycyAtIEFkZGl0aW9uYWwgZmV0Y2ggcGFyYW1ldGVyc1xuKiBAcGFyYW0gYm9keSAtIFJlcXVlc3QgYm9keVxuKiBAcGFyYW0gbmFtZXNwYWNlIC0gRXJyb3IgbmFtZXNwYWNlICgnc3RvcmFnZScgb3IgJ3ZlY3RvcnMnKVxuKiBAcmV0dXJucyBQcm9taXNlIHdpdGggcGFyc2VkIHJlc3BvbnNlIG9yIGVycm9yXG4qL1xuYXN5bmMgZnVuY3Rpb24gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgbWV0aG9kLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHksIG5hbWVzcGFjZSkge1xuXHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdGZldGNoZXIodXJsLCBfZ2V0UmVxdWVzdFBhcmFtcyhtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpKS50aGVuKChyZXN1bHQpID0+IHtcblx0XHRcdGlmICghcmVzdWx0Lm9rKSB0aHJvdyByZXN1bHQ7XG5cdFx0XHRpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm5vUmVzb2x2ZUpzb24pIHJldHVybiByZXN1bHQ7XG5cdFx0XHRpZiAobmFtZXNwYWNlID09PSBcInZlY3RvcnNcIikge1xuXHRcdFx0XHRjb25zdCBjb250ZW50VHlwZSA9IHJlc3VsdC5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcblx0XHRcdFx0aWYgKHJlc3VsdC5oZWFkZXJzLmdldChcImNvbnRlbnQtbGVuZ3RoXCIpID09PSBcIjBcIiB8fCByZXN1bHQuc3RhdHVzID09PSAyMDQpIHJldHVybiB7fTtcblx0XHRcdFx0aWYgKCFjb250ZW50VHlwZSB8fCAhY29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSByZXR1cm4ge307XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0Lmpzb24oKTtcblx0XHR9KS50aGVuKChkYXRhKSA9PiByZXNvbHZlKGRhdGEpKS5jYXRjaCgoZXJyb3IpID0+IGhhbmRsZUVycm9yKGVycm9yLCByZWplY3QsIG9wdGlvbnMsIG5hbWVzcGFjZSkpO1xuXHR9KTtcbn1cbi8qKlxuKiBDcmVhdGVzIGEgZmV0Y2ggQVBJIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lc3BhY2VcbiogQHBhcmFtIG5hbWVzcGFjZSAtIEVycm9yIG5hbWVzcGFjZSAoJ3N0b3JhZ2UnIG9yICd2ZWN0b3JzJylcbiogQHJldHVybnMgT2JqZWN0IHdpdGggSFRUUCBtZXRob2QgZnVuY3Rpb25zXG4qL1xuZnVuY3Rpb24gY3JlYXRlRmV0Y2hBcGkobmFtZXNwYWNlID0gXCJzdG9yYWdlXCIpIHtcblx0cmV0dXJuIHtcblx0XHRnZXQ6IGFzeW5jIChmZXRjaGVyLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMpID0+IHtcblx0XHRcdHJldHVybiBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCBcIkdFVFwiLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIHZvaWQgMCwgbmFtZXNwYWNlKTtcblx0XHR9LFxuXHRcdHBvc3Q6IGFzeW5jIChmZXRjaGVyLCB1cmwsIGJvZHksIG9wdGlvbnMsIHBhcmFtZXRlcnMpID0+IHtcblx0XHRcdHJldHVybiBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCBcIlBPU1RcIiwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5LCBuYW1lc3BhY2UpO1xuXHRcdH0sXG5cdFx0cHV0OiBhc3luYyAoZmV0Y2hlciwgdXJsLCBib2R5LCBvcHRpb25zLCBwYXJhbWV0ZXJzKSA9PiB7XG5cdFx0XHRyZXR1cm4gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgXCJQVVRcIiwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5LCBuYW1lc3BhY2UpO1xuXHRcdH0sXG5cdFx0aGVhZDogYXN5bmMgKGZldGNoZXIsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycykgPT4ge1xuXHRcdFx0cmV0dXJuIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsIFwiSEVBRFwiLCB1cmwsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKSwge30sIHsgbm9SZXNvbHZlSnNvbjogdHJ1ZSB9KSwgcGFyYW1ldGVycywgdm9pZCAwLCBuYW1lc3BhY2UpO1xuXHRcdH0sXG5cdFx0cmVtb3ZlOiBhc3luYyAoZmV0Y2hlciwgdXJsLCBib2R5LCBvcHRpb25zLCBwYXJhbWV0ZXJzKSA9PiB7XG5cdFx0XHRyZXR1cm4gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgXCJERUxFVEVcIiwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5LCBuYW1lc3BhY2UpO1xuXHRcdH1cblx0fTtcbn1cbmNvbnN0IGRlZmF1bHRBcGkgPSBjcmVhdGVGZXRjaEFwaShcInN0b3JhZ2VcIik7XG5jb25zdCB7IGdldCwgcG9zdCwgcHV0LCBoZWFkLCByZW1vdmUgfSA9IGRlZmF1bHRBcGk7XG5jb25zdCB2ZWN0b3JzQXBpID0gY3JlYXRlRmV0Y2hBcGkoXCJ2ZWN0b3JzXCIpO1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL2NvbW1vbi9CYXNlQXBpQ2xpZW50LnRzXG4vKipcbiogQGlnbm9yZVxuKiBCYXNlIEFQSSBjbGllbnQgY2xhc3MgZm9yIGFsbCBTdG9yYWdlIEFQSSBjbGFzc2VzXG4qIFByb3ZpZGVzIGNvbW1vbiBpbmZyYXN0cnVjdHVyZSBmb3IgZXJyb3IgaGFuZGxpbmcgYW5kIGNvbmZpZ3VyYXRpb25cbipcbiogQHR5cGVQYXJhbSBURXJyb3IgLSBUaGUgZXJyb3IgdHlwZSAoU3RvcmFnZUVycm9yIG9yIHN1YmNsYXNzKVxuKi9cbnZhciBCYXNlQXBpQ2xpZW50ID0gY2xhc3Mge1xuXHQvKipcblx0KiBDcmVhdGVzIGEgbmV3IEJhc2VBcGlDbGllbnQgaW5zdGFuY2Vcblx0KiBAcGFyYW0gdXJsIC0gQmFzZSBVUkwgZm9yIEFQSSByZXF1ZXN0c1xuXHQqIEBwYXJhbSBoZWFkZXJzIC0gRGVmYXVsdCBoZWFkZXJzIGZvciBBUEkgcmVxdWVzdHNcblx0KiBAcGFyYW0gZmV0Y2ggLSBPcHRpb25hbCBjdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb25cblx0KiBAcGFyYW0gbmFtZXNwYWNlIC0gRXJyb3IgbmFtZXNwYWNlICgnc3RvcmFnZScgb3IgJ3ZlY3RvcnMnKVxuXHQqL1xuXHRjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMgPSB7fSwgZmV0Y2gkMSwgbmFtZXNwYWNlID0gXCJzdG9yYWdlXCIpIHtcblx0XHR0aGlzLnNob3VsZFRocm93T25FcnJvciA9IGZhbHNlO1xuXHRcdHRoaXMudXJsID0gdXJsO1xuXHRcdHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG5cdFx0dGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChmZXRjaCQxKTtcblx0XHR0aGlzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0fVxuXHQvKipcblx0KiBFbmFibGUgdGhyb3dpbmcgZXJyb3JzIGluc3RlYWQgb2YgcmV0dXJuaW5nIHRoZW0uXG5cdCogV2hlbiBlbmFibGVkLCBlcnJvcnMgYXJlIHRocm93biBpbnN0ZWFkIG9mIHJldHVybmVkIGluIHsgZGF0YSwgZXJyb3IgfSBmb3JtYXQuXG5cdCpcblx0KiBAcmV0dXJucyB0aGlzIC0gRm9yIG1ldGhvZCBjaGFpbmluZ1xuXHQqL1xuXHR0aHJvd09uRXJyb3IoKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSB0cnVlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIFNldCBhbiBIVFRQIGhlYWRlciBmb3IgdGhlIHJlcXVlc3QuXG5cdCogQ3JlYXRlcyBhIHNoYWxsb3cgY29weSBvZiBoZWFkZXJzIHRvIGF2b2lkIG11dGF0aW5nIHNoYXJlZCBzdGF0ZS5cblx0KlxuXHQqIEBwYXJhbSBuYW1lIC0gSGVhZGVyIG5hbWVcblx0KiBAcGFyYW0gdmFsdWUgLSBIZWFkZXIgdmFsdWVcblx0KiBAcmV0dXJucyB0aGlzIC0gRm9yIG1ldGhvZCBjaGFpbmluZ1xuXHQqL1xuXHRzZXRIZWFkZXIobmFtZSwgdmFsdWUpIHtcblx0XHR0aGlzLmhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgdGhpcy5oZWFkZXJzKSwge30sIHsgW25hbWVdOiB2YWx1ZSB9KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBIYW5kbGVzIEFQSSBvcGVyYXRpb24gd2l0aCBzdGFuZGFyZGl6ZWQgZXJyb3IgaGFuZGxpbmdcblx0KiBFbGltaW5hdGVzIHJlcGV0aXRpdmUgdHJ5LWNhdGNoIGJsb2NrcyBhY3Jvc3MgYWxsIEFQSSBtZXRob2RzXG5cdCpcblx0KiBUaGlzIHdyYXBwZXI6XG5cdCogMS4gRXhlY3V0ZXMgdGhlIG9wZXJhdGlvblxuXHQqIDIuIFJldHVybnMgeyBkYXRhLCBlcnJvcjogbnVsbCB9IG9uIHN1Y2Nlc3Ncblx0KiAzLiBSZXR1cm5zIHsgZGF0YTogbnVsbCwgZXJyb3IgfSBvbiBmYWlsdXJlIChpZiBzaG91bGRUaHJvd09uRXJyb3IgaXMgZmFsc2UpXG5cdCogNC4gVGhyb3dzIGVycm9yIG9uIGZhaWx1cmUgKGlmIHNob3VsZFRocm93T25FcnJvciBpcyB0cnVlKVxuXHQqXG5cdCogQHR5cGVQYXJhbSBUIC0gVGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBmcm9tIHRoZSBvcGVyYXRpb25cblx0KiBAcGFyYW0gb3BlcmF0aW9uIC0gQXN5bmMgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyB0aGUgQVBJIGNhbGxcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggeyBkYXRhLCBlcnJvciB9IHR1cGxlXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBhc3luYyBsaXN0QnVja2V0cygpIHtcblx0KiAgIHJldHVybiB0aGlzLmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG5cdCogICAgIHJldHVybiBhd2FpdCBnZXQodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L2J1Y2tldGAsIHtcblx0KiAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG5cdCogICAgIH0pXG5cdCogICB9KVxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgaGFuZGxlT3BlcmF0aW9uKG9wZXJhdGlvbikge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IG9wZXJhdGlvbigpLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3BhY2thZ2VzL1N0cmVhbURvd25sb2FkQnVpbGRlci50c1xudmFyIFN0cmVhbURvd25sb2FkQnVpbGRlciA9IGNsYXNzIHtcblx0Y29uc3RydWN0b3IoZG93bmxvYWRGbiwgc2hvdWxkVGhyb3dPbkVycm9yKSB7XG5cdFx0dGhpcy5kb3dubG9hZEZuID0gZG93bmxvYWRGbjtcblx0XHR0aGlzLnNob3VsZFRocm93T25FcnJvciA9IHNob3VsZFRocm93T25FcnJvcjtcblx0fVxuXHR0aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXhlY3V0ZSgpLnRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpO1xuXHR9XG5cdGFzeW5jIGV4ZWN1dGUoKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogKGF3YWl0IF90aGlzLmRvd25sb2FkRm4oKSkuYm9keSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9wYWNrYWdlcy9CbG9iRG93bmxvYWRCdWlsZGVyLnRzXG5sZXQgX1N5bWJvbCR0b1N0cmluZ1RhZztcbl9TeW1ib2wkdG9TdHJpbmdUYWcgPSBTeW1ib2wudG9TdHJpbmdUYWc7XG52YXIgQmxvYkRvd25sb2FkQnVpbGRlciA9IGNsYXNzIHtcblx0Y29uc3RydWN0b3IoZG93bmxvYWRGbiwgc2hvdWxkVGhyb3dPbkVycm9yKSB7XG5cdFx0dGhpcy5kb3dubG9hZEZuID0gZG93bmxvYWRGbjtcblx0XHR0aGlzLnNob3VsZFRocm93T25FcnJvciA9IHNob3VsZFRocm93T25FcnJvcjtcblx0XHR0aGlzW19TeW1ib2wkdG9TdHJpbmdUYWddID0gXCJCbG9iRG93bmxvYWRCdWlsZGVyXCI7XG5cdFx0dGhpcy5wcm9taXNlID0gbnVsbDtcblx0fVxuXHRhc1N0cmVhbSgpIHtcblx0XHRyZXR1cm4gbmV3IFN0cmVhbURvd25sb2FkQnVpbGRlcih0aGlzLmRvd25sb2FkRm4sIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKTtcblx0fVxuXHR0aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UHJvbWlzZSgpLnRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpO1xuXHR9XG5cdGNhdGNoKG9ucmVqZWN0ZWQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRQcm9taXNlKCkuY2F0Y2gob25yZWplY3RlZCk7XG5cdH1cblx0ZmluYWxseShvbmZpbmFsbHkpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRQcm9taXNlKCkuZmluYWxseShvbmZpbmFsbHkpO1xuXHR9XG5cdGdldFByb21pc2UoKSB7XG5cdFx0aWYgKCF0aGlzLnByb21pc2UpIHRoaXMucHJvbWlzZSA9IHRoaXMuZXhlY3V0ZSgpO1xuXHRcdHJldHVybiB0aGlzLnByb21pc2U7XG5cdH1cblx0YXN5bmMgZXhlY3V0ZSgpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCAoYXdhaXQgX3RoaXMuZG93bmxvYWRGbigpKS5ibG9iKCksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvcGFja2FnZXMvU3RvcmFnZUZpbGVBcGkudHNcbmNvbnN0IERFRkFVTFRfU0VBUkNIX09QVElPTlMgPSB7XG5cdGxpbWl0OiAxMDAsXG5cdG9mZnNldDogMCxcblx0c29ydEJ5OiB7XG5cdFx0Y29sdW1uOiBcIm5hbWVcIixcblx0XHRvcmRlcjogXCJhc2NcIlxuXHR9XG59O1xuY29uc3QgREVGQVVMVF9GSUxFX09QVElPTlMgPSB7XG5cdGNhY2hlQ29udHJvbDogXCIzNjAwXCIsXG5cdGNvbnRlbnRUeXBlOiBcInRleHQvcGxhaW47Y2hhcnNldD1VVEYtOFwiLFxuXHR1cHNlcnQ6IGZhbHNlXG59O1xudmFyIFN0b3JhZ2VGaWxlQXBpID0gY2xhc3MgZXh0ZW5kcyBCYXNlQXBpQ2xpZW50IHtcblx0Y29uc3RydWN0b3IodXJsLCBoZWFkZXJzID0ge30sIGJ1Y2tldElkLCBmZXRjaCQxKSB7XG5cdFx0c3VwZXIodXJsLCBoZWFkZXJzLCBmZXRjaCQxLCBcInN0b3JhZ2VcIik7XG5cdFx0dGhpcy5idWNrZXRJZCA9IGJ1Y2tldElkO1xuXHR9XG5cdC8qKlxuXHQqIFVwbG9hZHMgYSBmaWxlIHRvIGFuIGV4aXN0aW5nIGJ1Y2tldCBvciByZXBsYWNlcyBhbiBleGlzdGluZyBmaWxlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aCB3aXRoIGEgbmV3IG9uZS5cblx0KlxuXHQqIEBwYXJhbSBtZXRob2QgSFRUUCBtZXRob2QuXG5cdCogQHBhcmFtIHBhdGggVGhlIHJlbGF0aXZlIGZpbGUgcGF0aC4gU2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgYGZvbGRlci9zdWJmb2xkZXIvZmlsZW5hbWUucG5nYC4gVGhlIGJ1Y2tldCBtdXN0IGFscmVhZHkgZXhpc3QgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdXBsb2FkLlxuXHQqIEBwYXJhbSBmaWxlQm9keSBUaGUgYm9keSBvZiB0aGUgZmlsZSB0byBiZSBzdG9yZWQgaW4gdGhlIGJ1Y2tldC5cblx0Ki9cblx0YXN5bmMgdXBsb2FkT3JVcGRhdGUobWV0aG9kLCBwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHJldHVybiBfdGhpcy5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuXHRcdFx0bGV0IGJvZHk7XG5cdFx0XHRjb25zdCBvcHRpb25zID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfRklMRV9PUFRJT05TKSwgZmlsZU9wdGlvbnMpO1xuXHRcdFx0bGV0IGhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgX3RoaXMuaGVhZGVycyksIG1ldGhvZCA9PT0gXCJQT1NUXCIgJiYgeyBcIngtdXBzZXJ0XCI6IFN0cmluZyhvcHRpb25zLnVwc2VydCkgfSk7XG5cdFx0XHRjb25zdCBtZXRhZGF0YSA9IG9wdGlvbnMubWV0YWRhdGE7XG5cdFx0XHRpZiAodHlwZW9mIEJsb2IgIT09IFwidW5kZWZpbmVkXCIgJiYgZmlsZUJvZHkgaW5zdGFuY2VvZiBCbG9iKSB7XG5cdFx0XHRcdGJvZHkgPSBuZXcgRm9ybURhdGEoKTtcblx0XHRcdFx0Ym9keS5hcHBlbmQoXCJjYWNoZUNvbnRyb2xcIiwgb3B0aW9ucy5jYWNoZUNvbnRyb2wpO1xuXHRcdFx0XHRpZiAobWV0YWRhdGEpIGJvZHkuYXBwZW5kKFwibWV0YWRhdGFcIiwgX3RoaXMuZW5jb2RlTWV0YWRhdGEobWV0YWRhdGEpKTtcblx0XHRcdFx0Ym9keS5hcHBlbmQoXCJcIiwgZmlsZUJvZHkpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgRm9ybURhdGEgIT09IFwidW5kZWZpbmVkXCIgJiYgZmlsZUJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuXHRcdFx0XHRib2R5ID0gZmlsZUJvZHk7XG5cdFx0XHRcdGlmICghYm9keS5oYXMoXCJjYWNoZUNvbnRyb2xcIikpIGJvZHkuYXBwZW5kKFwiY2FjaGVDb250cm9sXCIsIG9wdGlvbnMuY2FjaGVDb250cm9sKTtcblx0XHRcdFx0aWYgKG1ldGFkYXRhICYmICFib2R5LmhhcyhcIm1ldGFkYXRhXCIpKSBib2R5LmFwcGVuZChcIm1ldGFkYXRhXCIsIF90aGlzLmVuY29kZU1ldGFkYXRhKG1ldGFkYXRhKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRib2R5ID0gZmlsZUJvZHk7XG5cdFx0XHRcdGhlYWRlcnNbXCJjYWNoZS1jb250cm9sXCJdID0gYG1heC1hZ2U9JHtvcHRpb25zLmNhY2hlQ29udHJvbH1gO1xuXHRcdFx0XHRoZWFkZXJzW1wiY29udGVudC10eXBlXCJdID0gb3B0aW9ucy5jb250ZW50VHlwZTtcblx0XHRcdFx0aWYgKG1ldGFkYXRhKSBoZWFkZXJzW1wieC1tZXRhZGF0YVwiXSA9IF90aGlzLnRvQmFzZTY0KF90aGlzLmVuY29kZU1ldGFkYXRhKG1ldGFkYXRhKSk7XG5cdFx0XHRcdGlmICgodHlwZW9mIFJlYWRhYmxlU3RyZWFtICE9PSBcInVuZGVmaW5lZFwiICYmIGJvZHkgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSB8fCBib2R5ICYmIHR5cGVvZiBib2R5ID09PSBcIm9iamVjdFwiICYmIFwicGlwZVwiIGluIGJvZHkgJiYgdHlwZW9mIGJvZHkucGlwZSA9PT0gXCJmdW5jdGlvblwiKSAmJiAhb3B0aW9ucy5kdXBsZXgpIG9wdGlvbnMuZHVwbGV4ID0gXCJoYWxmXCI7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZmlsZU9wdGlvbnMgPT09IG51bGwgfHwgZmlsZU9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbGVPcHRpb25zLmhlYWRlcnMpIGhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgaGVhZGVycyksIGZpbGVPcHRpb25zLmhlYWRlcnMpO1xuXHRcdFx0Y29uc3QgY2xlYW5QYXRoID0gX3RoaXMuX3JlbW92ZUVtcHR5Rm9sZGVycyhwYXRoKTtcblx0XHRcdGNvbnN0IF9wYXRoID0gX3RoaXMuX2dldEZpbmFsUGF0aChjbGVhblBhdGgpO1xuXHRcdFx0Y29uc3QgZGF0YSA9IGF3YWl0IChtZXRob2QgPT0gXCJQVVRcIiA/IHB1dCA6IHBvc3QpKF90aGlzLmZldGNoLCBgJHtfdGhpcy51cmx9L29iamVjdC8ke19wYXRofWAsIGJvZHksIF9vYmplY3RTcHJlYWQyKHsgaGVhZGVycyB9LCAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmR1cGxleCkgPyB7IGR1cGxleDogb3B0aW9ucy5kdXBsZXggfSA6IHt9KSk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRwYXRoOiBjbGVhblBhdGgsXG5cdFx0XHRcdGlkOiBkYXRhLklkLFxuXHRcdFx0XHRmdWxsUGF0aDogZGF0YS5LZXlcblx0XHRcdH07XG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogVXBsb2FkcyBhIGZpbGUgdG8gYW4gZXhpc3RpbmcgYnVja2V0LlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgZmlsZSBuYW1lLiBTaG91bGQgYmUgb2YgdGhlIGZvcm1hdCBgZm9sZGVyL3N1YmZvbGRlci9maWxlbmFtZS5wbmdgLiBUaGUgYnVja2V0IG11c3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGxvYWQuXG5cdCogQHBhcmFtIGZpbGVCb2R5IFRoZSBib2R5IG9mIHRoZSBmaWxlIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVja2V0LlxuXHQqIEBwYXJhbSBmaWxlT3B0aW9ucyBPcHRpb25hbCBmaWxlIHVwbG9hZCBvcHRpb25zIGluY2x1ZGluZyBjYWNoZUNvbnRyb2wsIGNvbnRlbnRUeXBlLCB1cHNlcnQsIGFuZCBtZXRhZGF0YS5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBmaWxlIHBhdGgsIGlkLCBhbmQgZnVsbFBhdGggb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIFVwbG9hZCBmaWxlXG5cdCogYGBganNcblx0KiBjb25zdCBhdmF0YXJGaWxlID0gZXZlbnQudGFyZ2V0LmZpbGVzWzBdXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAudXBsb2FkKCdwdWJsaWMvYXZhdGFyMS5wbmcnLCBhdmF0YXJGaWxlLCB7XG5cdCogICAgIGNhY2hlQ29udHJvbDogJzM2MDAnLFxuXHQqICAgICB1cHNlcnQ6IGZhbHNlXG5cdCogICB9KVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwicGF0aFwiOiBcInB1YmxpYy9hdmF0YXIxLnBuZ1wiLFxuXHQqICAgICBcImZ1bGxQYXRoXCI6IFwiYXZhdGFycy9wdWJsaWMvYXZhdGFyMS5wbmdcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIFVwbG9hZCBmaWxlIHVzaW5nIGBBcnJheUJ1ZmZlcmAgZnJvbSBiYXNlNjQgZmlsZSBkYXRhXG5cdCogYGBganNcblx0KiBpbXBvcnQgeyBkZWNvZGUgfSBmcm9tICdiYXNlNjQtYXJyYXlidWZmZXInXG5cdCpcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC51cGxvYWQoJ3B1YmxpYy9hdmF0YXIxLnBuZycsIGRlY29kZSgnYmFzZTY0RmlsZURhdGEnKSwge1xuXHQqICAgICBjb250ZW50VHlwZTogJ2ltYWdlL3BuZydcblx0KiAgIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIHVwbG9hZChwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpIHtcblx0XHRyZXR1cm4gdGhpcy51cGxvYWRPclVwZGF0ZShcIlBPU1RcIiwgcGF0aCwgZmlsZUJvZHksIGZpbGVPcHRpb25zKTtcblx0fVxuXHQvKipcblx0KiBVcGxvYWQgYSBmaWxlIHdpdGggYSB0b2tlbiBnZW5lcmF0ZWQgZnJvbSBgY3JlYXRlU2lnbmVkVXBsb2FkVXJsYC5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGZpbGUgbmFtZS4gU2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgYGZvbGRlci9zdWJmb2xkZXIvZmlsZW5hbWUucG5nYC4gVGhlIGJ1Y2tldCBtdXN0IGFscmVhZHkgZXhpc3QgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdXBsb2FkLlxuXHQqIEBwYXJhbSB0b2tlbiBUaGUgdG9rZW4gZ2VuZXJhdGVkIGZyb20gYGNyZWF0ZVNpZ25lZFVwbG9hZFVybGBcblx0KiBAcGFyYW0gZmlsZUJvZHkgVGhlIGJvZHkgb2YgdGhlIGZpbGUgdG8gYmUgc3RvcmVkIGluIHRoZSBidWNrZXQuXG5cdCogQHBhcmFtIGZpbGVPcHRpb25zIEhUVFAgaGVhZGVycyAoY2FjaGVDb250cm9sLCBjb250ZW50VHlwZSwgZXRjLikuXG5cdCogKipOb3RlOioqIFRoZSBgdXBzZXJ0YCBvcHRpb24gaGFzIG5vIGVmZmVjdCBoZXJlLiBUbyBlbmFibGUgdXBzZXJ0IGJlaGF2aW9yLFxuXHQqIHBhc3MgYHsgdXBzZXJ0OiB0cnVlIH1gIHdoZW4gY2FsbGluZyBgY3JlYXRlU2lnbmVkVXBsb2FkVXJsKClgIGluc3RlYWQuXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgZmlsZSBwYXRoIGFuZCBmdWxsUGF0aCBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgVXBsb2FkIHRvIGEgc2lnbmVkIFVSTFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAudXBsb2FkVG9TaWduZWRVcmwoJ2ZvbGRlci9jYXQuanBnJywgJ3Rva2VuLWZyb20tY3JlYXRlU2lnbmVkVXBsb2FkVXJsJywgZmlsZSlcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcInBhdGhcIjogXCJmb2xkZXIvY2F0LmpwZ1wiLFxuXHQqICAgICBcImZ1bGxQYXRoXCI6IFwiYXZhdGFycy9mb2xkZXIvY2F0LmpwZ1wiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyB1cGxvYWRUb1NpZ25lZFVybChwYXRoLCB0b2tlbiwgZmlsZUJvZHksIGZpbGVPcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cdFx0Y29uc3QgY2xlYW5QYXRoID0gX3RoaXMzLl9yZW1vdmVFbXB0eUZvbGRlcnMocGF0aCk7XG5cdFx0Y29uc3QgX3BhdGggPSBfdGhpczMuX2dldEZpbmFsUGF0aChjbGVhblBhdGgpO1xuXHRcdGNvbnN0IHVybCA9IG5ldyBVUkwoX3RoaXMzLnVybCArIGAvb2JqZWN0L3VwbG9hZC9zaWduLyR7X3BhdGh9YCk7XG5cdFx0dXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJ0b2tlblwiLCB0b2tlbik7XG5cdFx0cmV0dXJuIF90aGlzMy5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuXHRcdFx0bGV0IGJvZHk7XG5cdFx0XHRjb25zdCBvcHRpb25zID0gX29iamVjdFNwcmVhZDIoeyB1cHNlcnQ6IERFRkFVTFRfRklMRV9PUFRJT05TLnVwc2VydCB9LCBmaWxlT3B0aW9ucyk7XG5cdFx0XHRjb25zdCBoZWFkZXJzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIF90aGlzMy5oZWFkZXJzKSwgeyBcIngtdXBzZXJ0XCI6IFN0cmluZyhvcHRpb25zLnVwc2VydCkgfSk7XG5cdFx0XHRpZiAodHlwZW9mIEJsb2IgIT09IFwidW5kZWZpbmVkXCIgJiYgZmlsZUJvZHkgaW5zdGFuY2VvZiBCbG9iKSB7XG5cdFx0XHRcdGJvZHkgPSBuZXcgRm9ybURhdGEoKTtcblx0XHRcdFx0Ym9keS5hcHBlbmQoXCJjYWNoZUNvbnRyb2xcIiwgb3B0aW9ucy5jYWNoZUNvbnRyb2wpO1xuXHRcdFx0XHRib2R5LmFwcGVuZChcIlwiLCBmaWxlQm9keSk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBGb3JtRGF0YSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBmaWxlQm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG5cdFx0XHRcdGJvZHkgPSBmaWxlQm9keTtcblx0XHRcdFx0Ym9keS5hcHBlbmQoXCJjYWNoZUNvbnRyb2xcIiwgb3B0aW9ucy5jYWNoZUNvbnRyb2wpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ym9keSA9IGZpbGVCb2R5O1xuXHRcdFx0XHRoZWFkZXJzW1wiY2FjaGUtY29udHJvbFwiXSA9IGBtYXgtYWdlPSR7b3B0aW9ucy5jYWNoZUNvbnRyb2x9YDtcblx0XHRcdFx0aGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IG9wdGlvbnMuY29udGVudFR5cGU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRwYXRoOiBjbGVhblBhdGgsXG5cdFx0XHRcdGZ1bGxQYXRoOiAoYXdhaXQgcHV0KF90aGlzMy5mZXRjaCwgdXJsLnRvU3RyaW5nKCksIGJvZHksIHsgaGVhZGVycyB9KSkuS2V5XG5cdFx0XHR9O1xuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqIENyZWF0ZXMgYSBzaWduZWQgdXBsb2FkIFVSTC5cblx0KiBTaWduZWQgdXBsb2FkIFVSTHMgY2FuIGJlIHVzZWQgdG8gdXBsb2FkIGZpbGVzIHRvIHRoZSBidWNrZXQgd2l0aG91dCBmdXJ0aGVyIGF1dGhlbnRpY2F0aW9uLlxuXHQqIFRoZXkgYXJlIHZhbGlkIGZvciAyIGhvdXJzLlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cblx0KiBAcGFyYW0gb3B0aW9ucy51cHNlcnQgSWYgc2V0IHRvIHRydWUsIGFsbG93cyB0aGUgZmlsZSB0byBiZSBvdmVyd3JpdHRlbiBpZiBpdCBhbHJlYWR5IGV4aXN0cy5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBzaWduZWQgdXBsb2FkIFVSTCwgdG9rZW4sIGFuZCBwYXRoIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBDcmVhdGUgU2lnbmVkIFVwbG9hZCBVUkxcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmNyZWF0ZVNpZ25lZFVwbG9hZFVybCgnZm9sZGVyL2NhdC5qcGcnKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwic2lnbmVkVXJsXCI6IFwiaHR0cHM6Ly9leGFtcGxlLnN1cGFiYXNlLmNvL3N0b3JhZ2UvdjEvb2JqZWN0L3VwbG9hZC9zaWduL2F2YXRhcnMvZm9sZGVyL2NhdC5qcGc/dG9rZW49PFRPS0VOPlwiLFxuXHQqICAgICBcInBhdGhcIjogXCJmb2xkZXIvY2F0LmpwZ1wiLFxuXHQqICAgICBcInRva2VuXCI6IFwiPFRPS0VOPlwiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBjcmVhdGVTaWduZWRVcGxvYWRVcmwocGF0aCwgb3B0aW9ucykge1xuXHRcdHZhciBfdGhpczQgPSB0aGlzO1xuXHRcdHJldHVybiBfdGhpczQuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcblx0XHRcdGxldCBfcGF0aCA9IF90aGlzNC5fZ2V0RmluYWxQYXRoKHBhdGgpO1xuXHRcdFx0Y29uc3QgaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKHt9LCBfdGhpczQuaGVhZGVycyk7XG5cdFx0XHRpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnVwc2VydCkgaGVhZGVyc1tcIngtdXBzZXJ0XCJdID0gXCJ0cnVlXCI7XG5cdFx0XHRjb25zdCBkYXRhID0gYXdhaXQgcG9zdChfdGhpczQuZmV0Y2gsIGAke190aGlzNC51cmx9L29iamVjdC91cGxvYWQvc2lnbi8ke19wYXRofWAsIHt9LCB7IGhlYWRlcnMgfSk7XG5cdFx0XHRjb25zdCB1cmwgPSBuZXcgVVJMKF90aGlzNC51cmwgKyBkYXRhLnVybCk7XG5cdFx0XHRjb25zdCB0b2tlbiA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KFwidG9rZW5cIik7XG5cdFx0XHRpZiAoIXRva2VuKSB0aHJvdyBuZXcgU3RvcmFnZUVycm9yKFwiTm8gdG9rZW4gcmV0dXJuZWQgYnkgQVBJXCIpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0c2lnbmVkVXJsOiB1cmwudG9TdHJpbmcoKSxcblx0XHRcdFx0cGF0aCxcblx0XHRcdFx0dG9rZW5cblx0XHRcdH07XG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogUmVwbGFjZXMgYW4gZXhpc3RpbmcgZmlsZSBhdCB0aGUgc3BlY2lmaWVkIHBhdGggd2l0aCBhIG5ldyBvbmUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIHBhdGggVGhlIHJlbGF0aXZlIGZpbGUgcGF0aC4gU2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgYGZvbGRlci9zdWJmb2xkZXIvZmlsZW5hbWUucG5nYC4gVGhlIGJ1Y2tldCBtdXN0IGFscmVhZHkgZXhpc3QgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdXBkYXRlLlxuXHQqIEBwYXJhbSBmaWxlQm9keSBUaGUgYm9keSBvZiB0aGUgZmlsZSB0byBiZSBzdG9yZWQgaW4gdGhlIGJ1Y2tldC5cblx0KiBAcGFyYW0gZmlsZU9wdGlvbnMgT3B0aW9uYWwgZmlsZSB1cGxvYWQgb3B0aW9ucyBpbmNsdWRpbmcgY2FjaGVDb250cm9sLCBjb250ZW50VHlwZSwgdXBzZXJ0LCBhbmQgbWV0YWRhdGEuXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgZmlsZSBwYXRoLCBpZCwgYW5kIGZ1bGxQYXRoIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBVcGRhdGUgZmlsZVxuXHQqIGBgYGpzXG5cdCogY29uc3QgYXZhdGFyRmlsZSA9IGV2ZW50LnRhcmdldC5maWxlc1swXVxuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLnVwZGF0ZSgncHVibGljL2F2YXRhcjEucG5nJywgYXZhdGFyRmlsZSwge1xuXHQqICAgICBjYWNoZUNvbnRyb2w6ICczNjAwJyxcblx0KiAgICAgdXBzZXJ0OiB0cnVlXG5cdCogICB9KVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwicGF0aFwiOiBcInB1YmxpYy9hdmF0YXIxLnBuZ1wiLFxuXHQqICAgICBcImZ1bGxQYXRoXCI6IFwiYXZhdGFycy9wdWJsaWMvYXZhdGFyMS5wbmdcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIFVwZGF0ZSBmaWxlIHVzaW5nIGBBcnJheUJ1ZmZlcmAgZnJvbSBiYXNlNjQgZmlsZSBkYXRhXG5cdCogYGBganNcblx0KiBpbXBvcnQge2RlY29kZX0gZnJvbSAnYmFzZTY0LWFycmF5YnVmZmVyJ1xuXHQqXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAudXBkYXRlKCdwdWJsaWMvYXZhdGFyMS5wbmcnLCBkZWNvZGUoJ2Jhc2U2NEZpbGVEYXRhJyksIHtcblx0KiAgICAgY29udGVudFR5cGU6ICdpbWFnZS9wbmcnXG5cdCogICB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyB1cGRhdGUocGF0aCwgZmlsZUJvZHksIGZpbGVPcHRpb25zKSB7XG5cdFx0cmV0dXJuIHRoaXMudXBsb2FkT3JVcGRhdGUoXCJQVVRcIiwgcGF0aCwgZmlsZUJvZHksIGZpbGVPcHRpb25zKTtcblx0fVxuXHQvKipcblx0KiBNb3ZlcyBhbiBleGlzdGluZyBmaWxlIHRvIGEgbmV3IHBhdGggaW4gdGhlIHNhbWUgYnVja2V0LlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBmcm9tUGF0aCBUaGUgb3JpZ2luYWwgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG5cdCogQHBhcmFtIHRvUGF0aCBUaGUgbmV3IGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBuZXcgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLW5ldy5wbmdgLlxuXHQqIEBwYXJhbSBvcHRpb25zIFRoZSBkZXN0aW5hdGlvbiBvcHRpb25zLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIHN1Y2Nlc3MgbWVzc2FnZSBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgTW92ZSBmaWxlXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC5tb3ZlKCdwdWJsaWMvYXZhdGFyMS5wbmcnLCAncHJpdmF0ZS9hdmF0YXIyLnBuZycpXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJtZXNzYWdlXCI6IFwiU3VjY2Vzc2Z1bGx5IG1vdmVkXCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIG1vdmUoZnJvbVBhdGgsIHRvUGF0aCwgb3B0aW9ucykge1xuXHRcdHZhciBfdGhpczYgPSB0aGlzO1xuXHRcdHJldHVybiBfdGhpczYuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcblx0XHRcdHJldHVybiBhd2FpdCBwb3N0KF90aGlzNi5mZXRjaCwgYCR7X3RoaXM2LnVybH0vb2JqZWN0L21vdmVgLCB7XG5cdFx0XHRcdGJ1Y2tldElkOiBfdGhpczYuYnVja2V0SWQsXG5cdFx0XHRcdHNvdXJjZUtleTogZnJvbVBhdGgsXG5cdFx0XHRcdGRlc3RpbmF0aW9uS2V5OiB0b1BhdGgsXG5cdFx0XHRcdGRlc3RpbmF0aW9uQnVja2V0OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVzdGluYXRpb25CdWNrZXRcblx0XHRcdH0sIHsgaGVhZGVyczogX3RoaXM2LmhlYWRlcnMgfSk7XG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogQ29waWVzIGFuIGV4aXN0aW5nIGZpbGUgdG8gYSBuZXcgcGF0aCBpbiB0aGUgc2FtZSBidWNrZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIGZyb21QYXRoIFRoZSBvcmlnaW5hbCBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cblx0KiBAcGFyYW0gdG9QYXRoIFRoZSBuZXcgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIG5ldyBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UtY29weS5wbmdgLlxuXHQqIEBwYXJhbSBvcHRpb25zIFRoZSBkZXN0aW5hdGlvbiBvcHRpb25zLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGNvcGllZCBmaWxlIHBhdGggb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIENvcHkgZmlsZVxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAuY29weSgncHVibGljL2F2YXRhcjEucG5nJywgJ3ByaXZhdGUvYXZhdGFyMi5wbmcnKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwicGF0aFwiOiBcImF2YXRhcnMvcHJpdmF0ZS9hdmF0YXIyLnBuZ1wiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBjb3B5KGZyb21QYXRoLCB0b1BhdGgsIG9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXM3ID0gdGhpcztcblx0XHRyZXR1cm4gX3RoaXM3LmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG5cdFx0XHRyZXR1cm4geyBwYXRoOiAoYXdhaXQgcG9zdChfdGhpczcuZmV0Y2gsIGAke190aGlzNy51cmx9L29iamVjdC9jb3B5YCwge1xuXHRcdFx0XHRidWNrZXRJZDogX3RoaXM3LmJ1Y2tldElkLFxuXHRcdFx0XHRzb3VyY2VLZXk6IGZyb21QYXRoLFxuXHRcdFx0XHRkZXN0aW5hdGlvbktleTogdG9QYXRoLFxuXHRcdFx0XHRkZXN0aW5hdGlvbkJ1Y2tldDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRlc3RpbmF0aW9uQnVja2V0XG5cdFx0XHR9LCB7IGhlYWRlcnM6IF90aGlzNy5oZWFkZXJzIH0pKS5LZXkgfTtcblx0XHR9KTtcblx0fVxuXHQvKipcblx0KiBDcmVhdGVzIGEgc2lnbmVkIFVSTC4gVXNlIGEgc2lnbmVkIFVSTCB0byBzaGFyZSBhIGZpbGUgZm9yIGEgZml4ZWQgYW1vdW50IG9mIHRpbWUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIHBhdGggVGhlIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuXHQqIEBwYXJhbSBleHBpcmVzSW4gVGhlIG51bWJlciBvZiBzZWNvbmRzIHVudGlsIHRoZSBzaWduZWQgVVJMIGV4cGlyZXMuIEZvciBleGFtcGxlLCBgNjBgIGZvciBhIFVSTCB3aGljaCBpcyB2YWxpZCBmb3Igb25lIG1pbnV0ZS5cblx0KiBAcGFyYW0gb3B0aW9ucy5kb3dubG9hZCB0cmlnZ2VycyB0aGUgZmlsZSBhcyBhIGRvd25sb2FkIGlmIHNldCB0byB0cnVlLiBTZXQgdGhpcyBwYXJhbWV0ZXIgYXMgdGhlIG5hbWUgb2YgdGhlIGZpbGUgaWYgeW91IHdhbnQgdG8gdHJpZ2dlciB0aGUgZG93bmxvYWQgd2l0aCBhIGRpZmZlcmVudCBmaWxlbmFtZS5cblx0KiBAcGFyYW0gb3B0aW9ucy50cmFuc2Zvcm0gVHJhbnNmb3JtIHRoZSBhc3NldCBiZWZvcmUgc2VydmluZyBpdCB0byB0aGUgY2xpZW50LlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIHNpZ25lZCBVUkwgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIENyZWF0ZSBTaWduZWQgVVJMXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC5jcmVhdGVTaWduZWRVcmwoJ2ZvbGRlci9hdmF0YXIxLnBuZycsIDYwKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwic2lnbmVkVXJsXCI6IFwiaHR0cHM6Ly9leGFtcGxlLnN1cGFiYXNlLmNvL3N0b3JhZ2UvdjEvb2JqZWN0L3NpZ24vYXZhdGFycy9mb2xkZXIvYXZhdGFyMS5wbmc/dG9rZW49PFRPS0VOPlwiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqXG5cdCogQGV4YW1wbGUgQ3JlYXRlIGEgc2lnbmVkIFVSTCBmb3IgYW4gYXNzZXQgd2l0aCB0cmFuc2Zvcm1hdGlvbnNcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAuY3JlYXRlU2lnbmVkVXJsKCdmb2xkZXIvYXZhdGFyMS5wbmcnLCA2MCwge1xuXHQqICAgICB0cmFuc2Zvcm06IHtcblx0KiAgICAgICB3aWR0aDogMTAwLFxuXHQqICAgICAgIGhlaWdodDogMTAwLFxuXHQqICAgICB9XG5cdCogICB9KVxuXHQqIGBgYFxuXHQqXG5cdCogQGV4YW1wbGUgQ3JlYXRlIGEgc2lnbmVkIFVSTCB3aGljaCB0cmlnZ2VycyB0aGUgZG93bmxvYWQgb2YgdGhlIGFzc2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmNyZWF0ZVNpZ25lZFVybCgnZm9sZGVyL2F2YXRhcjEucG5nJywgNjAsIHtcblx0KiAgICAgZG93bmxvYWQ6IHRydWUsXG5cdCogICB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBjcmVhdGVTaWduZWRVcmwocGF0aCwgZXhwaXJlc0luLCBvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzOCA9IHRoaXM7XG5cdFx0cmV0dXJuIF90aGlzOC5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuXHRcdFx0bGV0IF9wYXRoID0gX3RoaXM4Ll9nZXRGaW5hbFBhdGgocGF0aCk7XG5cdFx0XHRsZXQgZGF0YSA9IGF3YWl0IHBvc3QoX3RoaXM4LmZldGNoLCBgJHtfdGhpczgudXJsfS9vYmplY3Qvc2lnbi8ke19wYXRofWAsIF9vYmplY3RTcHJlYWQyKHsgZXhwaXJlc0luIH0sIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSA/IHsgdHJhbnNmb3JtOiBvcHRpb25zLnRyYW5zZm9ybSB9IDoge30pLCB7IGhlYWRlcnM6IF90aGlzOC5oZWFkZXJzIH0pO1xuXHRcdFx0Y29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kb3dubG9hZCkgPyBgJmRvd25sb2FkPSR7b3B0aW9ucy5kb3dubG9hZCA9PT0gdHJ1ZSA/IFwiXCIgOiBvcHRpb25zLmRvd25sb2FkfWAgOiBcIlwiO1xuXHRcdFx0cmV0dXJuIHsgc2lnbmVkVXJsOiBlbmNvZGVVUkkoYCR7X3RoaXM4LnVybH0ke2RhdGEuc2lnbmVkVVJMfSR7ZG93bmxvYWRRdWVyeVBhcmFtfWApIH07XG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogQ3JlYXRlcyBtdWx0aXBsZSBzaWduZWQgVVJMcy4gVXNlIGEgc2lnbmVkIFVSTCB0byBzaGFyZSBhIGZpbGUgZm9yIGEgZml4ZWQgYW1vdW50IG9mIHRpbWUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIHBhdGhzIFRoZSBmaWxlIHBhdGhzIHRvIGJlIGRvd25sb2FkZWQsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWVzLiBGb3IgZXhhbXBsZSBgWydmb2xkZXIvaW1hZ2UucG5nJywgJ2ZvbGRlcjIvaW1hZ2UyLnBuZyddYC5cblx0KiBAcGFyYW0gZXhwaXJlc0luIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyB1bnRpbCB0aGUgc2lnbmVkIFVSTHMgZXhwaXJlLiBGb3IgZXhhbXBsZSwgYDYwYCBmb3IgVVJMcyB3aGljaCBhcmUgdmFsaWQgZm9yIG9uZSBtaW51dGUuXG5cdCogQHBhcmFtIG9wdGlvbnMuZG93bmxvYWQgdHJpZ2dlcnMgdGhlIGZpbGUgYXMgYSBkb3dubG9hZCBpZiBzZXQgdG8gdHJ1ZS4gU2V0IHRoaXMgcGFyYW1ldGVyIGFzIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGlmIHlvdSB3YW50IHRvIHRyaWdnZXIgdGhlIGRvd25sb2FkIHdpdGggYSBkaWZmZXJlbnQgZmlsZW5hbWUuXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHNpZ25lZFVybCwgcGF0aCwgYW5kIGVycm9yIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBDcmVhdGUgU2lnbmVkIFVSTHNcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmNyZWF0ZVNpZ25lZFVybHMoWydmb2xkZXIvYXZhdGFyMS5wbmcnLCAnZm9sZGVyL2F2YXRhcjIucG5nJ10sIDYwKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiBbXG5cdCogICAgIHtcblx0KiAgICAgICBcImVycm9yXCI6IG51bGwsXG5cdCogICAgICAgXCJwYXRoXCI6IFwiZm9sZGVyL2F2YXRhcjEucG5nXCIsXG5cdCogICAgICAgXCJzaWduZWRVUkxcIjogXCIvb2JqZWN0L3NpZ24vYXZhdGFycy9mb2xkZXIvYXZhdGFyMS5wbmc/dG9rZW49PFRPS0VOPlwiLFxuXHQqICAgICAgIFwic2lnbmVkVXJsXCI6IFwiaHR0cHM6Ly9leGFtcGxlLnN1cGFiYXNlLmNvL3N0b3JhZ2UvdjEvb2JqZWN0L3NpZ24vYXZhdGFycy9mb2xkZXIvYXZhdGFyMS5wbmc/dG9rZW49PFRPS0VOPlwiXG5cdCogICAgIH0sXG5cdCogICAgIHtcblx0KiAgICAgICBcImVycm9yXCI6IG51bGwsXG5cdCogICAgICAgXCJwYXRoXCI6IFwiZm9sZGVyL2F2YXRhcjIucG5nXCIsXG5cdCogICAgICAgXCJzaWduZWRVUkxcIjogXCIvb2JqZWN0L3NpZ24vYXZhdGFycy9mb2xkZXIvYXZhdGFyMi5wbmc/dG9rZW49PFRPS0VOPlwiLFxuXHQqICAgICAgIFwic2lnbmVkVXJsXCI6IFwiaHR0cHM6Ly9leGFtcGxlLnN1cGFiYXNlLmNvL3N0b3JhZ2UvdjEvb2JqZWN0L3NpZ24vYXZhdGFycy9mb2xkZXIvYXZhdGFyMi5wbmc/dG9rZW49PFRPS0VOPlwiXG5cdCogICAgIH1cblx0KiAgIF0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGNyZWF0ZVNpZ25lZFVybHMocGF0aHMsIGV4cGlyZXNJbiwgb3B0aW9ucykge1xuXHRcdHZhciBfdGhpczkgPSB0aGlzO1xuXHRcdHJldHVybiBfdGhpczkuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcblx0XHRcdGNvbnN0IGRhdGEgPSBhd2FpdCBwb3N0KF90aGlzOS5mZXRjaCwgYCR7X3RoaXM5LnVybH0vb2JqZWN0L3NpZ24vJHtfdGhpczkuYnVja2V0SWR9YCwge1xuXHRcdFx0XHRleHBpcmVzSW4sXG5cdFx0XHRcdHBhdGhzXG5cdFx0XHR9LCB7IGhlYWRlcnM6IF90aGlzOS5oZWFkZXJzIH0pO1xuXHRcdFx0Y29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kb3dubG9hZCkgPyBgJmRvd25sb2FkPSR7b3B0aW9ucy5kb3dubG9hZCA9PT0gdHJ1ZSA/IFwiXCIgOiBvcHRpb25zLmRvd25sb2FkfWAgOiBcIlwiO1xuXHRcdFx0cmV0dXJuIGRhdGEubWFwKChkYXR1bSkgPT4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGRhdHVtKSwge30sIHsgc2lnbmVkVXJsOiBkYXR1bS5zaWduZWRVUkwgPyBlbmNvZGVVUkkoYCR7X3RoaXM5LnVybH0ke2RhdHVtLnNpZ25lZFVSTH0ke2Rvd25sb2FkUXVlcnlQYXJhbX1gKSA6IG51bGwgfSkpO1xuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqIERvd25sb2FkcyBhIGZpbGUgZnJvbSBhIHByaXZhdGUgYnVja2V0LiBGb3IgcHVibGljIGJ1Y2tldHMsIG1ha2UgYSByZXF1ZXN0IHRvIHRoZSBVUkwgcmV0dXJuZWQgZnJvbSBgZ2V0UHVibGljVXJsYCBpbnN0ZWFkLlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBwYXRoIFRoZSBmdWxsIHBhdGggYW5kIGZpbGUgbmFtZSBvZiB0aGUgZmlsZSB0byBiZSBkb3dubG9hZGVkLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG5cdCogQHBhcmFtIG9wdGlvbnMudHJhbnNmb3JtIFRyYW5zZm9ybSB0aGUgYXNzZXQgYmVmb3JlIHNlcnZpbmcgaXQgdG8gdGhlIGNsaWVudC5cblx0KiBAcGFyYW0gcGFyYW1ldGVycyBBZGRpdGlvbmFsIGZldGNoIHBhcmFtZXRlcnMgbGlrZSBzaWduYWwgZm9yIGNhbmNlbGxhdGlvbi4gU3VwcG9ydHMgc3RhbmRhcmQgZmV0Y2ggb3B0aW9ucyBpbmNsdWRpbmcgY2FjaGUgY29udHJvbC5cblx0KiBAcmV0dXJucyBCbG9iRG93bmxvYWRCdWlsZGVyIGluc3RhbmNlIGZvciBkb3dubG9hZGluZyB0aGUgZmlsZVxuXHQqXG5cdCogQGV4YW1wbGUgRG93bmxvYWQgZmlsZVxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAuZG93bmxvYWQoJ2ZvbGRlci9hdmF0YXIxLnBuZycpXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IDxCTE9CPixcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIERvd25sb2FkIGZpbGUgd2l0aCB0cmFuc2Zvcm1hdGlvbnNcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmRvd25sb2FkKCdmb2xkZXIvYXZhdGFyMS5wbmcnLCB7XG5cdCogICAgIHRyYW5zZm9ybToge1xuXHQqICAgICAgIHdpZHRoOiAxMDAsXG5cdCogICAgICAgaGVpZ2h0OiAxMDAsXG5cdCogICAgICAgcXVhbGl0eTogODBcblx0KiAgICAgfVxuXHQqICAgfSlcblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIERvd25sb2FkIHdpdGggY2FjaGUgY29udHJvbCAodXNlZnVsIGluIEVkZ2UgRnVuY3Rpb25zKVxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAuZG93bmxvYWQoJ2ZvbGRlci9hdmF0YXIxLnBuZycsIHt9LCB7IGNhY2hlOiAnbm8tc3RvcmUnIH0pXG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBEb3dubG9hZCB3aXRoIGFib3J0IHNpZ25hbFxuXHQqIGBgYGpzXG5cdCogY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuXHQqIHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCA1MDAwKVxuXHQqXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAuZG93bmxvYWQoJ2ZvbGRlci9hdmF0YXIxLnBuZycsIHt9LCB7IHNpZ25hbDogY29udHJvbGxlci5zaWduYWwgfSlcblx0KiBgYGBcblx0Ki9cblx0ZG93bmxvYWQocGF0aCwgb3B0aW9ucywgcGFyYW1ldGVycykge1xuXHRcdGNvbnN0IHJlbmRlclBhdGggPSB0eXBlb2YgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc2Zvcm0pICE9PSBcInVuZGVmaW5lZFwiID8gXCJyZW5kZXIvaW1hZ2UvYXV0aGVudGljYXRlZFwiIDogXCJvYmplY3RcIjtcblx0XHRjb25zdCB0cmFuc2Zvcm1hdGlvblF1ZXJ5ID0gdGhpcy50cmFuc2Zvcm1PcHRzVG9RdWVyeVN0cmluZygob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYW5zZm9ybSkgfHwge30pO1xuXHRcdGNvbnN0IHF1ZXJ5U3RyaW5nID0gdHJhbnNmb3JtYXRpb25RdWVyeSA/IGA/JHt0cmFuc2Zvcm1hdGlvblF1ZXJ5fWAgOiBcIlwiO1xuXHRcdGNvbnN0IF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKHBhdGgpO1xuXHRcdGNvbnN0IGRvd25sb2FkRm4gPSAoKSA9PiBnZXQodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9LyR7cmVuZGVyUGF0aH0vJHtfcGF0aH0ke3F1ZXJ5U3RyaW5nfWAsIHtcblx0XHRcdGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcblx0XHRcdG5vUmVzb2x2ZUpzb246IHRydWVcblx0XHR9LCBwYXJhbWV0ZXJzKTtcblx0XHRyZXR1cm4gbmV3IEJsb2JEb3dubG9hZEJ1aWxkZXIoZG93bmxvYWRGbiwgdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpO1xuXHR9XG5cdC8qKlxuXHQqIFJldHJpZXZlcyB0aGUgZGV0YWlscyBvZiBhbiBleGlzdGluZyBmaWxlLlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgZmlsZSBtZXRhZGF0YSBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgR2V0IGZpbGUgaW5mb1xuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAuaW5mbygnZm9sZGVyL2F2YXRhcjEucG5nJylcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgaW5mbyhwYXRoKSB7XG5cdFx0dmFyIF90aGlzMTAgPSB0aGlzO1xuXHRcdGNvbnN0IF9wYXRoID0gX3RoaXMxMC5fZ2V0RmluYWxQYXRoKHBhdGgpO1xuXHRcdHJldHVybiBfdGhpczEwLmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG5cdFx0XHRyZXR1cm4gcmVjdXJzaXZlVG9DYW1lbChhd2FpdCBnZXQoX3RoaXMxMC5mZXRjaCwgYCR7X3RoaXMxMC51cmx9L29iamVjdC9pbmZvLyR7X3BhdGh9YCwgeyBoZWFkZXJzOiBfdGhpczEwLmhlYWRlcnMgfSkpO1xuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqIENoZWNrcyB0aGUgZXhpc3RlbmNlIG9mIGEgZmlsZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGJvb2xlYW4gaW5kaWNhdGluZyBmaWxlIGV4aXN0ZW5jZSBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgQ2hlY2sgZmlsZSBleGlzdGVuY2Vcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmV4aXN0cygnZm9sZGVyL2F2YXRhcjEucG5nJylcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgZXhpc3RzKHBhdGgpIHtcblx0XHR2YXIgX3RoaXMxMSA9IHRoaXM7XG5cdFx0Y29uc3QgX3BhdGggPSBfdGhpczExLl9nZXRGaW5hbFBhdGgocGF0aCk7XG5cdFx0dHJ5IHtcblx0XHRcdGF3YWl0IGhlYWQoX3RoaXMxMS5mZXRjaCwgYCR7X3RoaXMxMS51cmx9L29iamVjdC8ke19wYXRofWAsIHsgaGVhZGVyczogX3RoaXMxMS5oZWFkZXJzIH0pO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogdHJ1ZSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczExLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpICYmIGVycm9yIGluc3RhbmNlb2YgU3RvcmFnZVVua25vd25FcnJvcikge1xuXHRcdFx0XHRjb25zdCBvcmlnaW5hbEVycm9yID0gZXJyb3Iub3JpZ2luYWxFcnJvcjtcblx0XHRcdFx0aWYgKFs0MDAsIDQwNF0uaW5jbHVkZXMob3JpZ2luYWxFcnJvciA9PT0gbnVsbCB8fCBvcmlnaW5hbEVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbEVycm9yLnN0YXR1cykpIHJldHVybiB7XG5cdFx0XHRcdFx0ZGF0YTogZmFsc2UsXG5cdFx0XHRcdFx0ZXJyb3Jcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBBIHNpbXBsZSBjb252ZW5pZW5jZSBmdW5jdGlvbiB0byBnZXQgdGhlIFVSTCBmb3IgYW4gYXNzZXQgaW4gYSBwdWJsaWMgYnVja2V0LiBJZiB5b3UgZG8gbm90IHdhbnQgdG8gdXNlIHRoaXMgZnVuY3Rpb24sIHlvdSBjYW4gY29uc3RydWN0IHRoZSBwdWJsaWMgVVJMIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIGJ1Y2tldCBVUkwgd2l0aCB0aGUgcGF0aCB0byB0aGUgYXNzZXQuXG5cdCogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCB2ZXJpZnkgaWYgdGhlIGJ1Y2tldCBpcyBwdWJsaWMuIElmIGEgcHVibGljIFVSTCBpcyBjcmVhdGVkIGZvciBhIGJ1Y2tldCB3aGljaCBpcyBub3QgcHVibGljLCB5b3Ugd2lsbCBub3QgYmUgYWJsZSB0byBkb3dubG9hZCB0aGUgYXNzZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIHBhdGggVGhlIHBhdGggYW5kIG5hbWUgb2YgdGhlIGZpbGUgdG8gZ2VuZXJhdGUgdGhlIHB1YmxpYyBVUkwgZm9yLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG5cdCogQHBhcmFtIG9wdGlvbnMuZG93bmxvYWQgVHJpZ2dlcnMgdGhlIGZpbGUgYXMgYSBkb3dubG9hZCBpZiBzZXQgdG8gdHJ1ZS4gU2V0IHRoaXMgcGFyYW1ldGVyIGFzIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGlmIHlvdSB3YW50IHRvIHRyaWdnZXIgdGhlIGRvd25sb2FkIHdpdGggYSBkaWZmZXJlbnQgZmlsZW5hbWUuXG5cdCogQHBhcmFtIG9wdGlvbnMudHJhbnNmb3JtIFRyYW5zZm9ybSB0aGUgYXNzZXQgYmVmb3JlIHNlcnZpbmcgaXQgdG8gdGhlIGNsaWVudC5cblx0KiBAcmV0dXJucyBPYmplY3Qgd2l0aCBwdWJsaWMgVVJMXG5cdCpcblx0KiBAZXhhbXBsZSBSZXR1cm5zIHRoZSBVUkwgZm9yIGFuIGFzc2V0IGluIGEgcHVibGljIGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhIH0gPSBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdwdWJsaWMtYnVja2V0Jylcblx0KiAgIC5nZXRQdWJsaWNVcmwoJ2ZvbGRlci9hdmF0YXIxLnBuZycpXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJwdWJsaWNVcmxcIjogXCJodHRwczovL2V4YW1wbGUuc3VwYWJhc2UuY28vc3RvcmFnZS92MS9vYmplY3QvcHVibGljL3B1YmxpYy1idWNrZXQvZm9sZGVyL2F2YXRhcjEucG5nXCJcblx0KiAgIH1cblx0KiB9XG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBSZXR1cm5zIHRoZSBVUkwgZm9yIGFuIGFzc2V0IGluIGEgcHVibGljIGJ1Y2tldCB3aXRoIHRyYW5zZm9ybWF0aW9uc1xuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhIH0gPSBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdwdWJsaWMtYnVja2V0Jylcblx0KiAgIC5nZXRQdWJsaWNVcmwoJ2ZvbGRlci9hdmF0YXIxLnBuZycsIHtcblx0KiAgICAgdHJhbnNmb3JtOiB7XG5cdCogICAgICAgd2lkdGg6IDEwMCxcblx0KiAgICAgICBoZWlnaHQ6IDEwMCxcblx0KiAgICAgfVxuXHQqICAgfSlcblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIFJldHVybnMgdGhlIFVSTCB3aGljaCB0cmlnZ2VycyB0aGUgZG93bmxvYWQgb2YgYW4gYXNzZXQgaW4gYSBwdWJsaWMgYnVja2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEgfSA9IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ3B1YmxpYy1idWNrZXQnKVxuXHQqICAgLmdldFB1YmxpY1VybCgnZm9sZGVyL2F2YXRhcjEucG5nJywge1xuXHQqICAgICBkb3dubG9hZDogdHJ1ZSxcblx0KiAgIH0pXG5cdCogYGBgXG5cdCovXG5cdGdldFB1YmxpY1VybChwYXRoLCBvcHRpb25zKSB7XG5cdFx0Y29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aCk7XG5cdFx0Y29uc3QgX3F1ZXJ5U3RyaW5nID0gW107XG5cdFx0Y29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kb3dubG9hZCkgPyBgZG93bmxvYWQ9JHtvcHRpb25zLmRvd25sb2FkID09PSB0cnVlID8gXCJcIiA6IG9wdGlvbnMuZG93bmxvYWR9YCA6IFwiXCI7XG5cdFx0aWYgKGRvd25sb2FkUXVlcnlQYXJhbSAhPT0gXCJcIikgX3F1ZXJ5U3RyaW5nLnB1c2goZG93bmxvYWRRdWVyeVBhcmFtKTtcblx0XHRjb25zdCByZW5kZXJQYXRoID0gdHlwZW9mIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSAhPT0gXCJ1bmRlZmluZWRcIiA/IFwicmVuZGVyL2ltYWdlXCIgOiBcIm9iamVjdFwiO1xuXHRcdGNvbnN0IHRyYW5zZm9ybWF0aW9uUXVlcnkgPSB0aGlzLnRyYW5zZm9ybU9wdHNUb1F1ZXJ5U3RyaW5nKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSB8fCB7fSk7XG5cdFx0aWYgKHRyYW5zZm9ybWF0aW9uUXVlcnkgIT09IFwiXCIpIF9xdWVyeVN0cmluZy5wdXNoKHRyYW5zZm9ybWF0aW9uUXVlcnkpO1xuXHRcdGxldCBxdWVyeVN0cmluZyA9IF9xdWVyeVN0cmluZy5qb2luKFwiJlwiKTtcblx0XHRpZiAocXVlcnlTdHJpbmcgIT09IFwiXCIpIHF1ZXJ5U3RyaW5nID0gYD8ke3F1ZXJ5U3RyaW5nfWA7XG5cdFx0cmV0dXJuIHsgZGF0YTogeyBwdWJsaWNVcmw6IGVuY29kZVVSSShgJHt0aGlzLnVybH0vJHtyZW5kZXJQYXRofS9wdWJsaWMvJHtfcGF0aH0ke3F1ZXJ5U3RyaW5nfWApIH0gfTtcblx0fVxuXHQvKipcblx0KiBEZWxldGVzIGZpbGVzIHdpdGhpbiB0aGUgc2FtZSBidWNrZXRcblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aHMgQW4gYXJyYXkgb2YgZmlsZXMgdG8gZGVsZXRlLCBpbmNsdWRpbmcgdGhlIHBhdGggYW5kIGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgW2AnZm9sZGVyL2ltYWdlLnBuZydgXS5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBhcnJheSBvZiBkZWxldGVkIGZpbGUgb2JqZWN0cyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgRGVsZXRlIGZpbGVcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLnJlbW92ZShbJ2ZvbGRlci9hdmF0YXIxLnBuZyddKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiBbXSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgcmVtb3ZlKHBhdGhzKSB7XG5cdFx0dmFyIF90aGlzMTIgPSB0aGlzO1xuXHRcdHJldHVybiBfdGhpczEyLmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgcmVtb3ZlKF90aGlzMTIuZmV0Y2gsIGAke190aGlzMTIudXJsfS9vYmplY3QvJHtfdGhpczEyLmJ1Y2tldElkfWAsIHsgcHJlZml4ZXM6IHBhdGhzIH0sIHsgaGVhZGVyczogX3RoaXMxMi5oZWFkZXJzIH0pO1xuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqIEdldCBmaWxlIG1ldGFkYXRhXG5cdCogQHBhcmFtIGlkIHRoZSBmaWxlIGlkIHRvIHJldHJpZXZlIG1ldGFkYXRhXG5cdCovXG5cdC8qKlxuXHQqIFVwZGF0ZSBmaWxlIG1ldGFkYXRhXG5cdCogQHBhcmFtIGlkIHRoZSBmaWxlIGlkIHRvIHVwZGF0ZSBtZXRhZGF0YVxuXHQqIEBwYXJhbSBtZXRhIHRoZSBuZXcgZmlsZSBtZXRhZGF0YVxuXHQqL1xuXHQvKipcblx0KiBMaXN0cyBhbGwgdGhlIGZpbGVzIGFuZCBmb2xkZXJzIHdpdGhpbiBhIHBhdGggb2YgdGhlIGJ1Y2tldC5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgZm9sZGVyIHBhdGguXG5cdCogQHBhcmFtIG9wdGlvbnMgU2VhcmNoIG9wdGlvbnMgaW5jbHVkaW5nIGxpbWl0IChkZWZhdWx0cyB0byAxMDApLCBvZmZzZXQsIHNvcnRCeSwgYW5kIHNlYXJjaFxuXHQqIEBwYXJhbSBwYXJhbWV0ZXJzIE9wdGlvbmFsIGZldGNoIHBhcmFtZXRlcnMgaW5jbHVkaW5nIHNpZ25hbCBmb3IgY2FuY2VsbGF0aW9uXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgYXJyYXkgb2YgZmlsZXMgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIExpc3QgZmlsZXMgaW4gYSBidWNrZXRcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmxpc3QoJ2ZvbGRlcicsIHtcblx0KiAgICAgbGltaXQ6IDEwMCxcblx0KiAgICAgb2Zmc2V0OiAwLFxuXHQqICAgICBzb3J0Qnk6IHsgY29sdW1uOiAnbmFtZScsIG9yZGVyOiAnYXNjJyB9LFxuXHQqICAgfSlcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjogW1xuXHQqICAgICB7XG5cdCogICAgICAgXCJuYW1lXCI6IFwiYXZhdGFyMS5wbmdcIixcblx0KiAgICAgICBcImlkXCI6IFwiZTY2OGNmN2YtODIxYi00YTJmLTlkY2UtN2RmYTVkZDFjZmQyXCIsXG5cdCogICAgICAgXCJ1cGRhdGVkX2F0XCI6IFwiMjAyNC0wNS0yMlQyMzowNjowNS41ODBaXCIsXG5cdCogICAgICAgXCJjcmVhdGVkX2F0XCI6IFwiMjAyNC0wNS0yMlQyMzowNDozNC40NDNaXCIsXG5cdCogICAgICAgXCJsYXN0X2FjY2Vzc2VkX2F0XCI6IFwiMjAyNC0wNS0yMlQyMzowNDozNC40NDNaXCIsXG5cdCogICAgICAgXCJtZXRhZGF0YVwiOiB7XG5cdCogICAgICAgICBcImVUYWdcIjogXCJcXFwiYzVlOGM1NTMyMzVkOWFmMzBlZjRmNmUyODA3OTBiOTJcXFwiXCIsXG5cdCogICAgICAgICBcInNpemVcIjogMzIxNzUsXG5cdCogICAgICAgICBcIm1pbWV0eXBlXCI6IFwiaW1hZ2UvcG5nXCIsXG5cdCogICAgICAgICBcImNhY2hlQ29udHJvbFwiOiBcIm1heC1hZ2U9MzYwMFwiLFxuXHQqICAgICAgICAgXCJsYXN0TW9kaWZpZWRcIjogXCIyMDI0LTA1LTIyVDIzOjA2OjA1LjU3NFpcIixcblx0KiAgICAgICAgIFwiY29udGVudExlbmd0aFwiOiAzMjE3NSxcblx0KiAgICAgICAgIFwiaHR0cFN0YXR1c0NvZGVcIjogMjAwXG5cdCogICAgICAgfVxuXHQqICAgICB9XG5cdCogICBdLFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqXG5cdCogQGV4YW1wbGUgU2VhcmNoIGZpbGVzIGluIGEgYnVja2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC5saXN0KCdmb2xkZXInLCB7XG5cdCogICAgIGxpbWl0OiAxMDAsXG5cdCogICAgIG9mZnNldDogMCxcblx0KiAgICAgc29ydEJ5OiB7IGNvbHVtbjogJ25hbWUnLCBvcmRlcjogJ2FzYycgfSxcblx0KiAgICAgc2VhcmNoOiAnam9uJ1xuXHQqICAgfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgbGlzdChwYXRoLCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG5cdFx0dmFyIF90aGlzMTMgPSB0aGlzO1xuXHRcdHJldHVybiBfdGhpczEzLmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG5cdFx0XHRjb25zdCBib2R5ID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfU0VBUkNIX09QVElPTlMpLCBvcHRpb25zKSwge30sIHsgcHJlZml4OiBwYXRoIHx8IFwiXCIgfSk7XG5cdFx0XHRyZXR1cm4gYXdhaXQgcG9zdChfdGhpczEzLmZldGNoLCBgJHtfdGhpczEzLnVybH0vb2JqZWN0L2xpc3QvJHtfdGhpczEzLmJ1Y2tldElkfWAsIGJvZHksIHsgaGVhZGVyczogX3RoaXMxMy5oZWFkZXJzIH0sIHBhcmFtZXRlcnMpO1xuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqIEBleHBlcmltZW50YWwgdGhpcyBtZXRob2Qgc2lnbmF0dXJlIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgc2VhcmNoIG9wdGlvbnNcblx0KiBAcGFyYW0gcGFyYW1ldGVyc1xuXHQqL1xuXHRhc3luYyBsaXN0VjIob3B0aW9ucywgcGFyYW1ldGVycykge1xuXHRcdHZhciBfdGhpczE0ID0gdGhpcztcblx0XHRyZXR1cm4gX3RoaXMxNC5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuXHRcdFx0Y29uc3QgYm9keSA9IF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKTtcblx0XHRcdHJldHVybiBhd2FpdCBwb3N0KF90aGlzMTQuZmV0Y2gsIGAke190aGlzMTQudXJsfS9vYmplY3QvbGlzdC12Mi8ke190aGlzMTQuYnVja2V0SWR9YCwgYm9keSwgeyBoZWFkZXJzOiBfdGhpczE0LmhlYWRlcnMgfSwgcGFyYW1ldGVycyk7XG5cdFx0fSk7XG5cdH1cblx0ZW5jb2RlTWV0YWRhdGEobWV0YWRhdGEpIHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpO1xuXHR9XG5cdHRvQmFzZTY0KGRhdGEpIHtcblx0XHRpZiAodHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIEJ1ZmZlci5mcm9tKGRhdGEpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuXHRcdHJldHVybiBidG9hKGRhdGEpO1xuXHR9XG5cdF9nZXRGaW5hbFBhdGgocGF0aCkge1xuXHRcdHJldHVybiBgJHt0aGlzLmJ1Y2tldElkfS8ke3BhdGgucmVwbGFjZSgvXlxcLysvLCBcIlwiKX1gO1xuXHR9XG5cdF9yZW1vdmVFbXB0eUZvbGRlcnMocGF0aCkge1xuXHRcdHJldHVybiBwYXRoLnJlcGxhY2UoL15cXC98XFwvJC9nLCBcIlwiKS5yZXBsYWNlKC9cXC8rL2csIFwiL1wiKTtcblx0fVxuXHR0cmFuc2Zvcm1PcHRzVG9RdWVyeVN0cmluZyh0cmFuc2Zvcm0pIHtcblx0XHRjb25zdCBwYXJhbXMgPSBbXTtcblx0XHRpZiAodHJhbnNmb3JtLndpZHRoKSBwYXJhbXMucHVzaChgd2lkdGg9JHt0cmFuc2Zvcm0ud2lkdGh9YCk7XG5cdFx0aWYgKHRyYW5zZm9ybS5oZWlnaHQpIHBhcmFtcy5wdXNoKGBoZWlnaHQ9JHt0cmFuc2Zvcm0uaGVpZ2h0fWApO1xuXHRcdGlmICh0cmFuc2Zvcm0ucmVzaXplKSBwYXJhbXMucHVzaChgcmVzaXplPSR7dHJhbnNmb3JtLnJlc2l6ZX1gKTtcblx0XHRpZiAodHJhbnNmb3JtLmZvcm1hdCkgcGFyYW1zLnB1c2goYGZvcm1hdD0ke3RyYW5zZm9ybS5mb3JtYXR9YCk7XG5cdFx0aWYgKHRyYW5zZm9ybS5xdWFsaXR5KSBwYXJhbXMucHVzaChgcXVhbGl0eT0ke3RyYW5zZm9ybS5xdWFsaXR5fWApO1xuXHRcdHJldHVybiBwYXJhbXMuam9pbihcIiZcIik7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvdmVyc2lvbi50c1xuY29uc3QgdmVyc2lvbiA9IFwiMi45Ny4wXCI7XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvY29uc3RhbnRzLnRzXG5jb25zdCBERUZBVUxUX0hFQURFUlMgPSB7IFwiWC1DbGllbnQtSW5mb1wiOiBgc3RvcmFnZS1qcy8ke3ZlcnNpb259YCB9O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvcGFja2FnZXMvU3RvcmFnZUJ1Y2tldEFwaS50c1xudmFyIFN0b3JhZ2VCdWNrZXRBcGkgPSBjbGFzcyBleHRlbmRzIEJhc2VBcGlDbGllbnQge1xuXHRjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMgPSB7fSwgZmV0Y2gkMSwgb3B0cykge1xuXHRcdGNvbnN0IGJhc2VVcmwgPSBuZXcgVVJMKHVybCk7XG5cdFx0aWYgKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy51c2VOZXdIb3N0bmFtZSkge1xuXHRcdFx0aWYgKC9zdXBhYmFzZVxcLihjb3xpbnxyZWQpJC8udGVzdChiYXNlVXJsLmhvc3RuYW1lKSAmJiAhYmFzZVVybC5ob3N0bmFtZS5pbmNsdWRlcyhcInN0b3JhZ2Uuc3VwYWJhc2UuXCIpKSBiYXNlVXJsLmhvc3RuYW1lID0gYmFzZVVybC5ob3N0bmFtZS5yZXBsYWNlKFwic3VwYWJhc2UuXCIsIFwic3RvcmFnZS5zdXBhYmFzZS5cIik7XG5cdFx0fVxuXHRcdGNvbnN0IGZpbmFsVXJsID0gYmFzZVVybC5ocmVmLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcblx0XHRjb25zdCBmaW5hbEhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9IRUFERVJTKSwgaGVhZGVycyk7XG5cdFx0c3VwZXIoZmluYWxVcmwsIGZpbmFsSGVhZGVycywgZmV0Y2gkMSwgXCJzdG9yYWdlXCIpO1xuXHR9XG5cdC8qKlxuXHQqIFJldHJpZXZlcyB0aGUgZGV0YWlscyBvZiBhbGwgU3RvcmFnZSBidWNrZXRzIHdpdGhpbiBhbiBleGlzdGluZyBwcm9qZWN0LlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zIFF1ZXJ5IHBhcmFtZXRlcnMgZm9yIGxpc3RpbmcgYnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zLmxpbWl0IE1heGltdW0gbnVtYmVyIG9mIGJ1Y2tldHMgdG8gcmV0dXJuXG5cdCogQHBhcmFtIG9wdGlvbnMub2Zmc2V0IE51bWJlciBvZiBidWNrZXRzIHRvIHNraXBcblx0KiBAcGFyYW0gb3B0aW9ucy5zb3J0Q29sdW1uIENvbHVtbiB0byBzb3J0IGJ5ICgnaWQnLCAnbmFtZScsICdjcmVhdGVkX2F0JywgJ3VwZGF0ZWRfYXQnKVxuXHQqIEBwYXJhbSBvcHRpb25zLnNvcnRPcmRlciBTb3J0IG9yZGVyICgnYXNjJyBvciAnZGVzYycpXG5cdCogQHBhcmFtIG9wdGlvbnMuc2VhcmNoIFNlYXJjaCB0ZXJtIHRvIGZpbHRlciBidWNrZXQgbmFtZXNcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBhcnJheSBvZiBidWNrZXRzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBMaXN0IGJ1Y2tldHNcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmxpc3RCdWNrZXRzKClcblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIExpc3QgYnVja2V0cyB3aXRoIG9wdGlvbnNcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmxpc3RCdWNrZXRzKHtcblx0KiAgICAgbGltaXQ6IDEwLFxuXHQqICAgICBvZmZzZXQ6IDAsXG5cdCogICAgIHNvcnRDb2x1bW46ICdjcmVhdGVkX2F0Jyxcblx0KiAgICAgc29ydE9yZGVyOiAnZGVzYycsXG5cdCogICAgIHNlYXJjaDogJ3Byb2QnXG5cdCogICB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBsaXN0QnVja2V0cyhvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHRyZXR1cm4gX3RoaXMuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcblx0XHRcdGNvbnN0IHF1ZXJ5U3RyaW5nID0gX3RoaXMubGlzdEJ1Y2tldE9wdGlvbnNUb1F1ZXJ5U3RyaW5nKG9wdGlvbnMpO1xuXHRcdFx0cmV0dXJuIGF3YWl0IGdldChfdGhpcy5mZXRjaCwgYCR7X3RoaXMudXJsfS9idWNrZXQke3F1ZXJ5U3RyaW5nfWAsIHsgaGVhZGVyczogX3RoaXMuaGVhZGVycyB9KTtcblx0XHR9KTtcblx0fVxuXHQvKipcblx0KiBSZXRyaWV2ZXMgdGhlIGRldGFpbHMgb2YgYW4gZXhpc3RpbmcgU3RvcmFnZSBidWNrZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIHJldHJpZXZlLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGJ1Y2tldCBkZXRhaWxzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBHZXQgYnVja2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5nZXRCdWNrZXQoJ2F2YXRhcnMnKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwiaWRcIjogXCJhdmF0YXJzXCIsXG5cdCogICAgIFwibmFtZVwiOiBcImF2YXRhcnNcIixcblx0KiAgICAgXCJvd25lclwiOiBcIlwiLFxuXHQqICAgICBcInB1YmxpY1wiOiBmYWxzZSxcblx0KiAgICAgXCJmaWxlX3NpemVfbGltaXRcIjogMTAyNCxcblx0KiAgICAgXCJhbGxvd2VkX21pbWVfdHlwZXNcIjogW1xuXHQqICAgICAgIFwiaW1hZ2UvcG5nXCJcblx0KiAgICAgXSxcblx0KiAgICAgXCJjcmVhdGVkX2F0XCI6IFwiMjAyNC0wNS0yMlQyMjoyNjowNS4xMDBaXCIsXG5cdCogICAgIFwidXBkYXRlZF9hdFwiOiBcIjIwMjQtMDUtMjJUMjI6MjY6MDUuMTAwWlwiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBnZXRCdWNrZXQoaWQpIHtcblx0XHR2YXIgX3RoaXMyID0gdGhpcztcblx0XHRyZXR1cm4gX3RoaXMyLmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgZ2V0KF90aGlzMi5mZXRjaCwgYCR7X3RoaXMyLnVybH0vYnVja2V0LyR7aWR9YCwgeyBoZWFkZXJzOiBfdGhpczIuaGVhZGVycyB9KTtcblx0XHR9KTtcblx0fVxuXHQvKipcblx0KiBDcmVhdGVzIGEgbmV3IFN0b3JhZ2UgYnVja2V0XG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIGlkIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBidWNrZXQgeW91IGFyZSBjcmVhdGluZy5cblx0KiBAcGFyYW0gb3B0aW9ucy5wdWJsaWMgVGhlIHZpc2liaWxpdHkgb2YgdGhlIGJ1Y2tldC4gUHVibGljIGJ1Y2tldHMgZG9uJ3QgcmVxdWlyZSBhbiBhdXRob3JpemF0aW9uIHRva2VuIHRvIGRvd25sb2FkIG9iamVjdHMsIGJ1dCBzdGlsbCByZXF1aXJlIGEgdmFsaWQgdG9rZW4gZm9yIGFsbCBvdGhlciBvcGVyYXRpb25zLiBCeSBkZWZhdWx0LCBidWNrZXRzIGFyZSBwcml2YXRlLlxuXHQqIEBwYXJhbSBvcHRpb25zLmZpbGVTaXplTGltaXQgc3BlY2lmaWVzIHRoZSBtYXggZmlsZSBzaXplIGluIGJ5dGVzIHRoYXQgY2FuIGJlIHVwbG9hZGVkIHRvIHRoaXMgYnVja2V0LlxuXHQqIFRoZSBnbG9iYWwgZmlsZSBzaXplIGxpbWl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0aGlzIHZhbHVlLlxuXHQqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIG51bGwsIHdoaWNoIGRvZXNuJ3Qgc2V0IGEgcGVyIGJ1Y2tldCBmaWxlIHNpemUgbGltaXQuXG5cdCogQHBhcmFtIG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlcyBzcGVjaWZpZXMgdGhlIGFsbG93ZWQgbWltZSB0eXBlcyB0aGF0IHRoaXMgYnVja2V0IGNhbiBhY2NlcHQgZHVyaW5nIHVwbG9hZC5cblx0KiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsLCB3aGljaCBhbGxvd3MgZmlsZXMgd2l0aCBhbGwgbWltZSB0eXBlcyB0byBiZSB1cGxvYWRlZC5cblx0KiBFYWNoIG1pbWUgdHlwZSBzcGVjaWZpZWQgY2FuIGJlIGEgd2lsZGNhcmQsIGUuZy4gaW1hZ2UvKiwgb3IgYSBzcGVjaWZpYyBtaW1lIHR5cGUsIGUuZy4gaW1hZ2UvcG5nLlxuXHQqIEBwYXJhbSBvcHRpb25zLnR5cGUgKHByaXZhdGUtYmV0YSkgc3BlY2lmaWVzIHRoZSBidWNrZXQgdHlwZS4gc2VlIGBCdWNrZXRUeXBlYCBmb3IgbW9yZSBkZXRhaWxzLlxuXHQqICAgLSBkZWZhdWx0IGJ1Y2tldCB0eXBlIGlzIGBTVEFOREFSRGBcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBuZXdseSBjcmVhdGVkIGJ1Y2tldCBuYW1lIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBDcmVhdGUgYnVja2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5jcmVhdGVCdWNrZXQoJ2F2YXRhcnMnLCB7XG5cdCogICAgIHB1YmxpYzogZmFsc2UsXG5cdCogICAgIGFsbG93ZWRNaW1lVHlwZXM6IFsnaW1hZ2UvcG5nJ10sXG5cdCogICAgIGZpbGVTaXplTGltaXQ6IDEwMjRcblx0KiAgIH0pXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJuYW1lXCI6IFwiYXZhdGFyc1wiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBjcmVhdGVCdWNrZXQoaWQsIG9wdGlvbnMgPSB7IHB1YmxpYzogZmFsc2UgfSkge1xuXHRcdHZhciBfdGhpczMgPSB0aGlzO1xuXHRcdHJldHVybiBfdGhpczMuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcblx0XHRcdHJldHVybiBhd2FpdCBwb3N0KF90aGlzMy5mZXRjaCwgYCR7X3RoaXMzLnVybH0vYnVja2V0YCwge1xuXHRcdFx0XHRpZCxcblx0XHRcdFx0bmFtZTogaWQsXG5cdFx0XHRcdHR5cGU6IG9wdGlvbnMudHlwZSxcblx0XHRcdFx0cHVibGljOiBvcHRpb25zLnB1YmxpYyxcblx0XHRcdFx0ZmlsZV9zaXplX2xpbWl0OiBvcHRpb25zLmZpbGVTaXplTGltaXQsXG5cdFx0XHRcdGFsbG93ZWRfbWltZV90eXBlczogb3B0aW9ucy5hbGxvd2VkTWltZVR5cGVzXG5cdFx0XHR9LCB7IGhlYWRlcnM6IF90aGlzMy5oZWFkZXJzIH0pO1xuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqIFVwZGF0ZXMgYSBTdG9yYWdlIGJ1Y2tldFxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBpZCBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgYnVja2V0IHlvdSBhcmUgdXBkYXRpbmcuXG5cdCogQHBhcmFtIG9wdGlvbnMucHVibGljIFRoZSB2aXNpYmlsaXR5IG9mIHRoZSBidWNrZXQuIFB1YmxpYyBidWNrZXRzIGRvbid0IHJlcXVpcmUgYW4gYXV0aG9yaXphdGlvbiB0b2tlbiB0byBkb3dubG9hZCBvYmplY3RzLCBidXQgc3RpbGwgcmVxdWlyZSBhIHZhbGlkIHRva2VuIGZvciBhbGwgb3RoZXIgb3BlcmF0aW9ucy5cblx0KiBAcGFyYW0gb3B0aW9ucy5maWxlU2l6ZUxpbWl0IHNwZWNpZmllcyB0aGUgbWF4IGZpbGUgc2l6ZSBpbiBieXRlcyB0aGF0IGNhbiBiZSB1cGxvYWRlZCB0byB0aGlzIGJ1Y2tldC5cblx0KiBUaGUgZ2xvYmFsIGZpbGUgc2l6ZSBsaW1pdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhpcyB2YWx1ZS5cblx0KiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsLCB3aGljaCBkb2Vzbid0IHNldCBhIHBlciBidWNrZXQgZmlsZSBzaXplIGxpbWl0LlxuXHQqIEBwYXJhbSBvcHRpb25zLmFsbG93ZWRNaW1lVHlwZXMgc3BlY2lmaWVzIHRoZSBhbGxvd2VkIG1pbWUgdHlwZXMgdGhhdCB0aGlzIGJ1Y2tldCBjYW4gYWNjZXB0IGR1cmluZyB1cGxvYWQuXG5cdCogVGhlIGRlZmF1bHQgdmFsdWUgaXMgbnVsbCwgd2hpY2ggYWxsb3dzIGZpbGVzIHdpdGggYWxsIG1pbWUgdHlwZXMgdG8gYmUgdXBsb2FkZWQuXG5cdCogRWFjaCBtaW1lIHR5cGUgc3BlY2lmaWVkIGNhbiBiZSBhIHdpbGRjYXJkLCBlLmcuIGltYWdlLyosIG9yIGEgc3BlY2lmaWMgbWltZSB0eXBlLCBlLmcuIGltYWdlL3BuZy5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBzdWNjZXNzIG1lc3NhZ2Ugb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIFVwZGF0ZSBidWNrZXRcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLnVwZGF0ZUJ1Y2tldCgnYXZhdGFycycsIHtcblx0KiAgICAgcHVibGljOiBmYWxzZSxcblx0KiAgICAgYWxsb3dlZE1pbWVUeXBlczogWydpbWFnZS9wbmcnXSxcblx0KiAgICAgZmlsZVNpemVMaW1pdDogMTAyNFxuXHQqICAgfSlcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcIm1lc3NhZ2VcIjogXCJTdWNjZXNzZnVsbHkgdXBkYXRlZFwiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyB1cGRhdGVCdWNrZXQoaWQsIG9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXM0ID0gdGhpcztcblx0XHRyZXR1cm4gX3RoaXM0LmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgcHV0KF90aGlzNC5mZXRjaCwgYCR7X3RoaXM0LnVybH0vYnVja2V0LyR7aWR9YCwge1xuXHRcdFx0XHRpZCxcblx0XHRcdFx0bmFtZTogaWQsXG5cdFx0XHRcdHB1YmxpYzogb3B0aW9ucy5wdWJsaWMsXG5cdFx0XHRcdGZpbGVfc2l6ZV9saW1pdDogb3B0aW9ucy5maWxlU2l6ZUxpbWl0LFxuXHRcdFx0XHRhbGxvd2VkX21pbWVfdHlwZXM6IG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlc1xuXHRcdFx0fSwgeyBoZWFkZXJzOiBfdGhpczQuaGVhZGVycyB9KTtcblx0XHR9KTtcblx0fVxuXHQvKipcblx0KiBSZW1vdmVzIGFsbCBvYmplY3RzIGluc2lkZSBhIHNpbmdsZSBidWNrZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIGVtcHR5LlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBzdWNjZXNzIG1lc3NhZ2Ugb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIEVtcHR5IGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZW1wdHlCdWNrZXQoJ2F2YXRhcnMnKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwibWVzc2FnZVwiOiBcIlN1Y2Nlc3NmdWxseSBlbXB0aWVkXCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGVtcHR5QnVja2V0KGlkKSB7XG5cdFx0dmFyIF90aGlzNSA9IHRoaXM7XG5cdFx0cmV0dXJuIF90aGlzNS5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuXHRcdFx0cmV0dXJuIGF3YWl0IHBvc3QoX3RoaXM1LmZldGNoLCBgJHtfdGhpczUudXJsfS9idWNrZXQvJHtpZH0vZW1wdHlgLCB7fSwgeyBoZWFkZXJzOiBfdGhpczUuaGVhZGVycyB9KTtcblx0XHR9KTtcblx0fVxuXHQvKipcblx0KiBEZWxldGVzIGFuIGV4aXN0aW5nIGJ1Y2tldC4gQSBidWNrZXQgY2FuJ3QgYmUgZGVsZXRlZCB3aXRoIGV4aXN0aW5nIG9iamVjdHMgaW5zaWRlIGl0LlxuXHQqIFlvdSBtdXN0IGZpcnN0IGBlbXB0eSgpYCB0aGUgYnVja2V0LlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBpZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGJ1Y2tldCB5b3Ugd291bGQgbGlrZSB0byBkZWxldGUuXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHN1Y2Nlc3MgbWVzc2FnZSBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgRGVsZXRlIGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZGVsZXRlQnVja2V0KCdhdmF0YXJzJylcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcIm1lc3NhZ2VcIjogXCJTdWNjZXNzZnVsbHkgZGVsZXRlZFwiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBkZWxldGVCdWNrZXQoaWQpIHtcblx0XHR2YXIgX3RoaXM2ID0gdGhpcztcblx0XHRyZXR1cm4gX3RoaXM2LmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgcmVtb3ZlKF90aGlzNi5mZXRjaCwgYCR7X3RoaXM2LnVybH0vYnVja2V0LyR7aWR9YCwge30sIHsgaGVhZGVyczogX3RoaXM2LmhlYWRlcnMgfSk7XG5cdFx0fSk7XG5cdH1cblx0bGlzdEJ1Y2tldE9wdGlvbnNUb1F1ZXJ5U3RyaW5nKG9wdGlvbnMpIHtcblx0XHRjb25zdCBwYXJhbXMgPSB7fTtcblx0XHRpZiAob3B0aW9ucykge1xuXHRcdFx0aWYgKFwibGltaXRcIiBpbiBvcHRpb25zKSBwYXJhbXMubGltaXQgPSBTdHJpbmcob3B0aW9ucy5saW1pdCk7XG5cdFx0XHRpZiAoXCJvZmZzZXRcIiBpbiBvcHRpb25zKSBwYXJhbXMub2Zmc2V0ID0gU3RyaW5nKG9wdGlvbnMub2Zmc2V0KTtcblx0XHRcdGlmIChvcHRpb25zLnNlYXJjaCkgcGFyYW1zLnNlYXJjaCA9IG9wdGlvbnMuc2VhcmNoO1xuXHRcdFx0aWYgKG9wdGlvbnMuc29ydENvbHVtbikgcGFyYW1zLnNvcnRDb2x1bW4gPSBvcHRpb25zLnNvcnRDb2x1bW47XG5cdFx0XHRpZiAob3B0aW9ucy5zb3J0T3JkZXIpIHBhcmFtcy5zb3J0T3JkZXIgPSBvcHRpb25zLnNvcnRPcmRlcjtcblx0XHR9XG5cdFx0cmV0dXJuIE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID4gMCA/IFwiP1wiICsgbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbXMpLnRvU3RyaW5nKCkgOiBcIlwiO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvcGFja2FnZXMvU3RvcmFnZUFuYWx5dGljc0NsaWVudC50c1xuLyoqXG4qIENsaWVudCBjbGFzcyBmb3IgbWFuYWdpbmcgQW5hbHl0aWNzIEJ1Y2tldHMgdXNpbmcgSWNlYmVyZyB0YWJsZXNcbiogUHJvdmlkZXMgbWV0aG9kcyBmb3IgY3JlYXRpbmcsIGxpc3RpbmcsIGFuZCBkZWxldGluZyBhbmFseXRpY3MgYnVja2V0c1xuKi9cbnZhciBTdG9yYWdlQW5hbHl0aWNzQ2xpZW50ID0gY2xhc3MgZXh0ZW5kcyBCYXNlQXBpQ2xpZW50IHtcblx0LyoqXG5cdCogQGFscGhhXG5cdCpcblx0KiBDcmVhdGVzIGEgbmV3IFN0b3JhZ2VBbmFseXRpY3NDbGllbnQgaW5zdGFuY2Vcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgQW5hbHl0aWNzIEJ1Y2tldHNcblx0KiBAcGFyYW0gdXJsIC0gVGhlIGJhc2UgVVJMIGZvciB0aGUgc3RvcmFnZSBBUElcblx0KiBAcGFyYW0gaGVhZGVycyAtIEhUVFAgaGVhZGVycyB0byBpbmNsdWRlIGluIHJlcXVlc3RzXG5cdCogQHBhcmFtIGZldGNoIC0gT3B0aW9uYWwgY3VzdG9tIGZldGNoIGltcGxlbWVudGF0aW9uXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBjbGllbnQgPSBuZXcgU3RvcmFnZUFuYWx5dGljc0NsaWVudCh1cmwsIGhlYWRlcnMpXG5cdCogYGBgXG5cdCovXG5cdGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBmZXRjaCQxKSB7XG5cdFx0Y29uc3QgZmluYWxVcmwgPSB1cmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuXHRcdGNvbnN0IGZpbmFsSGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX0hFQURFUlMpLCBoZWFkZXJzKTtcblx0XHRzdXBlcihmaW5hbFVybCwgZmluYWxIZWFkZXJzLCBmZXRjaCQxLCBcInN0b3JhZ2VcIik7XG5cdH1cblx0LyoqXG5cdCogQGFscGhhXG5cdCpcblx0KiBDcmVhdGVzIGEgbmV3IGFuYWx5dGljcyBidWNrZXQgdXNpbmcgSWNlYmVyZyB0YWJsZXNcblx0KiBBbmFseXRpY3MgYnVja2V0cyBhcmUgb3B0aW1pemVkIGZvciBhbmFseXRpY2FsIHF1ZXJpZXMgYW5kIGRhdGEgcHJvY2Vzc2luZ1xuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBBbmFseXRpY3MgQnVja2V0c1xuXHQqIEBwYXJhbSBuYW1lIEEgdW5pcXVlIG5hbWUgZm9yIHRoZSBidWNrZXQgeW91IGFyZSBjcmVhdGluZ1xuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIG5ld2x5IGNyZWF0ZWQgYW5hbHl0aWNzIGJ1Y2tldCBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgQ3JlYXRlIGFuYWx5dGljcyBidWNrZXRcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmFuYWx5dGljc1xuXHQqICAgLmNyZWF0ZUJ1Y2tldCgnYW5hbHl0aWNzLWRhdGEnKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwibmFtZVwiOiBcImFuYWx5dGljcy1kYXRhXCIsXG5cdCogICAgIFwidHlwZVwiOiBcIkFOQUxZVElDU1wiLFxuXHQqICAgICBcImZvcm1hdFwiOiBcImljZWJlcmdcIixcblx0KiAgICAgXCJjcmVhdGVkX2F0XCI6IFwiMjAyNC0wNS0yMlQyMjoyNjowNS4xMDBaXCIsXG5cdCogICAgIFwidXBkYXRlZF9hdFwiOiBcIjIwMjQtMDUtMjJUMjI6MjY6MDUuMTAwWlwiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBjcmVhdGVCdWNrZXQobmFtZSkge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0cmV0dXJuIF90aGlzLmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgcG9zdChfdGhpcy5mZXRjaCwgYCR7X3RoaXMudXJsfS9idWNrZXRgLCB7IG5hbWUgfSwgeyBoZWFkZXJzOiBfdGhpcy5oZWFkZXJzIH0pO1xuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogUmV0cmlldmVzIHRoZSBkZXRhaWxzIG9mIGFsbCBBbmFseXRpY3MgU3RvcmFnZSBidWNrZXRzIHdpdGhpbiBhbiBleGlzdGluZyBwcm9qZWN0XG5cdCogT25seSByZXR1cm5zIGJ1Y2tldHMgb2YgdHlwZSAnQU5BTFlUSUNTJ1xuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBBbmFseXRpY3MgQnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zIFF1ZXJ5IHBhcmFtZXRlcnMgZm9yIGxpc3RpbmcgYnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zLmxpbWl0IE1heGltdW0gbnVtYmVyIG9mIGJ1Y2tldHMgdG8gcmV0dXJuXG5cdCogQHBhcmFtIG9wdGlvbnMub2Zmc2V0IE51bWJlciBvZiBidWNrZXRzIHRvIHNraXBcblx0KiBAcGFyYW0gb3B0aW9ucy5zb3J0Q29sdW1uIENvbHVtbiB0byBzb3J0IGJ5ICgnbmFtZScsICdjcmVhdGVkX2F0JywgJ3VwZGF0ZWRfYXQnKVxuXHQqIEBwYXJhbSBvcHRpb25zLnNvcnRPcmRlciBTb3J0IG9yZGVyICgnYXNjJyBvciAnZGVzYycpXG5cdCogQHBhcmFtIG9wdGlvbnMuc2VhcmNoIFNlYXJjaCB0ZXJtIHRvIGZpbHRlciBidWNrZXQgbmFtZXNcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBhcnJheSBvZiBhbmFseXRpY3MgYnVja2V0cyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgTGlzdCBhbmFseXRpY3MgYnVja2V0c1xuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuYW5hbHl0aWNzXG5cdCogICAubGlzdEJ1Y2tldHMoe1xuXHQqICAgICBsaW1pdDogMTAsXG5cdCogICAgIG9mZnNldDogMCxcblx0KiAgICAgc29ydENvbHVtbjogJ2NyZWF0ZWRfYXQnLFxuXHQqICAgICBzb3J0T3JkZXI6ICdkZXNjJ1xuXHQqICAgfSlcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjogW1xuXHQqICAgICB7XG5cdCogICAgICAgXCJuYW1lXCI6IFwiYW5hbHl0aWNzLWRhdGFcIixcblx0KiAgICAgICBcInR5cGVcIjogXCJBTkFMWVRJQ1NcIixcblx0KiAgICAgICBcImZvcm1hdFwiOiBcImljZWJlcmdcIixcblx0KiAgICAgICBcImNyZWF0ZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIyOjI2OjA1LjEwMFpcIixcblx0KiAgICAgICBcInVwZGF0ZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIyOjI2OjA1LjEwMFpcIlxuXHQqICAgICB9XG5cdCogICBdLFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBsaXN0QnVja2V0cyhvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzMiA9IHRoaXM7XG5cdFx0cmV0dXJuIF90aGlzMi5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuXHRcdFx0Y29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG5cdFx0XHRpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5saW1pdCkgIT09IHZvaWQgMCkgcXVlcnlQYXJhbXMuc2V0KFwibGltaXRcIiwgb3B0aW9ucy5saW1pdC50b1N0cmluZygpKTtcblx0XHRcdGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9mZnNldCkgIT09IHZvaWQgMCkgcXVlcnlQYXJhbXMuc2V0KFwib2Zmc2V0XCIsIG9wdGlvbnMub2Zmc2V0LnRvU3RyaW5nKCkpO1xuXHRcdFx0aWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zb3J0Q29sdW1uKSBxdWVyeVBhcmFtcy5zZXQoXCJzb3J0Q29sdW1uXCIsIG9wdGlvbnMuc29ydENvbHVtbik7XG5cdFx0XHRpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNvcnRPcmRlcikgcXVlcnlQYXJhbXMuc2V0KFwic29ydE9yZGVyXCIsIG9wdGlvbnMuc29ydE9yZGVyKTtcblx0XHRcdGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2VhcmNoKSBxdWVyeVBhcmFtcy5zZXQoXCJzZWFyY2hcIiwgb3B0aW9ucy5zZWFyY2gpO1xuXHRcdFx0Y29uc3QgcXVlcnlTdHJpbmcgPSBxdWVyeVBhcmFtcy50b1N0cmluZygpO1xuXHRcdFx0Y29uc3QgdXJsID0gcXVlcnlTdHJpbmcgPyBgJHtfdGhpczIudXJsfS9idWNrZXQ/JHtxdWVyeVN0cmluZ31gIDogYCR7X3RoaXMyLnVybH0vYnVja2V0YDtcblx0XHRcdHJldHVybiBhd2FpdCBnZXQoX3RoaXMyLmZldGNoLCB1cmwsIHsgaGVhZGVyczogX3RoaXMyLmhlYWRlcnMgfSk7XG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogQGFscGhhXG5cdCpcblx0KiBEZWxldGVzIGFuIGV4aXN0aW5nIGFuYWx5dGljcyBidWNrZXRcblx0KiBBIGJ1Y2tldCBjYW4ndCBiZSBkZWxldGVkIHdpdGggZXhpc3Rpbmcgb2JqZWN0cyBpbnNpZGUgaXRcblx0KiBZb3UgbXVzdCBmaXJzdCBlbXB0eSB0aGUgYnVja2V0IGJlZm9yZSBkZWxldGlvblxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBBbmFseXRpY3MgQnVja2V0c1xuXHQqIEBwYXJhbSBidWNrZXROYW1lIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIGRlbGV0ZVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIHN1Y2Nlc3MgbWVzc2FnZSBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgRGVsZXRlIGFuYWx5dGljcyBidWNrZXRcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmFuYWx5dGljc1xuXHQqICAgLmRlbGV0ZUJ1Y2tldCgnYW5hbHl0aWNzLWRhdGEnKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwibWVzc2FnZVwiOiBcIlN1Y2Nlc3NmdWxseSBkZWxldGVkXCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGRlbGV0ZUJ1Y2tldChidWNrZXROYW1lKSB7XG5cdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cdFx0cmV0dXJuIF90aGlzMy5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuXHRcdFx0cmV0dXJuIGF3YWl0IHJlbW92ZShfdGhpczMuZmV0Y2gsIGAke190aGlzMy51cmx9L2J1Y2tldC8ke2J1Y2tldE5hbWV9YCwge30sIHsgaGVhZGVyczogX3RoaXMzLmhlYWRlcnMgfSk7XG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogQGFscGhhXG5cdCpcblx0KiBHZXQgYW4gSWNlYmVyZyBSRVNUIENhdGFsb2cgY2xpZW50IGNvbmZpZ3VyZWQgZm9yIGEgc3BlY2lmaWMgYW5hbHl0aWNzIGJ1Y2tldFxuXHQqIFVzZSB0aGlzIHRvIHBlcmZvcm0gYWR2YW5jZWQgdGFibGUgYW5kIG5hbWVzcGFjZSBvcGVyYXRpb25zIHdpdGhpbiB0aGUgYnVja2V0XG5cdCogVGhlIHJldHVybmVkIGNsaWVudCBwcm92aWRlcyBmdWxsIGFjY2VzcyB0byB0aGUgQXBhY2hlIEljZWJlcmcgUkVTVCBDYXRhbG9nIEFQSVxuXHQqIHdpdGggdGhlIFN1cGFiYXNlIGB7IGRhdGEsIGVycm9yIH1gIHBhdHRlcm4gZm9yIGNvbnNpc3RlbnQgZXJyb3IgaGFuZGxpbmcgb24gYWxsIG9wZXJhdGlvbnMuXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IEFuYWx5dGljcyBCdWNrZXRzXG5cdCogQHBhcmFtIGJ1Y2tldE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgYW5hbHl0aWNzIGJ1Y2tldCAod2FyZWhvdXNlKSB0byBjb25uZWN0IHRvXG5cdCogQHJldHVybnMgVGhlIHdyYXBwZWQgSWNlYmVyZyBjYXRhbG9nIGNsaWVudFxuXHQqIEB0aHJvd3Mge1N0b3JhZ2VFcnJvcn0gSWYgdGhlIGJ1Y2tldCBuYW1lIGlzIGludmFsaWRcblx0KlxuXHQqIEBleGFtcGxlIEdldCBjYXRhbG9nIGFuZCBjcmVhdGUgdGFibGVcblx0KiBgYGBqc1xuXHQqIC8vIEZpcnN0LCBjcmVhdGUgYW4gYW5hbHl0aWNzIGJ1Y2tldFxuXHQqIGNvbnN0IHsgZGF0YTogYnVja2V0LCBlcnJvcjogYnVja2V0RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmFuYWx5dGljc1xuXHQqICAgLmNyZWF0ZUJ1Y2tldCgnYW5hbHl0aWNzLWRhdGEnKVxuXHQqXG5cdCogLy8gR2V0IHRoZSBJY2ViZXJnIGNhdGFsb2cgZm9yIHRoYXQgYnVja2V0XG5cdCogY29uc3QgY2F0YWxvZyA9IHN1cGFiYXNlLnN0b3JhZ2UuYW5hbHl0aWNzLmZyb20oJ2FuYWx5dGljcy1kYXRhJylcblx0KlxuXHQqIC8vIENyZWF0ZSBhIG5hbWVzcGFjZVxuXHQqIGNvbnN0IHsgZXJyb3I6IG5zRXJyb3IgfSA9IGF3YWl0IGNhdGFsb2cuY3JlYXRlTmFtZXNwYWNlKHsgbmFtZXNwYWNlOiBbJ2RlZmF1bHQnXSB9KVxuXHQqXG5cdCogLy8gQ3JlYXRlIGEgdGFibGUgd2l0aCBzY2hlbWFcblx0KiBjb25zdCB7IGRhdGE6IHRhYmxlTWV0YWRhdGEsIGVycm9yOiB0YWJsZUVycm9yIH0gPSBhd2FpdCBjYXRhbG9nLmNyZWF0ZVRhYmxlKFxuXHQqICAgeyBuYW1lc3BhY2U6IFsnZGVmYXVsdCddIH0sXG5cdCogICB7XG5cdCogICAgIG5hbWU6ICdldmVudHMnLFxuXHQqICAgICBzY2hlbWE6IHtcblx0KiAgICAgICB0eXBlOiAnc3RydWN0Jyxcblx0KiAgICAgICBmaWVsZHM6IFtcblx0KiAgICAgICAgIHsgaWQ6IDEsIG5hbWU6ICdpZCcsIHR5cGU6ICdsb25nJywgcmVxdWlyZWQ6IHRydWUgfSxcblx0KiAgICAgICAgIHsgaWQ6IDIsIG5hbWU6ICd0aW1lc3RhbXAnLCB0eXBlOiAndGltZXN0YW1wJywgcmVxdWlyZWQ6IHRydWUgfSxcblx0KiAgICAgICAgIHsgaWQ6IDMsIG5hbWU6ICd1c2VyX2lkJywgdHlwZTogJ3N0cmluZycsIHJlcXVpcmVkOiBmYWxzZSB9XG5cdCogICAgICAgXSxcblx0KiAgICAgICAnc2NoZW1hLWlkJzogMCxcblx0KiAgICAgICAnaWRlbnRpZmllci1maWVsZC1pZHMnOiBbMV1cblx0KiAgICAgfSxcblx0KiAgICAgJ3BhcnRpdGlvbi1zcGVjJzoge1xuXHQqICAgICAgICdzcGVjLWlkJzogMCxcblx0KiAgICAgICBmaWVsZHM6IFtdXG5cdCogICAgIH0sXG5cdCogICAgICd3cml0ZS1vcmRlcic6IHtcblx0KiAgICAgICAnb3JkZXItaWQnOiAwLFxuXHQqICAgICAgIGZpZWxkczogW11cblx0KiAgICAgfSxcblx0KiAgICAgcHJvcGVydGllczoge1xuXHQqICAgICAgICd3cml0ZS5mb3JtYXQuZGVmYXVsdCc6ICdwYXJxdWV0J1xuXHQqICAgICB9XG5cdCogICB9XG5cdCogKVxuXHQqIGBgYFxuXHQqXG5cdCogQGV4YW1wbGUgTGlzdCB0YWJsZXMgaW4gbmFtZXNwYWNlXG5cdCogYGBganNcblx0KiBjb25zdCBjYXRhbG9nID0gc3VwYWJhc2Uuc3RvcmFnZS5hbmFseXRpY3MuZnJvbSgnYW5hbHl0aWNzLWRhdGEnKVxuXHQqXG5cdCogLy8gTGlzdCBhbGwgdGFibGVzIGluIHRoZSBkZWZhdWx0IG5hbWVzcGFjZVxuXHQqIGNvbnN0IHsgZGF0YTogdGFibGVzLCBlcnJvcjogbGlzdEVycm9yIH0gPSBhd2FpdCBjYXRhbG9nLmxpc3RUYWJsZXMoeyBuYW1lc3BhY2U6IFsnZGVmYXVsdCddIH0pXG5cdCogaWYgKGxpc3RFcnJvcikge1xuXHQqICAgaWYgKGxpc3RFcnJvci5pc05vdEZvdW5kKCkpIHtcblx0KiAgICAgY29uc29sZS5sb2coJ05hbWVzcGFjZSBub3QgZm91bmQnKVxuXHQqICAgfVxuXHQqICAgcmV0dXJuXG5cdCogfVxuXHQqIGNvbnNvbGUubG9nKHRhYmxlcykgLy8gW3sgbmFtZXNwYWNlOiBbJ2RlZmF1bHQnXSwgbmFtZTogJ2V2ZW50cycgfV1cblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIFdvcmtpbmcgd2l0aCBuYW1lc3BhY2VzXG5cdCogYGBganNcblx0KiBjb25zdCBjYXRhbG9nID0gc3VwYWJhc2Uuc3RvcmFnZS5hbmFseXRpY3MuZnJvbSgnYW5hbHl0aWNzLWRhdGEnKVxuXHQqXG5cdCogLy8gTGlzdCBhbGwgbmFtZXNwYWNlc1xuXHQqIGNvbnN0IHsgZGF0YTogbmFtZXNwYWNlcyB9ID0gYXdhaXQgY2F0YWxvZy5saXN0TmFtZXNwYWNlcygpXG5cdCpcblx0KiAvLyBDcmVhdGUgbmFtZXNwYWNlIHdpdGggcHJvcGVydGllc1xuXHQqIGF3YWl0IGNhdGFsb2cuY3JlYXRlTmFtZXNwYWNlKFxuXHQqICAgeyBuYW1lc3BhY2U6IFsncHJvZHVjdGlvbiddIH0sXG5cdCogICB7IHByb3BlcnRpZXM6IHsgb3duZXI6ICdkYXRhLXRlYW0nLCBlbnY6ICdwcm9kJyB9IH1cblx0KiApXG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBDbGVhbnVwIG9wZXJhdGlvbnNcblx0KiBgYGBqc1xuXHQqIGNvbnN0IGNhdGFsb2cgPSBzdXBhYmFzZS5zdG9yYWdlLmFuYWx5dGljcy5mcm9tKCdhbmFseXRpY3MtZGF0YScpXG5cdCpcblx0KiAvLyBEcm9wIHRhYmxlIHdpdGggcHVyZ2Ugb3B0aW9uIChyZW1vdmVzIGFsbCBkYXRhKVxuXHQqIGNvbnN0IHsgZXJyb3I6IGRyb3BFcnJvciB9ID0gYXdhaXQgY2F0YWxvZy5kcm9wVGFibGUoXG5cdCogICB7IG5hbWVzcGFjZTogWydkZWZhdWx0J10sIG5hbWU6ICdldmVudHMnIH0sXG5cdCogICB7IHB1cmdlOiB0cnVlIH1cblx0KiApXG5cdCpcblx0KiBpZiAoZHJvcEVycm9yPy5pc05vdEZvdW5kKCkpIHtcblx0KiAgIGNvbnNvbGUubG9nKCdUYWJsZSBkb2VzIG5vdCBleGlzdCcpXG5cdCogfVxuXHQqXG5cdCogLy8gRHJvcCBuYW1lc3BhY2UgKG11c3QgYmUgZW1wdHkpXG5cdCogYXdhaXQgY2F0YWxvZy5kcm9wTmFtZXNwYWNlKHsgbmFtZXNwYWNlOiBbJ2RlZmF1bHQnXSB9KVxuXHQqIGBgYFxuXHQqXG5cdCogQHJlbWFya3Ncblx0KiBUaGlzIG1ldGhvZCBwcm92aWRlcyBhIGJyaWRnZSBiZXR3ZWVuIFN1cGFiYXNlJ3MgYnVja2V0IG1hbmFnZW1lbnQgYW5kIHRoZSBzdGFuZGFyZFxuXHQqIEFwYWNoZSBJY2ViZXJnIFJFU1QgQ2F0YWxvZyBBUEkuIFRoZSBidWNrZXQgbmFtZSBtYXBzIHRvIHRoZSBJY2ViZXJnIHdhcmVob3VzZSBwYXJhbWV0ZXIuXG5cdCogQWxsIGF1dGhlbnRpY2F0aW9uIGFuZCBjb25maWd1cmF0aW9uIGlzIGhhbmRsZWQgYXV0b21hdGljYWxseSB1c2luZyB5b3VyIFN1cGFiYXNlIGNyZWRlbnRpYWxzLlxuXHQqXG5cdCogKipFcnJvciBIYW5kbGluZyoqOiBJbnZhbGlkIGJ1Y2tldCBuYW1lcyB0aHJvdyBpbW1lZGlhdGVseS4gQWxsIGNhdGFsb2dcblx0KiBvcGVyYXRpb25zIHJldHVybiBgeyBkYXRhLCBlcnJvciB9YCB3aGVyZSBlcnJvcnMgYXJlIGBJY2ViZXJnRXJyb3JgIGluc3RhbmNlcyBmcm9tIGljZWJlcmctanMuXG5cdCogVXNlIGhlbHBlciBtZXRob2RzIGxpa2UgYGVycm9yLmlzTm90Rm91bmQoKWAgb3IgY2hlY2sgYGVycm9yLnN0YXR1c2AgZm9yIHNwZWNpZmljIGVycm9yIGhhbmRsaW5nLlxuXHQqIFVzZSBgLnRocm93T25FcnJvcigpYCBvbiB0aGUgYW5hbHl0aWNzIGNsaWVudCBpZiB5b3UgcHJlZmVyIGV4Y2VwdGlvbnMgZm9yIGNhdGFsb2cgb3BlcmF0aW9ucy5cblx0KlxuXHQqICoqQ2xlYW51cCBPcGVyYXRpb25zKio6IFdoZW4gdXNpbmcgYGRyb3BUYWJsZWAsIHRoZSBgcHVyZ2U6IHRydWVgIG9wdGlvbiBwZXJtYW5lbnRseVxuXHQqIGRlbGV0ZXMgYWxsIHRhYmxlIGRhdGEuIFdpdGhvdXQgaXQsIHRoZSB0YWJsZSBpcyBtYXJrZWQgYXMgZGVsZXRlZCBidXQgZGF0YSByZW1haW5zLlxuXHQqXG5cdCogKipMaWJyYXJ5IERlcGVuZGVuY3kqKjogVGhlIHJldHVybmVkIGNhdGFsb2cgd3JhcHMgYEljZWJlcmdSZXN0Q2F0YWxvZ2AgZnJvbSBpY2ViZXJnLWpzLlxuXHQqIEZvciBjb21wbGV0ZSBBUEkgZG9jdW1lbnRhdGlvbiBhbmQgYWR2YW5jZWQgdXNhZ2UsIHJlZmVyIHRvIHRoZVxuXHQqIFtpY2ViZXJnLWpzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vc3VwYWJhc2UuZ2l0aHViLmlvL2ljZWJlcmctanMvKS5cblx0Ki9cblx0ZnJvbShidWNrZXROYW1lKSB7XG5cdFx0dmFyIF90aGlzNCA9IHRoaXM7XG5cdFx0aWYgKCFpc1ZhbGlkQnVja2V0TmFtZShidWNrZXROYW1lKSkgdGhyb3cgbmV3IFN0b3JhZ2VFcnJvcihcIkludmFsaWQgYnVja2V0IG5hbWU6IEZpbGUsIGZvbGRlciwgYW5kIGJ1Y2tldCBuYW1lcyBtdXN0IGZvbGxvdyBBV1Mgb2JqZWN0IGtleSBuYW1pbmcgZ3VpZGVsaW5lcyBhbmQgc2hvdWxkIGF2b2lkIHRoZSB1c2Ugb2YgYW55IG90aGVyIGNoYXJhY3RlcnMuXCIpO1xuXHRcdGNvbnN0IGNhdGFsb2cgPSBuZXcgSWNlYmVyZ1Jlc3RDYXRhbG9nKHtcblx0XHRcdGJhc2VVcmw6IHRoaXMudXJsLFxuXHRcdFx0Y2F0YWxvZ05hbWU6IGJ1Y2tldE5hbWUsXG5cdFx0XHRhdXRoOiB7XG5cdFx0XHRcdHR5cGU6IFwiY3VzdG9tXCIsXG5cdFx0XHRcdGdldEhlYWRlcnM6IGFzeW5jICgpID0+IF90aGlzNC5oZWFkZXJzXG5cdFx0XHR9LFxuXHRcdFx0ZmV0Y2g6IHRoaXMuZmV0Y2hcblx0XHR9KTtcblx0XHRjb25zdCBzaG91bGRUaHJvd09uRXJyb3IgPSB0aGlzLnNob3VsZFRocm93T25FcnJvcjtcblx0XHRyZXR1cm4gbmV3IFByb3h5KGNhdGFsb2csIHsgZ2V0KHRhcmdldCwgcHJvcCkge1xuXHRcdFx0Y29uc3QgdmFsdWUgPSB0YXJnZXRbcHJvcF07XG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiB2YWx1ZTtcblx0XHRcdHJldHVybiBhc3luYyAoLi4uYXJncykgPT4ge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRkYXRhOiBhd2FpdCB2YWx1ZS5hcHBseSh0YXJnZXQsIGFyZ3MpLFxuXHRcdFx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdGlmIChzaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRcdFx0ZXJyb3Jcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0gfSk7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9wYWNrYWdlcy9WZWN0b3JJbmRleEFwaS50c1xuLyoqXG4qIEBoaWRkZW5cbiogQmFzZSBpbXBsZW1lbnRhdGlvbiBmb3IgdmVjdG9yIGluZGV4IG9wZXJhdGlvbnMuXG4qIFVzZSB7QGxpbmsgVmVjdG9yQnVja2V0U2NvcGV9IHZpYSBgc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2J1Y2tldCcpYCBpbnN0ZWFkLlxuKi9cbnZhciBWZWN0b3JJbmRleEFwaSA9IGNsYXNzIGV4dGVuZHMgQmFzZUFwaUNsaWVudCB7XG5cdC8qKiBDcmVhdGVzIGEgbmV3IFZlY3RvckluZGV4QXBpIGluc3RhbmNlICovXG5cdGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBmZXRjaCQxKSB7XG5cdFx0Y29uc3QgZmluYWxVcmwgPSB1cmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuXHRcdGNvbnN0IGZpbmFsSGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX0hFQURFUlMpLCB7fSwgeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LCBoZWFkZXJzKTtcblx0XHRzdXBlcihmaW5hbFVybCwgZmluYWxIZWFkZXJzLCBmZXRjaCQxLCBcInZlY3RvcnNcIik7XG5cdH1cblx0LyoqIENyZWF0ZXMgYSBuZXcgdmVjdG9yIGluZGV4IHdpdGhpbiBhIGJ1Y2tldCAqL1xuXHRhc3luYyBjcmVhdGVJbmRleChvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHRyZXR1cm4gX3RoaXMuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcblx0XHRcdHJldHVybiBhd2FpdCB2ZWN0b3JzQXBpLnBvc3QoX3RoaXMuZmV0Y2gsIGAke190aGlzLnVybH0vQ3JlYXRlSW5kZXhgLCBvcHRpb25zLCB7IGhlYWRlcnM6IF90aGlzLmhlYWRlcnMgfSkgfHwge307XG5cdFx0fSk7XG5cdH1cblx0LyoqIFJldHJpZXZlcyBtZXRhZGF0YSBmb3IgYSBzcGVjaWZpYyB2ZWN0b3IgaW5kZXggKi9cblx0YXN5bmMgZ2V0SW5kZXgodmVjdG9yQnVja2V0TmFtZSwgaW5kZXhOYW1lKSB7XG5cdFx0dmFyIF90aGlzMiA9IHRoaXM7XG5cdFx0cmV0dXJuIF90aGlzMi5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuXHRcdFx0cmV0dXJuIGF3YWl0IHZlY3RvcnNBcGkucG9zdChfdGhpczIuZmV0Y2gsIGAke190aGlzMi51cmx9L0dldEluZGV4YCwge1xuXHRcdFx0XHR2ZWN0b3JCdWNrZXROYW1lLFxuXHRcdFx0XHRpbmRleE5hbWVcblx0XHRcdH0sIHsgaGVhZGVyczogX3RoaXMyLmhlYWRlcnMgfSk7XG5cdFx0fSk7XG5cdH1cblx0LyoqIExpc3RzIHZlY3RvciBpbmRleGVzIHdpdGhpbiBhIGJ1Y2tldCB3aXRoIG9wdGlvbmFsIGZpbHRlcmluZyBhbmQgcGFnaW5hdGlvbiAqL1xuXHRhc3luYyBsaXN0SW5kZXhlcyhvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cdFx0cmV0dXJuIF90aGlzMy5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuXHRcdFx0cmV0dXJuIGF3YWl0IHZlY3RvcnNBcGkucG9zdChfdGhpczMuZmV0Y2gsIGAke190aGlzMy51cmx9L0xpc3RJbmRleGVzYCwgb3B0aW9ucywgeyBoZWFkZXJzOiBfdGhpczMuaGVhZGVycyB9KTtcblx0XHR9KTtcblx0fVxuXHQvKiogRGVsZXRlcyBhIHZlY3RvciBpbmRleCBhbmQgYWxsIGl0cyBkYXRhICovXG5cdGFzeW5jIGRlbGV0ZUluZGV4KHZlY3RvckJ1Y2tldE5hbWUsIGluZGV4TmFtZSkge1xuXHRcdHZhciBfdGhpczQgPSB0aGlzO1xuXHRcdHJldHVybiBfdGhpczQuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcblx0XHRcdHJldHVybiBhd2FpdCB2ZWN0b3JzQXBpLnBvc3QoX3RoaXM0LmZldGNoLCBgJHtfdGhpczQudXJsfS9EZWxldGVJbmRleGAsIHtcblx0XHRcdFx0dmVjdG9yQnVja2V0TmFtZSxcblx0XHRcdFx0aW5kZXhOYW1lXG5cdFx0XHR9LCB7IGhlYWRlcnM6IF90aGlzNC5oZWFkZXJzIH0pIHx8IHt9O1xuXHRcdH0pO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvcGFja2FnZXMvVmVjdG9yRGF0YUFwaS50c1xuLyoqXG4qIEBoaWRkZW5cbiogQmFzZSBpbXBsZW1lbnRhdGlvbiBmb3IgdmVjdG9yIGRhdGEgb3BlcmF0aW9ucy5cbiogVXNlIHtAbGluayBWZWN0b3JJbmRleFNjb3BlfSB2aWEgYHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdidWNrZXQnKS5pbmRleCgnaWR4JylgIGluc3RlYWQuXG4qL1xudmFyIFZlY3RvckRhdGFBcGkgPSBjbGFzcyBleHRlbmRzIEJhc2VBcGlDbGllbnQge1xuXHQvKiogQ3JlYXRlcyBhIG5ldyBWZWN0b3JEYXRhQXBpIGluc3RhbmNlICovXG5cdGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBmZXRjaCQxKSB7XG5cdFx0Y29uc3QgZmluYWxVcmwgPSB1cmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuXHRcdGNvbnN0IGZpbmFsSGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX0hFQURFUlMpLCB7fSwgeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LCBoZWFkZXJzKTtcblx0XHRzdXBlcihmaW5hbFVybCwgZmluYWxIZWFkZXJzLCBmZXRjaCQxLCBcInZlY3RvcnNcIik7XG5cdH1cblx0LyoqIEluc2VydHMgb3IgdXBkYXRlcyB2ZWN0b3JzIGluIGJhdGNoICgxLTUwMCBwZXIgcmVxdWVzdCkgKi9cblx0YXN5bmMgcHV0VmVjdG9ycyhvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHRpZiAob3B0aW9ucy52ZWN0b3JzLmxlbmd0aCA8IDEgfHwgb3B0aW9ucy52ZWN0b3JzLmxlbmd0aCA+IDUwMCkgdGhyb3cgbmV3IEVycm9yKFwiVmVjdG9yIGJhdGNoIHNpemUgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDUwMCBpdGVtc1wiKTtcblx0XHRyZXR1cm4gX3RoaXMuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcblx0XHRcdHJldHVybiBhd2FpdCB2ZWN0b3JzQXBpLnBvc3QoX3RoaXMuZmV0Y2gsIGAke190aGlzLnVybH0vUHV0VmVjdG9yc2AsIG9wdGlvbnMsIHsgaGVhZGVyczogX3RoaXMuaGVhZGVycyB9KSB8fCB7fTtcblx0XHR9KTtcblx0fVxuXHQvKiogUmV0cmlldmVzIHZlY3RvcnMgYnkgdGhlaXIga2V5cyBpbiBiYXRjaCAqL1xuXHRhc3luYyBnZXRWZWN0b3JzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXMyID0gdGhpcztcblx0XHRyZXR1cm4gX3RoaXMyLmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgdmVjdG9yc0FwaS5wb3N0KF90aGlzMi5mZXRjaCwgYCR7X3RoaXMyLnVybH0vR2V0VmVjdG9yc2AsIG9wdGlvbnMsIHsgaGVhZGVyczogX3RoaXMyLmhlYWRlcnMgfSk7XG5cdFx0fSk7XG5cdH1cblx0LyoqIExpc3RzIHZlY3RvcnMgaW4gYW4gaW5kZXggd2l0aCBwYWdpbmF0aW9uICovXG5cdGFzeW5jIGxpc3RWZWN0b3JzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXMzID0gdGhpcztcblx0XHRpZiAob3B0aW9ucy5zZWdtZW50Q291bnQgIT09IHZvaWQgMCkge1xuXHRcdFx0aWYgKG9wdGlvbnMuc2VnbWVudENvdW50IDwgMSB8fCBvcHRpb25zLnNlZ21lbnRDb3VudCA+IDE2KSB0aHJvdyBuZXcgRXJyb3IoXCJzZWdtZW50Q291bnQgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDE2XCIpO1xuXHRcdFx0aWYgKG9wdGlvbnMuc2VnbWVudEluZGV4ICE9PSB2b2lkIDApIHtcblx0XHRcdFx0aWYgKG9wdGlvbnMuc2VnbWVudEluZGV4IDwgMCB8fCBvcHRpb25zLnNlZ21lbnRJbmRleCA+PSBvcHRpb25zLnNlZ21lbnRDb3VudCkgdGhyb3cgbmV3IEVycm9yKGBzZWdtZW50SW5kZXggbXVzdCBiZSBiZXR3ZWVuIDAgYW5kICR7b3B0aW9ucy5zZWdtZW50Q291bnQgLSAxfWApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gX3RoaXMzLmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgdmVjdG9yc0FwaS5wb3N0KF90aGlzMy5mZXRjaCwgYCR7X3RoaXMzLnVybH0vTGlzdFZlY3RvcnNgLCBvcHRpb25zLCB7IGhlYWRlcnM6IF90aGlzMy5oZWFkZXJzIH0pO1xuXHRcdH0pO1xuXHR9XG5cdC8qKiBRdWVyaWVzIGZvciBzaW1pbGFyIHZlY3RvcnMgdXNpbmcgYXBwcm94aW1hdGUgbmVhcmVzdCBuZWlnaGJvciBzZWFyY2ggKi9cblx0YXN5bmMgcXVlcnlWZWN0b3JzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXM0ID0gdGhpcztcblx0XHRyZXR1cm4gX3RoaXM0LmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgdmVjdG9yc0FwaS5wb3N0KF90aGlzNC5mZXRjaCwgYCR7X3RoaXM0LnVybH0vUXVlcnlWZWN0b3JzYCwgb3B0aW9ucywgeyBoZWFkZXJzOiBfdGhpczQuaGVhZGVycyB9KTtcblx0XHR9KTtcblx0fVxuXHQvKiogRGVsZXRlcyB2ZWN0b3JzIGJ5IHRoZWlyIGtleXMgaW4gYmF0Y2ggKDEtNTAwIHBlciByZXF1ZXN0KSAqL1xuXHRhc3luYyBkZWxldGVWZWN0b3JzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXM1ID0gdGhpcztcblx0XHRpZiAob3B0aW9ucy5rZXlzLmxlbmd0aCA8IDEgfHwgb3B0aW9ucy5rZXlzLmxlbmd0aCA+IDUwMCkgdGhyb3cgbmV3IEVycm9yKFwiS2V5cyBiYXRjaCBzaXplIG11c3QgYmUgYmV0d2VlbiAxIGFuZCA1MDAgaXRlbXNcIik7XG5cdFx0cmV0dXJuIF90aGlzNS5oYW5kbGVPcGVyYXRpb24oYXN5bmMgKCkgPT4ge1xuXHRcdFx0cmV0dXJuIGF3YWl0IHZlY3RvcnNBcGkucG9zdChfdGhpczUuZmV0Y2gsIGAke190aGlzNS51cmx9L0RlbGV0ZVZlY3RvcnNgLCBvcHRpb25zLCB7IGhlYWRlcnM6IF90aGlzNS5oZWFkZXJzIH0pIHx8IHt9O1xuXHRcdH0pO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvcGFja2FnZXMvVmVjdG9yQnVja2V0QXBpLnRzXG4vKipcbiogQGhpZGRlblxuKiBCYXNlIGltcGxlbWVudGF0aW9uIGZvciB2ZWN0b3IgYnVja2V0IG9wZXJhdGlvbnMuXG4qIFVzZSB7QGxpbmsgU3RvcmFnZVZlY3RvcnNDbGllbnR9IHZpYSBgc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzYCBpbnN0ZWFkLlxuKi9cbnZhciBWZWN0b3JCdWNrZXRBcGkgPSBjbGFzcyBleHRlbmRzIEJhc2VBcGlDbGllbnQge1xuXHQvKiogQ3JlYXRlcyBhIG5ldyBWZWN0b3JCdWNrZXRBcGkgaW5zdGFuY2UgKi9cblx0Y29uc3RydWN0b3IodXJsLCBoZWFkZXJzID0ge30sIGZldGNoJDEpIHtcblx0XHRjb25zdCBmaW5hbFVybCA9IHVybC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG5cdFx0Y29uc3QgZmluYWxIZWFkZXJzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfSEVBREVSUyksIHt9LCB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sIGhlYWRlcnMpO1xuXHRcdHN1cGVyKGZpbmFsVXJsLCBmaW5hbEhlYWRlcnMsIGZldGNoJDEsIFwidmVjdG9yc1wiKTtcblx0fVxuXHQvKiogQ3JlYXRlcyBhIG5ldyB2ZWN0b3IgYnVja2V0ICovXG5cdGFzeW5jIGNyZWF0ZUJ1Y2tldCh2ZWN0b3JCdWNrZXROYW1lKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHRyZXR1cm4gX3RoaXMuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcblx0XHRcdHJldHVybiBhd2FpdCB2ZWN0b3JzQXBpLnBvc3QoX3RoaXMuZmV0Y2gsIGAke190aGlzLnVybH0vQ3JlYXRlVmVjdG9yQnVja2V0YCwgeyB2ZWN0b3JCdWNrZXROYW1lIH0sIHsgaGVhZGVyczogX3RoaXMuaGVhZGVycyB9KSB8fCB7fTtcblx0XHR9KTtcblx0fVxuXHQvKiogUmV0cmlldmVzIG1ldGFkYXRhIGZvciBhIHNwZWNpZmljIHZlY3RvciBidWNrZXQgKi9cblx0YXN5bmMgZ2V0QnVja2V0KHZlY3RvckJ1Y2tldE5hbWUpIHtcblx0XHR2YXIgX3RoaXMyID0gdGhpcztcblx0XHRyZXR1cm4gX3RoaXMyLmhhbmRsZU9wZXJhdGlvbihhc3luYyAoKSA9PiB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgdmVjdG9yc0FwaS5wb3N0KF90aGlzMi5mZXRjaCwgYCR7X3RoaXMyLnVybH0vR2V0VmVjdG9yQnVja2V0YCwgeyB2ZWN0b3JCdWNrZXROYW1lIH0sIHsgaGVhZGVyczogX3RoaXMyLmhlYWRlcnMgfSk7XG5cdFx0fSk7XG5cdH1cblx0LyoqIExpc3RzIHZlY3RvciBidWNrZXRzIHdpdGggb3B0aW9uYWwgZmlsdGVyaW5nIGFuZCBwYWdpbmF0aW9uICovXG5cdGFzeW5jIGxpc3RCdWNrZXRzKG9wdGlvbnMgPSB7fSkge1xuXHRcdHZhciBfdGhpczMgPSB0aGlzO1xuXHRcdHJldHVybiBfdGhpczMuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcblx0XHRcdHJldHVybiBhd2FpdCB2ZWN0b3JzQXBpLnBvc3QoX3RoaXMzLmZldGNoLCBgJHtfdGhpczMudXJsfS9MaXN0VmVjdG9yQnVja2V0c2AsIG9wdGlvbnMsIHsgaGVhZGVyczogX3RoaXMzLmhlYWRlcnMgfSk7XG5cdFx0fSk7XG5cdH1cblx0LyoqIERlbGV0ZXMgYSB2ZWN0b3IgYnVja2V0IChtdXN0IGJlIGVtcHR5IGZpcnN0KSAqL1xuXHRhc3luYyBkZWxldGVCdWNrZXQodmVjdG9yQnVja2V0TmFtZSkge1xuXHRcdHZhciBfdGhpczQgPSB0aGlzO1xuXHRcdHJldHVybiBfdGhpczQuaGFuZGxlT3BlcmF0aW9uKGFzeW5jICgpID0+IHtcblx0XHRcdHJldHVybiBhd2FpdCB2ZWN0b3JzQXBpLnBvc3QoX3RoaXM0LmZldGNoLCBgJHtfdGhpczQudXJsfS9EZWxldGVWZWN0b3JCdWNrZXRgLCB7IHZlY3RvckJ1Y2tldE5hbWUgfSwgeyBoZWFkZXJzOiBfdGhpczQuaGVhZGVycyB9KSB8fCB7fTtcblx0XHR9KTtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3BhY2thZ2VzL1N0b3JhZ2VWZWN0b3JzQ2xpZW50LnRzXG4vKipcbipcbiogQGFscGhhXG4qXG4qIE1haW4gY2xpZW50IGZvciBpbnRlcmFjdGluZyB3aXRoIFMzIFZlY3RvcnMgQVBJXG4qIFByb3ZpZGVzIGFjY2VzcyB0byBidWNrZXQsIGluZGV4LCBhbmQgdmVjdG9yIGRhdGEgb3BlcmF0aW9uc1xuKlxuKiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuKlxuKiAqKlVzYWdlIFBhdHRlcm5zOioqXG4qXG4qIGBgYHR5cGVzY3JpcHRcbiogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiogIC5zdG9yYWdlXG4qICAudmVjdG9yc1xuKiAgLmNyZWF0ZUJ1Y2tldCgnZW1iZWRkaW5ncy1wcm9kJylcbipcbiogLy8gQWNjZXNzIGluZGV4IG9wZXJhdGlvbnMgdmlhIGJ1Y2tldHNcbiogY29uc3QgYnVja2V0ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpXG4qIGF3YWl0IGJ1Y2tldC5jcmVhdGVJbmRleCh7XG4qICAgaW5kZXhOYW1lOiAnZG9jdW1lbnRzJyxcbiogICBkYXRhVHlwZTogJ2Zsb2F0MzInLFxuKiAgIGRpbWVuc2lvbjogMTUzNixcbiogICBkaXN0YW5jZU1ldHJpYzogJ2Nvc2luZSdcbiogfSlcbipcbiogLy8gQWNjZXNzIHZlY3RvciBvcGVyYXRpb25zIHZpYSBpbmRleFxuKiBjb25zdCBpbmRleCA9IGJ1Y2tldC5pbmRleCgnZG9jdW1lbnRzJylcbiogYXdhaXQgaW5kZXgucHV0VmVjdG9ycyh7XG4qICAgdmVjdG9yczogW1xuKiAgICAgeyBrZXk6ICdkb2MtMScsIGRhdGE6IHsgZmxvYXQzMjogWy4uLl0gfSwgbWV0YWRhdGE6IHsgdGl0bGU6ICdJbnRybycgfSB9XG4qICAgXVxuKiB9KVxuKlxuKiAvLyBRdWVyeSBzaW1pbGFyIHZlY3RvcnNcbiogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBpbmRleC5xdWVyeVZlY3RvcnMoe1xuKiAgIHF1ZXJ5VmVjdG9yOiB7IGZsb2F0MzI6IFsuLi5dIH0sXG4qICAgdG9wSzogNSxcbiogICByZXR1cm5EaXN0YW5jZTogdHJ1ZVxuKiB9KVxuKiBgYGBcbiovXG52YXIgU3RvcmFnZVZlY3RvcnNDbGllbnQgPSBjbGFzcyBleHRlbmRzIFZlY3RvckJ1Y2tldEFwaSB7XG5cdC8qKlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogQ3JlYXRlcyBhIFN0b3JhZ2VWZWN0b3JzQ2xpZW50IHRoYXQgY2FuIG1hbmFnZSBidWNrZXRzLCBpbmRleGVzLCBhbmQgdmVjdG9ycy5cblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gdXJsIC0gQmFzZSBVUkwgb2YgdGhlIFN0b3JhZ2UgVmVjdG9ycyBSRVNUIEFQSS5cblx0KiBAcGFyYW0gb3B0aW9ucy5oZWFkZXJzIC0gT3B0aW9uYWwgaGVhZGVycyAoZm9yIGV4YW1wbGUgYEF1dGhvcml6YXRpb25gKSBhcHBsaWVkIHRvIGV2ZXJ5IHJlcXVlc3QuXG5cdCogQHBhcmFtIG9wdGlvbnMuZmV0Y2ggLSBPcHRpb25hbCBjdXN0b20gYGZldGNoYCBpbXBsZW1lbnRhdGlvbiBmb3Igbm9uLWJyb3dzZXIgcnVudGltZXMuXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBjbGllbnQgPSBuZXcgU3RvcmFnZVZlY3RvcnNDbGllbnQodXJsLCBvcHRpb25zKVxuXHQqIGBgYFxuXHQqL1xuXHRjb25zdHJ1Y3Rvcih1cmwsIG9wdGlvbnMgPSB7fSkge1xuXHRcdHN1cGVyKHVybCwgb3B0aW9ucy5oZWFkZXJzIHx8IHt9LCBvcHRpb25zLmZldGNoKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogQWNjZXNzIG9wZXJhdGlvbnMgZm9yIGEgc3BlY2lmaWMgdmVjdG9yIGJ1Y2tldFxuXHQqIFJldHVybnMgYSBzY29wZWQgY2xpZW50IGZvciBpbmRleCBhbmQgdmVjdG9yIG9wZXJhdGlvbnMgd2l0aGluIHRoZSBidWNrZXRcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gdmVjdG9yQnVja2V0TmFtZSAtIE5hbWUgb2YgdGhlIHZlY3RvciBidWNrZXRcblx0KiBAcmV0dXJucyBCdWNrZXQtc2NvcGVkIGNsaWVudCB3aXRoIGluZGV4IGFuZCB2ZWN0b3Igb3BlcmF0aW9uc1xuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgYnVja2V0ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpXG5cdCogYGBgXG5cdCovXG5cdGZyb20odmVjdG9yQnVja2V0TmFtZSkge1xuXHRcdHJldHVybiBuZXcgVmVjdG9yQnVja2V0U2NvcGUodGhpcy51cmwsIHRoaXMuaGVhZGVycywgdmVjdG9yQnVja2V0TmFtZSwgdGhpcy5mZXRjaCk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIENyZWF0ZXMgYSBuZXcgdmVjdG9yIGJ1Y2tldFxuXHQqIFZlY3RvciBidWNrZXRzIGFyZSBjb250YWluZXJzIGZvciB2ZWN0b3IgaW5kZXhlcyBhbmQgdGhlaXIgZGF0YVxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSB2ZWN0b3JCdWNrZXROYW1lIC0gVW5pcXVlIG5hbWUgZm9yIHRoZSB2ZWN0b3IgYnVja2V0XG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIGVtcHR5IHJlc3BvbnNlIG9uIHN1Y2Nlc3Mgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLnZlY3RvcnNcblx0KiAgIC5jcmVhdGVCdWNrZXQoJ2VtYmVkZGluZ3MtcHJvZCcpXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGNyZWF0ZUJ1Y2tldCh2ZWN0b3JCdWNrZXROYW1lKSB7XG5cdFx0dmFyIF9zdXBlcnByb3BfZ2V0Q3JlYXRlQnVja2V0ID0gKCkgPT4gc3VwZXIuY3JlYXRlQnVja2V0LCBfdGhpcyA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0Q3JlYXRlQnVja2V0KCkuY2FsbChfdGhpcywgdmVjdG9yQnVja2V0TmFtZSk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIFJldHJpZXZlcyBtZXRhZGF0YSBmb3IgYSBzcGVjaWZpYyB2ZWN0b3IgYnVja2V0XG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIHZlY3RvckJ1Y2tldE5hbWUgLSBOYW1lIG9mIHRoZSB2ZWN0b3IgYnVja2V0XG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIGJ1Y2tldCBtZXRhZGF0YSBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAudmVjdG9yc1xuXHQqICAgLmdldEJ1Y2tldCgnZW1iZWRkaW5ncy1wcm9kJylcblx0KlxuXHQqIGNvbnNvbGUubG9nKCdCdWNrZXQgY3JlYXRlZDonLCBkYXRhPy52ZWN0b3JCdWNrZXQuY3JlYXRpb25UaW1lKVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBnZXRCdWNrZXQodmVjdG9yQnVja2V0TmFtZSkge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldEdldEJ1Y2tldCA9ICgpID0+IHN1cGVyLmdldEJ1Y2tldCwgX3RoaXMyID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXRHZXRCdWNrZXQoKS5jYWxsKF90aGlzMiwgdmVjdG9yQnVja2V0TmFtZSk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIExpc3RzIGFsbCB2ZWN0b3IgYnVja2V0cyB3aXRoIG9wdGlvbmFsIGZpbHRlcmluZyBhbmQgcGFnaW5hdGlvblxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgZmlsdGVycyAocHJlZml4LCBtYXhSZXN1bHRzLCBuZXh0VG9rZW4pXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIGxpc3Qgb2YgYnVja2V0cyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAudmVjdG9yc1xuXHQqICAgLmxpc3RCdWNrZXRzKHsgcHJlZml4OiAnZW1iZWRkaW5ncy0nIH0pXG5cdCpcblx0KiBkYXRhPy52ZWN0b3JCdWNrZXRzLmZvckVhY2goYnVja2V0ID0+IHtcblx0KiAgIGNvbnNvbGUubG9nKGJ1Y2tldC52ZWN0b3JCdWNrZXROYW1lKVxuXHQqIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGxpc3RCdWNrZXRzKG9wdGlvbnMgPSB7fSkge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldExpc3RCdWNrZXRzID0gKCkgPT4gc3VwZXIubGlzdEJ1Y2tldHMsIF90aGlzMyA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0TGlzdEJ1Y2tldHMoKS5jYWxsKF90aGlzMywgb3B0aW9ucyk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIERlbGV0ZXMgYSB2ZWN0b3IgYnVja2V0IChidWNrZXQgbXVzdCBiZSBlbXB0eSlcblx0KiBBbGwgaW5kZXhlcyBtdXN0IGJlIGRlbGV0ZWQgYmVmb3JlIGRlbGV0aW5nIHRoZSBidWNrZXRcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gdmVjdG9yQnVja2V0TmFtZSAtIE5hbWUgb2YgdGhlIHZlY3RvciBidWNrZXQgdG8gZGVsZXRlXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIGVtcHR5IHJlc3BvbnNlIG9uIHN1Y2Nlc3Mgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLnZlY3RvcnNcblx0KiAgIC5kZWxldGVCdWNrZXQoJ2VtYmVkZGluZ3Mtb2xkJylcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgZGVsZXRlQnVja2V0KHZlY3RvckJ1Y2tldE5hbWUpIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXREZWxldGVCdWNrZXQgPSAoKSA9PiBzdXBlci5kZWxldGVCdWNrZXQsIF90aGlzNCA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0RGVsZXRlQnVja2V0KCkuY2FsbChfdGhpczQsIHZlY3RvckJ1Y2tldE5hbWUpO1xuXHR9XG59O1xuLyoqXG4qXG4qIEBhbHBoYVxuKlxuKiBTY29wZWQgY2xpZW50IGZvciBvcGVyYXRpb25zIHdpdGhpbiBhIHNwZWNpZmljIHZlY3RvciBidWNrZXRcbiogUHJvdmlkZXMgaW5kZXggbWFuYWdlbWVudCBhbmQgYWNjZXNzIHRvIHZlY3RvciBvcGVyYXRpb25zXG4qXG4qICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG4qL1xudmFyIFZlY3RvckJ1Y2tldFNjb3BlID0gY2xhc3MgZXh0ZW5kcyBWZWN0b3JJbmRleEFwaSB7XG5cdC8qKlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogQ3JlYXRlcyBhIGhlbHBlciB0aGF0IGF1dG9tYXRpY2FsbHkgc2NvcGVzIGFsbCBpbmRleCBvcGVyYXRpb25zIHRvIHRoZSBwcm92aWRlZCBidWNrZXQuXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgYnVja2V0ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpXG5cdCogYGBgXG5cdCovXG5cdGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycywgdmVjdG9yQnVja2V0TmFtZSwgZmV0Y2gkMSkge1xuXHRcdHN1cGVyKHVybCwgaGVhZGVycywgZmV0Y2gkMSk7XG5cdFx0dGhpcy52ZWN0b3JCdWNrZXROYW1lID0gdmVjdG9yQnVja2V0TmFtZTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogQ3JlYXRlcyBhIG5ldyB2ZWN0b3IgaW5kZXggaW4gdGhpcyBidWNrZXRcblx0KiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdXRvbWF0aWNhbGx5IGluY2x1ZGVzIHRoZSBidWNrZXQgbmFtZVxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zIC0gSW5kZXggY29uZmlndXJhdGlvbiAodmVjdG9yQnVja2V0TmFtZSBpcyBhdXRvbWF0aWNhbGx5IHNldClcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggZW1wdHkgcmVzcG9uc2Ugb24gc3VjY2VzcyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgYnVja2V0ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpXG5cdCogYXdhaXQgYnVja2V0LmNyZWF0ZUluZGV4KHtcblx0KiAgIGluZGV4TmFtZTogJ2RvY3VtZW50cy1vcGVuYWknLFxuXHQqICAgZGF0YVR5cGU6ICdmbG9hdDMyJyxcblx0KiAgIGRpbWVuc2lvbjogMTUzNixcblx0KiAgIGRpc3RhbmNlTWV0cmljOiAnY29zaW5lJyxcblx0KiAgIG1ldGFkYXRhQ29uZmlndXJhdGlvbjoge1xuXHQqICAgICBub25GaWx0ZXJhYmxlTWV0YWRhdGFLZXlzOiBbJ3Jhd190ZXh0J11cblx0KiAgIH1cblx0KiB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBjcmVhdGVJbmRleChvcHRpb25zKSB7XG5cdFx0dmFyIF9zdXBlcnByb3BfZ2V0Q3JlYXRlSW5kZXggPSAoKSA9PiBzdXBlci5jcmVhdGVJbmRleCwgX3RoaXM1ID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXRDcmVhdGVJbmRleCgpLmNhbGwoX3RoaXM1LCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgb3B0aW9ucyksIHt9LCB7IHZlY3RvckJ1Y2tldE5hbWU6IF90aGlzNS52ZWN0b3JCdWNrZXROYW1lIH0pKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogTGlzdHMgaW5kZXhlcyBpbiB0aGlzIGJ1Y2tldFxuXHQqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF1dG9tYXRpY2FsbHkgaW5jbHVkZXMgdGhlIGJ1Y2tldCBuYW1lXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBMaXN0aW5nIG9wdGlvbnMgKHZlY3RvckJ1Y2tldE5hbWUgaXMgYXV0b21hdGljYWxseSBzZXQpXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgaW5kZXhlcyBhcnJheSBhbmQgcGFnaW5hdGlvbiB0b2tlbiBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgYnVja2V0ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpXG5cdCogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBidWNrZXQubGlzdEluZGV4ZXMoeyBwcmVmaXg6ICdkb2N1bWVudHMtJyB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBsaXN0SW5kZXhlcyhvcHRpb25zID0ge30pIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXRMaXN0SW5kZXhlcyA9ICgpID0+IHN1cGVyLmxpc3RJbmRleGVzLCBfdGhpczYgPSB0aGlzO1xuXHRcdHJldHVybiBfc3VwZXJwcm9wX2dldExpc3RJbmRleGVzKCkuY2FsbChfdGhpczYsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKSwge30sIHsgdmVjdG9yQnVja2V0TmFtZTogX3RoaXM2LnZlY3RvckJ1Y2tldE5hbWUgfSkpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBSZXRyaWV2ZXMgbWV0YWRhdGEgZm9yIGEgc3BlY2lmaWMgaW5kZXggaW4gdGhpcyBidWNrZXRcblx0KiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdXRvbWF0aWNhbGx5IGluY2x1ZGVzIHRoZSBidWNrZXQgbmFtZVxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSBpbmRleE5hbWUgLSBOYW1lIG9mIHRoZSBpbmRleCB0byByZXRyaWV2ZVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBpbmRleCBtZXRhZGF0YSBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgYnVja2V0ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpXG5cdCogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBidWNrZXQuZ2V0SW5kZXgoJ2RvY3VtZW50cy1vcGVuYWknKVxuXHQqIGNvbnNvbGUubG9nKCdEaW1lbnNpb246JywgZGF0YT8uaW5kZXguZGltZW5zaW9uKVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBnZXRJbmRleChpbmRleE5hbWUpIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXRHZXRJbmRleCA9ICgpID0+IHN1cGVyLmdldEluZGV4LCBfdGhpczcgPSB0aGlzO1xuXHRcdHJldHVybiBfc3VwZXJwcm9wX2dldEdldEluZGV4KCkuY2FsbChfdGhpczcsIF90aGlzNy52ZWN0b3JCdWNrZXROYW1lLCBpbmRleE5hbWUpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBEZWxldGVzIGFuIGluZGV4IGZyb20gdGhpcyBidWNrZXRcblx0KiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdXRvbWF0aWNhbGx5IGluY2x1ZGVzIHRoZSBidWNrZXQgbmFtZVxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSBpbmRleE5hbWUgLSBOYW1lIG9mIHRoZSBpbmRleCB0byBkZWxldGVcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggZW1wdHkgcmVzcG9uc2Ugb24gc3VjY2VzcyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgYnVja2V0ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpXG5cdCogYXdhaXQgYnVja2V0LmRlbGV0ZUluZGV4KCdvbGQtaW5kZXgnKVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBkZWxldGVJbmRleChpbmRleE5hbWUpIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXREZWxldGVJbmRleCA9ICgpID0+IHN1cGVyLmRlbGV0ZUluZGV4LCBfdGhpczggPSB0aGlzO1xuXHRcdHJldHVybiBfc3VwZXJwcm9wX2dldERlbGV0ZUluZGV4KCkuY2FsbChfdGhpczgsIF90aGlzOC52ZWN0b3JCdWNrZXROYW1lLCBpbmRleE5hbWUpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBBY2Nlc3Mgb3BlcmF0aW9ucyBmb3IgYSBzcGVjaWZpYyBpbmRleCB3aXRoaW4gdGhpcyBidWNrZXRcblx0KiBSZXR1cm5zIGEgc2NvcGVkIGNsaWVudCBmb3IgdmVjdG9yIGRhdGEgb3BlcmF0aW9uc1xuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSBpbmRleE5hbWUgLSBOYW1lIG9mIHRoZSBpbmRleFxuXHQqIEByZXR1cm5zIEluZGV4LXNjb3BlZCBjbGllbnQgd2l0aCB2ZWN0b3IgZGF0YSBvcGVyYXRpb25zXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBpbmRleCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKS5pbmRleCgnZG9jdW1lbnRzLW9wZW5haScpXG5cdCpcblx0KiAvLyBJbnNlcnQgdmVjdG9yc1xuXHQqIGF3YWl0IGluZGV4LnB1dFZlY3RvcnMoe1xuXHQqICAgdmVjdG9yczogW1xuXHQqICAgICB7IGtleTogJ2RvYy0xJywgZGF0YTogeyBmbG9hdDMyOiBbLi4uXSB9LCBtZXRhZGF0YTogeyB0aXRsZTogJ0ludHJvJyB9IH1cblx0KiAgIF1cblx0KiB9KVxuXHQqXG5cdCogLy8gUXVlcnkgc2ltaWxhciB2ZWN0b3JzXG5cdCogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBpbmRleC5xdWVyeVZlY3RvcnMoe1xuXHQqICAgcXVlcnlWZWN0b3I6IHsgZmxvYXQzMjogWy4uLl0gfSxcblx0KiAgIHRvcEs6IDVcblx0KiB9KVxuXHQqIGBgYFxuXHQqL1xuXHRpbmRleChpbmRleE5hbWUpIHtcblx0XHRyZXR1cm4gbmV3IFZlY3RvckluZGV4U2NvcGUodGhpcy51cmwsIHRoaXMuaGVhZGVycywgdGhpcy52ZWN0b3JCdWNrZXROYW1lLCBpbmRleE5hbWUsIHRoaXMuZmV0Y2gpO1xuXHR9XG59O1xuLyoqXG4qXG4qIEBhbHBoYVxuKlxuKiBTY29wZWQgY2xpZW50IGZvciBvcGVyYXRpb25zIHdpdGhpbiBhIHNwZWNpZmljIHZlY3RvciBpbmRleFxuKiBQcm92aWRlcyB2ZWN0b3IgZGF0YSBvcGVyYXRpb25zIChwdXQsIGdldCwgbGlzdCwgcXVlcnksIGRlbGV0ZSlcbipcbiogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cbiovXG52YXIgVmVjdG9ySW5kZXhTY29wZSA9IGNsYXNzIGV4dGVuZHMgVmVjdG9yRGF0YUFwaSB7XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBDcmVhdGVzIGEgaGVscGVyIHRoYXQgYXV0b21hdGljYWxseSBzY29wZXMgYWxsIHZlY3RvciBvcGVyYXRpb25zIHRvIHRoZSBwcm92aWRlZCBidWNrZXQvaW5kZXggbmFtZXMuXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgaW5kZXggPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJykuaW5kZXgoJ2RvY3VtZW50cy1vcGVuYWknKVxuXHQqIGBgYFxuXHQqL1xuXHRjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMsIHZlY3RvckJ1Y2tldE5hbWUsIGluZGV4TmFtZSwgZmV0Y2gkMSkge1xuXHRcdHN1cGVyKHVybCwgaGVhZGVycywgZmV0Y2gkMSk7XG5cdFx0dGhpcy52ZWN0b3JCdWNrZXROYW1lID0gdmVjdG9yQnVja2V0TmFtZTtcblx0XHR0aGlzLmluZGV4TmFtZSA9IGluZGV4TmFtZTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogSW5zZXJ0cyBvciB1cGRhdGVzIHZlY3RvcnMgaW4gdGhpcyBpbmRleFxuXHQqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF1dG9tYXRpY2FsbHkgaW5jbHVkZXMgYnVja2V0IGFuZCBpbmRleCBuYW1lc1xuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zIC0gVmVjdG9yIGluc2VydGlvbiBvcHRpb25zIChidWNrZXQgYW5kIGluZGV4IG5hbWVzIGF1dG9tYXRpY2FsbHkgc2V0KVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBlbXB0eSByZXNwb25zZSBvbiBzdWNjZXNzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBpbmRleCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKS5pbmRleCgnZG9jdW1lbnRzLW9wZW5haScpXG5cdCogYXdhaXQgaW5kZXgucHV0VmVjdG9ycyh7XG5cdCogICB2ZWN0b3JzOiBbXG5cdCogICAgIHtcblx0KiAgICAgICBrZXk6ICdkb2MtMScsXG5cdCogICAgICAgZGF0YTogeyBmbG9hdDMyOiBbMC4xLCAwLjIsIC4uLl0gfSxcblx0KiAgICAgICBtZXRhZGF0YTogeyB0aXRsZTogJ0ludHJvZHVjdGlvbicsIHBhZ2U6IDEgfVxuXHQqICAgICB9XG5cdCogICBdXG5cdCogfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgcHV0VmVjdG9ycyhvcHRpb25zKSB7XG5cdFx0dmFyIF9zdXBlcnByb3BfZ2V0UHV0VmVjdG9ycyA9ICgpID0+IHN1cGVyLnB1dFZlY3RvcnMsIF90aGlzOSA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0UHV0VmVjdG9ycygpLmNhbGwoX3RoaXM5LCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgb3B0aW9ucyksIHt9LCB7XG5cdFx0XHR2ZWN0b3JCdWNrZXROYW1lOiBfdGhpczkudmVjdG9yQnVja2V0TmFtZSxcblx0XHRcdGluZGV4TmFtZTogX3RoaXM5LmluZGV4TmFtZVxuXHRcdH0pKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogUmV0cmlldmVzIHZlY3RvcnMgYnkga2V5cyBmcm9tIHRoaXMgaW5kZXhcblx0KiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdXRvbWF0aWNhbGx5IGluY2x1ZGVzIGJ1Y2tldCBhbmQgaW5kZXggbmFtZXNcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucyAtIFZlY3RvciByZXRyaWV2YWwgb3B0aW9ucyAoYnVja2V0IGFuZCBpbmRleCBuYW1lcyBhdXRvbWF0aWNhbGx5IHNldClcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyB2ZWN0b3JzIGFycmF5IG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBpbmRleCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKS5pbmRleCgnZG9jdW1lbnRzLW9wZW5haScpXG5cdCogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBpbmRleC5nZXRWZWN0b3JzKHtcblx0KiAgIGtleXM6IFsnZG9jLTEnLCAnZG9jLTInXSxcblx0KiAgIHJldHVybk1ldGFkYXRhOiB0cnVlXG5cdCogfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgZ2V0VmVjdG9ycyhvcHRpb25zKSB7XG5cdFx0dmFyIF9zdXBlcnByb3BfZ2V0R2V0VmVjdG9ycyA9ICgpID0+IHN1cGVyLmdldFZlY3RvcnMsIF90aGlzMTAgPSB0aGlzO1xuXHRcdHJldHVybiBfc3VwZXJwcm9wX2dldEdldFZlY3RvcnMoKS5jYWxsKF90aGlzMTAsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKSwge30sIHtcblx0XHRcdHZlY3RvckJ1Y2tldE5hbWU6IF90aGlzMTAudmVjdG9yQnVja2V0TmFtZSxcblx0XHRcdGluZGV4TmFtZTogX3RoaXMxMC5pbmRleE5hbWVcblx0XHR9KSk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIExpc3RzIHZlY3RvcnMgaW4gdGhpcyBpbmRleCB3aXRoIHBhZ2luYXRpb25cblx0KiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdXRvbWF0aWNhbGx5IGluY2x1ZGVzIGJ1Y2tldCBhbmQgaW5kZXggbmFtZXNcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucyAtIExpc3Rpbmcgb3B0aW9ucyAoYnVja2V0IGFuZCBpbmRleCBuYW1lcyBhdXRvbWF0aWNhbGx5IHNldClcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyB2ZWN0b3JzIGFycmF5IGFuZCBwYWdpbmF0aW9uIHRva2VuIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBpbmRleCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKS5pbmRleCgnZG9jdW1lbnRzLW9wZW5haScpXG5cdCogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBpbmRleC5saXN0VmVjdG9ycyh7XG5cdCogICBtYXhSZXN1bHRzOiA1MDAsXG5cdCogICByZXR1cm5NZXRhZGF0YTogdHJ1ZVxuXHQqIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGxpc3RWZWN0b3JzKG9wdGlvbnMgPSB7fSkge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldExpc3RWZWN0b3JzID0gKCkgPT4gc3VwZXIubGlzdFZlY3RvcnMsIF90aGlzMTEgPSB0aGlzO1xuXHRcdHJldHVybiBfc3VwZXJwcm9wX2dldExpc3RWZWN0b3JzKCkuY2FsbChfdGhpczExLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgb3B0aW9ucyksIHt9LCB7XG5cdFx0XHR2ZWN0b3JCdWNrZXROYW1lOiBfdGhpczExLnZlY3RvckJ1Y2tldE5hbWUsXG5cdFx0XHRpbmRleE5hbWU6IF90aGlzMTEuaW5kZXhOYW1lXG5cdFx0fSkpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBRdWVyaWVzIGZvciBzaW1pbGFyIHZlY3RvcnMgaW4gdGhpcyBpbmRleFxuXHQqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF1dG9tYXRpY2FsbHkgaW5jbHVkZXMgYnVja2V0IGFuZCBpbmRleCBuYW1lc1xuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zIC0gUXVlcnkgb3B0aW9ucyAoYnVja2V0IGFuZCBpbmRleCBuYW1lcyBhdXRvbWF0aWNhbGx5IHNldClcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBtYXRjaGVzIGFycmF5IG9mIHNpbWlsYXIgdmVjdG9ycyBvcmRlcmVkIGJ5IGRpc3RhbmNlIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBpbmRleCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKS5pbmRleCgnZG9jdW1lbnRzLW9wZW5haScpXG5cdCogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBpbmRleC5xdWVyeVZlY3RvcnMoe1xuXHQqICAgcXVlcnlWZWN0b3I6IHsgZmxvYXQzMjogWzAuMSwgMC4yLCAuLi5dIH0sXG5cdCogICB0b3BLOiA1LFxuXHQqICAgZmlsdGVyOiB7IGNhdGVnb3J5OiAndGVjaG5pY2FsJyB9LFxuXHQqICAgcmV0dXJuRGlzdGFuY2U6IHRydWUsXG5cdCogICByZXR1cm5NZXRhZGF0YTogdHJ1ZVxuXHQqIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIHF1ZXJ5VmVjdG9ycyhvcHRpb25zKSB7XG5cdFx0dmFyIF9zdXBlcnByb3BfZ2V0UXVlcnlWZWN0b3JzID0gKCkgPT4gc3VwZXIucXVlcnlWZWN0b3JzLCBfdGhpczEyID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXRRdWVyeVZlY3RvcnMoKS5jYWxsKF90aGlzMTIsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKSwge30sIHtcblx0XHRcdHZlY3RvckJ1Y2tldE5hbWU6IF90aGlzMTIudmVjdG9yQnVja2V0TmFtZSxcblx0XHRcdGluZGV4TmFtZTogX3RoaXMxMi5pbmRleE5hbWVcblx0XHR9KSk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIERlbGV0ZXMgdmVjdG9ycyBieSBrZXlzIGZyb20gdGhpcyBpbmRleFxuXHQqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF1dG9tYXRpY2FsbHkgaW5jbHVkZXMgYnVja2V0IGFuZCBpbmRleCBuYW1lc1xuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zIC0gRGVsZXRpb24gb3B0aW9ucyAoYnVja2V0IGFuZCBpbmRleCBuYW1lcyBhdXRvbWF0aWNhbGx5IHNldClcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggZW1wdHkgcmVzcG9uc2Ugb24gc3VjY2VzcyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgaW5kZXggPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJykuaW5kZXgoJ2RvY3VtZW50cy1vcGVuYWknKVxuXHQqIGF3YWl0IGluZGV4LmRlbGV0ZVZlY3RvcnMoe1xuXHQqICAga2V5czogWydkb2MtMScsICdkb2MtMicsICdkb2MtMyddXG5cdCogfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgZGVsZXRlVmVjdG9ycyhvcHRpb25zKSB7XG5cdFx0dmFyIF9zdXBlcnByb3BfZ2V0RGVsZXRlVmVjdG9ycyA9ICgpID0+IHN1cGVyLmRlbGV0ZVZlY3RvcnMsIF90aGlzMTMgPSB0aGlzO1xuXHRcdHJldHVybiBfc3VwZXJwcm9wX2dldERlbGV0ZVZlY3RvcnMoKS5jYWxsKF90aGlzMTMsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKSwge30sIHtcblx0XHRcdHZlY3RvckJ1Y2tldE5hbWU6IF90aGlzMTMudmVjdG9yQnVja2V0TmFtZSxcblx0XHRcdGluZGV4TmFtZTogX3RoaXMxMy5pbmRleE5hbWVcblx0XHR9KSk7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9TdG9yYWdlQ2xpZW50LnRzXG52YXIgU3RvcmFnZUNsaWVudCA9IGNsYXNzIGV4dGVuZHMgU3RvcmFnZUJ1Y2tldEFwaSB7XG5cdC8qKlxuXHQqIENyZWF0ZXMgYSBjbGllbnQgZm9yIFN0b3JhZ2UgYnVja2V0cywgZmlsZXMsIGFuYWx5dGljcywgYW5kIHZlY3RvcnMuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0c1xuXHQqIGltcG9ydCB7IFN0b3JhZ2VDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3RvcmFnZS1qcydcblx0KlxuXHQqIGNvbnN0IHN0b3JhZ2UgPSBuZXcgU3RvcmFnZUNsaWVudCgnaHR0cHM6Ly94eXpjb21wYW55LnN1cGFiYXNlLmNvL3N0b3JhZ2UvdjEnLCB7XG5cdCogICBhcGlrZXk6ICdwdWJsaWMtYW5vbi1rZXknLFxuXHQqIH0pXG5cdCogY29uc3QgYXZhdGFycyA9IHN0b3JhZ2UuZnJvbSgnYXZhdGFycycpXG5cdCogYGBgXG5cdCovXG5cdGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBmZXRjaCQxLCBvcHRzKSB7XG5cdFx0c3VwZXIodXJsLCBoZWFkZXJzLCBmZXRjaCQxLCBvcHRzKTtcblx0fVxuXHQvKipcblx0KiBQZXJmb3JtIGZpbGUgb3BlcmF0aW9uIGluIGEgYnVja2V0LlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBpZCBUaGUgYnVja2V0IGlkIHRvIG9wZXJhdGUgb24uXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCBhdmF0YXJzID0gc3VwYWJhc2Uuc3RvcmFnZS5mcm9tKCdhdmF0YXJzJylcblx0KiBgYGBcblx0Ki9cblx0ZnJvbShpZCkge1xuXHRcdHJldHVybiBuZXcgU3RvcmFnZUZpbGVBcGkodGhpcy51cmwsIHRoaXMuaGVhZGVycywgaWQsIHRoaXMuZmV0Y2gpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBBY2Nlc3MgdmVjdG9yIHN0b3JhZ2Ugb3BlcmF0aW9ucy5cblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcmV0dXJucyBBIFN0b3JhZ2VWZWN0b3JzQ2xpZW50IGluc3RhbmNlIGNvbmZpZ3VyZWQgd2l0aCB0aGUgY3VycmVudCBzdG9yYWdlIHNldHRpbmdzLlxuXHQqL1xuXHRnZXQgdmVjdG9ycygpIHtcblx0XHRyZXR1cm4gbmV3IFN0b3JhZ2VWZWN0b3JzQ2xpZW50KHRoaXMudXJsICsgXCIvdmVjdG9yXCIsIHtcblx0XHRcdGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcblx0XHRcdGZldGNoOiB0aGlzLmZldGNoXG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIEFjY2VzcyBhbmFseXRpY3Mgc3RvcmFnZSBvcGVyYXRpb25zIHVzaW5nIEljZWJlcmcgdGFibGVzLlxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBBbmFseXRpY3MgQnVja2V0c1xuXHQqIEByZXR1cm5zIEEgU3RvcmFnZUFuYWx5dGljc0NsaWVudCBpbnN0YW5jZSBjb25maWd1cmVkIHdpdGggdGhlIGN1cnJlbnQgc3RvcmFnZSBzZXR0aW5ncy5cblx0Ki9cblx0Z2V0IGFuYWx5dGljcygpIHtcblx0XHRyZXR1cm4gbmV3IFN0b3JhZ2VBbmFseXRpY3NDbGllbnQodGhpcy51cmwgKyBcIi9pY2ViZXJnXCIsIHRoaXMuaGVhZGVycywgdGhpcy5mZXRjaCk7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuZXhwb3J0IHsgU3RvcmFnZUFuYWx5dGljc0NsaWVudCwgU3RvcmFnZUFwaUVycm9yLCBTdG9yYWdlQ2xpZW50LCBTdG9yYWdlRXJyb3IsIFN0b3JhZ2VVbmtub3duRXJyb3IsIFN0b3JhZ2VWZWN0b3JzQXBpRXJyb3IsIFN0b3JhZ2VWZWN0b3JzQ2xpZW50LCBTdG9yYWdlVmVjdG9yc0Vycm9yLCBTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSwgU3RvcmFnZVZlY3RvcnNVbmtub3duRXJyb3IsIFZlY3RvckJ1Y2tldEFwaSwgVmVjdG9yQnVja2V0U2NvcGUsIFZlY3RvckRhdGFBcGksIFZlY3RvckluZGV4QXBpLCBWZWN0b3JJbmRleFNjb3BlLCBpc1N0b3JhZ2VFcnJvciwgaXNTdG9yYWdlVmVjdG9yc0Vycm9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbIkljZWJlcmdSZXN0Q2F0YWxvZyIsIlN0b3JhZ2VFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwibmFtZXNwYWNlIiwic3RhdHVzIiwic3RhdHVzQ29kZSIsIl9faXNTdG9yYWdlRXJyb3IiLCJuYW1lIiwiaXNTdG9yYWdlRXJyb3IiLCJlcnJvciIsIlN0b3JhZ2VBcGlFcnJvciIsInRvSlNPTiIsIlN0b3JhZ2VVbmtub3duRXJyb3IiLCJvcmlnaW5hbEVycm9yIiwiU3RvcmFnZVZlY3RvcnNFcnJvciIsImlzU3RvcmFnZVZlY3RvcnNFcnJvciIsIlN0b3JhZ2VWZWN0b3JzQXBpRXJyb3IiLCJTdG9yYWdlVmVjdG9yc1Vua25vd25FcnJvciIsIlN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlIiwiU3RvcmFnZVZlY3RvcnNFcnJvckNvZGUkMSIsInJlc29sdmVGZXRjaCIsImN1c3RvbUZldGNoIiwiYXJncyIsImZldGNoIiwiaXNQbGFpbk9iamVjdCIsInZhbHVlIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsIml0ZXJhdG9yIiwicmVjdXJzaXZlVG9DYW1lbCIsIml0ZW0iLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJlbCIsInJlc3VsdCIsImVudHJpZXMiLCJmb3JFYWNoIiwia2V5IiwibmV3S2V5IiwicmVwbGFjZSIsImMiLCJ0b1VwcGVyQ2FzZSIsImlzVmFsaWRCdWNrZXROYW1lIiwiYnVja2V0TmFtZSIsImxlbmd0aCIsInRyaW0iLCJpbmNsdWRlcyIsInRlc3QiLCJfdHlwZW9mIiwibyIsIm8kMSIsInRvUHJpbWl0aXZlIiwidCIsInIiLCJlIiwiaSIsImNhbGwiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJ0b1Byb3BlcnR5S2V5IiwiX2RlZmluZVByb3BlcnR5IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsInIkMSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQyIiwiYXJndW1lbnRzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfZ2V0RXJyb3JNZXNzYWdlIiwiZXJyIiwiX2VyciRlcnJvciIsIm1zZyIsImVycm9yX2Rlc2NyaXB0aW9uIiwiSlNPTiIsInN0cmluZ2lmeSIsImhhbmRsZUVycm9yIiwicmVqZWN0Iiwib3B0aW9ucyIsIm5vUmVzb2x2ZUpzb24iLCJyZXNwb25zZUVycm9yIiwianNvbiIsInRoZW4iLCJjb2RlIiwiY2F0Y2giLCJzdGF0dXNUZXh0IiwiX2dldFJlcXVlc3RQYXJhbXMiLCJtZXRob2QiLCJwYXJhbWV0ZXJzIiwiYm9keSIsInBhcmFtcyIsImhlYWRlcnMiLCJkdXBsZXgiLCJfaGFuZGxlUmVxdWVzdCIsImZldGNoZXIiLCJ1cmwiLCJQcm9taXNlIiwicmVzb2x2ZSIsIm9rIiwiY29udGVudFR5cGUiLCJnZXQiLCJkYXRhIiwiY3JlYXRlRmV0Y2hBcGkiLCJwb3N0IiwicHV0IiwiaGVhZCIsInJlbW92ZSIsImRlZmF1bHRBcGkiLCJ2ZWN0b3JzQXBpIiwiQmFzZUFwaUNsaWVudCIsImZldGNoJDEiLCJzaG91bGRUaHJvd09uRXJyb3IiLCJ0aHJvd09uRXJyb3IiLCJzZXRIZWFkZXIiLCJoYW5kbGVPcGVyYXRpb24iLCJvcGVyYXRpb24iLCJfdGhpcyIsIlN0cmVhbURvd25sb2FkQnVpbGRlciIsImRvd25sb2FkRm4iLCJvbmZ1bGZpbGxlZCIsIm9ucmVqZWN0ZWQiLCJleGVjdXRlIiwiX1N5bWJvbCR0b1N0cmluZ1RhZyIsIkJsb2JEb3dubG9hZEJ1aWxkZXIiLCJwcm9taXNlIiwiYXNTdHJlYW0iLCJnZXRQcm9taXNlIiwiZmluYWxseSIsIm9uZmluYWxseSIsImJsb2IiLCJERUZBVUxUX1NFQVJDSF9PUFRJT05TIiwibGltaXQiLCJvZmZzZXQiLCJzb3J0QnkiLCJjb2x1bW4iLCJvcmRlciIsIkRFRkFVTFRfRklMRV9PUFRJT05TIiwiY2FjaGVDb250cm9sIiwidXBzZXJ0IiwiU3RvcmFnZUZpbGVBcGkiLCJidWNrZXRJZCIsInVwbG9hZE9yVXBkYXRlIiwicGF0aCIsImZpbGVCb2R5IiwiZmlsZU9wdGlvbnMiLCJtZXRhZGF0YSIsIkJsb2IiLCJGb3JtRGF0YSIsImFwcGVuZCIsImVuY29kZU1ldGFkYXRhIiwiaGFzIiwidG9CYXNlNjQiLCJSZWFkYWJsZVN0cmVhbSIsInBpcGUiLCJjbGVhblBhdGgiLCJfcmVtb3ZlRW1wdHlGb2xkZXJzIiwiX3BhdGgiLCJfZ2V0RmluYWxQYXRoIiwiaWQiLCJJZCIsImZ1bGxQYXRoIiwiS2V5IiwidXBsb2FkIiwidXBsb2FkVG9TaWduZWRVcmwiLCJ0b2tlbiIsIl90aGlzMyIsIlVSTCIsInNlYXJjaFBhcmFtcyIsInNldCIsInRvU3RyaW5nIiwiY3JlYXRlU2lnbmVkVXBsb2FkVXJsIiwiX3RoaXM0Iiwic2lnbmVkVXJsIiwidXBkYXRlIiwibW92ZSIsImZyb21QYXRoIiwidG9QYXRoIiwiX3RoaXM2Iiwic291cmNlS2V5IiwiZGVzdGluYXRpb25LZXkiLCJkZXN0aW5hdGlvbkJ1Y2tldCIsImNvcHkiLCJfdGhpczciLCJjcmVhdGVTaWduZWRVcmwiLCJleHBpcmVzSW4iLCJfdGhpczgiLCJ0cmFuc2Zvcm0iLCJkb3dubG9hZFF1ZXJ5UGFyYW0iLCJkb3dubG9hZCIsImVuY29kZVVSSSIsInNpZ25lZFVSTCIsImNyZWF0ZVNpZ25lZFVybHMiLCJwYXRocyIsIl90aGlzOSIsImRhdHVtIiwicmVuZGVyUGF0aCIsInRyYW5zZm9ybWF0aW9uUXVlcnkiLCJ0cmFuc2Zvcm1PcHRzVG9RdWVyeVN0cmluZyIsInF1ZXJ5U3RyaW5nIiwiaW5mbyIsIl90aGlzMTAiLCJleGlzdHMiLCJfdGhpczExIiwiZ2V0UHVibGljVXJsIiwiX3F1ZXJ5U3RyaW5nIiwiam9pbiIsInB1YmxpY1VybCIsIl90aGlzMTIiLCJwcmVmaXhlcyIsImxpc3QiLCJfdGhpczEzIiwicHJlZml4IiwibGlzdFYyIiwiX3RoaXMxNCIsIkJ1ZmZlciIsImZyb20iLCJidG9hIiwid2lkdGgiLCJoZWlnaHQiLCJyZXNpemUiLCJmb3JtYXQiLCJxdWFsaXR5IiwidmVyc2lvbiIsIkRFRkFVTFRfSEVBREVSUyIsIlN0b3JhZ2VCdWNrZXRBcGkiLCJvcHRzIiwiYmFzZVVybCIsInVzZU5ld0hvc3RuYW1lIiwiaG9zdG5hbWUiLCJmaW5hbFVybCIsImhyZWYiLCJmaW5hbEhlYWRlcnMiLCJsaXN0QnVja2V0cyIsImxpc3RCdWNrZXRPcHRpb25zVG9RdWVyeVN0cmluZyIsImdldEJ1Y2tldCIsIl90aGlzMiIsImNyZWF0ZUJ1Y2tldCIsInB1YmxpYyIsInR5cGUiLCJmaWxlX3NpemVfbGltaXQiLCJmaWxlU2l6ZUxpbWl0IiwiYWxsb3dlZF9taW1lX3R5cGVzIiwiYWxsb3dlZE1pbWVUeXBlcyIsInVwZGF0ZUJ1Y2tldCIsImVtcHR5QnVja2V0IiwiX3RoaXM1IiwiZGVsZXRlQnVja2V0Iiwic2VhcmNoIiwic29ydENvbHVtbiIsInNvcnRPcmRlciIsIlVSTFNlYXJjaFBhcmFtcyIsIlN0b3JhZ2VBbmFseXRpY3NDbGllbnQiLCJxdWVyeVBhcmFtcyIsImNhdGFsb2ciLCJjYXRhbG9nTmFtZSIsImF1dGgiLCJnZXRIZWFkZXJzIiwiUHJveHkiLCJ0YXJnZXQiLCJwcm9wIiwiVmVjdG9ySW5kZXhBcGkiLCJjcmVhdGVJbmRleCIsImdldEluZGV4IiwidmVjdG9yQnVja2V0TmFtZSIsImluZGV4TmFtZSIsImxpc3RJbmRleGVzIiwiZGVsZXRlSW5kZXgiLCJWZWN0b3JEYXRhQXBpIiwicHV0VmVjdG9ycyIsInZlY3RvcnMiLCJnZXRWZWN0b3JzIiwibGlzdFZlY3RvcnMiLCJzZWdtZW50Q291bnQiLCJzZWdtZW50SW5kZXgiLCJxdWVyeVZlY3RvcnMiLCJkZWxldGVWZWN0b3JzIiwiVmVjdG9yQnVja2V0QXBpIiwiU3RvcmFnZVZlY3RvcnNDbGllbnQiLCJWZWN0b3JCdWNrZXRTY29wZSIsIl9zdXBlcnByb3BfZ2V0Q3JlYXRlQnVja2V0IiwiX3N1cGVycHJvcF9nZXRHZXRCdWNrZXQiLCJfc3VwZXJwcm9wX2dldExpc3RCdWNrZXRzIiwiX3N1cGVycHJvcF9nZXREZWxldGVCdWNrZXQiLCJfc3VwZXJwcm9wX2dldENyZWF0ZUluZGV4IiwiX3N1cGVycHJvcF9nZXRMaXN0SW5kZXhlcyIsIl9zdXBlcnByb3BfZ2V0R2V0SW5kZXgiLCJfc3VwZXJwcm9wX2dldERlbGV0ZUluZGV4IiwiaW5kZXgiLCJWZWN0b3JJbmRleFNjb3BlIiwiX3N1cGVycHJvcF9nZXRQdXRWZWN0b3JzIiwiX3N1cGVycHJvcF9nZXRHZXRWZWN0b3JzIiwiX3N1cGVycHJvcF9nZXRMaXN0VmVjdG9ycyIsIl9zdXBlcnByb3BfZ2V0UXVlcnlWZWN0b3JzIiwiX3N1cGVycHJvcF9nZXREZWxldGVWZWN0b3JzIiwiU3RvcmFnZUNsaWVudCIsImFuYWx5dGljcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/supabase-js/dist/index.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/index.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthAdminApi: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthAdminApi),\n/* harmony export */   AuthApiError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthApiError),\n/* harmony export */   AuthClient: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthClient),\n/* harmony export */   AuthError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthError),\n/* harmony export */   AuthImplicitGrantRedirectError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError),\n/* harmony export */   AuthInvalidCredentialsError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError),\n/* harmony export */   AuthInvalidJwtError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidJwtError),\n/* harmony export */   AuthInvalidTokenResponseError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError),\n/* harmony export */   AuthPKCECodeVerifierMissingError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthPKCECodeVerifierMissingError),\n/* harmony export */   AuthPKCEGrantCodeExchangeError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthPKCEGrantCodeExchangeError),\n/* harmony export */   AuthRetryableFetchError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError),\n/* harmony export */   AuthSessionMissingError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError),\n/* harmony export */   AuthUnknownError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthUnknownError),\n/* harmony export */   AuthWeakPasswordError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthWeakPasswordError),\n/* harmony export */   CustomAuthError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.CustomAuthError),\n/* harmony export */   FunctionRegion: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_5__.FunctionRegion),\n/* harmony export */   FunctionsError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_5__.FunctionsError),\n/* harmony export */   FunctionsFetchError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_5__.FunctionsFetchError),\n/* harmony export */   FunctionsHttpError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_5__.FunctionsHttpError),\n/* harmony export */   FunctionsRelayError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_5__.FunctionsRelayError),\n/* harmony export */   GoTrueAdminApi: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.GoTrueAdminApi),\n/* harmony export */   GoTrueClient: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.GoTrueClient),\n/* harmony export */   NavigatorLockAcquireTimeoutError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.NavigatorLockAcquireTimeoutError),\n/* harmony export */   PostgrestError: () => (/* reexport safe */ _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_0__.PostgrestError),\n/* harmony export */   REALTIME_CHANNEL_STATES: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.REALTIME_CHANNEL_STATES),\n/* harmony export */   REALTIME_LISTEN_TYPES: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.REALTIME_LISTEN_TYPES),\n/* harmony export */   REALTIME_POSTGRES_CHANGES_LISTEN_EVENT: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT),\n/* harmony export */   REALTIME_PRESENCE_LISTEN_EVENTS: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.REALTIME_PRESENCE_LISTEN_EVENTS),\n/* harmony export */   REALTIME_SUBSCRIBE_STATES: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.REALTIME_SUBSCRIBE_STATES),\n/* harmony export */   RealtimeChannel: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.RealtimeChannel),\n/* harmony export */   RealtimeClient: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.RealtimeClient),\n/* harmony export */   RealtimePresence: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.RealtimePresence),\n/* harmony export */   SIGN_OUT_SCOPES: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.SIGN_OUT_SCOPES),\n/* harmony export */   SupabaseClient: () => (/* binding */ SupabaseClient),\n/* harmony export */   WebSocketFactory: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.WebSocketFactory),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   isAuthApiError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.isAuthApiError),\n/* harmony export */   isAuthError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.isAuthError),\n/* harmony export */   isAuthImplicitGrantRedirectError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.isAuthImplicitGrantRedirectError),\n/* harmony export */   isAuthPKCECodeVerifierMissingError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.isAuthPKCECodeVerifierMissingError),\n/* harmony export */   isAuthRetryableFetchError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError),\n/* harmony export */   isAuthSessionMissingError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.isAuthSessionMissingError),\n/* harmony export */   isAuthWeakPasswordError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.isAuthWeakPasswordError),\n/* harmony export */   lockInternals: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.lockInternals),\n/* harmony export */   navigatorLock: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.navigatorLock),\n/* harmony export */   processLock: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.processLock)\n/* harmony export */ });\n/* harmony import */ var _supabase_functions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @supabase/functions-js */ \"(ssr)/./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js\");\n/* harmony import */ var _supabase_functions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @supabase/functions-js */ \"(ssr)/./node_modules/@supabase/functions-js/dist/module/types.js\");\n/* harmony import */ var _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/postgrest-js */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/index.mjs\");\n/* harmony import */ var _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/realtime-js */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/index.js\");\n/* harmony import */ var _supabase_storage_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @supabase/storage-js */ \"(ssr)/./node_modules/@supabase/storage-js/dist/index.mjs\");\n/* harmony import */ var _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @supabase/auth-js */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/index.js\");\n\n\n\n\n\n\n\n//#region src/lib/version.ts\nconst version = \"2.97.0\";\n//#endregion\n//#region src/lib/constants.ts\nlet JS_ENV = \"\";\nif (typeof Deno !== \"undefined\") JS_ENV = \"deno\";\nelse if (typeof document !== \"undefined\") JS_ENV = \"web\";\nelse if (typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") JS_ENV = \"react-native\";\nelse JS_ENV = \"node\";\nconst DEFAULT_HEADERS = {\n    \"X-Client-Info\": `supabase-js-${JS_ENV}/${version}`\n};\nconst DEFAULT_GLOBAL_OPTIONS = {\n    headers: DEFAULT_HEADERS\n};\nconst DEFAULT_DB_OPTIONS = {\n    schema: \"public\"\n};\nconst DEFAULT_AUTH_OPTIONS = {\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    flowType: \"implicit\"\n};\nconst DEFAULT_REALTIME_OPTIONS = {};\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/typeof.js\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o$1) {\n        return typeof o$1;\n    } : function(o$1) {\n        return o$1 && \"function\" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? \"symbol\" : typeof o$1;\n    }, _typeof(o);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPrimitive.js\nfunction toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPropertyKey.js\nfunction toPropertyKey(t) {\n    var i = toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/defineProperty.js\nfunction _defineProperty(e, r, t) {\n    return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/objectSpread2.js\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r$1) {\n            return Object.getOwnPropertyDescriptor(e, r$1).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread2(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r$1) {\n            _defineProperty(e, r$1, t[r$1]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {\n            Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));\n        });\n    }\n    return e;\n}\n//#endregion\n//#region src/lib/fetch.ts\nconst resolveFetch = (customFetch)=>{\n    if (customFetch) return (...args)=>customFetch(...args);\n    return (...args)=>fetch(...args);\n};\nconst resolveHeadersConstructor = ()=>{\n    return Headers;\n};\nconst fetchWithAuth = (supabaseKey, getAccessToken, customFetch)=>{\n    const fetch$1 = resolveFetch(customFetch);\n    const HeadersConstructor = resolveHeadersConstructor();\n    return async (input, init)=>{\n        var _await$getAccessToken;\n        const accessToken = (_await$getAccessToken = await getAccessToken()) !== null && _await$getAccessToken !== void 0 ? _await$getAccessToken : supabaseKey;\n        let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);\n        if (!headers.has(\"apikey\")) headers.set(\"apikey\", supabaseKey);\n        if (!headers.has(\"Authorization\")) headers.set(\"Authorization\", `Bearer ${accessToken}`);\n        return fetch$1(input, _objectSpread2(_objectSpread2({}, init), {}, {\n            headers\n        }));\n    };\n};\n//#endregion\n//#region src/lib/helpers.ts\nfunction ensureTrailingSlash(url) {\n    return url.endsWith(\"/\") ? url : url + \"/\";\n}\nfunction applySettingDefaults(options, defaults) {\n    var _DEFAULT_GLOBAL_OPTIO, _globalOptions$header;\n    const { db: dbOptions, auth: authOptions, realtime: realtimeOptions, global: globalOptions } = options;\n    const { db: DEFAULT_DB_OPTIONS$1, auth: DEFAULT_AUTH_OPTIONS$1, realtime: DEFAULT_REALTIME_OPTIONS$1, global: DEFAULT_GLOBAL_OPTIONS$1 } = defaults;\n    const result = {\n        db: _objectSpread2(_objectSpread2({}, DEFAULT_DB_OPTIONS$1), dbOptions),\n        auth: _objectSpread2(_objectSpread2({}, DEFAULT_AUTH_OPTIONS$1), authOptions),\n        realtime: _objectSpread2(_objectSpread2({}, DEFAULT_REALTIME_OPTIONS$1), realtimeOptions),\n        storage: {},\n        global: _objectSpread2(_objectSpread2(_objectSpread2({}, DEFAULT_GLOBAL_OPTIONS$1), globalOptions), {}, {\n            headers: _objectSpread2(_objectSpread2({}, (_DEFAULT_GLOBAL_OPTIO = DEFAULT_GLOBAL_OPTIONS$1 === null || DEFAULT_GLOBAL_OPTIONS$1 === void 0 ? void 0 : DEFAULT_GLOBAL_OPTIONS$1.headers) !== null && _DEFAULT_GLOBAL_OPTIO !== void 0 ? _DEFAULT_GLOBAL_OPTIO : {}), (_globalOptions$header = globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.headers) !== null && _globalOptions$header !== void 0 ? _globalOptions$header : {})\n        }),\n        accessToken: async ()=>\"\"\n    };\n    if (options.accessToken) result.accessToken = options.accessToken;\n    else delete result.accessToken;\n    return result;\n}\n/**\n* Validates a Supabase client URL\n*\n* @param {string} supabaseUrl - The Supabase client URL string.\n* @returns {URL} - The validated base URL.\n* @throws {Error}\n*/ function validateSupabaseUrl(supabaseUrl) {\n    const trimmedUrl = supabaseUrl === null || supabaseUrl === void 0 ? void 0 : supabaseUrl.trim();\n    if (!trimmedUrl) throw new Error(\"supabaseUrl is required.\");\n    if (!trimmedUrl.match(/^https?:\\/\\//i)) throw new Error(\"Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.\");\n    try {\n        return new URL(ensureTrailingSlash(trimmedUrl));\n    } catch (_unused) {\n        throw Error(\"Invalid supabaseUrl: Provided URL is malformed.\");\n    }\n}\n//#endregion\n//#region src/lib/SupabaseAuthClient.ts\nvar SupabaseAuthClient = class extends _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthClient {\n    constructor(options){\n        super(options);\n    }\n};\n//#endregion\n//#region src/SupabaseClient.ts\n/**\n* Supabase Client.\n*\n* An isomorphic Javascript client for interacting with Postgres.\n*/ var SupabaseClient = class {\n    /**\n\t* Create a new client for use in the browser.\n\t* @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n\t* @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n\t* @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n\t* @param options.auth.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n\t* @param options.auth.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n\t* @param options.auth.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n\t* @param options.realtime Options passed along to realtime-js constructor.\n\t* @param options.storage Options passed along to the storage-js constructor.\n\t* @param options.global.fetch A custom fetch implementation.\n\t* @param options.global.headers Any additional headers to send with each network request.\n\t* @example\n\t* ```ts\n\t* import { createClient } from '@supabase/supabase-js'\n\t*\n\t* const supabase = createClient('https://xyzcompany.supabase.co', 'public-anon-key')\n\t* const { data } = await supabase.from('profiles').select('*')\n\t* ```\n\t*/ constructor(supabaseUrl, supabaseKey, options){\n        var _settings$auth$storag, _settings$global$head;\n        this.supabaseUrl = supabaseUrl;\n        this.supabaseKey = supabaseKey;\n        const baseUrl = validateSupabaseUrl(supabaseUrl);\n        if (!supabaseKey) throw new Error(\"supabaseKey is required.\");\n        this.realtimeUrl = new URL(\"realtime/v1\", baseUrl);\n        this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace(\"http\", \"ws\");\n        this.authUrl = new URL(\"auth/v1\", baseUrl);\n        this.storageUrl = new URL(\"storage/v1\", baseUrl);\n        this.functionsUrl = new URL(\"functions/v1\", baseUrl);\n        const defaultStorageKey = `sb-${baseUrl.hostname.split(\".\")[0]}-auth-token`;\n        const DEFAULTS = {\n            db: DEFAULT_DB_OPTIONS,\n            realtime: DEFAULT_REALTIME_OPTIONS,\n            auth: _objectSpread2(_objectSpread2({}, DEFAULT_AUTH_OPTIONS), {}, {\n                storageKey: defaultStorageKey\n            }),\n            global: DEFAULT_GLOBAL_OPTIONS\n        };\n        const settings = applySettingDefaults(options !== null && options !== void 0 ? options : {}, DEFAULTS);\n        this.storageKey = (_settings$auth$storag = settings.auth.storageKey) !== null && _settings$auth$storag !== void 0 ? _settings$auth$storag : \"\";\n        this.headers = (_settings$global$head = settings.global.headers) !== null && _settings$global$head !== void 0 ? _settings$global$head : {};\n        if (!settings.accessToken) {\n            var _settings$auth;\n            this.auth = this._initSupabaseAuthClient((_settings$auth = settings.auth) !== null && _settings$auth !== void 0 ? _settings$auth : {}, this.headers, settings.global.fetch);\n        } else {\n            this.accessToken = settings.accessToken;\n            this.auth = new Proxy({}, {\n                get: (_, prop)=>{\n                    throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`);\n                }\n            });\n        }\n        this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);\n        this.realtime = this._initRealtimeClient(_objectSpread2({\n            headers: this.headers,\n            accessToken: this._getAccessToken.bind(this)\n        }, settings.realtime));\n        if (this.accessToken) Promise.resolve(this.accessToken()).then((token)=>this.realtime.setAuth(token)).catch((e)=>console.warn(\"Failed to set initial Realtime auth token:\", e));\n        this.rest = new _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_0__.PostgrestClient(new URL(\"rest/v1\", baseUrl).href, {\n            headers: this.headers,\n            schema: settings.db.schema,\n            fetch: this.fetch,\n            timeout: settings.db.timeout,\n            urlLengthLimit: settings.db.urlLengthLimit\n        });\n        this.storage = new _supabase_storage_js__WEBPACK_IMPORTED_MODULE_3__.StorageClient(this.storageUrl.href, this.headers, this.fetch, options === null || options === void 0 ? void 0 : options.storage);\n        if (!settings.accessToken) this._listenForAuthEvents();\n    }\n    /**\n\t* Supabase Functions allows you to deploy and invoke edge functions.\n\t*/ get functions() {\n        return new _supabase_functions_js__WEBPACK_IMPORTED_MODULE_4__.FunctionsClient(this.functionsUrl.href, {\n            headers: this.headers,\n            customFetch: this.fetch\n        });\n    }\n    /**\n\t* Perform a query on a table or a view.\n\t*\n\t* @param relation - The table or view name to query\n\t*/ from(relation) {\n        return this.rest.from(relation);\n    }\n    /**\n\t* Select a schema to query or perform an function (rpc) call.\n\t*\n\t* The schema needs to be on the list of exposed schemas inside Supabase.\n\t*\n\t* @param schema - The schema to query\n\t*/ schema(schema) {\n        return this.rest.schema(schema);\n    }\n    /**\n\t* Perform a function call.\n\t*\n\t* @param fn - The function name to call\n\t* @param args - The arguments to pass to the function call\n\t* @param options - Named parameters\n\t* @param options.head - When set to `true`, `data` will not be returned.\n\t* Useful if you only need the count.\n\t* @param options.get - When set to `true`, the function will be called with\n\t* read-only access mode.\n\t* @param options.count - Count algorithm to use to count rows returned by the\n\t* function. Only applicable for [set-returning\n\t* functions](https://www.postgresql.org/docs/current/functions-srf.html).\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*/ rpc(fn, args = {}, options = {\n        head: false,\n        get: false,\n        count: void 0\n    }) {\n        return this.rest.rpc(fn, args, options);\n    }\n    /**\n\t* Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.\n\t*\n\t* @param {string} name - The name of the Realtime channel.\n\t* @param {Object} opts - The options to pass to the Realtime channel.\n\t*\n\t*/ channel(name, opts = {\n        config: {}\n    }) {\n        return this.realtime.channel(name, opts);\n    }\n    /**\n\t* Returns all Realtime channels.\n\t*/ getChannels() {\n        return this.realtime.getChannels();\n    }\n    /**\n\t* Unsubscribes and removes Realtime channel from Realtime client.\n\t*\n\t* @param {RealtimeChannel} channel - The name of the Realtime channel.\n\t*\n\t*/ removeChannel(channel) {\n        return this.realtime.removeChannel(channel);\n    }\n    /**\n\t* Unsubscribes and removes all Realtime channels from Realtime client.\n\t*/ removeAllChannels() {\n        return this.realtime.removeAllChannels();\n    }\n    async _getAccessToken() {\n        var _this = this;\n        var _data$session$access_, _data$session;\n        if (_this.accessToken) return await _this.accessToken();\n        const { data } = await _this.auth.getSession();\n        return (_data$session$access_ = (_data$session = data.session) === null || _data$session === void 0 ? void 0 : _data$session.access_token) !== null && _data$session$access_ !== void 0 ? _data$session$access_ : _this.supabaseKey;\n    }\n    _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, storage, userStorage, storageKey, flowType, lock, debug, throwOnError }, headers, fetch$1) {\n        const authHeaders = {\n            Authorization: `Bearer ${this.supabaseKey}`,\n            apikey: `${this.supabaseKey}`\n        };\n        return new SupabaseAuthClient({\n            url: this.authUrl.href,\n            headers: _objectSpread2(_objectSpread2({}, authHeaders), headers),\n            storageKey,\n            autoRefreshToken,\n            persistSession,\n            detectSessionInUrl,\n            storage,\n            userStorage,\n            flowType,\n            lock,\n            debug,\n            throwOnError,\n            fetch: fetch$1,\n            hasCustomAuthorizationHeader: Object.keys(this.headers).some((key)=>key.toLowerCase() === \"authorization\")\n        });\n    }\n    _initRealtimeClient(options) {\n        return new _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.RealtimeClient(this.realtimeUrl.href, _objectSpread2(_objectSpread2({}, options), {}, {\n            params: _objectSpread2(_objectSpread2({}, {\n                apikey: this.supabaseKey\n            }), options === null || options === void 0 ? void 0 : options.params)\n        }));\n    }\n    _listenForAuthEvents() {\n        return this.auth.onAuthStateChange((event, session)=>{\n            this._handleTokenChanged(event, \"CLIENT\", session === null || session === void 0 ? void 0 : session.access_token);\n        });\n    }\n    _handleTokenChanged(event, source, token) {\n        if ((event === \"TOKEN_REFRESHED\" || event === \"SIGNED_IN\") && this.changedAccessToken !== token) {\n            this.changedAccessToken = token;\n            this.realtime.setAuth(token);\n        } else if (event === \"SIGNED_OUT\") {\n            this.realtime.setAuth();\n            if (source == \"STORAGE\") this.auth.signOut();\n            this.changedAccessToken = void 0;\n        }\n    }\n};\n//#endregion\n//#region src/index.ts\n/**\n* Creates a new Supabase Client.\n*\n* @example\n* ```ts\n* import { createClient } from '@supabase/supabase-js'\n*\n* const supabase = createClient('https://xyzcompany.supabase.co', 'public-anon-key')\n* const { data, error } = await supabase.from('profiles').select('*')\n* ```\n*/ const createClient = (supabaseUrl, supabaseKey, options)=>{\n    return new SupabaseClient(supabaseUrl, supabaseKey, options);\n};\nfunction shouldShowDeprecationWarning() {\n    if (false) {}\n    const _process = globalThis[\"process\"];\n    if (!_process) return false;\n    const processVersion = _process[\"version\"];\n    if (processVersion === void 0 || processVersion === null) return false;\n    const versionMatch = processVersion.match(/^v(\\d+)\\./);\n    if (!versionMatch) return false;\n    return parseInt(versionMatch[1], 10) <= 18;\n}\nif (shouldShowDeprecationWarning()) console.warn(\"  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217\");\n//#endregion\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUo7QUFDOUU7QUFDbEI7QUFDRjtBQUNOO0FBRVY7QUFFSjtBQUVqQyw0QkFBNEI7QUFDNUIsTUFBTVcsVUFBVTtBQUVoQixZQUFZO0FBQ1osOEJBQThCO0FBQzlCLElBQUlDLFNBQVM7QUFDYixJQUFJLE9BQU9DLFNBQVMsYUFBYUQsU0FBUztLQUNyQyxJQUFJLE9BQU9FLGFBQWEsYUFBYUYsU0FBUztLQUM5QyxJQUFJLE9BQU9HLGNBQWMsZUFBZUEsVUFBVUMsT0FBTyxLQUFLLGVBQWVKLFNBQVM7S0FDdEZBLFNBQVM7QUFDZCxNQUFNSyxrQkFBa0I7SUFBRSxpQkFBaUIsQ0FBQyxZQUFZLEVBQUVMLE9BQU8sQ0FBQyxFQUFFRCxRQUFRLENBQUM7QUFBQztBQUM5RSxNQUFNTyx5QkFBeUI7SUFBRUMsU0FBU0Y7QUFBZ0I7QUFDMUQsTUFBTUcscUJBQXFCO0lBQUVDLFFBQVE7QUFBUztBQUM5QyxNQUFNQyx1QkFBdUI7SUFDNUJDLGtCQUFrQjtJQUNsQkMsZ0JBQWdCO0lBQ2hCQyxvQkFBb0I7SUFDcEJDLFVBQVU7QUFDWDtBQUNBLE1BQU1DLDJCQUEyQixDQUFDO0FBRWxDLFlBQVk7QUFDWiwwREFBMEQ7QUFDMUQsU0FBU0MsUUFBUUMsQ0FBQztJQUNqQjtJQUNBLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVNDLEdBQUc7UUFDaEcsT0FBTyxPQUFPQTtJQUNmLElBQUksU0FBU0EsR0FBRztRQUNmLE9BQU9BLE9BQU8sY0FBYyxPQUFPRixVQUFVRSxJQUFJQyxXQUFXLEtBQUtILFVBQVVFLFFBQVFGLE9BQU9JLFNBQVMsR0FBRyxXQUFXLE9BQU9GO0lBQ3pILEdBQUdKLFFB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QUFDc0YsY0FBYyxPQUFPO0lBQzFCLE9BQU9DLFNBQVNELFlBQVksQ0FBQyxFQUFFLEVBQUUsT0FBTztBQUN6QztBQUNBLElBQUlKLGdDQUFnQy9DLFFBQVFDLElBQUksQ0FBQztBQUVqRCxZQUFZO0FBQzBJLENBQ3RKLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FuY2hvci13b3JrZmxvd3MvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvaW5kZXgubWpzPzQ5M2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRnVuY3Rpb25SZWdpb24sIEZ1bmN0aW9uc0NsaWVudCwgRnVuY3Rpb25zRXJyb3IsIEZ1bmN0aW9uc0ZldGNoRXJyb3IsIEZ1bmN0aW9uc0h0dHBFcnJvciwgRnVuY3Rpb25zUmVsYXlFcnJvciB9IGZyb20gXCJAc3VwYWJhc2UvZnVuY3Rpb25zLWpzXCI7XG5pbXBvcnQgeyBQb3N0Z3Jlc3RDbGllbnQsIFBvc3RncmVzdEVycm9yIH0gZnJvbSBcIkBzdXBhYmFzZS9wb3N0Z3Jlc3QtanNcIjtcbmltcG9ydCB7IFJlYWx0aW1lQ2xpZW50IH0gZnJvbSBcIkBzdXBhYmFzZS9yZWFsdGltZS1qc1wiO1xuaW1wb3J0IHsgU3RvcmFnZUNsaWVudCB9IGZyb20gXCJAc3VwYWJhc2Uvc3RvcmFnZS1qc1wiO1xuaW1wb3J0IHsgQXV0aENsaWVudCB9IGZyb20gXCJAc3VwYWJhc2UvYXV0aC1qc1wiO1xuXG5leHBvcnQgKiBmcm9tIFwiQHN1cGFiYXNlL3JlYWx0aW1lLWpzXCJcblxuZXhwb3J0ICogZnJvbSBcIkBzdXBhYmFzZS9hdXRoLWpzXCJcblxuLy8jcmVnaW9uIHNyYy9saWIvdmVyc2lvbi50c1xuY29uc3QgdmVyc2lvbiA9IFwiMi45Ny4wXCI7XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvY29uc3RhbnRzLnRzXG5sZXQgSlNfRU5WID0gXCJcIjtcbmlmICh0eXBlb2YgRGVubyAhPT0gXCJ1bmRlZmluZWRcIikgSlNfRU5WID0gXCJkZW5vXCI7XG5lbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIEpTX0VOViA9IFwid2ViXCI7XG5lbHNlIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSBcIlJlYWN0TmF0aXZlXCIpIEpTX0VOViA9IFwicmVhY3QtbmF0aXZlXCI7XG5lbHNlIEpTX0VOViA9IFwibm9kZVwiO1xuY29uc3QgREVGQVVMVF9IRUFERVJTID0geyBcIlgtQ2xpZW50LUluZm9cIjogYHN1cGFiYXNlLWpzLSR7SlNfRU5WfS8ke3ZlcnNpb259YCB9O1xuY29uc3QgREVGQVVMVF9HTE9CQUxfT1BUSU9OUyA9IHsgaGVhZGVyczogREVGQVVMVF9IRUFERVJTIH07XG5jb25zdCBERUZBVUxUX0RCX09QVElPTlMgPSB7IHNjaGVtYTogXCJwdWJsaWNcIiB9O1xuY29uc3QgREVGQVVMVF9BVVRIX09QVElPTlMgPSB7XG5cdGF1dG9SZWZyZXNoVG9rZW46IHRydWUsXG5cdHBlcnNpc3RTZXNzaW9uOiB0cnVlLFxuXHRkZXRlY3RTZXNzaW9uSW5Vcmw6IHRydWUsXG5cdGZsb3dUeXBlOiBcImltcGxpY2l0XCJcbn07XG5jb25zdCBERUZBVUxUX1JFQUxUSU1FX09QVElPTlMgPSB7fTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gXFwwQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC4xMDEuMC9oZWxwZXJzL3R5cGVvZi5qc1xuZnVuY3Rpb24gX3R5cGVvZihvKSB7XG5cdFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblx0cmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbihvJDEpIHtcblx0XHRyZXR1cm4gdHlwZW9mIG8kMTtcblx0fSA6IGZ1bmN0aW9uKG8kMSkge1xuXHRcdHJldHVybiBvJDEgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgbyQxLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyQxICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvJDE7XG5cdH0sIF90eXBlb2Yobyk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIFxcMEBveGMtcHJvamVjdCtydW50aW1lQDAuMTAxLjAvaGVscGVycy90b1ByaW1pdGl2ZS5qc1xuZnVuY3Rpb24gdG9QcmltaXRpdmUodCwgcikge1xuXHRpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDtcblx0dmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG5cdGlmICh2b2lkIDAgIT09IGUpIHtcblx0XHR2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTtcblx0XHRpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG5cdH1cblx0cmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gXFwwQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC4xMDEuMC9oZWxwZXJzL3RvUHJvcGVydHlLZXkuanNcbmZ1bmN0aW9uIHRvUHJvcGVydHlLZXkodCkge1xuXHR2YXIgaSA9IHRvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuXHRyZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBcXDBAb3hjLXByb2plY3QrcnVudGltZUAwLjEwMS4wL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanNcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7XG5cdHJldHVybiAociA9IHRvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwge1xuXHRcdHZhbHVlOiB0LFxuXHRcdGVudW1lcmFibGU6ICEwLFxuXHRcdGNvbmZpZ3VyYWJsZTogITAsXG5cdFx0d3JpdGFibGU6ICEwXG5cdH0pIDogZVtyXSA9IHQsIGU7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIFxcMEBveGMtcHJvamVjdCtydW50aW1lQDAuMTAxLjAvaGVscGVycy9vYmplY3RTcHJlYWQyLmpzXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHtcblx0dmFyIHQgPSBPYmplY3Qua2V5cyhlKTtcblx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHR2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG5cdFx0ciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uKHIkMSkge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgciQxKS5lbnVtZXJhYmxlO1xuXHRcdH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pO1xuXHR9XG5cdHJldHVybiB0O1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIoZSkge1xuXHRmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykge1xuXHRcdHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTtcblx0XHRyICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbihyJDEpIHtcblx0XHRcdF9kZWZpbmVQcm9wZXJ0eShlLCByJDEsIHRbciQxXSk7XG5cdFx0fSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uKHIkMSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIkMSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByJDEpKTtcblx0XHR9KTtcblx0fVxuXHRyZXR1cm4gZTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2xpYi9mZXRjaC50c1xuY29uc3QgcmVzb2x2ZUZldGNoID0gKGN1c3RvbUZldGNoKSA9PiB7XG5cdGlmIChjdXN0b21GZXRjaCkgcmV0dXJuICguLi5hcmdzKSA9PiBjdXN0b21GZXRjaCguLi5hcmdzKTtcblx0cmV0dXJuICguLi5hcmdzKSA9PiBmZXRjaCguLi5hcmdzKTtcbn07XG5jb25zdCByZXNvbHZlSGVhZGVyc0NvbnN0cnVjdG9yID0gKCkgPT4ge1xuXHRyZXR1cm4gSGVhZGVycztcbn07XG5jb25zdCBmZXRjaFdpdGhBdXRoID0gKHN1cGFiYXNlS2V5LCBnZXRBY2Nlc3NUb2tlbiwgY3VzdG9tRmV0Y2gpID0+IHtcblx0Y29uc3QgZmV0Y2gkMSA9IHJlc29sdmVGZXRjaChjdXN0b21GZXRjaCk7XG5cdGNvbnN0IEhlYWRlcnNDb25zdHJ1Y3RvciA9IHJlc29sdmVIZWFkZXJzQ29uc3RydWN0b3IoKTtcblx0cmV0dXJuIGFzeW5jIChpbnB1dCwgaW5pdCkgPT4ge1xuXHRcdHZhciBfYXdhaXQkZ2V0QWNjZXNzVG9rZW47XG5cdFx0Y29uc3QgYWNjZXNzVG9rZW4gPSAoX2F3YWl0JGdldEFjY2Vzc1Rva2VuID0gYXdhaXQgZ2V0QWNjZXNzVG9rZW4oKSkgIT09IG51bGwgJiYgX2F3YWl0JGdldEFjY2Vzc1Rva2VuICE9PSB2b2lkIDAgPyBfYXdhaXQkZ2V0QWNjZXNzVG9rZW4gOiBzdXBhYmFzZUtleTtcblx0XHRsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzQ29uc3RydWN0b3IoaW5pdCA9PT0gbnVsbCB8fCBpbml0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnMpO1xuXHRcdGlmICghaGVhZGVycy5oYXMoXCJhcGlrZXlcIikpIGhlYWRlcnMuc2V0KFwiYXBpa2V5XCIsIHN1cGFiYXNlS2V5KTtcblx0XHRpZiAoIWhlYWRlcnMuaGFzKFwiQXV0aG9yaXphdGlvblwiKSkgaGVhZGVycy5zZXQoXCJBdXRob3JpemF0aW9uXCIsIGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gKTtcblx0XHRyZXR1cm4gZmV0Y2gkMShpbnB1dCwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGluaXQpLCB7fSwgeyBoZWFkZXJzIH0pKTtcblx0fTtcbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvaGVscGVycy50c1xuZnVuY3Rpb24gZW5zdXJlVHJhaWxpbmdTbGFzaCh1cmwpIHtcblx0cmV0dXJuIHVybC5lbmRzV2l0aChcIi9cIikgPyB1cmwgOiB1cmwgKyBcIi9cIjtcbn1cbmZ1bmN0aW9uIGFwcGx5U2V0dGluZ0RlZmF1bHRzKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG5cdHZhciBfREVGQVVMVF9HTE9CQUxfT1BUSU8sIF9nbG9iYWxPcHRpb25zJGhlYWRlcjtcblx0Y29uc3QgeyBkYjogZGJPcHRpb25zLCBhdXRoOiBhdXRoT3B0aW9ucywgcmVhbHRpbWU6IHJlYWx0aW1lT3B0aW9ucywgZ2xvYmFsOiBnbG9iYWxPcHRpb25zIH0gPSBvcHRpb25zO1xuXHRjb25zdCB7IGRiOiBERUZBVUxUX0RCX09QVElPTlMkMSwgYXV0aDogREVGQVVMVF9BVVRIX09QVElPTlMkMSwgcmVhbHRpbWU6IERFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUyQxLCBnbG9iYWw6IERFRkFVTFRfR0xPQkFMX09QVElPTlMkMSB9ID0gZGVmYXVsdHM7XG5cdGNvbnN0IHJlc3VsdCA9IHtcblx0XHRkYjogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfREJfT1BUSU9OUyQxKSwgZGJPcHRpb25zKSxcblx0XHRhdXRoOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9BVVRIX09QVElPTlMkMSksIGF1dGhPcHRpb25zKSxcblx0XHRyZWFsdGltZTogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUyQxKSwgcmVhbHRpbWVPcHRpb25zKSxcblx0XHRzdG9yYWdlOiB7fSxcblx0XHRnbG9iYWw6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX0dMT0JBTF9PUFRJT05TJDEpLCBnbG9iYWxPcHRpb25zKSwge30sIHsgaGVhZGVyczogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIChfREVGQVVMVF9HTE9CQUxfT1BUSU8gPSBERUZBVUxUX0dMT0JBTF9PUFRJT05TJDEgPT09IG51bGwgfHwgREVGQVVMVF9HTE9CQUxfT1BUSU9OUyQxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBERUZBVUxUX0dMT0JBTF9PUFRJT05TJDEuaGVhZGVycykgIT09IG51bGwgJiYgX0RFRkFVTFRfR0xPQkFMX09QVElPICE9PSB2b2lkIDAgPyBfREVGQVVMVF9HTE9CQUxfT1BUSU8gOiB7fSksIChfZ2xvYmFsT3B0aW9ucyRoZWFkZXIgPSBnbG9iYWxPcHRpb25zID09PSBudWxsIHx8IGdsb2JhbE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdsb2JhbE9wdGlvbnMuaGVhZGVycykgIT09IG51bGwgJiYgX2dsb2JhbE9wdGlvbnMkaGVhZGVyICE9PSB2b2lkIDAgPyBfZ2xvYmFsT3B0aW9ucyRoZWFkZXIgOiB7fSkgfSksXG5cdFx0YWNjZXNzVG9rZW46IGFzeW5jICgpID0+IFwiXCJcblx0fTtcblx0aWYgKG9wdGlvbnMuYWNjZXNzVG9rZW4pIHJlc3VsdC5hY2Nlc3NUb2tlbiA9IG9wdGlvbnMuYWNjZXNzVG9rZW47XG5cdGVsc2UgZGVsZXRlIHJlc3VsdC5hY2Nlc3NUb2tlbjtcblx0cmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuKiBWYWxpZGF0ZXMgYSBTdXBhYmFzZSBjbGllbnQgVVJMXG4qXG4qIEBwYXJhbSB7c3RyaW5nfSBzdXBhYmFzZVVybCAtIFRoZSBTdXBhYmFzZSBjbGllbnQgVVJMIHN0cmluZy5cbiogQHJldHVybnMge1VSTH0gLSBUaGUgdmFsaWRhdGVkIGJhc2UgVVJMLlxuKiBAdGhyb3dzIHtFcnJvcn1cbiovXG5mdW5jdGlvbiB2YWxpZGF0ZVN1cGFiYXNlVXJsKHN1cGFiYXNlVXJsKSB7XG5cdGNvbnN0IHRyaW1tZWRVcmwgPSBzdXBhYmFzZVVybCA9PT0gbnVsbCB8fCBzdXBhYmFzZVVybCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3VwYWJhc2VVcmwudHJpbSgpO1xuXHRpZiAoIXRyaW1tZWRVcmwpIHRocm93IG5ldyBFcnJvcihcInN1cGFiYXNlVXJsIGlzIHJlcXVpcmVkLlwiKTtcblx0aWYgKCF0cmltbWVkVXJsLm1hdGNoKC9eaHR0cHM/OlxcL1xcLy9pKSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdXBhYmFzZVVybDogTXVzdCBiZSBhIHZhbGlkIEhUVFAgb3IgSFRUUFMgVVJMLlwiKTtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IFVSTChlbnN1cmVUcmFpbGluZ1NsYXNoKHRyaW1tZWRVcmwpKTtcblx0fSBjYXRjaCAoX3VudXNlZCkge1xuXHRcdHRocm93IEVycm9yKFwiSW52YWxpZCBzdXBhYmFzZVVybDogUHJvdmlkZWQgVVJMIGlzIG1hbGZvcm1lZC5cIik7XG5cdH1cbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2xpYi9TdXBhYmFzZUF1dGhDbGllbnQudHNcbnZhciBTdXBhYmFzZUF1dGhDbGllbnQgPSBjbGFzcyBleHRlbmRzIEF1dGhDbGllbnQge1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0c3VwZXIob3B0aW9ucyk7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9TdXBhYmFzZUNsaWVudC50c1xuLyoqXG4qIFN1cGFiYXNlIENsaWVudC5cbipcbiogQW4gaXNvbW9ycGhpYyBKYXZhc2NyaXB0IGNsaWVudCBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBQb3N0Z3Jlcy5cbiovXG52YXIgU3VwYWJhc2VDbGllbnQgPSBjbGFzcyB7XG5cdC8qKlxuXHQqIENyZWF0ZSBhIG5ldyBjbGllbnQgZm9yIHVzZSBpbiB0aGUgYnJvd3Nlci5cblx0KiBAcGFyYW0gc3VwYWJhc2VVcmwgVGhlIHVuaXF1ZSBTdXBhYmFzZSBVUkwgd2hpY2ggaXMgc3VwcGxpZWQgd2hlbiB5b3UgY3JlYXRlIGEgbmV3IHByb2plY3QgaW4geW91ciBwcm9qZWN0IGRhc2hib2FyZC5cblx0KiBAcGFyYW0gc3VwYWJhc2VLZXkgVGhlIHVuaXF1ZSBTdXBhYmFzZSBLZXkgd2hpY2ggaXMgc3VwcGxpZWQgd2hlbiB5b3UgY3JlYXRlIGEgbmV3IHByb2plY3QgaW4geW91ciBwcm9qZWN0IGRhc2hib2FyZC5cblx0KiBAcGFyYW0gb3B0aW9ucy5kYi5zY2hlbWEgWW91IGNhbiBzd2l0Y2ggaW4gYmV0d2VlbiBzY2hlbWFzLiBUaGUgc2NoZW1hIG5lZWRzIHRvIGJlIG9uIHRoZSBsaXN0IG9mIGV4cG9zZWQgc2NoZW1hcyBpbnNpZGUgU3VwYWJhc2UuXG5cdCogQHBhcmFtIG9wdGlvbnMuYXV0aC5hdXRvUmVmcmVzaFRva2VuIFNldCB0byBcInRydWVcIiBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IHJlZnJlc2ggdGhlIHRva2VuIGJlZm9yZSBleHBpcmluZy5cblx0KiBAcGFyYW0gb3B0aW9ucy5hdXRoLnBlcnNpc3RTZXNzaW9uIFNldCB0byBcInRydWVcIiBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IHNhdmUgdGhlIHVzZXIgc2Vzc2lvbiBpbnRvIGxvY2FsIHN0b3JhZ2UuXG5cdCogQHBhcmFtIG9wdGlvbnMuYXV0aC5kZXRlY3RTZXNzaW9uSW5VcmwgU2V0IHRvIFwidHJ1ZVwiIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgZGV0ZWN0cyBPQXV0aCBncmFudHMgaW4gdGhlIFVSTCBhbmQgc2lnbnMgaW4gdGhlIHVzZXIuXG5cdCogQHBhcmFtIG9wdGlvbnMucmVhbHRpbWUgT3B0aW9ucyBwYXNzZWQgYWxvbmcgdG8gcmVhbHRpbWUtanMgY29uc3RydWN0b3IuXG5cdCogQHBhcmFtIG9wdGlvbnMuc3RvcmFnZSBPcHRpb25zIHBhc3NlZCBhbG9uZyB0byB0aGUgc3RvcmFnZS1qcyBjb25zdHJ1Y3Rvci5cblx0KiBAcGFyYW0gb3B0aW9ucy5nbG9iYWwuZmV0Y2ggQSBjdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb24uXG5cdCogQHBhcmFtIG9wdGlvbnMuZ2xvYmFsLmhlYWRlcnMgQW55IGFkZGl0aW9uYWwgaGVhZGVycyB0byBzZW5kIHdpdGggZWFjaCBuZXR3b3JrIHJlcXVlc3QuXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0c1xuXHQqIGltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcydcblx0KlxuXHQqIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KCdodHRwczovL3h5emNvbXBhbnkuc3VwYWJhc2UuY28nLCAncHVibGljLWFub24ta2V5Jylcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ3Byb2ZpbGVzJykuc2VsZWN0KCcqJylcblx0KiBgYGBcblx0Ki9cblx0Y29uc3RydWN0b3Ioc3VwYWJhc2VVcmwsIHN1cGFiYXNlS2V5LCBvcHRpb25zKSB7XG5cdFx0dmFyIF9zZXR0aW5ncyRhdXRoJHN0b3JhZywgX3NldHRpbmdzJGdsb2JhbCRoZWFkO1xuXHRcdHRoaXMuc3VwYWJhc2VVcmwgPSBzdXBhYmFzZVVybDtcblx0XHR0aGlzLnN1cGFiYXNlS2V5ID0gc3VwYWJhc2VLZXk7XG5cdFx0Y29uc3QgYmFzZVVybCA9IHZhbGlkYXRlU3VwYWJhc2VVcmwoc3VwYWJhc2VVcmwpO1xuXHRcdGlmICghc3VwYWJhc2VLZXkpIHRocm93IG5ldyBFcnJvcihcInN1cGFiYXNlS2V5IGlzIHJlcXVpcmVkLlwiKTtcblx0XHR0aGlzLnJlYWx0aW1lVXJsID0gbmV3IFVSTChcInJlYWx0aW1lL3YxXCIsIGJhc2VVcmwpO1xuXHRcdHRoaXMucmVhbHRpbWVVcmwucHJvdG9jb2wgPSB0aGlzLnJlYWx0aW1lVXJsLnByb3RvY29sLnJlcGxhY2UoXCJodHRwXCIsIFwid3NcIik7XG5cdFx0dGhpcy5hdXRoVXJsID0gbmV3IFVSTChcImF1dGgvdjFcIiwgYmFzZVVybCk7XG5cdFx0dGhpcy5zdG9yYWdlVXJsID0gbmV3IFVSTChcInN0b3JhZ2UvdjFcIiwgYmFzZVVybCk7XG5cdFx0dGhpcy5mdW5jdGlvbnNVcmwgPSBuZXcgVVJMKFwiZnVuY3Rpb25zL3YxXCIsIGJhc2VVcmwpO1xuXHRcdGNvbnN0IGRlZmF1bHRTdG9yYWdlS2V5ID0gYHNiLSR7YmFzZVVybC5ob3N0bmFtZS5zcGxpdChcIi5cIilbMF19LWF1dGgtdG9rZW5gO1xuXHRcdGNvbnN0IERFRkFVTFRTID0ge1xuXHRcdFx0ZGI6IERFRkFVTFRfREJfT1BUSU9OUyxcblx0XHRcdHJlYWx0aW1lOiBERUZBVUxUX1JFQUxUSU1FX09QVElPTlMsXG5cdFx0XHRhdXRoOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9BVVRIX09QVElPTlMpLCB7fSwgeyBzdG9yYWdlS2V5OiBkZWZhdWx0U3RvcmFnZUtleSB9KSxcblx0XHRcdGdsb2JhbDogREVGQVVMVF9HTE9CQUxfT1BUSU9OU1xuXHRcdH07XG5cdFx0Y29uc3Qgc2V0dGluZ3MgPSBhcHBseVNldHRpbmdEZWZhdWx0cyhvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSwgREVGQVVMVFMpO1xuXHRcdHRoaXMuc3RvcmFnZUtleSA9IChfc2V0dGluZ3MkYXV0aCRzdG9yYWcgPSBzZXR0aW5ncy5hdXRoLnN0b3JhZ2VLZXkpICE9PSBudWxsICYmIF9zZXR0aW5ncyRhdXRoJHN0b3JhZyAhPT0gdm9pZCAwID8gX3NldHRpbmdzJGF1dGgkc3RvcmFnIDogXCJcIjtcblx0XHR0aGlzLmhlYWRlcnMgPSAoX3NldHRpbmdzJGdsb2JhbCRoZWFkID0gc2V0dGluZ3MuZ2xvYmFsLmhlYWRlcnMpICE9PSBudWxsICYmIF9zZXR0aW5ncyRnbG9iYWwkaGVhZCAhPT0gdm9pZCAwID8gX3NldHRpbmdzJGdsb2JhbCRoZWFkIDoge307XG5cdFx0aWYgKCFzZXR0aW5ncy5hY2Nlc3NUb2tlbikge1xuXHRcdFx0dmFyIF9zZXR0aW5ncyRhdXRoO1xuXHRcdFx0dGhpcy5hdXRoID0gdGhpcy5faW5pdFN1cGFiYXNlQXV0aENsaWVudCgoX3NldHRpbmdzJGF1dGggPSBzZXR0aW5ncy5hdXRoKSAhPT0gbnVsbCAmJiBfc2V0dGluZ3MkYXV0aCAhPT0gdm9pZCAwID8gX3NldHRpbmdzJGF1dGggOiB7fSwgdGhpcy5oZWFkZXJzLCBzZXR0aW5ncy5nbG9iYWwuZmV0Y2gpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmFjY2Vzc1Rva2VuID0gc2V0dGluZ3MuYWNjZXNzVG9rZW47XG5cdFx0XHR0aGlzLmF1dGggPSBuZXcgUHJveHkoe30sIHsgZ2V0OiAoXywgcHJvcCkgPT4ge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9zdXBhYmFzZS1qczogU3VwYWJhc2UgQ2xpZW50IGlzIGNvbmZpZ3VyZWQgd2l0aCB0aGUgYWNjZXNzVG9rZW4gb3B0aW9uLCBhY2Nlc3Npbmcgc3VwYWJhc2UuYXV0aC4ke1N0cmluZyhwcm9wKX0gaXMgbm90IHBvc3NpYmxlYCk7XG5cdFx0XHR9IH0pO1xuXHRcdH1cblx0XHR0aGlzLmZldGNoID0gZmV0Y2hXaXRoQXV0aChzdXBhYmFzZUtleSwgdGhpcy5fZ2V0QWNjZXNzVG9rZW4uYmluZCh0aGlzKSwgc2V0dGluZ3MuZ2xvYmFsLmZldGNoKTtcblx0XHR0aGlzLnJlYWx0aW1lID0gdGhpcy5faW5pdFJlYWx0aW1lQ2xpZW50KF9vYmplY3RTcHJlYWQyKHtcblx0XHRcdGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcblx0XHRcdGFjY2Vzc1Rva2VuOiB0aGlzLl9nZXRBY2Nlc3NUb2tlbi5iaW5kKHRoaXMpXG5cdFx0fSwgc2V0dGluZ3MucmVhbHRpbWUpKTtcblx0XHRpZiAodGhpcy5hY2Nlc3NUb2tlbikgUHJvbWlzZS5yZXNvbHZlKHRoaXMuYWNjZXNzVG9rZW4oKSkudGhlbigodG9rZW4pID0+IHRoaXMucmVhbHRpbWUuc2V0QXV0aCh0b2tlbikpLmNhdGNoKChlKSA9PiBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gc2V0IGluaXRpYWwgUmVhbHRpbWUgYXV0aCB0b2tlbjpcIiwgZSkpO1xuXHRcdHRoaXMucmVzdCA9IG5ldyBQb3N0Z3Jlc3RDbGllbnQobmV3IFVSTChcInJlc3QvdjFcIiwgYmFzZVVybCkuaHJlZiwge1xuXHRcdFx0aGVhZGVyczogdGhpcy5oZWFkZXJzLFxuXHRcdFx0c2NoZW1hOiBzZXR0aW5ncy5kYi5zY2hlbWEsXG5cdFx0XHRmZXRjaDogdGhpcy5mZXRjaCxcblx0XHRcdHRpbWVvdXQ6IHNldHRpbmdzLmRiLnRpbWVvdXQsXG5cdFx0XHR1cmxMZW5ndGhMaW1pdDogc2V0dGluZ3MuZGIudXJsTGVuZ3RoTGltaXRcblx0XHR9KTtcblx0XHR0aGlzLnN0b3JhZ2UgPSBuZXcgU3RvcmFnZUNsaWVudCh0aGlzLnN0b3JhZ2VVcmwuaHJlZiwgdGhpcy5oZWFkZXJzLCB0aGlzLmZldGNoLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc3RvcmFnZSk7XG5cdFx0aWYgKCFzZXR0aW5ncy5hY2Nlc3NUb2tlbikgdGhpcy5fbGlzdGVuRm9yQXV0aEV2ZW50cygpO1xuXHR9XG5cdC8qKlxuXHQqIFN1cGFiYXNlIEZ1bmN0aW9ucyBhbGxvd3MgeW91IHRvIGRlcGxveSBhbmQgaW52b2tlIGVkZ2UgZnVuY3Rpb25zLlxuXHQqL1xuXHRnZXQgZnVuY3Rpb25zKCkge1xuXHRcdHJldHVybiBuZXcgRnVuY3Rpb25zQ2xpZW50KHRoaXMuZnVuY3Rpb25zVXJsLmhyZWYsIHtcblx0XHRcdGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcblx0XHRcdGN1c3RvbUZldGNoOiB0aGlzLmZldGNoXG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogUGVyZm9ybSBhIHF1ZXJ5IG9uIGEgdGFibGUgb3IgYSB2aWV3LlxuXHQqXG5cdCogQHBhcmFtIHJlbGF0aW9uIC0gVGhlIHRhYmxlIG9yIHZpZXcgbmFtZSB0byBxdWVyeVxuXHQqL1xuXHRmcm9tKHJlbGF0aW9uKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVzdC5mcm9tKHJlbGF0aW9uKTtcblx0fVxuXHQvKipcblx0KiBTZWxlY3QgYSBzY2hlbWEgdG8gcXVlcnkgb3IgcGVyZm9ybSBhbiBmdW5jdGlvbiAocnBjKSBjYWxsLlxuXHQqXG5cdCogVGhlIHNjaGVtYSBuZWVkcyB0byBiZSBvbiB0aGUgbGlzdCBvZiBleHBvc2VkIHNjaGVtYXMgaW5zaWRlIFN1cGFiYXNlLlxuXHQqXG5cdCogQHBhcmFtIHNjaGVtYSAtIFRoZSBzY2hlbWEgdG8gcXVlcnlcblx0Ki9cblx0c2NoZW1hKHNjaGVtYSkge1xuXHRcdHJldHVybiB0aGlzLnJlc3Quc2NoZW1hKHNjaGVtYSk7XG5cdH1cblx0LyoqXG5cdCogUGVyZm9ybSBhIGZ1bmN0aW9uIGNhbGwuXG5cdCpcblx0KiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gbmFtZSB0byBjYWxsXG5cdCogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGZ1bmN0aW9uIGNhbGxcblx0KiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcblx0KiBAcGFyYW0gb3B0aW9ucy5oZWFkIC0gV2hlbiBzZXQgdG8gYHRydWVgLCBgZGF0YWAgd2lsbCBub3QgYmUgcmV0dXJuZWQuXG5cdCogVXNlZnVsIGlmIHlvdSBvbmx5IG5lZWQgdGhlIGNvdW50LlxuXHQqIEBwYXJhbSBvcHRpb25zLmdldCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgdGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGhcblx0KiByZWFkLW9ubHkgYWNjZXNzIG1vZGUuXG5cdCogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHJvd3MgcmV0dXJuZWQgYnkgdGhlXG5cdCogZnVuY3Rpb24uIE9ubHkgYXBwbGljYWJsZSBmb3IgW3NldC1yZXR1cm5pbmdcblx0KiBmdW5jdGlvbnNdKGh0dHBzOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvY3VycmVudC9mdW5jdGlvbnMtc3JmLmh0bWwpLlxuXHQqXG5cdCogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuXHQqIGhvb2QuXG5cdCpcblx0KiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuXHQqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG5cdCpcblx0KiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG5cdCogbnVtYmVycy5cblx0Ki9cblx0cnBjKGZuLCBhcmdzID0ge30sIG9wdGlvbnMgPSB7XG5cdFx0aGVhZDogZmFsc2UsXG5cdFx0Z2V0OiBmYWxzZSxcblx0XHRjb3VudDogdm9pZCAwXG5cdH0pIHtcblx0XHRyZXR1cm4gdGhpcy5yZXN0LnJwYyhmbiwgYXJncywgb3B0aW9ucyk7XG5cdH1cblx0LyoqXG5cdCogQ3JlYXRlcyBhIFJlYWx0aW1lIGNoYW5uZWwgd2l0aCBCcm9hZGNhc3QsIFByZXNlbmNlLCBhbmQgUG9zdGdyZXMgQ2hhbmdlcy5cblx0KlxuXHQqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIFJlYWx0aW1lIGNoYW5uZWwuXG5cdCogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBSZWFsdGltZSBjaGFubmVsLlxuXHQqXG5cdCovXG5cdGNoYW5uZWwobmFtZSwgb3B0cyA9IHsgY29uZmlnOiB7fSB9KSB7XG5cdFx0cmV0dXJuIHRoaXMucmVhbHRpbWUuY2hhbm5lbChuYW1lLCBvcHRzKTtcblx0fVxuXHQvKipcblx0KiBSZXR1cm5zIGFsbCBSZWFsdGltZSBjaGFubmVscy5cblx0Ki9cblx0Z2V0Q2hhbm5lbHMoKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVhbHRpbWUuZ2V0Q2hhbm5lbHMoKTtcblx0fVxuXHQvKipcblx0KiBVbnN1YnNjcmliZXMgYW5kIHJlbW92ZXMgUmVhbHRpbWUgY2hhbm5lbCBmcm9tIFJlYWx0aW1lIGNsaWVudC5cblx0KlxuXHQqIEBwYXJhbSB7UmVhbHRpbWVDaGFubmVsfSBjaGFubmVsIC0gVGhlIG5hbWUgb2YgdGhlIFJlYWx0aW1lIGNoYW5uZWwuXG5cdCpcblx0Ki9cblx0cmVtb3ZlQ2hhbm5lbChjaGFubmVsKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVhbHRpbWUucmVtb3ZlQ2hhbm5lbChjaGFubmVsKTtcblx0fVxuXHQvKipcblx0KiBVbnN1YnNjcmliZXMgYW5kIHJlbW92ZXMgYWxsIFJlYWx0aW1lIGNoYW5uZWxzIGZyb20gUmVhbHRpbWUgY2xpZW50LlxuXHQqL1xuXHRyZW1vdmVBbGxDaGFubmVscygpIHtcblx0XHRyZXR1cm4gdGhpcy5yZWFsdGltZS5yZW1vdmVBbGxDaGFubmVscygpO1xuXHR9XG5cdGFzeW5jIF9nZXRBY2Nlc3NUb2tlbigpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciBfZGF0YSRzZXNzaW9uJGFjY2Vzc18sIF9kYXRhJHNlc3Npb247XG5cdFx0aWYgKF90aGlzLmFjY2Vzc1Rva2VuKSByZXR1cm4gYXdhaXQgX3RoaXMuYWNjZXNzVG9rZW4oKTtcblx0XHRjb25zdCB7IGRhdGEgfSA9IGF3YWl0IF90aGlzLmF1dGguZ2V0U2Vzc2lvbigpO1xuXHRcdHJldHVybiAoX2RhdGEkc2Vzc2lvbiRhY2Nlc3NfID0gKF9kYXRhJHNlc3Npb24gPSBkYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9kYXRhJHNlc3Npb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kYXRhJHNlc3Npb24uYWNjZXNzX3Rva2VuKSAhPT0gbnVsbCAmJiBfZGF0YSRzZXNzaW9uJGFjY2Vzc18gIT09IHZvaWQgMCA/IF9kYXRhJHNlc3Npb24kYWNjZXNzXyA6IF90aGlzLnN1cGFiYXNlS2V5O1xuXHR9XG5cdF9pbml0U3VwYWJhc2VBdXRoQ2xpZW50KHsgYXV0b1JlZnJlc2hUb2tlbiwgcGVyc2lzdFNlc3Npb24sIGRldGVjdFNlc3Npb25JblVybCwgc3RvcmFnZSwgdXNlclN0b3JhZ2UsIHN0b3JhZ2VLZXksIGZsb3dUeXBlLCBsb2NrLCBkZWJ1ZywgdGhyb3dPbkVycm9yIH0sIGhlYWRlcnMsIGZldGNoJDEpIHtcblx0XHRjb25zdCBhdXRoSGVhZGVycyA9IHtcblx0XHRcdEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0aGlzLnN1cGFiYXNlS2V5fWAsXG5cdFx0XHRhcGlrZXk6IGAke3RoaXMuc3VwYWJhc2VLZXl9YFxuXHRcdH07XG5cdFx0cmV0dXJuIG5ldyBTdXBhYmFzZUF1dGhDbGllbnQoe1xuXHRcdFx0dXJsOiB0aGlzLmF1dGhVcmwuaHJlZixcblx0XHRcdGhlYWRlcnM6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBhdXRoSGVhZGVycyksIGhlYWRlcnMpLFxuXHRcdFx0c3RvcmFnZUtleSxcblx0XHRcdGF1dG9SZWZyZXNoVG9rZW4sXG5cdFx0XHRwZXJzaXN0U2Vzc2lvbixcblx0XHRcdGRldGVjdFNlc3Npb25JblVybCxcblx0XHRcdHN0b3JhZ2UsXG5cdFx0XHR1c2VyU3RvcmFnZSxcblx0XHRcdGZsb3dUeXBlLFxuXHRcdFx0bG9jayxcblx0XHRcdGRlYnVnLFxuXHRcdFx0dGhyb3dPbkVycm9yLFxuXHRcdFx0ZmV0Y2g6IGZldGNoJDEsXG5cdFx0XHRoYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyOiBPYmplY3Qua2V5cyh0aGlzLmhlYWRlcnMpLnNvbWUoKGtleSkgPT4ga2V5LnRvTG93ZXJDYXNlKCkgPT09IFwiYXV0aG9yaXphdGlvblwiKVxuXHRcdH0pO1xuXHR9XG5cdF9pbml0UmVhbHRpbWVDbGllbnQob3B0aW9ucykge1xuXHRcdHJldHVybiBuZXcgUmVhbHRpbWVDbGllbnQodGhpcy5yZWFsdGltZVVybC5ocmVmLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgb3B0aW9ucyksIHt9LCB7IHBhcmFtczogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHsgYXBpa2V5OiB0aGlzLnN1cGFiYXNlS2V5IH0pLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyYW1zKSB9KSk7XG5cdH1cblx0X2xpc3RlbkZvckF1dGhFdmVudHMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXV0aC5vbkF1dGhTdGF0ZUNoYW5nZSgoZXZlbnQsIHNlc3Npb24pID0+IHtcblx0XHRcdHRoaXMuX2hhbmRsZVRva2VuQ2hhbmdlZChldmVudCwgXCJDTElFTlRcIiwgc2Vzc2lvbiA9PT0gbnVsbCB8fCBzZXNzaW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXNzaW9uLmFjY2Vzc190b2tlbik7XG5cdFx0fSk7XG5cdH1cblx0X2hhbmRsZVRva2VuQ2hhbmdlZChldmVudCwgc291cmNlLCB0b2tlbikge1xuXHRcdGlmICgoZXZlbnQgPT09IFwiVE9LRU5fUkVGUkVTSEVEXCIgfHwgZXZlbnQgPT09IFwiU0lHTkVEX0lOXCIpICYmIHRoaXMuY2hhbmdlZEFjY2Vzc1Rva2VuICE9PSB0b2tlbikge1xuXHRcdFx0dGhpcy5jaGFuZ2VkQWNjZXNzVG9rZW4gPSB0b2tlbjtcblx0XHRcdHRoaXMucmVhbHRpbWUuc2V0QXV0aCh0b2tlbik7XG5cdFx0fSBlbHNlIGlmIChldmVudCA9PT0gXCJTSUdORURfT1VUXCIpIHtcblx0XHRcdHRoaXMucmVhbHRpbWUuc2V0QXV0aCgpO1xuXHRcdFx0aWYgKHNvdXJjZSA9PSBcIlNUT1JBR0VcIikgdGhpcy5hdXRoLnNpZ25PdXQoKTtcblx0XHRcdHRoaXMuY2hhbmdlZEFjY2Vzc1Rva2VuID0gdm9pZCAwO1xuXHRcdH1cblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2luZGV4LnRzXG4vKipcbiogQ3JlYXRlcyBhIG5ldyBTdXBhYmFzZSBDbGllbnQuXG4qXG4qIEBleGFtcGxlXG4qIGBgYHRzXG4qIGltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcydcbipcbiogY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoJ2h0dHBzOi8veHl6Y29tcGFueS5zdXBhYmFzZS5jbycsICdwdWJsaWMtYW5vbi1rZXknKVxuKiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKCdwcm9maWxlcycpLnNlbGVjdCgnKicpXG4qIGBgYFxuKi9cbmNvbnN0IGNyZWF0ZUNsaWVudCA9IChzdXBhYmFzZVVybCwgc3VwYWJhc2VLZXksIG9wdGlvbnMpID0+IHtcblx0cmV0dXJuIG5ldyBTdXBhYmFzZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VLZXksIG9wdGlvbnMpO1xufTtcbmZ1bmN0aW9uIHNob3VsZFNob3dEZXByZWNhdGlvbldhcm5pbmcoKSB7XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZmFsc2U7XG5cdGNvbnN0IF9wcm9jZXNzID0gZ2xvYmFsVGhpc1tcInByb2Nlc3NcIl07XG5cdGlmICghX3Byb2Nlc3MpIHJldHVybiBmYWxzZTtcblx0Y29uc3QgcHJvY2Vzc1ZlcnNpb24gPSBfcHJvY2Vzc1tcInZlcnNpb25cIl07XG5cdGlmIChwcm9jZXNzVmVyc2lvbiA9PT0gdm9pZCAwIHx8IHByb2Nlc3NWZXJzaW9uID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdGNvbnN0IHZlcnNpb25NYXRjaCA9IHByb2Nlc3NWZXJzaW9uLm1hdGNoKC9edihcXGQrKVxcLi8pO1xuXHRpZiAoIXZlcnNpb25NYXRjaCkgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gcGFyc2VJbnQodmVyc2lvbk1hdGNoWzFdLCAxMCkgPD0gMTg7XG59XG5pZiAoc2hvdWxkU2hvd0RlcHJlY2F0aW9uV2FybmluZygpKSBjb25zb2xlLndhcm4oXCLimqDvuI8gIE5vZGUuanMgMTggYW5kIGJlbG93IGFyZSBkZXByZWNhdGVkIGFuZCB3aWxsIG5vIGxvbmdlciBiZSBzdXBwb3J0ZWQgaW4gZnV0dXJlIHZlcnNpb25zIG9mIEBzdXBhYmFzZS9zdXBhYmFzZS1qcy4gUGxlYXNlIHVwZ3JhZGUgdG8gTm9kZS5qcyAyMCBvciBsYXRlci4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHZpc2l0OiBodHRwczovL2dpdGh1Yi5jb20vb3Jncy9zdXBhYmFzZS9kaXNjdXNzaW9ucy8zNzIxN1wiKTtcblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBGdW5jdGlvblJlZ2lvbiwgRnVuY3Rpb25zRXJyb3IsIEZ1bmN0aW9uc0ZldGNoRXJyb3IsIEZ1bmN0aW9uc0h0dHBFcnJvciwgRnVuY3Rpb25zUmVsYXlFcnJvciwgUG9zdGdyZXN0RXJyb3IsIFN1cGFiYXNlQ2xpZW50LCBjcmVhdGVDbGllbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsiRnVuY3Rpb25SZWdpb24iLCJGdW5jdGlvbnNDbGllbnQiLCJGdW5jdGlvbnNFcnJvciIsIkZ1bmN0aW9uc0ZldGNoRXJyb3IiLCJGdW5jdGlvbnNIdHRwRXJyb3IiLCJGdW5jdGlvbnNSZWxheUVycm9yIiwiUG9zdGdyZXN0Q2xpZW50IiwiUG9zdGdyZXN0RXJyb3IiLCJSZWFsdGltZUNsaWVudCIsIlN0b3JhZ2VDbGllbnQiLCJBdXRoQ2xpZW50IiwidmVyc2lvbiIsIkpTX0VOViIsIkRlbm8iLCJkb2N1bWVudCIsIm5hdmlnYXRvciIsInByb2R1Y3QiLCJERUZBVUxUX0hFQURFUlMiLCJERUZBVUxUX0dMT0JBTF9PUFRJT05TIiwiaGVhZGVycyIsIkRFRkFVTFRfREJfT1BUSU9OUyIsInNjaGVtYSIsIkRFRkFVTFRfQVVUSF9PUFRJT05TIiwiYXV0b1JlZnJlc2hUb2tlbiIsInBlcnNpc3RTZXNzaW9uIiwiZGV0ZWN0U2Vzc2lvbkluVXJsIiwiZmxvd1R5cGUiLCJERUZBVUxUX1JFQUxUSU1FX09QVElPTlMiLCJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwibyQxIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJ0b1ByaW1pdGl2ZSIsInQiLCJyIiwiZSIsImkiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwidG9Qcm9wZXJ0eUtleSIsIl9kZWZpbmVQcm9wZXJ0eSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsInIkMSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQyIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicmVzb2x2ZUZldGNoIiwiY3VzdG9tRmV0Y2giLCJhcmdzIiwiZmV0Y2giLCJyZXNvbHZlSGVhZGVyc0NvbnN0cnVjdG9yIiwiSGVhZGVycyIsImZldGNoV2l0aEF1dGgiLCJzdXBhYmFzZUtleSIsImdldEFjY2Vzc1Rva2VuIiwiZmV0Y2gkMSIsIkhlYWRlcnNDb25zdHJ1Y3RvciIsImlucHV0IiwiaW5pdCIsIl9hd2FpdCRnZXRBY2Nlc3NUb2tlbiIsImFjY2Vzc1Rva2VuIiwiaGFzIiwic2V0IiwiZW5zdXJlVHJhaWxpbmdTbGFzaCIsInVybCIsImVuZHNXaXRoIiwiYXBwbHlTZXR0aW5nRGVmYXVsdHMiLCJvcHRpb25zIiwiZGVmYXVsdHMiLCJfREVGQVVMVF9HTE9CQUxfT1BUSU8iLCJfZ2xvYmFsT3B0aW9ucyRoZWFkZXIiLCJkYiIsImRiT3B0aW9ucyIsImF1dGgiLCJhdXRoT3B0aW9ucyIsInJlYWx0aW1lIiwicmVhbHRpbWVPcHRpb25zIiwiZ2xvYmFsIiwiZ2xvYmFsT3B0aW9ucyIsIkRFRkFVTFRfREJfT1BUSU9OUyQxIiwiREVGQVVMVF9BVVRIX09QVElPTlMkMSIsIkRFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUyQxIiwiREVGQVVMVF9HTE9CQUxfT1BUSU9OUyQxIiwicmVzdWx0Iiwic3RvcmFnZSIsInZhbGlkYXRlU3VwYWJhc2VVcmwiLCJzdXBhYmFzZVVybCIsInRyaW1tZWRVcmwiLCJ0cmltIiwiRXJyb3IiLCJtYXRjaCIsIlVSTCIsIl91bnVzZWQiLCJTdXBhYmFzZUF1dGhDbGllbnQiLCJTdXBhYmFzZUNsaWVudCIsIl9zZXR0aW5ncyRhdXRoJHN0b3JhZyIsIl9zZXR0aW5ncyRnbG9iYWwkaGVhZCIsImJhc2VVcmwiLCJyZWFsdGltZVVybCIsInByb3RvY29sIiwicmVwbGFjZSIsImF1dGhVcmwiLCJzdG9yYWdlVXJsIiwiZnVuY3Rpb25zVXJsIiwiZGVmYXVsdFN0b3JhZ2VLZXkiLCJob3N0bmFtZSIsInNwbGl0IiwiREVGQVVMVFMiLCJzdG9yYWdlS2V5Iiwic2V0dGluZ3MiLCJfc2V0dGluZ3MkYXV0aCIsIl9pbml0U3VwYWJhc2VBdXRoQ2xpZW50IiwiUHJveHkiLCJnZXQiLCJfIiwicHJvcCIsIl9nZXRBY2Nlc3NUb2tlbiIsImJpbmQiLCJfaW5pdFJlYWx0aW1lQ2xpZW50IiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwidG9rZW4iLCJzZXRBdXRoIiwiY2F0Y2giLCJjb25zb2xlIiwid2FybiIsInJlc3QiLCJocmVmIiwidGltZW91dCIsInVybExlbmd0aExpbWl0IiwiX2xpc3RlbkZvckF1dGhFdmVudHMiLCJmdW5jdGlvbnMiLCJmcm9tIiwicmVsYXRpb24iLCJycGMiLCJmbiIsImhlYWQiLCJjb3VudCIsImNoYW5uZWwiLCJuYW1lIiwib3B0cyIsImNvbmZpZyIsImdldENoYW5uZWxzIiwicmVtb3ZlQ2hhbm5lbCIsInJlbW92ZUFsbENoYW5uZWxzIiwiX3RoaXMiLCJfZGF0YSRzZXNzaW9uJGFjY2Vzc18iLCJfZGF0YSRzZXNzaW9uIiwiZGF0YSIsImdldFNlc3Npb24iLCJzZXNzaW9uIiwiYWNjZXNzX3Rva2VuIiwidXNlclN0b3JhZ2UiLCJsb2NrIiwiZGVidWciLCJ0aHJvd09uRXJyb3IiLCJhdXRoSGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJhcGlrZXkiLCJoYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyIiwic29tZSIsImtleSIsInRvTG93ZXJDYXNlIiwicGFyYW1zIiwib25BdXRoU3RhdGVDaGFuZ2UiLCJldmVudCIsIl9oYW5kbGVUb2tlbkNoYW5nZWQiLCJzb3VyY2UiLCJjaGFuZ2VkQWNjZXNzVG9rZW4iLCJzaWduT3V0IiwiY3JlYXRlQ2xpZW50Iiwic2hvdWxkU2hvd0RlcHJlY2F0aW9uV2FybmluZyIsIl9wcm9jZXNzIiwiZ2xvYmFsVGhpcyIsInByb2Nlc3NWZXJzaW9uIiwidmVyc2lvbk1hdGNoIiwicGFyc2VJbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/supabase-js/dist/index.mjs\n");

/***/ })

};
;